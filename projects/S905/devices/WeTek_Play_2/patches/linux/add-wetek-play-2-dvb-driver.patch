diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index 59dc6f7..0d0d438 100644
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -97,6 +97,8 @@ source "drivers/amlogic/pm/Kconfig"
 
 source "drivers/amlogic/dvb_tv/Kconfig"
 
+source "drivers/amlogic/wetek/Kconfig"
+
 source "drivers/amlogic/mailbox/Kconfig"
 
 source "drivers/amlogic/rdma/Kconfig"
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index a57bde9..158fb7c 100644
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -104,6 +104,8 @@ obj-$(CONFIG_MESON_SUSPEND)	+= pm/
 
 obj-$(CONFIG_AM_DVB)		+= dvb_tv/
 
+obj-$(CONFIG_WETEK)		+= wetek/
+
 obj-$(CONFIG_MESON_MHU_MBOX)	+= mailbox/
 
 obj-$(CONFIG_AML_RDMA)		+= rdma/
diff --git a/drivers/amlogic/wetek/Kconfig b/drivers/amlogic/wetek/Kconfig
new file mode 100644
index 0000000..09cba03
--- /dev/null
+++ b/drivers/amlogic/wetek/Kconfig
@@ -0,0 +1,13 @@
+#
+# Wetek Play driver configuration
+#
+
+menu "WeTek Play driver"
+
+config WETEK
+	tristate "Wetek Play driver"
+	default m
+	select DVB_CORE
+	help
+		Select to enable Wetek Play driver.
+endmenu
diff --git a/drivers/amlogic/wetek/Makefile b/drivers/amlogic/wetek/Makefile
new file mode 100644
index 0000000..42d65d5
--- /dev/null
+++ b/drivers/amlogic/wetek/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Wetek Play driver.
+#
+
+obj-$(CONFIG_WETEK) += wetekplay.o wetekdvb.o
+
+wetekplay-objs = nimdetect.o mxl603.o avl6211.o mn88436.o cxd2837.o cxd2841er_wetek.o ascot3.o
+
+wetekdvb-objs = wetek_dvb.o wetek_dmx.o 
+
+EXTRA_CFLAGS += -Idrivers/media/dvb-core -Idrivers/media/tuners
diff --git a/drivers/amlogic/wetek/ascot3.c b/drivers/amlogic/wetek/ascot3.c
new file mode 100644
index 0000000..0b424e8
--- /dev/null
+++ b/drivers/amlogic/wetek/ascot3.c
@@ -0,0 +1,563 @@
+/*
+ * ascot3.c
+ *
+ * Sony Ascot3 DVB-T/T2/C tuner driver
+ *
+ * Copyright (C) 2015 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ * Based on ascot2e driver
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/dvb/frontend.h>
+#include <linux/types.h>
+#include "ascot3.h"
+#include "dvb_frontend.h"
+
+#define MAX_WRITE_REGSIZE 32
+
+enum ascot3_state {
+	STATE_UNKNOWN,
+	STATE_SLEEP,
+	STATE_ACTIVE
+};
+
+struct ascot3_priv {
+	u32			frequency;
+	u8			i2c_address;
+	struct i2c_adapter	*i2c;
+	enum ascot3_state	state;
+};
+
+enum ascot3_tv_system_t {
+	ASCOT3_DTV_DVBT_5,
+	ASCOT3_DTV_DVBT_6,
+	ASCOT3_DTV_DVBT_7,
+	ASCOT3_DTV_DVBT_8,
+	ASCOT3_DTV_DVBT2_1_7,
+	ASCOT3_DTV_DVBT2_5,
+	ASCOT3_DTV_DVBT2_6,
+	ASCOT3_DTV_DVBT2_7,
+	ASCOT3_DTV_DVBT2_8,
+	ASCOT3_DTV_DVBC_6,
+	ASCOT3_DTV_DVBC_8,
+	ASCOT3_DTV_DVBC2_6,
+	ASCOT3_DTV_DVBC2_8,
+	ASCOT3_DTV_UNKNOWN
+};
+
+struct ascot3_band_sett {
+	u8 	outlmt;
+	u8	rf_gain;
+	u8	if_bpf_gc;
+	u8	rfovld_det_lv1_vl;
+	u8	rfovld_det_lv1_vh;
+	u8	rfovld_det_lv1_u;
+	u8	ifovld_det_lv_vl;
+	u8	ifovld_det_lv_vh;
+	u8	ifovld_det_lv_u;
+	u8	if_bpf_f0;
+	u8	bw;
+	u8	fif_offset;
+	u8	bw_offset;
+	u8	agc_sel;
+	u8	if_out_sel;	
+	u8	is_lowerlocal;	
+};
+
+#define ASCOT3_AUTO		0xff
+#define ASCOT3_OFFSET(ofs)	((u8)(ofs) & 0x1F)
+#define ASCOT3_BW_6		0x00
+#define ASCOT3_BW_7		0x01
+#define ASCOT3_BW_8		0x02
+#define ASCOT3_BW_1_7	0x03
+
+static struct ascot3_band_sett ascot3_sett[] = {
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6, ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_7,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-5), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-4), ASCOT3_OFFSET(-6), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_1_7,ASCOT3_OFFSET(-10),ASCOT3_OFFSET(-10),ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_7,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-5), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-4), ASCOT3_OFFSET(-6), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x05, 0x09, 0x09, 0x09, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-4), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x05, 0x09, 0x09, 0x09, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-2), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x03, 0x0A, 0x0A, 0x0A, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-2), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x03, 0x0A, 0x0A, 0x0A, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-2), ASCOT3_OFFSET(0),  ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }
+};
+  
+static int ascot3_write_regs(struct ascot3_priv *priv,
+			      u8 reg, const u8 *data, u32 len)
+{
+	int ret;
+	u8 buf[MAX_WRITE_REGSIZE + 1];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.len = len + 1,
+			.buf = buf,
+		}
+	};
+
+	if (len + 1 >= sizeof(buf)) {
+		dev_warn(&priv->i2c->dev,"wr reg=%04x: len=%d is too big!\n",
+			 reg, len + 1);
+		return -E2BIG;
+	}
+
+
+	buf[0] = reg;
+	memcpy(&buf[1], data, len);
+	ret = i2c_transfer(priv->i2c, msg, 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EREMOTEIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"i2c wr failed=%d reg=%02x len=%d\n",
+			ret, reg, len);
+		return ret;
+	}
+	return 0;
+}
+
+static int ascot3_write_reg(struct ascot3_priv *priv, u8 reg, u8 val)
+{
+	return ascot3_write_regs(priv, reg, &val, 1);
+}
+
+static int ascot3_read_regs(struct ascot3_priv *priv,
+			     u8 reg, u8 *val, u32 len)
+{
+	int ret;
+	struct i2c_msg msg[2] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.len = 1,
+			.buf = &reg,
+		}, {
+			.addr = priv->i2c_address,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val,
+		}
+	};
+
+	ret = i2c_transfer(priv->i2c, &msg[0], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EREMOTEIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"I2C rw failed=%d addr=%02x reg=%02x\n",
+			ret, priv->i2c_address, reg);
+		return ret;
+	}
+	ret = i2c_transfer(priv->i2c, &msg[1], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EREMOTEIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"i2c rd failed=%d addr=%02x reg=%02x\n",
+			 ret, priv->i2c_address, reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ascot3_read_reg(struct ascot3_priv *priv, u8 reg, u8 *val)
+{
+	return ascot3_read_regs(priv, reg, val, 1);
+}
+
+static int ascot3_set_reg_bits(struct ascot3_priv *priv,
+				u8 reg, u8 data, u8 mask)
+{
+	int res;
+	u8 rdata;
+
+	if (mask != 0xff) {
+		res = ascot3_read_reg(priv, reg, &rdata);
+		if (res != 0)
+			return res;
+		data = ((data & mask) | (rdata & (mask ^ 0xFF)));
+	}
+	return ascot3_write_reg(priv, reg, data);
+}
+
+static int ascot3_enter_power_save(struct ascot3_priv *priv)
+{
+	u8 data[3];
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	
+	if (priv->state == STATE_SLEEP)
+		return 0;
+		
+	/* Loop Through setting And RFIN matching in Power Save */
+	ascot3_write_reg(priv, 0x67, 0x06);
+	/* Disable IF signal output (IF_OUT_SEL setting) */
+	ascot3_set_reg_bits(priv, 0x74, 0x02, 0x03);
+	/* Power save setting for analog block */
+	data[0] = 0x15;
+	data[1] = 0x00;
+	data[2] = 0x00;
+	ascot3_write_regs(priv, 0x5E, data, 3);
+	/* Standby setting for CPU */
+	ascot3_write_reg(priv, 0x88, 0x00);
+	/* Standby setting for internal logic block */
+	ascot3_write_reg(priv, 0x87, 0xC0);	
+	priv->state = STATE_SLEEP;	
+	return 0;
+}
+
+static int ascot3_init(struct dvb_frontend *fe)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	return 0;
+}
+
+static int ascot3_release(struct dvb_frontend *fe)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int ascot3_sleep(struct dvb_frontend *fe)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+		
+	ascot3_enter_power_save(priv);
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	return 0;
+}
+
+static enum ascot3_tv_system_t ascot3_get_tv_system(struct dvb_frontend *fe)
+{
+	enum ascot3_tv_system_t system = ASCOT3_DTV_UNKNOWN;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	if (p->delivery_system == SYS_DVBT) {
+		if (p->bandwidth_hz <= 5000000)
+			system = ASCOT3_DTV_DVBT_5;
+		else if (p->bandwidth_hz <= 6000000)
+			system = ASCOT3_DTV_DVBT_6;
+		else if (p->bandwidth_hz <= 7000000)
+			system = ASCOT3_DTV_DVBT_7;
+		else if (p->bandwidth_hz <= 8000000)
+			system = ASCOT3_DTV_DVBT_8;
+		else {
+			system = ASCOT3_DTV_DVBT_8;
+			p->bandwidth_hz = 8000000;
+		}
+	} else if (p->delivery_system == SYS_DVBT2) {
+		if (p->bandwidth_hz <= 5000000)
+			system = ASCOT3_DTV_DVBT2_5;
+		else if (p->bandwidth_hz <= 6000000)
+			system = ASCOT3_DTV_DVBT2_6;
+		else if (p->bandwidth_hz <= 7000000)
+			system = ASCOT3_DTV_DVBT2_7;
+		else if (p->bandwidth_hz <= 8000000)
+			system = ASCOT3_DTV_DVBT2_8;
+		else {
+			system = ASCOT3_DTV_DVBT2_8;
+			p->bandwidth_hz = 8000000;
+		}
+	} else if (p->delivery_system == SYS_DVBC_ANNEX_A) {
+		if (p->bandwidth_hz <= 6000000)
+			system = ASCOT3_DTV_DVBC_6;
+		else if (p->bandwidth_hz <= 8000000)
+			system = ASCOT3_DTV_DVBC_8;
+	}
+	dev_dbg(&priv->i2c->dev,
+		"%s(): ASCOT2E DTV system %d (delsys %d, bandwidth %d)\n",
+		__func__, (int)system, p->delivery_system, p->bandwidth_hz);
+	return system;
+}
+
+static int ascot3_set_params(struct dvb_frontend *fe)
+{
+	u8 data[20];
+	u32 frequency;
+	enum ascot3_tv_system_t tv_system;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): tune frequency %dkHz\n",
+		__func__, p->frequency / 1000);
+	tv_system = ascot3_get_tv_system(fe);
+
+	if (tv_system == ASCOT3_DTV_UNKNOWN) {
+		dev_dbg(&priv->i2c->dev, "%s(): unknown DTV system\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	frequency = roundup(p->frequency / 1000, 25);
+
+	/* Disable IF signal output (IF_OUT_SEL setting) */
+	ascot3_set_reg_bits(priv, 0x74, 0x02, 0x03);
+	/* Clock enable for internal logic block, CPU wake-up */
+	data[0] = 0xC4;
+	data[1] = 0x40;
+	ascot3_write_regs(priv, 0x87, data, 2);
+	
+	/* Initial setting for internal analog block */	
+	if (tv_system == ASCOT3_DTV_DVBC_6 ||
+			tv_system == ASCOT3_DTV_DVBC_8) {		
+		data[0] = 0x16;
+		data[1] = 0x26;
+	} else {		
+		data[0] = 0x10;
+		data[1] = 0x20;
+	}
+	ascot3_write_regs(priv, 0x91, data, 2);
+	
+	/* Setting for analog block */
+	data[0] = 0x00;
+	data[1] = (u8)(ascot3_sett[tv_system].is_lowerlocal & 0x01);
+	ascot3_write_regs(priv, 0x9C, data, 2);
+	
+	/* Enable for analog block */
+	data[0] = 0xEE;
+	data[1] = 0x02;
+	data[2] = 0x1E;
+	/* Tuning setting for CPU */
+	data[3] = 0x67;
+	/* Setting for PLL reference divider (REF_R) */
+	data[4] = 0x02;
+	/* Tuning setting for analog block*/
+	if (tv_system == ASCOT3_DTV_DVBC_6 ||
+			tv_system == ASCOT3_DTV_DVBC_8) {		
+		data[5] = 0x50;
+		data[6] = 0x78;
+		data[7] = 0x08;
+		data[8] = 0x30;
+	} else {		
+		data[5] = 0xAF;
+		data[6] = 0x78;
+		data[7] = 0x08;
+		data[8] = 0x30;
+	}
+	ascot3_write_regs(priv, 0x5E, data, 9);
+	
+	/* Setting for IFOUT_LIMIT */
+	data[0] = (u8)(ascot3_sett[tv_system].outlmt & 0x03);
+	/* Setting for IF BPF buffer gain */
+	/* RF_GAIN setting */
+	if (ascot3_sett[tv_system].rf_gain == ASCOT3_AUTO) 
+		data[1] = 0x80;
+	else
+		data[1] = (u8)((ascot3_sett[tv_system].rf_gain << 4) & 0x70);
+	
+	/* IF_BPF_GC setting */
+	data[1] |= (u8)(ascot3_sett[tv_system].if_bpf_gc & 0x0F);
+
+	/* Setting for internal RFAGC */
+	data[2] = 0x00;	
+	if (frequency <= 172000) {
+		data[3] = (u8)(ascot3_sett[tv_system].rfovld_det_lv1_vl & 0x0F);
+		data[4] = (u8)(ascot3_sett[tv_system].ifovld_det_lv_vl & 0x07);
+	} else if (frequency <= 464000) {		
+		data[3] = (u8)(ascot3_sett[tv_system].rfovld_det_lv1_vh & 0x0F);
+		data[4] = (u8)(ascot3_sett[tv_system].ifovld_det_lv_vh & 0x07);
+	} else {	
+		data[3] = (u8)(ascot3_sett[tv_system].rfovld_det_lv1_u & 0x0F);
+		data[4] = (u8)(ascot3_sett[tv_system].ifovld_det_lv_u & 0x07);
+	}	
+	data[4] |= 0x20;
+	
+	/* Setting for IF frequency and bandwidth */
+	data[5] = (u8)((ascot3_sett[tv_system].if_bpf_f0 << 4) & 0x30);
+	data[5] |= (u8)(ascot3_sett[tv_system].bw & 0x03);
+	data[6] = (u8)(ascot3_sett[tv_system].fif_offset & 0x1F);
+	data[7] = (u8)(ascot3_sett[tv_system].bw_offset & 0x1F);
+	
+	/* RF tuning frequency setting */
+	data[8] = (u8)(frequency & 0xFF);         /* 0x10: FRF_L */
+	data[9] = (u8)((frequency >> 8) & 0xFF);  /* 0x11: FRF_M */
+	data[10] = (u8)((frequency >> 16) & 0x0F); /* 0x12: FRF_H (bit[3:0]) */
+	/* Tuning command */
+	data[11] = 0xFF;
+	/* Enable IF output, AGC and IFOUT pin selection */
+	data[12] = 0x11;
+	/* Tuning setting for analog block*/
+	if (tv_system == ASCOT3_DTV_DVBC_6 ||
+			tv_system == ASCOT3_DTV_DVBC_8) {		
+		data[13] = 0xD9;
+		data[14] = 0x0F;
+		data[15] = 0x25;
+		data[16] = 0x87;
+	} else {		
+		data[13] = 0x99;
+		data[14] = 0x00;
+		data[15] = 0x24;
+		data[16] = 0x87;
+	}
+	ascot3_write_regs(priv, 0x68, data, 17);
+
+	msleep(50);
+	
+	priv->state = STATE_ACTIVE;	
+	ascot3_write_reg(priv, 0x88, 0x00);
+	ascot3_write_reg(priv, 0x87, 0xC0);
+	
+	priv->frequency = frequency;
+	return 0;
+}
+
+static int ascot3_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	*frequency = priv->frequency * 1000;
+	return 0;
+}
+
+static struct dvb_tuner_ops ascot3_tuner_ops = {
+	.info = {
+		.name = "Sony ASCOT3",
+		.frequency_min = 1000000,
+		.frequency_max = 1200000000,
+		.frequency_step = 25000,
+	},
+	.init = ascot3_init,
+	.release = ascot3_release,
+	.sleep = ascot3_sleep,
+	.set_params = ascot3_set_params,
+	.get_frequency = ascot3_get_frequency,
+};
+
+struct dvb_frontend *ascot3_attach(struct dvb_frontend *fe,
+				    const struct ascot3_config *config,
+				    struct i2c_adapter *i2c)
+{
+	u8 data[20];
+	struct ascot3_priv *priv = NULL;
+
+	priv = kzalloc(sizeof(struct ascot3_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
+	priv->i2c_address = config->i2c_address;
+	priv->i2c = i2c;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	/* Check if tuner is Sony ASCOT3 */
+	data[0] = 0x00;
+	ascot3_read_reg(priv, 0x7F, data);
+	if (((data[0] & 0xF0) != 0xC0) && ((data[0] & 0xF0) != 0xD0)) {
+		kfree(priv);
+		return NULL;	
+	}	
+	/* Initial setting for internal logic block */	
+	data[0] = 0x7A;
+	data[1] = 0x01;
+	ascot3_write_regs(priv, 0x99, data, 2);
+	/* 16 MHz xTal frequency */
+	data[0] = 16;
+	/* Driver current setting for crystal oscillator */	
+	/* Load capacitance setting for crystal oscillator */
+	data[1] = 0x84;
+	data[2] = 0xB0;
+	/* Setting for REFOUT signal output */
+	data[3] = 0x00;
+	/* GPIO0, GPIO1 port setting */
+	data[4] = 0x00;
+	data[5] = 0x00;
+	/* Logic wake up, CPU boot */
+	data[6] = 0xC4;
+	data[7] = 0x40;
+	/* For burst-write */
+	data[8] = 0x10;
+	/* Setting for internal RFAGC */
+	data[9] = 0x00;
+	data[10] = 0x45;
+	data[11] = 0x56;
+	/* Setting for analog block */
+	data[12] = 0x07;
+	/* Initial setting for internal analog block */
+	data[13] = 0x1C;
+	data[14] = 0x3F;
+	data[15] = 0x02;
+	data[16] = 0x10;
+	data[17] = 0x20;
+	data[18] = 0x0A;
+	data[19] = 0x00;
+	ascot3_write_regs(priv, 0x81, data, 20);
+	/* Setting for internal RFAGC */
+	ascot3_write_reg(priv, 0x9B, 0x00);
+	msleep(10);
+	/* VCO current setting */
+	data[0] = 0x8D;
+	data[1] = 0x06;
+	ascot3_write_regs(priv, 0x17, data, 2);
+	msleep(1);
+	ascot3_read_reg(priv, 0x19, data);
+	ascot3_write_reg(priv, 0x95, ((data[0] >> 4) & 0x0F));
+	ascot3_enter_power_save(priv);	
+	/* Load capacitance control setting for crystal oscillator */
+	ascot3_write_reg(priv, 0x80, 0x01);
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	memcpy(&fe->ops.tuner_ops, &ascot3_tuner_ops,
+				sizeof(struct dvb_tuner_ops));
+	fe->tuner_priv = priv;
+	dev_info(&priv->i2c->dev,
+		"Sony ASCOT3 attached on addr=%x at I2C adapter %p\n",
+		priv->i2c_address, priv->i2c);
+	return fe;
+}
+EXPORT_SYMBOL(ascot3_attach);
+
+MODULE_DESCRIPTION("Sony ASCOT3 terr/cab tuner driver");
+MODULE_AUTHOR("sasa.savic.sr@gmail.com");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/ascot3.h b/drivers/amlogic/wetek/ascot3.h
new file mode 100644
index 0000000..e245539
--- /dev/null
+++ b/drivers/amlogic/wetek/ascot3.h
@@ -0,0 +1,46 @@
+/*
+ * ascot3.h
+ *
+ * Sony Ascot3 DVB-T/T2/C tuner driver
+ *
+ * Copyright (C) 2015 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ * Based on ascot2e driver
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#ifndef __DVB_ASCOT3_H__
+#define __DVB_ASCOT3_H__
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+#include <linux/i2c.h>
+
+/**
+ * struct ascot3_config - the configuration of Ascot2E tuner driver
+ * @i2c_address:	I2C address of the tuner
+ * @xtal_freq_mhz:	Oscillator frequency, MHz
+ */
+struct ascot3_config {
+	u8	i2c_address;
+	u8	xtal_freq_mhz;
+};
+
+extern struct dvb_frontend *ascot3_attach(struct dvb_frontend *fe,
+					const struct ascot3_config *config,
+					struct i2c_adapter *i2c);
+#endif
diff --git a/drivers/amlogic/wetek/avl6211.c b/drivers/amlogic/wetek/avl6211.c
new file mode 100644
index 0000000..f57acbe
--- /dev/null
+++ b/drivers/amlogic/wetek/avl6211.c
@@ -0,0 +1,1981 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "dvb_frontend.h"
+#include "avl6211_reg.h"
+#include "avl6211.h"
+
+
+const struct avl6211_pllconf pll_conf[] = {
+	/* The following set of PLL configuration at different reference clock frequencies refer to demod operation */
+	/* in standard performance mode. */
+	 { 503,  1, 7, 4, 2,  4000, 11200, 16800, 25200 } /* Reference clock 4 MHz,   Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 447,  1, 7, 4, 2,  4500, 11200, 16800, 25200 } /* Reference clock 4.5 MHz, Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 503,  4, 7, 4, 2, 10000, 11200, 16800, 25200 } /* Reference clock 10 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 503,  7, 7, 4, 2, 16000, 11200, 16800, 25200 } /* Reference clock 16 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 111,  2, 7, 4, 2, 27000, 11200, 16800, 25200 } /* Reference clock 27 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	
+	/* The following set of PLL configuration at different reference clock frequencies refer to demod operation */
+	/* in high performance mode. */
+	,{ 566,  1, 7, 4, 2,  4000, 12600, 18900, 28350 } /* Reference clock 4 MHz,   Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 503,  1, 7, 4, 2,  4500, 12600, 18900, 28350 } /* Reference clock 4.5 MHz, Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 566,  4, 7, 4, 2, 10000, 12600, 18900, 28350 } /* Reference clock 10 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 566,  7, 7, 4, 2, 16000, 12600, 18900, 28350 } /* Reference clock 16 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 377,  8, 7, 4, 2, 27000, 12600, 18900, 28350 } /* Reference clock 27 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+};
+
+const unsigned short pll_array_size = sizeof(pll_conf) / sizeof(struct avl6211_pllconf);
+
+struct avl6211_state
+{
+	struct i2c_adapter* i2c;
+	struct avl6211_config* config;
+	struct dvb_frontend frontend;
+	
+	u8 diseqc_status;
+	u16 locked;
+	u32 frequency;
+	u32 symbol_rate;	
+	u32 flags;
+	
+	int demod_id;
+	
+	u16 tuner_lpf;
+	u16 demod_freq;	/* Demod clock in 10kHz units */
+	u16 fec_freq;	/* FEC clock in 10kHz units */
+	u16 mpeg_freq;	/* MPEG clock in 10kHz units */
+	
+	bool boot;
+	bool gpio_on;
+};
+struct avl6211_diseqc_tx_status
+{
+	u8 tx_done;		
+	u8 tx_fifo_cnt;
+};
+static u16 extract_16(const u8 * buf)
+{
+	u16 data;
+	data = buf[0];
+	data = (u16)(data << 8) + buf[1];
+	return data;
+}
+static u32 extract_32(const u8 * buf)
+{
+	unsigned int data;
+	data = buf[0];
+	data = (data << 8) + buf[1];
+	data = (data << 8) + buf[2];
+	data = (data << 8) + buf[3];
+	return data;
+}
+static int avl6211_i2c_writereg(struct avl6211_state *state, u8 *data, u16 *size)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+				.addr = state->config->demod_address, 
+				.flags = 0,
+				.buf = data,
+				.len = *size,
+			}
+	};
+	
+	ret = i2c_transfer(state->i2c, msg, 1);	
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d", ret);
+		ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+static int avl6211_i2c_readreg(struct avl6211_state* state, u8 * data, u16 * size)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+					.addr = state->config->demod_address, 
+					.flags = I2C_M_RD,
+					.buf = data,
+					.len = *size,
+			}
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 1);
+	
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d", ret);
+		ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+static int avl6211_i2c_read(struct avl6211_state* state, u32 offset, u8 * buf, u16 buf_size)
+{
+	int ret;
+	u8 buf_tmp[3];
+	u16 x1 = 3, x2 = 0;
+	u16 size;
+
+	format_addr(offset, buf_tmp);
+	ret = avl6211_i2c_writereg(state, buf_tmp, &x1);  
+	if (ret)
+		goto err;
+
+	if (buf_size & 1)
+		size = buf_size - 1;
+	else
+		size = buf_size;
+
+	while (size > I2C_MAX_READ) {
+		x1 = I2C_MAX_READ;
+		ret = avl6211_i2c_readreg(state, buf + x2, &x1);
+		if (ret)
+			goto err;			
+		x2 += I2C_MAX_READ;
+		size -= I2C_MAX_READ;
+	}
+
+	if (size != 0) {
+		ret = avl6211_i2c_readreg(state, buf + x2, &size);
+		if (ret)
+			goto err;
+	}
+
+	if (buf_size & 1) {
+		x1 = 2;
+		ret = avl6211_i2c_readreg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+		buf[buf_size-1] = buf_tmp[0];
+	}
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write(struct avl6211_state* state, u8 * buf, u16 buf_size)
+{
+	int ret;
+	u8 buf_tmp[5], *x3;
+	u16 x1, x2 = 0, tmp;
+	u16 size;
+	u32 addr;
+
+	if (WARN_ON(buf_size < 3))
+		return -EINVAL;	
+		
+	/* Actual data size */
+	buf_size -= 3;
+	/* Dump address */
+	addr = buf[0];
+	addr = addr << 8;
+	addr += buf[1];
+	addr = addr << 8;
+	addr += buf[2];
+	
+	if (buf_size & 1)
+		size = buf_size -1;
+	else
+		size = buf_size;
+	
+	tmp = (I2C_MAX_WRITE - 3) & 0xfffe; /* How many bytes data we can transfer every time */
+	
+	x2 = 0;
+	while( size > tmp ) {
+		x1 = tmp + 3;
+		/* Save the data */
+		buf_tmp[0] = buf[x2];
+		buf_tmp[1] = buf[x2 + 1];
+		buf_tmp[2] = buf[x2 + 2];
+		x3 = buf + x2;
+		format_addr(addr, x3);
+		ret = avl6211_i2c_writereg(state, buf + x2, &x1);
+		if (ret)
+			goto err;
+		/* Restore data */
+		buf[x2] = buf_tmp[0];
+		buf[x2 + 1] = buf_tmp[1];
+		buf[x2 + 2] = buf_tmp[2];
+		addr += tmp;
+		x2 += tmp;
+		size -= tmp;
+	}
+
+	x1 = size + 3;
+	/* Save the data */
+	buf_tmp[0] = buf[x2];
+	buf_tmp[1] = buf[x2 + 1];
+	buf_tmp[2] = buf[x2 + 2];
+	x3 = buf + x2;
+	format_addr(addr, x3);
+	ret = avl6211_i2c_writereg(state, buf + x2, &x1);
+	if (ret)
+		goto err;
+	/* Restore data */
+	buf[x2] = buf_tmp[0];
+	buf[x2 + 1] = buf_tmp[1];
+	buf[x2 + 2] = buf_tmp[2];
+	addr += size;
+	x2 += size;
+		
+	if (buf_size & 1) {
+		format_addr(addr, buf_tmp);
+		x1 = 3;
+		ret = avl6211_i2c_writereg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+		x1 = 2;
+		ret = avl6211_i2c_readreg(state, buf_tmp + 3, &x1);
+			goto err;
+		buf_tmp[3] = buf[x2 + 3];
+		x1 = 5;
+		ret = avl6211_i2c_writereg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+	}
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_read16(struct avl6211_state* state, u32 addr, u16 *data)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, addr, buf, 2);
+	if (ret)
+		goto err;
+		
+	*data = extract_16(buf);
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_read32(struct avl6211_state* state, u32 addr, u32 *data)
+{
+	int ret;
+	u8 buf[4];
+
+	ret = avl6211_i2c_read(state, addr, buf, 4);
+	if (ret)
+		goto err;
+		
+	*data = extract_32(buf);
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write16(struct avl6211_state* state, u32 addr, u16 data)
+{
+	int ret;
+	u8 buf[5], *p;
+
+	format_addr(addr, buf);
+	p = buf + 3;
+	format_16(data, p);
+
+	ret = avl6211_i2c_write(state, buf, 5);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write32(struct avl6211_state* state, u32 addr, u32 data)
+{
+	int ret;
+	u8 buf[7], *p;
+
+	format_addr(addr, buf);
+	p = buf + 3;
+	format_32(data, p);
+	ret = avl6211_i2c_write(state, buf, 7);
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_get_op_status(struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, rx_cmd_addr, buf, 2);
+	if (ret)
+		goto err;
+		
+	if (buf[1] != 0) {
+		ret = -EINVAL;
+		goto err;
+	}
+	
+	return 0;
+err:	
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_send_op(u8 ucOpCmd, struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+	u16 x1;
+	int cnt = 20;
+
+	do {
+		ret = avl6211_get_op_status(state);
+		if (!ret)
+			break;
+	
+		msleep(10);
+		cnt--;
+	} while (cnt != 0);
+	
+	if (ret)
+		goto err;
+		
+	buf[0] = 0;
+	buf[1] = ucOpCmd;
+	x1 = extract_16(buf);
+	ret = avl6211_i2c_write16(state, rx_cmd_addr, x1);   
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_get_status(struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, i2cm_cmd_addr + I2CM_CMD_LENGTH - 2, buf, 2);
+	if (ret)
+		goto err;
+		
+	if (buf[1] != 0) {
+		ret = -EINVAL;
+		goto err;
+	}
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_i2c_repeater_exec(struct avl6211_state* state, u8 * buf, u8 size)
+{
+	int ret, i = 0;
+
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 60 < i++) 
+			goto err;
+			
+		msleep(5);
+	
+	} while (ret);
+	
+	ret = avl6211_i2c_write(state, buf, size);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_send(struct avl6211_state* state, u8 * buf, u16 size)
+{
+	int ret;
+	u8 tmp_buf[I2CM_CMD_LENGTH + 3];
+	u16 i, j;
+	u16 cmd_size;
+
+	if (WARN_ON(size > I2CM_CMD_LENGTH - 3))
+		return -EINVAL;
+
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	
+	cmd_size = ((size + 3) % 2) + 3 + size;
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - cmd_size, tmp_buf);
+
+	i = 3 + ((3 + size) % 2);	  /* skip one byte if the size +3 is odd */
+
+	for (j = 0; j < size; j++)
+		tmp_buf[i++] = buf[j];
+
+	tmp_buf[i++] = (u8)size;
+	tmp_buf[i++] = state->config->tuner_address;
+	tmp_buf[i++] = OP_I2CM_WRITE;
+
+			
+	ret = avl6211_i2c_repeater_exec(state, tmp_buf, (u8)(cmd_size + 3));
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_i2c_repeater_recv(struct avl6211_state* state, u8 * buf, u16 size)
+{
+	int ret, i = 0;
+	u8 tmp_buf[I2CM_RSP_LENGTH];
+
+	if (WARN_ON(size > I2CM_RSP_LENGTH))
+		return -EINVAL;
+
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - 4, tmp_buf);
+	tmp_buf[3] = 0x0;
+	tmp_buf[4] = (u8)size;
+	tmp_buf[5] = state->config->tuner_address;
+	tmp_buf[6] = OP_I2CM_READ;
+
+	ret = avl6211_i2c_repeater_exec(state, tmp_buf, 7);
+	if (ret)
+		goto err;
+	
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 100 < i++) 
+			goto err;
+			
+		msleep(10);
+	
+	} while (ret);
+
+	ret = avl6211_i2c_read(state, i2cm_rsp_addr, buf, size);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_init(u16 bus_clk, struct avl6211_state* state)
+{
+	u8 buf[5];
+	int ret;
+
+	ret = avl6211_i2c_write16(state, rc_i2cm_speed_kHz_addr, bus_clk);
+	if (ret)
+		goto err;
+		
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - 2, buf);
+	buf[3] = 0x01;
+	buf[4] = OP_I2CM_INIT;
+	ret = avl6211_i2c_repeater_exec(state, buf, 5);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int AV2011_I2C_write(u8 reg_start, u8* buff, u8 len, struct avl6211_state* state)
+{
+	int ret, i = 0;
+	u8 ucTemp[50] = { 0 };
+	
+	msleep(5);
+	ucTemp[0] = reg_start;
+	ret = avl6211_i2c_repeater_get_status(state);
+	
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 100 < i++) 
+			goto err;
+			
+		msleep(1);
+	
+	} while (ret);
+		
+	for (i = 1; i < len + 1; i++)			
+		ucTemp[i] = *(buff + i - 1);
+			
+	ret = avl6211_i2c_repeater_send(state, ucTemp, len+1);
+	if (ret)
+		goto err;
+	
+	msleep(5);
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int av2011_tuner_lock_status(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;	
+	int ret;
+	u8 lock = 0x0b;
+	u8 locked = 0;
+	ret = avl6211_i2c_repeater_send(state, &lock, 1);
+	if (ret)
+		goto err;
+		
+	ret = avl6211_i2c_repeater_recv(state, &locked, 1);
+	if (ret)
+		goto err;
+
+	if (!(locked & 0x01)) 
+		return -EINVAL;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_lock(struct dvb_frontend* fe)
+{
+	int ret;
+	struct avl6211_state *state = fe->demodulator_priv;	
+	u8 reg[50];
+	u32 fracN;
+	u32 BW;
+	u32 BF;
+	u32 freq = state->frequency / 1000;
+	u32 LPF = state->tuner_lpf * 100;
+
+	memset(reg, 0, sizeof(reg));
+
+	msleep(50);
+	
+	fracN = (freq + 27/2) / 27;
+	if (fracN > 0xff)
+		fracN = 0xff;
+		
+	reg[0] = (char)(fracN & 0xff);
+	fracN = (freq << 17) / 27;
+	fracN = fracN & 0x1ffff;
+	reg[1] = (char)((fracN >> 9) & 0xff);
+	reg[2] = (char)((fracN >> 1) & 0xff);
+	reg[3] = (char)((fracN << 7) & 0x80) | 0x50;
+
+	BW = (LPF * 135) / 200;
+	if (LPF < 6500)
+		BW = BW + 6000;
+   	BW = BW + 2000;
+	BW = BW*108/100;
+
+	if (BW < 4000)
+		BW = 4000;
+	if ( BW > 40000)
+		BW = 40000;
+	BF = (BW * 127 + 21100/2) / 21100; 
+	
+	dev_dbg(&state->i2c->dev, "BF is %d,BW is %d\n", BF, BW);
+	
+	reg[5] = (u8)BF;
+
+	msleep(5);
+	ret = AV2011_I2C_write(0, reg, 4, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+		
+	ret = AV2011_I2C_write(5, reg+5, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+			
+	reg[37] = 0x06;
+	ret = AV2011_I2C_write(37, reg+37, 1, state);
+	if (ret)
+		goto err;;
+		
+	msleep(5);
+		
+	reg[12] = 0x96 + (1 << 6);
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_tuner_reg_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+    int ret;
+	
+	u8 reg[50] = { 
+		0x38, 0x00, 0x00, 0x50, 0x1f, 0xa3, 0xfd, 0x58, 0x0e,
+		0xc2, 0x88, 0xb4, 0xd6, 0x40, 0x94, 0x9a, 0x66, 0x40,
+		0x80, 0x2b, 0x6a, 0x50, 0x91, 0x27, 0x8f, 0xcc, 0x21,
+		0x10, 0x80, 0x02, 0xf5, 0x7f, 0x4a, 0x9b, 0xe0, 0xe0,
+		0x36, 0x00, 0xab, 0x97, 0xc5, 0xa8,
+	};
+	
+	ret = AV2011_I2C_write(0, reg, 12, state);
+	if (ret)
+		goto err;
+		
+	msleep(1);
+		
+	ret = AV2011_I2C_write(13, reg+13, 12, state);
+	if (ret)
+		goto err;
+		
+	ret = AV2011_I2C_write(25, reg+25, 11, state);
+	if (ret)
+		goto err;
+		
+	ret = AV2011_I2C_write(36, reg+36, 6, state);
+	if (ret)
+		goto err;
+		
+	msleep(1);
+		
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(10);
+	
+	ret = AV2011_I2C_write(0, reg, 12, state);
+	if (ret)
+		goto err;
+			
+	msleep(1);
+					
+	ret = AV2011_I2C_write(13, reg+13 , 12, state);
+	if (ret)
+		goto err;
+			
+	ret = AV2011_I2C_write(25, reg+25 , 11, state);
+	if (ret)
+		goto err;
+			
+	ret = AV2011_I2C_write(36, reg+36, 6, state);
+	if (ret)
+		goto err;
+			
+	msleep(1);
+		
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+	
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_tuner_init(struct dvb_frontend* fe) 
+{
+    struct avl6211_state *state = fe->demodulator_priv;
+    int ret;
+	
+    ret = avl6211_i2c_write16(state, rc_tuner_slave_addr_addr, state->config->tuner_address);
+	if (ret)
+		goto err;
+	/* Use external control */
+	ret = avl6211_i2c_write16(state, rc_tuner_use_internal_control_addr, 0);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_tuner_LPF_margin_100kHz_addr, 0);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_tuner_max_LPF_100kHz_addr, 360 );
+	if (ret)
+		goto err;
+	
+    ret = avl6211_i2c_repeater_init(state->config->tuner_i2c_clock, state);
+	if (ret)
+		goto err;
+
+	ret = av2011_tuner_reg_init(fe);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+    return ret;
+}
+
+static int avl6211_diseqc_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+	
+	ret = avl6211_i2c_write32(state, diseqc_srst_addr, 1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_samp_frac_n_addr, 200);	/* 2M = 200 * 10kHz */
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_samp_frac_d_addr, state->demod_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_tone_frac_n_addr, (22 << 1));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_tone_frac_d_addr, state->demod_freq * 10);
+	if (ret)
+		goto err;
+
+	/* Initialize the tx_control */
+	ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+	if (ret)
+		goto err;
+	x1 &= 0x00000300;
+	x1 |= 0x20;		/* Reset tx_fifo */
+	x1 |= (u32)(0 << 6);
+	x1 |= (u32)(0 << 4);
+	x1 |= (1 << 3);			/* Enable tx gap */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	x1 &= ~(0x20);	/* Release tx_fifo reset */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+
+	/* Initialize the rx_control */
+	x1 = (u32)(0 << 2);
+	x1 |= (1 << 1);	/* Activate the receiver */
+	x1 |= (1 << 3);	/* Envelop high when tone present */
+	ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	x1 = (u32)(0 >> 12);
+	ret = avl6211_i2c_write32(state, diseqc_rx_msg_tim_addr, x1);
+	if (ret)
+		goto err;
+
+	ret = avl6211_i2c_write32(state, diseqc_srst_addr, 0);
+	if (ret)
+		goto err;
+
+	
+	state->diseqc_status = DISEQC_STATUS_INIT;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_switch_mode(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret = 0;
+	u32 x1;
+
+	switch (state->diseqc_status) {
+		case DISEQC_STATUS_MOD:
+		case DISEQC_STATUS_TONE:
+			ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+			if (ret)
+				goto err;
+			if (((x1 & 0x00000040) >> 6) != 1)
+				ret = -EINVAL;
+			break;
+		case DISEQC_STATUS_CONTINUOUS:
+		case DISEQC_STATUS_INIT:
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_get_tx_status(struct dvb_frontend* fe, struct avl6211_diseqc_tx_status * pTxStatus)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+
+	if ((state->diseqc_status == DISEQC_STATUS_MOD) || 
+		(state->diseqc_status == DISEQC_STATUS_TONE)) {
+		ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+		if (ret)
+			goto err;
+			
+		pTxStatus->tx_done = (u8)((x1 & 0x00000040) >> 6);
+		pTxStatus->tx_fifo_cnt = (u8)((x1 & 0x0000003c) >> 2);
+	}
+	else
+		ret = -EINVAL;
+
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_send_mod_data(struct dvb_frontend* fe, const u8 * buf, u8 size)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1, x2;
+	int cnt = 0;
+	u8 buf_tmp[8];
+	u8 Continuousflag = 0;
+
+
+	if (WARN_ON(size > 8))
+		return -EINVAL;		
+	else {
+		ret = avl6211_diseqc_switch_mode(fe);
+		if (ret)
+			goto err;
+		
+		if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			if ((x1 >> 10) & 0x01) {
+				Continuousflag = 1;
+				x1 &= 0xfffff3ff;
+				ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+				if (ret)
+					goto err;
+				msleep(20);
+			}
+		}
+			/* Reset rx_fifo */
+		ret = avl6211_i2c_read32(state, diseqc_rx_cntrl_addr, &x2);
+		if (ret)
+			goto err;
+		ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, (x2 | 0x01));
+		if (ret)
+			goto err;
+		ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, (x2 & 0xfffffffe));
+		if (ret)
+			goto err;
+
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8;	//set to modulation mode and put it to FIFO load mode
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+			
+			/* Trunk address */
+		format_addr(diseqc_tx_fifo_map_addr, buf_tmp);
+		buf_tmp[3] = 0;
+		buf_tmp[4] = 0;
+		buf_tmp[5] = 0;
+		for (x2 = 0; x2 < size; x2++) {
+			buf_tmp[6] = buf[x2];
+			ret = avl6211_i2c_write(state, buf_tmp, 7);
+			if (ret)
+				goto err;
+		}
+
+		x1 |= (1 << 2);  //start fifo transmit.
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		
+		state->diseqc_status = DISEQC_STATUS_MOD;
+		do 
+		{
+			msleep(1);
+			if (++cnt > 500) {
+				ret = -ETIME;
+				goto err;
+			}
+			ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+			if (ret)
+				goto err;
+		} while ( 1 != ((x1 & 0x00000040) >> 6) );
+
+		msleep(20);
+		if (Continuousflag == 1)			//resume to send out wave
+		{
+			//No data in FIFO
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffff8; 
+			x1 |= 0x03;		//switch to continuous mode
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+
+			//start to send out wave
+			x1 |= (1<<10);  
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			
+			state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+		}
+	}
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;;
+}
+
+static int avl6211_send_diseqc_msg(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *d)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct avl6211_diseqc_tx_status tx_status;
+	int cnt = 100;
+	int ret;
+
+	if ((d->msg_len < 3) || (d->msg_len > 6))
+        	return -EINVAL;
+
+	ret = avl6211_diseqc_send_mod_data(fe, d->msg, d->msg_len);
+	if (ret)
+		goto err;
+	
+	msleep(55);		
+		
+	do {
+		ret = avl6211_diseqc_get_tx_status(fe, &tx_status);
+		if (ret)
+			goto err;
+			
+		if ( tx_status.tx_done == 1 )
+			break;
+
+		msleep(10);
+		cnt--;
+		if (!cnt) {
+			ret = -ETIME;
+			goto err;
+		}
+	} while (tx_status.tx_done != 1);
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_diseqc_send_burst(struct dvb_frontend* fe, enum fe_sec_mini_cmd burst)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct avl6211_diseqc_tx_status tx_status;
+	int cnt = 100;
+	int tx_cnt = 0;
+	int ret;
+	u32 x1;
+	u8 buf[8];
+	u8 Continuousflag = 0;
+	
+	ret = avl6211_diseqc_switch_mode(fe);
+	if (ret)
+		goto err;
+
+	if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		if ((x1 >> 10) & 0x01) {
+			Continuousflag = 1;
+			x1 &= 0xfffff3ff;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+		}
+	}
+	/* No data in the FIFO */
+	ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+	if (ret)
+		goto err;
+	x1 &= 0xfffffff8;  /* Put it into the FIFO load mode */
+	if (burst == SEC_MINI_A)
+		x1 |= 0x02;
+	else
+		x1 |= 0x01;
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	/* Trunk address */
+	format_addr(diseqc_tx_fifo_map_addr, buf);
+	buf[3] = 0;
+	buf[4] = 0;
+	buf[5] = 0;
+	buf[6] = 1;
+
+	ret = avl6211_i2c_write(state, buf, 7);
+	if (ret)
+		goto err;
+
+	x1 |= (1<<2);  /* Start fifo transmit */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	
+	state->diseqc_status = DISEQC_STATUS_TONE;
+	
+	do 
+	{
+		msleep(1);
+		if (++tx_cnt > 500) {
+			ret = -ETIME;
+			goto err;
+		}
+		ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+		if (ret)
+			goto err;
+	} while ( 1 != ((x1 & 0x00000040) >> 6) );
+
+	msleep(20);
+	
+	if (Continuousflag == 1)			//resume to send out wave
+	{
+		//No data in FIFO
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8; 
+		x1 |= 0x03;		//switch to continuous mode
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+
+		//start to send out wave
+		x1 |= (1<<10);  
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		
+		state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+			
+	}	
+	do {
+		ret = avl6211_diseqc_get_tx_status(fe, &tx_status);
+		if ( tx_status.tx_done == 1 )
+			break;
+
+		msleep(10);
+		cnt--;
+		if (!cnt) {
+			ret = -ETIME;
+			goto err;
+		}
+	} while (tx_status.tx_done != 1);
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_set_tone(struct dvb_frontend* fe, enum fe_sec_tone_mode tone)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+
+	if (tone == SEC_TONE_ON) {
+		
+		ret = avl6211_diseqc_switch_mode(fe);
+		if (ret)
+			goto err;
+
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8;
+		x1 |= 0x03;	
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		x1 |= (1 << 10);
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+			
+		state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+	} else {
+	
+		if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffff3ff;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+		}
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_set_voltage(struct dvb_frontend *fe,
+	enum fe_sec_voltage voltage)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+	
+	if (voltage == SEC_VOLTAGE_OFF) {
+	
+		if (state->config->set_external_vol_gpio)
+			state->config->set_external_vol_gpio(&state->demod_id, 0);
+		
+		state->gpio_on = false;
+		
+		return 0;
+	}
+	if (voltage == SEC_VOLTAGE_13) {
+		if (state->config->use_lnb_pin59) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffdff;		
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);	//delay 20ms
+		}
+		
+		if (state->config->use_lnb_pin60) {
+					
+			ret = avl6211_i2c_read32(state, gpio_reg_enb, &x1);
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1);
+			ret = avl6211_i2c_write32(state, gpio_reg_enb, x1);  
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, gpio_data_reg_out, &x1);	
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1) ;			
+			ret = avl6211_i2c_write32(state, gpio_data_reg_out, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+
+		}						
+	} else if (voltage == SEC_VOLTAGE_18) {
+	
+		if (state->config->use_lnb_pin59) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffdff;
+			x1 |= 0x200;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);	//delay 20ms
+		}
+		if (state->config->use_lnb_pin60) {
+			ret = avl6211_i2c_read32(state, gpio_reg_enb, &x1);
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1);
+			ret = avl6211_i2c_write32(state, gpio_reg_enb, x1);  
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, gpio_data_reg_out, &x1);	
+			if (ret)
+				goto err;
+			x1 |= 1<<1 ;			
+			ret = avl6211_i2c_write32(state, gpio_data_reg_out, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+		}		
+	}
+	
+	if (!state->gpio_on) {	
+		state->gpio_on = true;		
+		if (state->config->set_external_vol_gpio) 
+			state->config->set_external_vol_gpio(&state->demod_id, 1);
+	}
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_ber(struct dvb_frontend* fe, u32* ber)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 r_ber;
+
+	*ber = 0;
+	
+	if (state->locked == 1) {		
+		ret = avl6211_i2c_read32(state, rp_uint_BER_addr, &r_ber);
+		if (ret)
+			goto err;
+			
+		if (r_ber > 0)			
+			*ber = r_ber / 1000000000;			
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+u8 DVBS_SNR[6] = { 12, 32, 41, 52, 58, 62 };
+u8 DVBS2Qpsk_SNR[8] = { 10, 24, 32, 41, 47, 52, 63, 65 };
+u8 DVBS28psk_SNR[6] = { 57, 67, 80, 95, 100, 110 };
+static int avl6211_read_snr(struct dvb_frontend* fe, u16 *snr)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u8 SNRrefer = 0;
+	u32 r_snr, code_rate, modulation;
+
+	*snr = 0;
+	
+	if (state->locked == 1) {
+		ret = avl6211_i2c_read32(state, rs_int_SNR_dB_addr, &r_snr);
+		if (ret)
+			goto err;
+		if (r_snr < 10000) {
+			ret = avl6211_i2c_read32(state, rs_code_rate_addr, &code_rate);
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, rs_modulation_addr, &modulation);
+			if (ret)
+				goto err;
+				
+			if (code_rate < 6)
+				SNRrefer = DVBS_SNR[code_rate];			
+			else {
+				if (modulation == 1)
+					SNRrefer = DVBS28psk_SNR[code_rate - 10];
+				else	
+					SNRrefer = DVBS2Qpsk_SNR[code_rate - 9];
+			}	
+			if ((r_snr / 10) > SNRrefer) {
+				r_snr = r_snr/10 - SNRrefer;
+				if (r_snr >= 100)
+					*snr = 99;
+				else if (r_snr >= 50)  //  >5.0dB
+					*snr = 80+ (r_snr - 50)*20/50;
+				else if (r_snr >= 25)  //  > 2.5dB
+					*snr = 50+ (r_snr - 25)*30/25;
+				else if (r_snr >= 10)  //  > 1dB
+					*snr = 25+ (r_snr - 10)*25/15;			
+				else 
+					*snr = 5 + (r_snr)*20/10;
+					
+				*snr = (*snr * 65535) / 100;
+			}
+		}
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+struct Signal_Level
+{
+	u16 SignalLevel;
+	short SignalDBM;
+};
+struct Signal_Level  AGC_LUT [91]=
+{
+    {63688,  0},{62626, -1},{61840, -2},{61175, -3},{60626, -4},{60120, -5},{59647, -6},{59187, -7},{58741, -8},{58293, -9},
+    {57822,-10},{57387,-11},{56913,-12},{56491,-13},{55755,-14},{55266,-15},{54765,-16},{54221,-17},{53710,-18},{53244,-19},
+    {52625,-20},{52043,-21},{51468,-22},{50904,-23},{50331,-24},{49772,-25},{49260,-26},{48730,-27},{48285,-28},{47804,-29},
+    {47333,-30},{46880,-31},{46460,-32},{46000,-33},{45539,-34},{45066,-35},{44621,-36},{44107,-37},{43611,-38},{43082,-39},
+    {42512,-40},{41947,-41},{41284,-42},{40531,-43},{39813,-44},{38978,-45},{38153,-46},{37294,-47},{36498,-48},{35714,-49},
+    {35010,-50},{34432,-51},{33814,-52},{33315,-53},{32989,-54},{32504,-55},{32039,-56},{31608,-57},{31141,-58},{30675,-59},
+    {30215,-60},{29711,-61},{29218,-62},{28688,-63},{28183,-64},{27593,-65},{26978,-66},{26344,-67},{25680,-68},{24988,-69},
+    {24121,-70},{23285,-71},{22460,-72},{21496,-73},{20495,-74},{19320,-75},{18132,-76},{16926,-77},{15564,-78},{14398,-79},
+    {12875,-80},{11913,-81},{10514,-82},{ 9070,-83},{ 7588,-84},{ 6044,-85},{ 4613,-86},{ 3177,-87},{ 1614,-88},{  123,-89},
+    {    0,-90}
+};
+static int avl6211_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)
+{
+	#define Level_High_Stage	36
+	#define Level_Low_Stage		76
+
+	#define Percent_Space_High	10
+	#define Percent_Space_Mid	30
+	#define Percent_Space_Low	60
+	
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 rf;
+	u16 Level;
+	int i = 0;
+	int Percent = 0;
+	*signal_strength = 0;
+		
+	if (state->locked == 1) {
+		ret = avl6211_i2c_read32(state, rx_aagc_gain, &rf);
+		if (ret)
+			goto err;
+		
+		rf += 0x800000;
+		rf &= 0xffffff;	
+		Level = (u16)(rf >> 8);
+
+	while( Level < AGC_LUT[i++].SignalLevel);
+	
+	if (i <= Level_High_Stage)
+		Percent = Percent_Space_Low+Percent_Space_Mid+ (Level_High_Stage-i)*Percent_Space_High/Level_High_Stage;
+	else if(i<=Level_Low_Stage)
+		Percent = Percent_Space_Low+ (Level_Low_Stage-i)*Percent_Space_Mid/(Level_Low_Stage-Level_High_Stage);
+	else
+		Percent =(90-i)*Percent_Space_Low/(90-Level_Low_Stage);
+
+	*signal_strength = (Percent * 65535) / 100;	
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_status(struct dvb_frontend* fe, enum fe_status* status)
+{
+	struct avl6211_state *state = fe->demodulator_priv;	
+	int ret;
+	*status = 0;
+	
+	ret = avl6211_i2c_read16(state, rs_fec_lock_addr, &state->locked);
+	if (ret)
+		goto err;
+
+	if (state->locked == 1) 
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | 
+				FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+static int avl6211_get_frontend(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 code_rate;
+	u16 ret;
+		
+	if (!state->locked)
+		return 0;
+	
+	ret = avl6211_i2c_read32(state, rs_code_rate_addr, &code_rate);
+	if (ret)
+		goto err;
+		
+	p->frequency = state->frequency;
+	p->inversion = INVERSION_AUTO;
+	p->symbol_rate = state->symbol_rate;
+	
+	switch (code_rate) { 
+		case 0:
+		p->fec_inner = FEC_1_2;
+		break;
+		case 1:
+		p->fec_inner = FEC_2_3;
+		break;
+		case 2:
+		p->fec_inner = FEC_3_4;
+		break;
+		case 13:
+		p->fec_inner = FEC_4_5;
+		break;
+		case 14:
+		p->fec_inner = FEC_5_6;
+		break;
+		case 4:
+		p->fec_inner = FEC_6_7;
+		break;
+		case 5:
+		p->fec_inner = FEC_7_8;
+		break;
+		case 15:
+		p->fec_inner = FEC_8_9;
+		break;
+		case 10:
+		p->fec_inner = FEC_3_5;
+		break;
+		case 16:
+		p->fec_inner = FEC_9_10;
+		break;
+		default:
+		p->fec_inner = FEC_AUTO;
+		break;
+	}
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_channel_lock(struct dvb_frontend* fe)
+{
+    struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 IQ;
+	u32 autoIQ_Detect;
+	u16 Standard;
+	u16 auto_manual_lock;
+	int cnt = 0;
+
+	ret = avl6211_i2c_write16(state, rc_lock_mode_addr, 0);	
+	if (ret)
+		goto err;
+		
+	IQ = ((state->flags) & CI_FLAG_IQ_BIT_MASK) >> CI_FLAG_IQ_BIT;
+	ret = avl6211_i2c_write32(state, rc_specinv_addr, IQ);
+	if (ret)
+		goto err;
+	
+	Standard = (u16)(((state->flags) & CI_FLAG_DVBS2_BIT_MASK) >> CI_FLAG_DVBS2_BIT);
+	autoIQ_Detect = (((state->flags) & CI_FLAG_IQ_AUTO_BIT_MASK) >> CI_FLAG_IQ_AUTO_BIT);
+	auto_manual_lock = (u16)(((state->flags) & CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK) >> CI_FLAG_MANUAL_LOCK_MODE_BIT);
+
+	
+	if((Standard == CI_FLAG_DVBS2_UNDEF) || (autoIQ_Detect == 1))
+		Standard = 0x14;
+
+	if (state->symbol_rate == 0)
+		state->symbol_rate = 1;
+	
+	ret = avl6211_i2c_write16(state, rc_fec_bypass_coderate_addr, auto_manual_lock);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_decode_mode_addr, Standard);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_iq_mode_addr, (u16)autoIQ_Detect);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_int_sym_rate_MHz_addr, state->symbol_rate);
+	if (ret)
+		goto err;
+	
+	
+	ret = avl6211_send_op(OP_RX_INIT_GO, state);
+	if (ret)
+		goto err;
+		
+	do {
+		ret = avl6211_get_op_status(state);
+		if(!ret)
+			break;
+		msleep(1);
+	} while(cnt++ < 200);
+	
+	if (ret)
+		goto err;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_set_frontend(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	u16 cnt;
+	u32 max_time;
+	
+	
+	state->frequency = c->frequency;
+	state->symbol_rate = c->symbol_rate;
+	
+	state->locked = 0;
+
+	dev_dbg(&state->i2c->dev, 
+		"%s: delivery_system=%d frequency=%d symbol_rate=%d\n", 
+		__func__, c->delivery_system, c->frequency, c->symbol_rate);
+
+	state->tuner_lpf = (state->symbol_rate / 100000);
+	if (state->tuner_lpf > 440)
+		state->tuner_lpf = 440;
+
+	ret = av2011_lock(fe);
+	if (ret)
+		goto err;
+
+	/* Wait for tuner locking */
+	max_time = 150;  /* Max waiting time: 150ms */
+
+	cnt = max_time / 10;
+	do {	
+		ret = av2011_tuner_lock_status(fe);		
+
+		if (!ret)
+			break;
+		else {		
+			msleep(10);    /* Wait 10ms for demod to lock the channel */			
+			continue;
+		}		
+		
+	} while (--cnt);
+
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	dev_dbg(&state->i2c->dev, "Tuner successfully lock!\n");
+
+	state->flags = (CI_FLAG_IQ_NO_SWAPPED) << CI_FLAG_IQ_BIT;			//Normal IQ
+	state->flags |= (CI_FLAG_IQ_AUTO_BIT_AUTO) << CI_FLAG_IQ_AUTO_BIT;	//Enable automatic IQ swap detection
+	state->flags |= (CI_FLAG_DVBS2_UNDEF) << CI_FLAG_DVBS2_BIT;			//Enable automatic standard detection
+
+	//This function should be called after tuner locked to lock the channel.
+	ret = avl6211_channel_lock(fe);
+	if (ret)
+		goto err;
+		
+	/* Wait a bit more when we have slow symbol rates */
+	if (c->symbol_rate < 5000000)
+		max_time = 5000*2; /* Max waiting time: 1000ms */
+	else if (c->symbol_rate < 10000000)
+		max_time = 600*2;  /* Max waiting time: 600ms */
+	else
+		max_time = 250*2;  /* Max waiting time: 250ms */
+
+	cnt = max_time / 10;
+	do {
+		ret = avl6211_i2c_read16(state, rs_fec_lock_addr, &state->locked);
+
+		if (!ret && state->locked == 1)
+				break;
+
+		msleep(10);    /* Wait 10ms for demod to lock the channel */		
+	} while (--cnt);
+	
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	dev_dbg(&state->i2c->dev, "Service locked!!!\n");
+
+	ret = avl6211_send_op(OP_RX_RESET_BERPER, state);
+	if (ret)
+		goto err;
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+
+static int avl6211_get_demod_status(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u8	buf[2]; 
+	u32 x1 = 0;
+	
+	ret = avl6211_i2c_read32(state, core_reset_b_reg, &x1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_read16(state, core_ready_word_addr, (u16 *)buf);	
+	if (ret)
+		goto err;
+	
+	if ((x1 == 0) || (buf[0] != 0x5a) || (buf[1] != 0xa5)) {
+		ret = -EINVAL;
+		goto err;
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_setup_pll(struct avl6211_state* state, const struct avl6211_pllconf * pll_ptr)
+{
+	int ret;
+	
+	ret = avl6211_i2c_write32(state, pll_clkf_map_addr, pll_ptr->m_uiClkf);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_bwadj_map_addr, pll_ptr->m_uiClkf);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_clkr_map_addr, pll_ptr->m_uiClkr);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od_map_addr, pll_ptr->m_uiPllod);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od2_map_addr, pll_ptr->m_uiPllod2);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od3_map_addr, pll_ptr->m_uiPllod3);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_softvalue_en_map_addr, 1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, reset_register_addr, 0);
+	if (ret)
+		goto err;
+	
+	/* Reset do not check for error */
+	avl6211_i2c_write32(state, reset_register_addr, 1);
+	
+	state->demod_freq = pll_ptr->demod_freq;
+	state->fec_freq = pll_ptr->fec_freq;
+	state->mpeg_freq = pll_ptr->mpeg_freq;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_load_firmware(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	const struct firmware *fw = NULL;
+	u8 *buffer = NULL;
+	u32 buf_size, data_size;
+	u32 i = 4;
+	int ret;
+	
+	ret = avl6211_i2c_write32(state, core_reset_b_reg, 0);
+	if (ret)
+		goto err;
+
+	dev_dbg(&state->i2c->dev, "Uploading demod firmware (%s)...\n", AVL6211_DEMOD_FW);
+	ret = request_firmware(&fw, AVL6211_DEMOD_FW, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Firmware upload failed. Timeout or file not found\n");
+		goto err;
+	}    
+
+	buffer = kmalloc(fw->size , GFP_KERNEL);
+	if (!buffer) {
+		release_firmware(fw);
+		fw = NULL;
+		dev_dbg(&state->i2c->dev, "Failed to allocate tmp memory for firmware\n");
+		return -ENOMEM;
+	}
+	memcpy(buffer, fw->data, fw->size);
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	data_size = extract_32(buffer);
+	while (i < data_size)
+	{
+		buf_size = extract_32(buffer + i);
+		i += 4;
+		ret = avl6211_i2c_write(state, buffer + i + 1, (u16)(buf_size + 3));
+		if (ret)
+			goto err;
+			
+		i += 4 + buf_size;
+	}
+	
+	ret = avl6211_i2c_write32(state, 0x00000000, 0x00003ffc);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write16(state, core_ready_word_addr, 0x0000);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write32(state, error_msg_addr, 0x00000000);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write32(state, error_msg_addr + 4, 0x00000000);
+	if (ret)
+			goto err;
+
+	/* Reset do not check for error */
+	avl6211_i2c_write32(state, core_reset_b_reg, 1);
+	
+	kfree(buffer);
+	return 0;
+	
+err:
+	kfree(buffer);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	int ret;
+
+	if (state->boot)
+		return 0;
+		
+	ret = avl6211_setup_pll(state, (const struct avl6211_pllconf * )(pll_conf + state->config->demod_refclk));
+	if (ret)
+		goto err;
+		
+	msleep(100);
+	
+	ret = avl6211_load_firmware(fe);
+	if (ret)
+		goto err;
+		
+	msleep(100);
+	
+	ret = avl6211_get_demod_status(fe);
+	if (ret)
+		goto err;
+	
+	
+	ret = avl6211_i2c_write32(state, 0x263E, 50000);
+	if (ret)
+		goto err;
+	/* Set clk to match the PLL */
+	ret = avl6211_i2c_write16(state, rc_int_dmd_clk_MHz_addr,  state->demod_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_int_fec_clk_MHz_addr, state->fec_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_int_mpeg_clk_MHz_addr, state->mpeg_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_format_addr, 1);
+	if (ret)
+		goto err;
+	
+	/* Set AGC polarization */
+	ret = avl6211_i2c_write32(state, rc_rfagc_pol_addr, (u32)state->config->tuner_rfagc);
+	if (ret)
+		goto err;	
+	/* Drive RF AGC */
+	ret = avl6211_i2c_write16(state, rc_aagc_ref_addr, 0x30);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_rfagc_tri_enb, 1);
+	if (ret)
+		goto err;
+
+	ret = avl6211_i2c_write16(state, rc_blind_scan_tuner_spectrum_inversion_addr, (u16)state->config->tuner_spectrum);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state, rc_mpeg_mode_addr, (u32)(state->config->mpeg_format));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_mpeg_serial_addr, (u16)(state->config->mpeg_mode));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_mpeg_posedge_addr, (u16)(state->config->mpeg_pol));
+	if (ret)
+		goto err;
+	
+	if (state->config->mpeg_mode) {
+		ret = avl6211_i2c_write32(state, rc_outpin_sel_addr, (u32)(state->config->mpeg_pin));		
+		if (ret)
+			goto err;
+	}
+	
+	ret = avl6211_i2c_write32(state, rc_mpeg_bus_tri_enb, 1);
+	if (ret)
+		goto err;
+	
+	ret = av2011_tuner_init(fe);
+	if (ret)
+		goto err;
+	ret = avl6211_diseqc_init(fe);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state,  gpio_data_reg_out, 0);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state, gpio_reg_enb, 0);
+	if (ret)
+		goto err;
+	
+	state->boot = true;
+	
+	dev_dbg(&state->i2c->dev, "AVL6211+AV2011 init OK\n");
+	
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static void avl6211_release(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static struct dvb_frontend_ops avl6211_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 }, 
+	.info = {
+		.name = "Availink AVL6211+AV2011 DVB-S/S2",	
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+		.frequency_stepsize = 0,		
+		.frequency_tolerance = 0,
+		.symbol_rate_min = 800000,		/* Min = 800K */
+		.symbol_rate_max = 50000000,	/* Max = 50M */
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK    | FE_CAN_RECOVER | FE_CAN_2G_MODULATION			
+	},
+
+	.init = avl6211_init,
+	.release = avl6211_release,
+	.read_status = avl6211_read_status,
+	.read_ber = avl6211_read_ber,
+	.read_signal_strength = avl6211_read_signal_strength,
+	.read_snr = avl6211_read_snr,
+	.read_ucblocks = avl6211_read_ucblocks,
+	.set_tone = avl6211_set_tone,	
+	.set_voltage = avl6211_set_voltage,
+	.diseqc_send_master_cmd = avl6211_send_diseqc_msg,
+	.diseqc_send_burst = avl6211_diseqc_send_burst,
+	.set_frontend = avl6211_set_frontend,
+	.get_frontend = avl6211_get_frontend,
+};
+
+struct dvb_frontend* avl6211_attach(struct i2c_adapter* i2c,
+									struct avl6211_config* config,
+									int id)
+									
+{
+	struct avl6211_state* state = NULL;
+	int ret;
+	u32 ChipID = 0;
+	
+	state = kzalloc(sizeof(struct avl6211_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+
+	state->config = config;
+	state->i2c = i2c;	
+	state->demod_id = id;
+	
+	ret = avl6211_i2c_read32(state, rs_cust_chip_id_addr, &ChipID);
+	if (ret || ChipID != 0x0000000F)
+		goto err2;
+
+	dev_info(&i2c->dev, "AVL6211+AV2011 DVB-S/S2 successfully attached\n");	
+	
+	memcpy(&state->frontend.ops, &avl6211_ops, sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+
+	return &state->frontend;
+	
+err2:	
+	kfree(state);
+err1:	
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);	
+	return NULL;
+}
+
+EXPORT_SYMBOL(avl6211_attach);
+
+MODULE_DESCRIPTION("Availink AVL6211+AV2011 demod+tuner driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/avl6211.h b/drivers/amlogic/wetek/avl6211.h
new file mode 100644
index 0000000..6a7d633
--- /dev/null
+++ b/drivers/amlogic/wetek/avl6211.h
@@ -0,0 +1,156 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __AVL6211_H_
+#define __AVL6211_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+
+#define AVL6211_DEMOD_FW 		"dvb-fe-avl6211.fw" 
+
+#define I2C_MAX_READ	64
+#define I2C_MAX_WRITE	64
+
+
+#define CI_FLAG_IQ_BIT							0x00000000
+#define CI_FLAG_IQ_BIT_MASK						0x00000001
+#define CI_FLAG_IQ_NO_SWAPPED					0x00000000
+#define CI_FLAG_IQ_SWAPPED						0x00000001
+#define CI_FLAG_IQ_AUTO_BIT_MASK				0x00000020  
+
+
+#define CI_FLAG_IQ_AUTO_BIT						0x00000005
+#define CI_FLAG_IQ_AUTO_BIT_AUTO				0x00000001
+
+#define CI_FLAG_DVBS2_BIT						0x00000002
+#define CI_FLAG_DVBS2_UNDEF						0x00000004
+#define CI_FLAG_DVBS2_BIT_MASK					0x0000001c
+
+#define CI_FLAG_MANUAL_LOCK_MODE_BIT			0x00000001
+#define CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK		0x00000002
+#define CI_FLAG_LOCK_MODE_BIT_MASK				0x00000040
+
+
+#define ENABLE_FAST_REACQ           0x01
+#define DISABLE_FAST_REACQ          0x00
+#define ENABLE_CCI                  0x03
+#define DISABLE_CCI                 0x02
+#define MAX_LOWIF_SR                5000000
+#define IF_OFFSET                   500
+
+
+/* Demod commands */
+#define OP_RX_NOOP                  0x00
+#define OP_RX_LD_DEFAULT            0x01
+#define OP_RX_INIT_GO               0x02
+#define OP_RX_RESET_BERPER          0x03
+#define OP_RX_HALT                  0x04
+#define OP_RX_SLEEP                 0x05
+#define OP_RX_WAKE                  0x06
+#define OP_RX_BLIND_SCAN            0x08
+#define OP_RX_STDOUT_MODE           0x09
+	
+/* Diseqc status */
+#define DISEQC_STATUS_UNINIT				0x00
+#define DISEQC_STATUS_INIT					0x01
+#define DISEQC_STATUS_CONTINUOUS			0x02
+#define DISEQC_STATUS_TONE					0x03
+#define DISEQC_STATUS_MOD					0x04
+
+#define I2CM_CMD_LENGTH   0x14
+#define I2CM_RSP_LENGTH   0x14
+
+#define OP_I2CM_NOOP      0x00
+#define OP_I2CM_INIT	  0x01
+#define OP_I2CM_WRITE     0x02
+#define OP_I2CM_READ      0x03
+
+	
+
+#define format_addr(X, Y)		\
+	do {						\
+		Y[0] =(u8)((X) >> 16);	\
+		Y[1] =(u8)((X) >> 8);	\
+		Y[2] =(u8)(X);			\
+	} while (0)
+
+
+#define format_16(X, Y)			\
+	do {						\
+		Y[0] =(u8)((X) >> 8);	\
+		Y[1] =(u8)((X) & 0xFF);	\
+	} while (0)
+
+
+#define format_32(X, Y)			\
+	do {						\
+		Y[0] =(u8)((X) >> 24);	\
+		Y[1] =(u8)((X) >> 16);	\
+		Y[2] =(u8)((X) >> 8);	\
+		Y[3] =(u8)((X) & 0xFF);	\
+	} while (0)
+
+
+struct avl6211_pllconf
+{
+	u16 m_uiClkf; /* Feedback clock divider */
+	u16 m_uiClkr; /* Reference clock divider */
+	u16 m_uiPllod; /* PLL output divider */
+	u16 m_uiPllod2; /* PLL output divider 2 */
+	u16 m_uiPllod3; /* PLL output divider 3 */
+	u16 ref_freq; /* Reference clock in kHz */
+	u16 demod_freq; /* Demod clock in 10kHz */
+	u16 fec_freq; /* FEC clock in 10kHz */
+	u16 mpeg_freq; /* MPEG clock in 10kHz */
+};
+
+struct avl6211_config
+{
+	u8 tuner_address; /* Tuner i2c address */
+	u16 tuner_i2c_clock;	
+	u8 demod_address;	/* The demodulator's i2c address  0x0C */ 
+				
+	u8 mpeg_pol; /* 0 - Falling, 1 - Rising */
+	u8 mpeg_mode; /* 0 - Parallel, 1 - Serial */
+	u8 mpeg_format; /* 0 - Default TS stream, 1 - TS stream plus parity format */
+	
+	u8 demod_refclk; /* Reference clock frequency selection */
+
+	/* Serial data is output on pin */
+	u8 mpeg_pin; /* 0 -  MPEG_DATA_0, 1 - MPEG_DATA_7 */
+	
+	u8 tuner_rfagc; /* 0 - Normal pol, 1 - Inverted pol */
+	u8 tuner_spectrum; /* 0 - signal spectrum normal, 1 - signal spectrum inverted */
+	
+	u8 use_lnb_pin59; /* control 13/18V over demod GPIO pin59 */
+	u8 use_lnb_pin60; /* control 13/18V over demod GPIO pin60 */
+
+	int (*set_external_vol_gpio)(int *demod_id, int on); /* external 13/18V control */
+};
+
+
+
+extern struct dvb_frontend* avl6211_attach(struct i2c_adapter* i2c,
+											struct avl6211_config* config,
+											int id);
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/wetek/avl6211_reg.h b/drivers/amlogic/wetek/avl6211_reg.h
new file mode 100644
index 0000000..76e865f
--- /dev/null
+++ b/drivers/amlogic/wetek/avl6211_reg.h
@@ -0,0 +1,101 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __AVL6211_REG_H_
+#define __AVL6211_REG_H_
+
+
+#define core_reset_b_reg            				0x600000
+#define gpio_data_in_to_reg         				0x6C0004
+#define gpio_data_reg_out           				0x6C0008
+#define gpio_reg_enb                				0x6C000C
+
+#define pll_clkr_map_addr           				0x6C40C0
+#define pll_clkf_map_addr          					0x6C4100
+#define pll_od_map_addr             				0x6C4080
+#define pll_od2_map_addr            				0x6C4140
+#define pll_od3_map_addr            				0x6C4180
+#define pll_bwadj_map_addr          				0x6C41C0
+#define pll_softvalue_en_map_addr   				0x6C4200
+#define reset_register_addr         				0x6C4000
+
+	
+#define rx_aagc_gain                                0x0040004C
+#define rc_rfagc_tri_enb                            0x006C002C
+#define rc_mpeg_bus_tri_enb                         0x006C0028
+
+
+#define raptor_status_addr						   (0x00000860 + 0x0)
+#define rx_state_addr                              (0x00000690 + 0x0)
+#define rx_cmd_addr                                (0x00000400 + 0x0)
+#define i2cm_cmd_addr                              (0x00000404 + 0x0)
+#define i2cm_rsp_addr                              (0x00000418 + 0x0)
+#define error_msg_addr                             (0x0000042c + 0x0)
+#define rx_config_addr                             (0x0000043c + 0x0)
+#define core_ready_word_addr                       (0x00000434 + 0x0)
+
+#define rs_cust_chip_id_addr                        0x006C0034
+
+#define	rp_uint_BER_addr                           (raptor_status_addr + 0x0)
+#define	rc_rfagc_pol_addr                          (rx_config_addr + 0x0)
+#define	rc_equalizer_addr                          (rx_config_addr + 0x8)
+#define	rs_code_rate_addr                          (rx_state_addr + 0x8)
+#define	rs_modulation_addr                         (rx_state_addr + 0xc)
+#define	rc_format_addr                             (rx_config_addr + 0x10)
+#define	rc_mpeg_mode_addr                          (rx_config_addr + 0x20)
+#define	rc_outpin_sel_addr                         (rx_config_addr + 0x24)
+#define	rs_int_SNR_dB_addr                         (rx_state_addr + 0x40)
+#define	rc_aagc_ref_addr                           (rx_config_addr + 0xaa)
+#define	rc_mpeg_posedge_addr                       (rx_config_addr + 0xbc)
+#define	rc_mpeg_serial_addr                        (rx_config_addr + 0xbe)
+#define	rs_fec_lock_addr                           (rx_state_addr + 0x164)
+#define	rc_specinv_addr                            (rx_config_addr + 0x34)
+#define	rc_int_sym_rate_MHz_addr                   (rx_config_addr + 0x54)
+#define	rc_dvbs_ber_addr                           (rx_config_addr + 0x98)
+#define	rc_int_dmd_clk_MHz_addr                    (rx_config_addr + 0x162)
+#define	rc_int_fec_clk_MHz_addr                    (rx_config_addr + 0x164)
+#define	rc_int_mpeg_clk_MHz_addr                   (rx_config_addr + 0x166)
+#define	rc_int_carrier_freq_half_range_MHz_addr    (rx_config_addr + 0x16c)
+#define	rc_fec_bypass_coderate_addr                (rx_config_addr + 0x194)
+#define	rc_i2cm_speed_kHz_addr                     (rx_config_addr + 0x1ae)
+#define	rc_tuner_slave_addr_addr                   (rx_config_addr + 0x1b6)
+#define	rc_tuner_max_LPF_100kHz_addr               (rx_config_addr + 0x1b8)
+#define	rc_tuner_LPF_margin_100kHz_addr            (rx_config_addr + 0x1ba)
+#define	rc_tuner_use_internal_control_addr         (rx_config_addr + 0x1bc)
+
+#define	rc_decode_mode_addr                        (rx_config_addr + 0x202)
+#define	rc_iq_mode_addr                            (rx_config_addr + 0x204)
+#define	rc_lock_mode_addr                          (rx_config_addr + 0x20a)
+#define	rc_blind_scan_tuner_spectrum_inversion_addr (rx_config_addr + 0x220)
+
+
+
+#define diseqc_tx_cntrl_addr						0x00700000
+#define diseqc_tone_frac_n_addr						0x00700004
+#define diseqc_tone_frac_d_addr						0x00700008
+#define diseqc_tx_st_addr							0x0070000c
+#define diseqc_rx_msg_tim_addr						0x00700014
+#define diseqc_rx_cntrl_addr						0x0070001c
+#define diseqc_srst_addr							0x00700020
+#define diseqc_samp_frac_n_addr						0x00700028
+#define diseqc_samp_frac_d_addr						0x0070002c
+#define diseqc_tx_fifo_map_addr						0x00700080
+
+#endif
diff --git a/drivers/amlogic/wetek/cxd2837.c b/drivers/amlogic/wetek/cxd2837.c
new file mode 100644
index 0000000..44193a7
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2837.c
@@ -0,0 +1,1790 @@
+/*
+ * Sony CXD2837 DVB-T/T2/C demodulator driver
+ *
+ * Copyright (C) 2010-2013 Digital Devices GmbH
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <asm/div64.h>
+#include "dvb_math.h"
+#include "dvb_frontend.h"
+#include "cxd2837.h"
+
+
+struct ts_clk {
+	u8 serialClkMode;      
+	u8 serialDutyMode;
+	u8 tsClkPeriod; 
+	u8 clkSelTsIf;
+};
+
+struct cxd_state {
+	struct dvb_frontend   frontend;
+	struct i2c_adapter   *i2c;
+	struct mutex          mutex;
+
+	u8  adrt;
+	u8  curbankt;
+
+	u8  adrx;
+	u8  curbankx;
+	
+	enum fe_delivery_system delivery_system;
+	u32 freq;
+	
+	enum EDemodState state;	
+	enum xtal_freq xtal;
+
+	u8	IF_AGC;
+	u8    IF_FS;
+	int   ContinuousClock;
+	int   SerialMode;
+	u8    SerialClockFrequency;
+	u8	ErrorPolarity;
+	u8	ClockPolarity;
+	u8	RfainMon;
+	u32   LockTimeout;
+	u32   TSLockTimeout;
+	u32   L1PostTimeout;
+	u32   DataSliceID;
+	int   FirstTimeLock;
+	u32   plp;
+	u32   last_status;
+
+	u32   bandwidth;
+	u32   bw;
+
+	unsigned long tune_time;
+
+	u32   LastBERNominator;
+	u32   LastBERDenominator;
+	u8    BERScaleMax;
+};
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+					.addr = adr, 
+					.flags = 0,
+					.buf = data,
+					.len = len,
+			}
+	};
+
+	ret = i2c_transfer(adap, msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+			dev_warn(&adap->dev, "i2c wr failed=%d reg=%02x "
+							, ret, data[0]);
+			ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+
+static int writeregs(struct cxd_state *state, u8 adr, u8 reg,
+		     u8 *regd, u16 len)
+{
+	u8 data[len + 1];
+
+	data[0] = reg;
+	memcpy(data + 1, regd, len);
+	return i2c_write(state->i2c, adr, data, len + 1);
+}
+
+static int writereg(struct cxd_state *state, u8 adr, u8 reg, u8 dat)
+{
+	u8 mm[2] = {reg, dat};
+
+	return i2c_write(state->i2c, adr, mm, 2);
+}
+
+static int i2c_read(struct i2c_adapter *adap,
+		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
+{
+	int ret;
+	struct i2c_msg msgs[2] = { 
+			{ 
+					.addr = adr, 
+					.flags = 0,
+				    .buf = msg,
+					.len = len
+			}, { 
+					.addr = adr,
+					.flags = I2C_M_RD,					
+				    .buf = answ, 
+					.len = alen, 
+			} 
+	};
+	ret = i2c_transfer(adap, msgs, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+			dev_warn(&adap->dev, "i2c rd failed=%d reg=%02x "
+							, ret, *msg);
+			ret = -EREMOTEIO;
+	}
+	return ret;
+}
+
+static int readregs(struct cxd_state *state, u8 adr, u8 reg,
+		    u8 *val, int count)
+{
+	return i2c_read(state->i2c, adr, &reg, 1, val, count);
+}
+
+static int readregst_unlocked(struct cxd_state *cxd, u8 bank,
+			      u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (bank != 0xFF && cxd->curbankt != bank) {
+		status = writereg(cxd, cxd->adrt, 0, bank);
+		if (status < 0) {
+			cxd->curbankt = 0xFF;
+			return status;
+		}
+		cxd->curbankt = bank;
+	}
+	status = readregs(cxd, cxd->adrt, Address, pValue, count);
+	return status;
+}
+
+static int readregst(struct cxd_state *cxd, u8 Bank,
+		     u8 Address, u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = readregst_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int readregsx_unlocked(struct cxd_state *cxd, u8 Bank,
+			      u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (Bank != 0xFF && cxd->curbankx != Bank) {
+		status = writereg(cxd, cxd->adrx, 0, Bank);
+		if (status < 0) {
+			cxd->curbankx = 0xFF;
+			return status;
+		}
+		cxd->curbankx = Bank;
+	}
+	status = readregs(cxd, cxd->adrx, Address, pValue, count);
+	return status;
+}
+
+static int readregsx(struct cxd_state *cxd, u8 Bank,
+		     u8 Address, u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = readregsx_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writeregsx_unlocked(struct cxd_state *cxd, u8 Bank,
+			       u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (Bank != 0xFF && cxd->curbankx != Bank) {
+		status = writereg(cxd, cxd->adrx, 0, Bank);
+		if (status < 0) {
+			cxd->curbankx = 0xFF;
+			return status;
+		}
+		cxd->curbankx = Bank;
+	}
+	status = writeregs(cxd, cxd->adrx, Address, pValue, count);
+	return status;
+}
+
+static int writeregsx(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = writeregsx_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writeregx(struct cxd_state *cxd, u8 Bank, u8 Address, u8 val)
+{
+	return writeregsx(cxd, Bank, Address, &val, 1);
+}
+
+static int writeregst_unlocked(struct cxd_state *cxd, u8 Bank,
+			       u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (Bank != 0xFF && cxd->curbankt != Bank) {
+		status = writereg(cxd, cxd->adrt, 0, Bank);
+		if (status < 0) {
+			cxd->curbankt = 0xFF;
+			return status;
+		}
+		cxd->curbankt = Bank;
+	}
+	status = writeregs(cxd, cxd->adrt, Address, pValue, count);
+	return status;
+}
+
+static int writeregst(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = writeregst_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writeregt(struct cxd_state *cxd, u8 Bank, u8 Address, u8 val)
+{
+	return writeregst(cxd, Bank, Address, &val, 1);
+}
+
+static int writebitsx(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 Value, u8 Mask)
+{
+	int status = 0;
+	u8 tmp;
+
+	mutex_lock(&cxd->mutex);
+	status = readregsx_unlocked(cxd, Bank, Address, &tmp, 1);
+	if (status < 0)
+		return status;
+	tmp = (tmp & ~Mask) | Value;
+	status = writeregsx_unlocked(cxd, Bank, Address, &tmp, 1);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writebitst(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 Value, u8 Mask)
+{
+	int status = 0;
+	u8 Tmp = 0x00;
+
+	mutex_lock(&cxd->mutex);
+	status = readregst_unlocked(cxd, Bank, Address, &Tmp, 1);
+	if (status < 0)
+		return status;
+	Tmp = (Tmp & ~Mask) | Value;
+	status = writeregst_unlocked(cxd, Bank, Address, &Tmp, 1);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int freeze_regst(struct cxd_state *cxd)
+{
+	mutex_lock(&cxd->mutex);
+	return writereg(cxd, cxd->adrt, 1, 1);
+}
+
+static int unfreeze_regst(struct cxd_state *cxd)
+{
+	int status = 0;
+
+	status = writereg(cxd, cxd->adrt, 1, 0);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static inline u32 MulDiv32(u32 a, u32 b, u32 c)
+{
+	u64 tmp64;
+
+	tmp64 = ((u64)a * (u64)b) + (u64)20500000;
+	do_div(tmp64, c);
+
+	return (u32) tmp64;
+}
+
+/* TPSData[0] [7:6]  CNST[1:0] */
+/* TPSData[0] [5:3]  HIER[2:0] */
+/* TPSData[0] [2:0]  HRATE[2:0] */
+/* TPSData[1] [7:5]  LRATE[2:0] */
+/* TPSData[1] [4:3]  GI[1:0] */
+/* TPSData[1] [2:1]  MODE[1:0] */
+/* TPSData[2] [7:6]  FNUM[1:0] */
+/* TPSData[2] [5:0]  LENGTH_INDICATOR[5:0] */
+/* TPSData[3] [7:0]  CELLID[15:8] */
+/* TPSData[4] [7:0]  CELLID[7:0] */
+/* TPSData[5] [5:0]  RESERVE_EVEN[5:0] */
+/* TPSData[6] [5:0]  RESERVE_ODD[5:0] */
+
+static int read_tps(struct cxd_state *state, u8 *tps)
+{
+	if (state->last_status != 0x1f)
+		return 0;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x10, 0x2f, tps, 7);
+	readregst_unlocked(state, 0x10, 0x3f, &tps[7], 1);
+	unfreeze_regst(state);
+	return 0;
+}
+
+static void Active_to_Sleep(struct cxd_state *state)
+{
+	if (state->state <= Sleep)
+		return;
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+	writeregt(state, 0x00, 0x80, 0x3F); /* Enable HighZ 1 */
+	writeregt(state, 0x00, 0x81, 0xFF); /* Enable HighZ 2 */
+	writeregx(state, 0x00, 0x18, 0x01); /* Disable ADC 4 */
+	writeregt(state, 0x00, 0x43, 0x0A); /* Disable ADC 2 */
+	writeregt(state, 0x00, 0x41, 0x0A); /* Disable ADC 1 */
+	writeregt(state, 0x00, 0x30, 0x00); /* Disable ADC Clock */
+	writeregt(state, 0x00, 0x2F, 0x00); /* Disable RF level Monitor */
+	writeregt(state, 0x00, 0x2C, 0x00); /* Disable Demod Clock */
+	state->state = Sleep;
+}
+
+static void ActiveT2_to_Sleep(struct cxd_state *state)
+{
+	if (state->state <= Sleep)
+		return;
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+	writeregt(state, 0x00, 0x80, 0x3F); /* Enable HighZ 1 */
+	writeregt(state, 0x00, 0x81, 0xFF); /* Enable HighZ 2 */
+
+	writeregt(state, 0x13, 0x83, 0x40);
+	writeregt(state, 0x13, 0x86, 0x21);
+	writebitst(state, 0x13, 0x9E, 0x09, 0x0F);
+	writeregt(state, 0x13, 0x9F, 0xFB);
+
+	writeregx(state, 0x00, 0x18, 0x01); /* Disable ADC 4 */
+	writeregt(state, 0x00, 0x43, 0x0A); /* Disable ADC 2 */
+	writeregt(state, 0x00, 0x41, 0x0A); /* Disable ADC 1 */
+	writeregt(state, 0x00, 0x30, 0x00); /* Disable ADC Clock */
+	writeregt(state, 0x00, 0x2F, 0x00); /* Disable RF level Monitor */
+	writeregt(state, 0x00, 0x2C, 0x00); /* Disable Demod Clock */
+	state->state = Sleep;
+}
+
+static int ConfigureTS(struct cxd_state *state,
+		       enum fe_delivery_system delivery_system)
+{
+	int ret = 0;
+	u8 serialTs;
+    u8 tsRateCtrlOff;
+    u8 tsInOff;
+    u8 backwardsCompatible = 0;
+	struct ts_clk tsClk;
+	
+	struct ts_clk sTsClk[2][6] = {
+		{ 			
+			{ 3, 1, 8, 0 }, 
+			{ 3, 1, 8, 1 },
+			{ 3, 1, 8, 2 }, 
+			{ 0, 2, 16, 0 }, 
+			{ 0, 2, 16, 1 }, 
+			{ 0, 2, 16, 2 }  
+		},
+		{ 		
+			{ 1, 1, 8, 0 },			
+			{ 1, 1, 8, 1 },
+			{ 1, 1, 8, 2 }, 
+			{ 2, 2, 16, 0 }, 
+			{ 2, 2, 16, 1 }, 
+			{ 2, 2, 16, 2 }			
+		}
+	};
+
+    struct ts_clk pTsClk = { 0, 0, 8, 0 };
+	
+    struct ts_clk bsTsClk[2] = {
+		{ 3, 1, 8, 1 },		
+		{ 1, 1, 8, 1 }		
+	}; 
+    struct ts_clk bpTsClk = { 0, 0, 8, 1 };
+	
+	readregst(state, 0x00, 0xC4, &serialTs, 1);
+	readregst(state, 0x00, 0xD3, &tsRateCtrlOff, 1);
+	readregst(state, 0x00, 0xDE, &tsInOff, 1);
+	
+	if ((tsRateCtrlOff & 0x01) != (tsInOff & 0x01)) {
+		ret = -EINVAL;
+		goto error;
+	}
+	if ((tsRateCtrlOff & 0x01) && (tsInOff & 0x01)) {
+        backwardsCompatible = 1;
+          
+        if (serialTs & 0x80) 
+            tsClk = bsTsClk[state->ContinuousClock];
+        else           
+            tsClk = bpTsClk;
+        
+    }
+    else if (serialTs & 0x80) 
+		tsClk = sTsClk[state->ContinuousClock][state->SerialClockFrequency];
+    else       
+		tsClk = pTsClk;
+	
+	if (serialTs & 0x80) {
+		writebitst(state, 0x00, 0xC4, tsClk.serialClkMode, 0x03); 
+		writebitst(state, 0x00, 0xD1, tsClk.serialDutyMode, 0x03);
+	}
+	writeregt(state, 0x00, 0xD9, tsClk.tsClkPeriod);
+	writebitst(state, 0x00, 0x32, 0x00, 0x01); /* Disable TS IF */
+	
+	writebitst(state, 0x00, 0x33, tsClk.clkSelTsIf, 0x03);
+	writebitst(state, 0x00, 0x32, 0x01, 0x01); /* Enable TS IF */
+
+	if (delivery_system == SYS_DVBT)
+		writebitst(state, 0x10, 0x66, 0x01, 0x01);
+	if (delivery_system == SYS_DVBC_ANNEX_A)
+		writebitst(state, 0x40, 0x66, 0x01, 0x01);
+
+error:
+	return ret;
+}
+
+static void BandSettingT(struct cxd_state *state, u32 iffreq)
+{
+	u8 IF_data[3] = { (iffreq >> 16) & 0xff,
+			  (iffreq >> 8) & 0xff, iffreq & 0xff};
+
+	switch (state->bw) {
+	default:
+	case 8:
+	{
+		u8 TR_data[] = { 0x11, 0xF0, 0x00, 0x00, 0x00 };
+		u8 CL_data[] = { 0x01, 0xE0 };
+		u8 NF_data[] = { 0x01, 0x02 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x00, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	case 7:
+	{
+		u8 TR_data[] = { 0x14, 0x80, 0x00, 0x00, 0x00 };
+		u8 CL_data[] = { 0x12, 0xF8 };
+		u8 NF_data[] = { 0x00, 0x03 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x02, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	case 6:
+	{
+		u8 TR_data[] = { 0x17, 0xEA, 0xAA, 0xAA, 0xAA };
+		u8 CL_data[] = { 0x1F, 0xDC };
+		u8 NF_data[] = { 0x00, 0x03 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x04, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	case 5:
+	{
+		static u8 TR_data[] = { 0x1C, 0xB3, 0x33, 0x33, 0x33 };
+		static u8 CL_data[] = { 0x26, 0x3C };
+		static u8 NF_data[] = { 0x00, 0x03 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x06, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	}
+}
+
+static void Sleep_to_ActiveT(struct cxd_state *state, u32 iffreq)
+{
+	u8 data[2] = { 0x00, 0x00 }; 
+	
+	if( state->xtal == XTAL_41000KHz) {
+		data[0] = 0x0A;
+        data[1] = 0xD4;
+	} else {
+		data[0] = 0x09;
+        data[1] = 0x54;
+	}
+	
+	ConfigureTS(state, SYS_DVBT);
+	writeregx(state, 0x00, 0x17, 0x01);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, 0x00);   /* Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+	
+	writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x0C, 0x1F); /* IF AGC Gain */
+	writeregt(state, 0x11, 0x6A, 0x48); /* BB AGC Target Level */
+
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writebitst(state, 0x18, 0x36, 0x40, 0x07); /* Pre RS Monitoring */
+	writebitst(state, 0x18, 0x30, 0x01, 0x01); /* FEC Autorecover */
+	writebitst(state, 0x18, 0x31, 0x01, 0x01); /* FEC Autorecover */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	BandSettingT(state, iffreq);
+
+	writebitst(state, 0x10, 0x60, 11, 0x1f); /* BER scaling */
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+
+static void BandSettingT2(struct cxd_state *state, u32 iffreq)
+{
+	u8 IF_data[3] = {(iffreq >> 16) & 0xff, (iffreq >> 8) & 0xff,
+			 iffreq & 0xff};
+
+	switch (state->bw) {
+	default:
+	case 8:
+	{
+		u8 TR_data[] = { 0x11, 0xF0, 0x00, 0x00, 0x00 };
+		/* Timing recovery */
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		/* Add EQ Optimisation for tuner here */
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		/* System Bandwidth */
+		writebitst(state, 0x10, 0xD7, 0x00, 0x07);
+	}
+	break;
+	case 7:
+	{
+		u8 TR_data[] = { 0x14, 0x80, 0x00, 0x00, 0x00 };
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x02, 0x07);
+	}
+	break;
+	case 6:
+	{
+		u8 TR_data[] = { 0x17, 0xEA, 0xAA, 0xAA, 0xAA };
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x04, 0x07);
+	}
+	break;
+	case 5:
+	{
+		u8 TR_data[] = { 0x1C, 0xB3, 0x33, 0x33, 0x33 };
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x06, 0x07);
+	}
+	break;
+	case 1: /* 1.7 MHz */
+	{
+		u8 TR_data[] = { 0x58, 0xE2, 0xAF, 0xE0, 0xBC };
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x03, 0x07);
+	}
+	break;
+	}
+}
+
+
+static void Sleep_to_ActiveT2(struct cxd_state *state, u32 iffreq)
+{
+	u8 data[2] = { 0x00, 0x00 }; 
+	
+	if( state->xtal == XTAL_41000KHz) {
+		data[0] = 0x0A;
+        data[1] = 0xD4;
+	} else {
+		data[0] = 0x09;
+        data[1] = 0x54;
+	}
+	
+	ConfigureTS(state, SYS_DVBT2);
+
+	writeregx(state, 0x00, 0x17, 0x02);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, state->RfainMon ? 0x01 : 0x00);   /* Enable/Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+
+	writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x0C, 0x1F); /* IFAGC  coarse gain */
+	writeregt(state, 0x11, 0x6A, 0x50); /* BB AGC Target Level */
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writeregt(state, 0x20, 0x8B, 0x3C); /* SNR Good count */
+	writebitst(state, 0x2B, 0x76, 0x20, 0x70); /* Noise Gain ACQ */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	writeregt(state, 0x13, 0x83, 0x10); /* T2 Inital settings */
+	writeregt(state, 0x13, 0x86, 0x34);
+	writebitst(state, 0x13, 0x9E, 0x09, 0x0F);
+	writeregt(state, 0x13, 0x9F, 0xD8);
+
+	BandSettingT2(state, iffreq);
+
+	writebitst(state, 0x20, 0x72, 0x08, 0x0f); /* BER scaling */
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+
+
+static void BandSettingC(struct cxd_state *state, u32 iffreq)
+{
+	u8 data[3];
+
+	data[0] = (iffreq >> 16) & 0xFF;
+	data[1] = (iffreq >>  8) & 0xFF;
+	data[2] = (iffreq) & 0xFF;
+	writeregst(state, 0x10, 0xB6, data, 3);
+}
+
+static void Sleep_to_ActiveC(struct cxd_state *state, u32 iffreq)
+{
+	u8 data[2] = { 0x00, 0x00 }; 
+	
+	if( state->xtal == XTAL_41000KHz) {
+		data[0] = 0x0A;
+        data[1] = 0xD4;
+	} else {
+		data[0] = 0x09;
+        data[1] = 0x54;
+	}
+	
+	ConfigureTS(state, SYS_DVBC_ANNEX_A);
+
+	writeregx(state, 0x00, 0x17, 0x04);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, 0x00);   /* Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+
+
+	writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x09, 0x1F); /* IF AGC Gain */
+	writeregt(state, 0x11, 0x6A, 0x48); /* BB AGC Target Level */
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writebitst(state, 0x40, 0xC3, 0x00, 0x04); /* OREG_BNDET_EN_64 */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	BandSettingC(state, iffreq);
+
+	writebitst(state, 0x40, 0x60, 11, 0x1f); /* BER scaling */
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+static void T2_SetParameters(struct cxd_state *state)
+{
+	u8 Profile = 0x00;    /* Automatic Profile detection */
+	u8 notT2time = 40;    /* early unlock detection time */
+	
+	writeregt(state, 0x23, 0xAD, 0x00);
+	
+	writebitst(state, 0x2E, 0x10, Profile, 0x07);
+	writeregt(state, 0x2B, 0x9D, notT2time);
+	
+}
+static void Stop(struct cxd_state *state)
+{
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+}
+
+static void ShutDown(struct cxd_state *state)
+{
+	switch (state->delivery_system) {
+	case SYS_DVBT2:
+		ActiveT2_to_Sleep(state);
+		break;
+	default:
+		Active_to_Sleep(state);
+		break;
+	}
+}
+
+static int gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	return writebitsx(state, 0xFF, 0x08, enable ? 0x01 : 0x00, 0x01);
+}
+
+static void release(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	Stop(state);
+	ShutDown(state);
+	kfree(state);
+}
+static int read_status(struct dvb_frontend *fe, enum fe_status *status);
+
+static int set_parameters(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	u32 IF = 0;
+
+	if (c->frequency == state->freq && c->delivery_system == state->delivery_system) {
+		enum fe_status status;
+		ret = read_status(fe, &status);
+		if (!ret && status == 0x1F) {
+			dev_dbg(&state->i2c->dev, "Ignoring tuning to same freq, allready locked!\n");	
+			return 0;
+		}
+	}
+	if (c->delivery_system != SYS_DVBC_ANNEX_A) {	
+		switch (c->bandwidth_hz) {
+		case 1700000:
+			state->bw = 1;
+			break;
+		case 5000000:
+			state->bw = 5;
+			break;
+		case 6000000:
+			state->bw = 6;
+			break;
+		case 7000000:
+			state->bw = 7;
+			break;
+		case 8000000:
+			state->bw = 8;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}	
+		
+		
+	if (fe->ops.tuner_ops.set_params) {
+		ret = fe->ops.tuner_ops.set_params(fe);
+		if (ret)
+			goto err;
+	}
+		
+	if (fe->ops.tuner_ops.get_if_frequency) {
+		ret = fe->ops.tuner_ops.get_if_frequency(fe, &IF);
+		if (ret)
+			goto err;
+	}
+		
+	IF = MulDiv32(IF, 16777216, 41000000);
+	
+	state->LockTimeout = 0;
+	state->TSLockTimeout = 0;
+	state->L1PostTimeout = 0;
+	state->last_status = 0;
+	state->FirstTimeLock = 1;
+	state->LastBERNominator = 0;
+	state->LastBERDenominator = 1;
+	state->BERScaleMax = 19;
+	
+	switch (c->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		state->BERScaleMax = 19;
+		if ( state->state == Active && c->delivery_system == state->delivery_system) {
+			writeregt(state, 0x00, 0xC3, 0x01);   /* Disable TS Output */
+		} else if (state->state == Active && c->delivery_system != state->delivery_system) {
+			Active_to_Sleep(state);
+			Sleep_to_ActiveC(state, IF);
+			state->delivery_system = c->delivery_system;
+		} else if (state->state == Sleep) {
+			Sleep_to_ActiveC(state, IF);
+			state->delivery_system = c->delivery_system;
+			state->state = Active;
+		}
+	break;
+	case SYS_DVBT:
+		state->BERScaleMax = 18;
+		/* Stick with HP ( 0x01 = LP ) */
+		writeregt(state, 0x10, 0x67, 0x00);
+		if ( state->state == Active && c->delivery_system == state->delivery_system) {
+			writeregt(state, 0x00, 0xC3, 0x01);   /* Disable TS Output */
+			BandSettingT(state, IF);
+		} else if (state->state == Active && c->delivery_system != state->delivery_system) {	
+			Active_to_Sleep(state);
+			Sleep_to_ActiveT(state, IF);
+			state->delivery_system = c->delivery_system;
+		} else if (state->state == Sleep) {
+			Sleep_to_ActiveT(state, IF);
+			state->delivery_system = c->delivery_system;
+			state->state = Active;
+		}
+	break;
+	case SYS_DVBT2:
+		state->BERScaleMax = 12;
+		T2_SetParameters(state);
+		if ( state->state == Active && c->delivery_system == state->delivery_system) {
+			writeregt(state, 0x00, 0xC3, 0x01);   /* Disable TS Output */
+			BandSettingT2(state, IF);
+		} else if (state->state == Active && c->delivery_system != state->delivery_system) {	
+			ActiveT2_to_Sleep(state);
+			Sleep_to_ActiveT2(state, IF);
+			state->delivery_system = c->delivery_system;
+		} else if (state->state == Sleep) {
+			Sleep_to_ActiveT2(state, IF);
+			state->delivery_system = c->delivery_system;
+			state->state = Active;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	writeregt(state, 0x00, 0xFE, 0x01);   /* SW Reset */
+	writeregt(state, 0x00, 0xC3, 0x00);   /* Enable TS Output */
+	state->freq = c->frequency;
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "failed=%d\n", ret);	
+	return ret;
+}
+
+
+static int init(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	u8 data[2] = { 0x00, state->xtal == XTAL_41000KHz ? 0x01 : 0x00 }; 
+	
+	
+	state->delivery_system = SYS_UNDEFINED;
+	state->state = Unknown;
+
+	state->curbankt = 0xff;
+	state->curbankx = 0xff;
+	
+	/* Start: demod any state to Sleep T / C state. */
+	writeregx(state, 0xFF, 0x02, 0x00);
+	usleep_range(4000, 5000);
+	
+	writeregx(state, 0x00, 0x10, 0x01);
+
+	writeregsx(state, 0x00, 0x13, data, 2);
+	
+	writeregx(state, 0x00, 0x10, 0x00);
+	usleep_range(2000, 3000);
+	
+	writeregt(state, 0x00, 0x43, 0x0A);
+	writeregt(state, 0x00, 0x41, 0x0A);	
+	
+	state->state = Sleep;
+	
+	/* Set demod config */
+	writebitst(state, 0x10, 0xCB, state->IF_AGC ? 0x40 : 0x00, 0x40);
+	writeregt(state, 0x10, 0xCD, state->IF_FS);
+
+	writebitst(state, 0x00, 0xCB, state->ErrorPolarity ? 0x00 : 0x01, 0x01); 
+	writebitst(state, 0x00, 0xC5, state->ClockPolarity ? 0x01 : 0x00, 0x01); 
+	
+	return 0;
+}
+
+
+static void init_state(struct cxd_state *state, struct cxd2837_cfg *cfg)
+{
+	state->adrt = cfg->adr;
+	state->adrx = cfg->adr + 0x02;
+	state->curbankt = 0xff;
+	state->curbankx = 0xff;
+	mutex_init(&state->mutex);
+
+	state->RfainMon = cfg->rfain_monitoring;
+	state->ErrorPolarity = cfg->ts_error_polarity;
+	state->ClockPolarity = cfg->clock_polarity;
+	state->IF_AGC = cfg->if_agc_polarity;
+	state->xtal = cfg->xtal;
+	state->ContinuousClock = 1;
+	state->SerialClockFrequency = cfg->ts_clock; /* 1 = fastest (82 MBit/s), 5 = slowest */
+	state->IF_FS = 0x50; /* 1.4Vpp - Default */
+		
+		
+	switch(cfg->ifagc_adc_range) {
+	case 0:	
+		break;
+	case 1:		        
+        state->IF_FS = 0x39; /* 1.0Vpp */
+		break;
+	case 2:          
+        state->IF_FS = 0x28; /* 0.7Vpp */
+        break;
+	default:	
+		break;
+	}	
+}
+
+static int get_tune_settings(struct dvb_frontend *fe,
+			     struct dvb_frontend_tune_settings *s)
+{
+	s->min_delay_ms = 1500;
+	s->step_size = fe->ops.info.frequency_stepsize;
+	
+	return 0;
+}
+
+static int read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	u8 rdata;
+
+	*status = 0;
+	switch (state->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		readregst(state, 0x40, 0x88, &rdata, 1);
+		if (rdata & 0x02)
+			break;
+		if (rdata & 0x01) {
+			*status |= 0x07;
+			readregst(state, 0x40, 0x10, &rdata, 1);
+			if (rdata & 0x20)
+				*status |= 0x1f;
+		}
+		break;
+	case SYS_DVBT:
+		readregst(state, 0x10, 0x10, &rdata, 1);
+		if (rdata & 0x10)
+			break;
+		if ((rdata & 0x07) == 0x06) {
+			*status |= 0x07;
+			if (rdata & 0x20)
+				*status |= 0x1f;
+		}
+		break;
+	case SYS_DVBT2:
+		readregst(state, 0x20, 0x10, &rdata, 1);		
+		if (rdata & 0x10)
+			break;
+		if ((rdata & 0x07) == 0x06) {
+			*status |= 0x07;
+			if (rdata & 0x20)
+				*status |= 0x08;
+		}
+		if (*status & 0x08) {
+			readregst(state, 0x22, 0x12, &rdata, 1);
+			if (rdata & 0x01)
+				*status |= 0x10;
+		}
+		break;
+	default:
+		break;
+	}
+	state->last_status = *status;
+	return 0;
+}
+
+static int get_ber_t(struct cxd_state *state, u32 *ber)
+{
+	u8 BERRegs[3];
+	u8 Scale;
+	u32 bitError = 0;
+    u32 period = 0;
+	u32 div = 0;
+    u32 Q = 0;
+    u32 R = 0;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x10, 0x39, BERRegs, 1);
+	readregst_unlocked(state, 0x10, 0x6F, &Scale, 1);
+	readregst_unlocked(state, 0x10, 0x22, &BERRegs[1], 2);
+	unfreeze_regst(state);
+	
+	if (!(BERRegs[0] & 0x10)) {
+		dev_dbg(&state->i2c->dev, "%s: no valid BER data\n", __func__);	
+		return 0;
+	}
+	
+	bitError = ((u32)BERRegs[1] << 8) | (u32)BERRegs[2];
+	period = ((Scale & 0x07) == 0) ? 256 : (4096 << (Scale & 0x07));
+	
+	div = period / 128;
+	Q = (bitError * 3125) / div;
+    R = (bitError * 3125) % div;
+	R *= 25;
+    Q = Q * 25 + R / div;
+    R = R % div;
+	*ber = (R >= div / 2) ? Q + 1 : Q;
+	
+	return 0;
+}
+
+static int get_ber_t2(struct cxd_state *state, u32 *ber)
+{
+	u8 BERRegs[4];
+	u8 Scale;
+	u8 plp;
+	u32 bitError = 0;
+    u32 periodExp = 0;
+	u32 div = 0;
+    u32 Q = 0;
+    u32 R = 0;
+	u32 n_ldpc = 0;
+	
+	freeze_regst(state);
+	readregst_unlocked(state, 0x20, 0x39, BERRegs, 4);
+	readregst_unlocked(state, 0x20, 0x6F, &Scale, 1);
+	readregst_unlocked(state, 0x22, 0x5E, &plp, 1);
+	unfreeze_regst(state);
+	
+	if (!(BERRegs[0] & 0x10)) {
+		dev_dbg(&state->i2c->dev, "%s: no valid BER data\n", __func__);	
+		return 0;
+	}
+	
+	bitError = ((BERRegs[0] & 0x0F) << 24) | (BERRegs[1] << 16) | (BERRegs[2] << 8) | BERRegs[3];	
+	periodExp = (Scale & 0x0F);
+	n_ldpc = ((plp & 0x03) == 0 ? 16200 : 64800);
+			
+	if (bitError > ((1U << periodExp) * n_ldpc)) {
+		dev_dbg(&state->i2c->dev, "%s: invalid BER value\n", __func__);	
+        return -EINVAL;
+    }
+
+    if (periodExp >= 4) {    
+		div = (1U << (periodExp - 4)) * (n_ldpc / 200);
+		Q = (bitError * 5) / div;
+		R = (bitError * 5) % div;
+		R *= 625;
+		Q = Q * 625 + R / div;
+		R = R % div;
+	} 
+	else {            
+		div = (1U << periodExp) * (n_ldpc / 200);
+		Q = (bitError * 10) / div;
+		R = (bitError * 10) % div;
+		R *= 5000;
+		Q = Q * 5000 + R / div;
+		R = R % div;
+	}
+
+	*ber = (R >= div/2) ? Q + 1 : Q;	
+	return 0;
+}
+
+static int get_ber_c(struct cxd_state *state, u32 *ber)
+{	
+	u8 BERRegs[3];
+	u8 Scale;
+	u32 bitError = 0;
+    u32 periodExp = 0;
+	u32 div = 0;
+    u32 Q = 0;
+    u32 R = 0;
+
+	readregst(state, 0x40, 0x62, BERRegs, 3);
+	readregst(state, 0x40, 0x60, &Scale, 1);
+
+		
+	if ((BERRegs[0] & 0x80) == 0) {
+		dev_dbg(&state->i2c->dev, "%s: no valid BER data\n", __func__);	
+		return 0;
+	}
+	
+	bitError = ((BERRegs[0] & 0x3F) << 16) | (BERRegs[1] << 8) | BERRegs[2];
+	periodExp = (Scale & 0x1F);
+
+	if ((periodExp <= 11) && (bitError > (1U << periodExp) * 204 * 8)) {
+		dev_dbg(&state->i2c->dev, "%s: invalid BER value\n", __func__);	
+        return -EINVAL;
+    }
+	
+	div = (periodExp <= 8) ? ((1U << periodExp) * 51) : ((1U << 8) * 51);
+    Q = (bitError * 250) / div;
+    R = (bitError * 250) % div;
+    R *= 1250;
+    Q = Q * 1250 + R / div;
+    R = R % div;
+
+    if (periodExp > 8) 
+		*ber = (Q + (1 << (periodExp - 9))) >> (periodExp - 8);
+    else 
+		*ber = (R >= div/2) ? Q + 1 : Q;
+		
+	return 0;
+}
+static int read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int ret = 0;
+
+	*ber = 0;
+	
+	if (state->last_status != 0x1f)
+		return 0;
+		
+	switch (state->delivery_system) {
+	case SYS_DVBT:
+		ret = get_ber_t(state, ber);
+		break;
+	case SYS_DVBT2:
+		ret = get_ber_t2(state, ber);
+		break;
+	case SYS_DVBC_ANNEX_A:
+		ret = get_ber_c(state, ber);
+		break;
+	default:
+		break;
+	}
+	
+	return 0;
+}
+static u32 sony_math_log10(u32 x)
+{
+	u32 count = 0;
+
+	for (x >>= 1; x > 0; x >>= 1)
+		count++;
+	return 10000 * count / 332;
+}
+
+static u32 sony_math_log(u32 x)
+{
+	u32 count = 0;
+
+	for (x >>= 1; x > 0; x >>= 1)
+		count++;
+	return 10000 * count / 144;
+}
+
+static void GetSignalToNoiseT2(struct cxd_state *state, int *SignalToNoise)
+{
+	u8 Data[2];
+	u32 reg;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x20, 0x28, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = ((u32)Data[0] << 8) | (u32)Data[1];
+	if (reg == 0) {
+		dev_dbg(&state->i2c->dev, "%s(): reg value out of range\n", __func__);
+		return;
+	}
+	if (reg > 10876)
+		reg = 10876;
+
+	*SignalToNoise = 100 * ((int)sony_math_log10(reg) - (int)sony_math_log10(12600 - reg));
+	*SignalToNoise += 32000;
+	
+}
+
+static void GetSignalToNoiseT(struct cxd_state *state, int *SignalToNoise)
+{
+	u8 Data[2];
+	u32 reg;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x10, 0x28, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = ((u32)Data[0] << 8) | (u32)Data[1];
+	if (reg == 0) {
+		dev_dbg(&state->i2c->dev, "%s(): reg value out of range\n", __func__);
+		return;
+	}
+	if (reg > 4996)
+		reg = 4996;
+
+	*SignalToNoise = 100 * ((int)sony_math_log10(reg) - (int)sony_math_log10(5350 - reg));
+	*SignalToNoise += 28500;
+	
+	
+	return;
+}
+static void GetSignalToNoiseC(struct cxd_state *state, int *SignalToNoise)
+{
+	u8 Data[2];
+	u8 Constellation = 0;
+	u32 reg;
+		
+	*SignalToNoise = 0;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x40, 0x19, &Constellation, 1);
+	readregst_unlocked(state, 0x40, 0x4C, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = ((u32)(Data[0] & 0x1F) << 8) | ((u32)Data[1]);
+	if (reg == 0) {
+		dev_dbg(&state->i2c->dev, "%s(): reg value out of range\n", __func__);
+		return;
+	}
+
+	switch (Constellation & 0x07) {
+	case 0: /* QAM 16 */
+	case 2: /* QAM 64 */
+	case 4: /* QAM 256 */
+		if (reg < 126)
+			reg = 126;
+		*SignalToNoise = -95 * (int)sony_math_log(reg) + 95941;
+		break;
+	case 1: /* QAM 32 */
+	case 3: /* QAM 128 */
+		if (reg < 69)
+			reg = 69;
+		*SignalToNoise = -88 * (int)sony_math_log(reg) + 86999;
+		break;
+	}
+	
+}
+
+static int read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int tSnr = 0;
+	*snr = 0;
+	
+	if (state->last_status != 0x1f)
+		return 0;
+
+	switch (state->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		GetSignalToNoiseC(state, &tSnr);	
+		break;
+	case SYS_DVBT:
+		GetSignalToNoiseT(state, &tSnr);	
+		break;
+	case SYS_DVBT2:
+		GetSignalToNoiseT2(state, &tSnr);	
+		break;
+	default:
+		break;
+	}
+	*snr = tSnr & 0xffff;
+	return 0;
+}
+static int get_signal_strengthC(struct cxd_state *state, u16 *strength)
+{
+	u8 data[2];
+	
+	readregst(state, 0x40, 0x49, data, 2);
+	*strength = 65535 - (((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4);
+	return 0;
+}
+static int get_signal_strengthT(struct cxd_state *state, u16 *strength)
+{
+	u8 data[2];
+	
+	readregst(state, 0x10, 0x26, data, 2);
+	*strength = 65535 - (((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4);
+	return 0;
+	
+}
+static int get_signal_strengthT2(struct cxd_state *state, u16 *strength)
+{	
+	u8 data[2];
+	
+	readregst(state, 0x20, 0x26, data, 2);
+	*strength = 65535 - (((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4);
+	return 0;
+}
+
+static int read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int ret = 0;
+	*strength = 0;
+				
+	if (state->last_status != 0x1f)
+		return 0;
+			
+	switch (state->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		ret = get_signal_strengthC(state, strength);
+		break;
+	case SYS_DVBT:
+		ret = get_signal_strengthT(state, strength);
+		break;
+	case SYS_DVBT2:
+		ret = get_signal_strengthT2(state, strength);
+		break;
+	default:
+		break;
+	}
+	
+	return ret;
+}
+static int get_ucblocksC(struct cxd_state *state, u32 *ucblocks)
+{
+	u8 data[3];
+	
+	readregst(state, 0x40, 0xEA, data, 3);
+	
+	if (!(data[2] & 0x01))
+		return 0;
+
+    *ucblocks = (data[0] << 8) | data[1]; 
+	return 0;
+}
+static int get_ucblocksT(struct cxd_state *state, u32 *ucblocks)
+{
+	u8 data[3];
+	
+	readregst(state, 0x10, 0xEA, data, 3);
+	
+	if (!(data[2] & 0x01))
+		return 0;
+
+    *ucblocks = (data[0] << 8) | data[1]; 
+	return 0;
+	
+}
+static int get_ucblocksT2(struct cxd_state *state, u32 *ucblocks)
+{	
+	u8 data[3];
+	
+	readregst(state, 0x24, 0xFD, data, 3);
+	if (!(data[0] & 0x01))
+		return 0;
+   
+	*ucblocks =  ((data[1] << 0x08) | data[2]);
+	
+	return 0;
+}
+
+
+static int read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int ret = 0;
+	*ucblocks = 0;
+				
+	if (state->last_status != 0x1f)
+		return 0;
+			
+	switch (state->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		ret = get_ucblocksC(state, ucblocks);
+		break;
+	case SYS_DVBT:
+		ret = get_ucblocksT(state, ucblocks);
+		break;
+	case SYS_DVBT2:
+		ret = get_ucblocksT2(state, ucblocks);
+		break;
+	default:
+		break;
+	}
+	
+	return 0;
+}
+static int get_fe_t(struct cxd_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8 tps[8];
+
+	read_tps(state, tps);
+
+/*  TPSData[0] [7:6]  CNST[1:0]
+    TPSData[0] [5:3]  HIER[2:0]
+    TPSData[0] [2:0]  HRATE[2:0]
+*/
+	switch ((tps[0] >> 6) & 0x03) {
+	case 0:
+		p->modulation = QPSK;
+		break;
+	case 1:
+		p->modulation = QAM_16;
+		break;
+	case 2:
+		p->modulation = QAM_64;
+		break;
+	}
+	switch ((tps[0] >> 3) & 0x07) {
+	case 0:
+		p->hierarchy = HIERARCHY_NONE;
+		break;
+	case 1:
+		p->hierarchy = HIERARCHY_1;
+		break;
+	case 2:
+		p->hierarchy = HIERARCHY_2;
+		break;
+	case 3:
+		p->hierarchy = HIERARCHY_4;
+		break;
+	}
+	switch ((tps[0] >> 0) & 0x07) {
+	case 0:
+		p->code_rate_HP = FEC_1_2;
+		break;
+	case 1:
+		p->code_rate_HP = FEC_2_3;
+		break;
+	case 2:
+		p->code_rate_HP = FEC_3_4;
+		break;
+	case 3:
+		p->code_rate_HP = FEC_5_6;
+		break;
+	case 4:
+		p->code_rate_HP = FEC_7_8;
+		break;
+	}
+
+/*  TPSData[1] [7:5]  LRATE[2:0]
+    TPSData[1] [4:3]  GI[1:0]
+    TPSData[1] [2:1]  MODE[1:0]
+*/
+	switch ((tps[1] >> 5) & 0x07) {
+	case 0:
+		p->code_rate_LP = FEC_1_2;
+		break;
+	case 1:
+		p->code_rate_LP = FEC_2_3;
+		break;
+	case 2:
+		p->code_rate_LP = FEC_3_4;
+		break;
+	case 3:
+		p->code_rate_LP = FEC_5_6;
+		break;
+	case 4:
+		p->code_rate_LP = FEC_7_8;
+		break;
+	}
+	switch ((tps[1] >> 3) & 0x03) {
+	case 0:
+		p->guard_interval = GUARD_INTERVAL_1_32;
+		break;
+	case 1:
+		p->guard_interval = GUARD_INTERVAL_1_16;
+		break;
+	case 2:
+		p->guard_interval = GUARD_INTERVAL_1_8;
+		break;
+	case 3:
+		p->guard_interval = GUARD_INTERVAL_1_4;
+		break;
+	}
+	switch ((tps[1] >> 1) & 0x03) {
+	case 0:
+		p->transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case 1:
+		p->transmission_mode = TRANSMISSION_MODE_8K;
+		break;
+	}
+
+	switch ((tps[7] >> 0) & 0x01) {
+	case 0:
+		p->inversion = INVERSION_OFF;
+		break;
+	case 1:
+		p->inversion = INVERSION_ON;
+		break;
+	}
+	
+	return 0;
+}
+static int get_fe_t2(struct cxd_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8 tps[5];
+	
+	freeze_regst(state);
+	readregst_unlocked(state, 0x20, 0x5C, tps, 2); 
+	readregst_unlocked(state, 0x22, 0x5B, &tps[2], 1); 
+	readregst_unlocked(state, 0x22, 0x5C, &tps[3], 1); 
+	readregst_unlocked(state, 0x28, 0xE6, &tps[4], 1); 
+	unfreeze_regst(state);
+	
+	switch ((tps[0] >> 0) & 0x07) {
+	case 0:
+		p->transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case 1:
+		p->transmission_mode = TRANSMISSION_MODE_8K;
+		break;
+	case 2:
+		p->transmission_mode = TRANSMISSION_MODE_4K;
+		break;
+	case 3:
+		p->transmission_mode = TRANSMISSION_MODE_1K;
+		break;
+	case 4:
+		p->transmission_mode = TRANSMISSION_MODE_16K;
+		break;
+	case 5:
+		p->transmission_mode = TRANSMISSION_MODE_32K;
+		break;
+	}
+
+	switch ((tps[1] >> 4) & 0x07) {
+	case 0:
+		p->guard_interval = GUARD_INTERVAL_1_32;
+		break;
+	case 1:
+		p->guard_interval = GUARD_INTERVAL_1_16;
+		break;
+	case 2:
+		p->guard_interval = GUARD_INTERVAL_1_8;
+		break;
+	case 3:
+		p->guard_interval = GUARD_INTERVAL_1_4;
+		break;
+	case 4:
+		p->guard_interval = GUARD_INTERVAL_1_128;
+		break;
+	case 5:
+		p->guard_interval = GUARD_INTERVAL_19_128;
+		break;
+	case 6:
+		p->guard_interval = GUARD_INTERVAL_19_256;
+		break;
+	}
+	
+	switch ((tps[2] >> 0) & 0x07) {
+	case 0:
+		p->fec_inner = FEC_1_2;
+		break;
+	case 1:
+		p->fec_inner = FEC_3_5;
+		break;
+	case 2:
+		p->fec_inner = FEC_2_3;
+		break;
+	case 3:
+		p->fec_inner = FEC_3_4;
+		break;
+	case 4:
+		p->fec_inner = FEC_4_5;
+		break;
+	case 5:
+		p->fec_inner = FEC_5_6;
+		break;
+	}
+
+	switch ((tps[3] >> 0) & 0x07) {
+	case 0:
+		p->modulation = QPSK;
+		break;
+	case 1:
+		p->modulation = QAM_16;
+		break;
+	case 2:
+		p->modulation = QAM_64;
+		break;
+	case 3:
+		p->modulation = QAM_256;
+		break;
+	}
+	
+	switch (tps[4] & 0x01) {
+	case 0:
+		p->inversion = INVERSION_OFF;
+		break;
+	case 1:
+		p->inversion = INVERSION_ON;
+		break;
+	}
+	
+	return 0;
+	
+}
+static int get_fe_c(struct cxd_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8 qam;
+	u8 rate[2];
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x40, 0x19, &qam, 1);
+	readregst_unlocked(state, 0x40, 0x1A, rate, 2);
+	unfreeze_regst(state);
+	
+	p->symbol_rate = 2500 * ((rate[0] & 0x0f) << 8 | rate[1]);
+	
+	p->modulation = qam & 0x07;
+	
+	switch (qam & 0x80) {
+	case 0:
+		p->inversion = INVERSION_OFF;
+		break;
+	case 1:
+		p->inversion = INVERSION_ON;
+		break;
+	}
+	
+	return 0;
+}
+
+static int get_frontend(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	if (state->last_status != 0x1f)
+		return 0;
+
+	switch (state->delivery_system) {
+	case SYS_DVBT:
+		get_fe_t(state);
+		break;
+	case SYS_DVBT2:
+		get_fe_t2(state);
+		break;
+	case SYS_DVBC_ANNEX_A:
+		get_fe_c(state);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static struct dvb_frontend_ops cxd_2837_ops = {
+	.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBT, SYS_DVBT2 },
+	.info = {
+		.name = "CXD2837 DVB-C DVB-T/T2",
+		.frequency_min = 47000000,	/* DVB-T: 47125000 */
+		.frequency_max = 865000000,	/* DVB-C: 862000000 */
+		.caps = 	FE_CAN_FEC_1_2 |
+					FE_CAN_FEC_2_3 |
+					FE_CAN_FEC_3_4 |
+					FE_CAN_FEC_5_6 |
+					FE_CAN_FEC_7_8 |
+					FE_CAN_FEC_AUTO |
+					FE_CAN_QPSK |
+					FE_CAN_QAM_16 |
+					FE_CAN_QAM_32 |
+					FE_CAN_QAM_64 |
+					FE_CAN_QAM_128 |
+					FE_CAN_QAM_256 |
+					FE_CAN_QAM_AUTO |
+					FE_CAN_TRANSMISSION_MODE_AUTO |
+					FE_CAN_GUARD_INTERVAL_AUTO |
+					FE_CAN_HIERARCHY_AUTO |
+					FE_CAN_MUTE_TS |
+					FE_CAN_2G_MODULATION |
+					FE_CAN_MULTISTREAM
+	},
+	.init = init,
+	.release = release,
+	.i2c_gate_ctrl = gate_ctrl,
+	.set_frontend = set_parameters,
+	.get_tune_settings = get_tune_settings,
+	.read_status = read_status,
+	.read_ber = read_ber,
+	.read_signal_strength = read_signal_strength,
+	.read_snr = read_snr,
+	.read_ucblocks = read_ucblocks,
+	.get_frontend = get_frontend,
+	
+};
+
+struct dvb_frontend *cxd2837_attach(struct i2c_adapter *i2c,
+				    struct cxd2837_cfg *cfg)
+{
+	struct cxd_state *state = NULL;
+	int ret;
+	u8 ChipID = 0x00;
+	
+	state = kzalloc(sizeof(struct cxd_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+
+	state->i2c = i2c;
+	init_state(state, cfg);
+	
+	ret = readregst(state, 0x00, 0xFD, &ChipID, 1);
+	if (ret) {
+		ret = readregsx(state, 0x00, 0xFD, &ChipID, 1);
+		if (ret)
+			goto err2;
+	}
+		
+	if (ChipID != 0xB1)
+		goto err2;
+		
+	dev_info(&i2c->dev, "CXD2837 DVB-T/T2/C successfully attached\n");						
+		
+	memcpy(&state->frontend.ops, &cxd_2837_ops,
+		       sizeof(struct dvb_frontend_ops));
+			   
+	state->frontend.demodulator_priv = state;
+	
+	return &state->frontend;
+	
+err2:	
+	kfree(state);
+err1:	
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);	
+	return NULL;
+}
+EXPORT_SYMBOL(cxd2837_attach);
+
+MODULE_DESCRIPTION("Sony CXD2837 DVB-T/T2/C demodulator driver");
+MODULE_AUTHOR("Ralph Metzler, Manfred Voelkel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/cxd2837.h b/drivers/amlogic/wetek/cxd2837.h
new file mode 100644
index 0000000..98300a8
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2837.h
@@ -0,0 +1,107 @@
+/*
+ * Driver for the Sony CXD2837ER DVB-T/T2/C demodulator.
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#ifndef _CXD2837_H_
+#define _CXD2837_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+enum EDemodState { 
+	Unknown,
+	Shutdown,
+	Sleep,
+	Active 
+};
+
+enum xtal_freq {
+	XTAL_20500KHz,           /* 20.5 MHz */
+	XTAL_41000KHz            /* 41 MHz */
+};
+
+enum ts_serial_clk {
+	SERIAL_TS_CLK_HIGH_FULL,   /* High frequency, full rate */
+	SERIAL_TS_CLK_MID_FULL,    /* Mid frequency, full rate */
+	SERIAL_TS_CLK_LOW_FULL,    /* Low frequency, full rate */
+	SERIAL_TS_CLK_HIGH_HALF,   /* High frequency, half rate */
+	SERIAL_TS_CLK_MID_HALF,    /* Mid frequency, half rate */
+	SERIAL_TS_CLK_LOW_HALF     /* Low frequency, half rate */
+};
+
+struct cxd2837_cfg {
+
+	/* Demodulator I2C address.
+	 * Default: none, must set
+	 * Values: 0x6c, 0x6d
+	 */
+	u8 adr;
+
+	/* IF AGC polarity.
+	 * Default: 0
+	 * Values: 0, 1
+	 */
+	bool if_agc_polarity;
+	
+	/* RFAIN monitoring.
+	 * Default: 0
+	 * Values: 0, 1
+	 */
+	bool rfain_monitoring;
+		
+	/* TS error polarity.
+	 * Default: 0
+	 * Values: 0 : low, 1 : high
+	 */
+	bool ts_error_polarity;
+	
+	/* Clock polarity.
+	 * Default: 0
+	 * Values:  0 : Falling edge, 1 : Rising edge
+	 */
+	bool clock_polarity;
+	
+	/* IFAGC ADC range/
+	 * Default: 0
+	 * Values:  0 : 1.4Vpp, 1 : 1.0Vpp, 2 : 0.7Vpp 
+	 */
+	u8 ifagc_adc_range;
+
+	/* Spectrum inversion.
+	 * Default: 0
+	 * Values: 0, 1
+	 */
+	bool spec_inv;
+	
+	/* Demodulator crystal frequency.
+	*/
+	enum xtal_freq xtal;
+	
+	
+	/* TS serial clock frequency
+	*/
+	enum ts_serial_clk ts_clock;
+};
+
+
+extern struct dvb_frontend *cxd2837_attach(struct i2c_adapter *i2c,
+					   struct cxd2837_cfg *cfg);
+
+#endif
diff --git a/drivers/amlogic/wetek/cxd2841er_priv_wetek.h b/drivers/amlogic/wetek/cxd2841er_priv_wetek.h
new file mode 100644
index 0000000..5e2b8d8
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2841er_priv_wetek.h
@@ -0,0 +1,45 @@
+/*
+ * cxd2841er_priv.h
+ *
+ * Sony CXD2441ER digital demodulator driver internal definitions
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef CXD2841ER_PRIV_H
+#define CXD2841ER_PRIV_H
+
+#define I2C_SLVX			0
+#define I2C_SLVT			1
+
+#define CXD2841ER_CHIP_ID		0xa7
+#define CXD2854ER_CHIP_ID		0xc1
+#define CXD2837ER_CHIP_ID		0xb1
+
+#define CXD2841ER_DVBS_POLLING_INVL	10
+
+struct cxd2841er_cnr_data {
+	u32 value;
+	int cnr_x1000;
+};
+
+enum cxd2841er_dvbt2_profile_t {
+	DVBT2_PROFILE_ANY = 0,
+	DVBT2_PROFILE_BASE = 1,
+	DVBT2_PROFILE_LITE = 2
+};
+
+#endif
diff --git a/drivers/amlogic/wetek/cxd2841er_wetek.c b/drivers/amlogic/wetek/cxd2841er_wetek.c
new file mode 100644
index 0000000..505accd
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2841er_wetek.c
@@ -0,0 +1,3812 @@
+/*
+ * cxd2841er.c
+ *
+ * Sony digital demodulator driver for
+ *	CXD2841ER - DVB-S/S2/T/T2/C/C2
+ *	CXD2854ER - DVB-S/S2/T/T2/C/C2, ISDB-T/S
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/bitops.h>
+#include <linux/math64.h>
+#include <linux/log2.h>
+#include <linux/dynamic_debug.h>
+
+#include "dvb_math.h"
+#include "dvb_frontend.h"
+#include "cxd2841er_wetek.h"
+#include "cxd2841er_priv_wetek.h"
+
+#define MAX_WRITE_REGSIZE	16
+#define LOG2_E_100X 144
+
+/* DVB-C constellation */
+enum sony_dvbc_constellation_t {
+	SONY_DVBC_CONSTELLATION_16QAM,
+	SONY_DVBC_CONSTELLATION_32QAM,
+	SONY_DVBC_CONSTELLATION_64QAM,
+	SONY_DVBC_CONSTELLATION_128QAM,
+	SONY_DVBC_CONSTELLATION_256QAM
+};
+
+enum cxd2841er_state {
+	STATE_SHUTDOWN = 0,
+	STATE_SLEEP_S,
+	STATE_ACTIVE_S,
+	STATE_SLEEP_TC,
+	STATE_ACTIVE_TC
+};
+
+struct cxd2841er_priv {
+	struct dvb_frontend		frontend;
+	struct i2c_adapter		*i2c;
+	u8				i2c_addr_slvx;
+	u8				i2c_addr_slvt;
+	const struct cxd2841er_config	*config;
+	enum cxd2841er_state		state;
+	u8				system;
+	enum cxd2841er_xtal		xtal;
+	enum fe_caps caps;
+};
+
+static const struct cxd2841er_cnr_data s_cn_data[] = {
+	{ 0x033e, 0 }, { 0x0339, 100 }, { 0x0333, 200 },
+	{ 0x032e, 300 }, { 0x0329, 400 }, { 0x0324, 500 },
+	{ 0x031e, 600 }, { 0x0319, 700 }, { 0x0314, 800 },
+	{ 0x030f, 900 }, { 0x030a, 1000 }, { 0x02ff, 1100 },
+	{ 0x02f4, 1200 }, { 0x02e9, 1300 }, { 0x02de, 1400 },
+	{ 0x02d4, 1500 }, { 0x02c9, 1600 }, { 0x02bf, 1700 },
+	{ 0x02b5, 1800 }, { 0x02ab, 1900 }, { 0x02a1, 2000 },
+	{ 0x029b, 2100 }, { 0x0295, 2200 }, { 0x0290, 2300 },
+	{ 0x028a, 2400 }, { 0x0284, 2500 }, { 0x027f, 2600 },
+	{ 0x0279, 2700 }, { 0x0274, 2800 }, { 0x026e, 2900 },
+	{ 0x0269, 3000 }, { 0x0262, 3100 }, { 0x025c, 3200 },
+	{ 0x0255, 3300 }, { 0x024f, 3400 }, { 0x0249, 3500 },
+	{ 0x0242, 3600 }, { 0x023c, 3700 }, { 0x0236, 3800 },
+	{ 0x0230, 3900 }, { 0x022a, 4000 }, { 0x0223, 4100 },
+	{ 0x021c, 4200 }, { 0x0215, 4300 }, { 0x020e, 4400 },
+	{ 0x0207, 4500 }, { 0x0201, 4600 }, { 0x01fa, 4700 },
+	{ 0x01f4, 4800 }, { 0x01ed, 4900 }, { 0x01e7, 5000 },
+	{ 0x01e0, 5100 }, { 0x01d9, 5200 }, { 0x01d2, 5300 },
+	{ 0x01cb, 5400 }, { 0x01c4, 5500 }, { 0x01be, 5600 },
+	{ 0x01b7, 5700 }, { 0x01b1, 5800 }, { 0x01aa, 5900 },
+	{ 0x01a4, 6000 }, { 0x019d, 6100 }, { 0x0196, 6200 },
+	{ 0x018f, 6300 }, { 0x0189, 6400 }, { 0x0182, 6500 },
+	{ 0x017c, 6600 }, { 0x0175, 6700 }, { 0x016f, 6800 },
+	{ 0x0169, 6900 }, { 0x0163, 7000 }, { 0x015c, 7100 },
+	{ 0x0156, 7200 }, { 0x0150, 7300 }, { 0x014a, 7400 },
+	{ 0x0144, 7500 }, { 0x013e, 7600 }, { 0x0138, 7700 },
+	{ 0x0132, 7800 }, { 0x012d, 7900 }, { 0x0127, 8000 },
+	{ 0x0121, 8100 }, { 0x011c, 8200 }, { 0x0116, 8300 },
+	{ 0x0111, 8400 }, { 0x010b, 8500 }, { 0x0106, 8600 },
+	{ 0x0101, 8700 }, { 0x00fc, 8800 }, { 0x00f7, 8900 },
+	{ 0x00f2, 9000 }, { 0x00ee, 9100 }, { 0x00ea, 9200 },
+	{ 0x00e6, 9300 }, { 0x00e2, 9400 }, { 0x00de, 9500 },
+	{ 0x00da, 9600 }, { 0x00d7, 9700 }, { 0x00d3, 9800 },
+	{ 0x00d0, 9900 }, { 0x00cc, 10000 }, { 0x00c7, 10100 },
+	{ 0x00c3, 10200 }, { 0x00bf, 10300 }, { 0x00ba, 10400 },
+	{ 0x00b6, 10500 }, { 0x00b2, 10600 }, { 0x00ae, 10700 },
+	{ 0x00aa, 10800 }, { 0x00a7, 10900 }, { 0x00a3, 11000 },
+	{ 0x009f, 11100 }, { 0x009c, 11200 }, { 0x0098, 11300 },
+	{ 0x0094, 11400 }, { 0x0091, 11500 }, { 0x008e, 11600 },
+	{ 0x008a, 11700 }, { 0x0087, 11800 }, { 0x0084, 11900 },
+	{ 0x0081, 12000 }, { 0x007e, 12100 }, { 0x007b, 12200 },
+	{ 0x0079, 12300 }, { 0x0076, 12400 }, { 0x0073, 12500 },
+	{ 0x0071, 12600 }, { 0x006e, 12700 }, { 0x006c, 12800 },
+	{ 0x0069, 12900 }, { 0x0067, 13000 }, { 0x0065, 13100 },
+	{ 0x0062, 13200 }, { 0x0060, 13300 }, { 0x005e, 13400 },
+	{ 0x005c, 13500 }, { 0x005a, 13600 }, { 0x0058, 13700 },
+	{ 0x0056, 13800 }, { 0x0054, 13900 }, { 0x0052, 14000 },
+	{ 0x0050, 14100 }, { 0x004e, 14200 }, { 0x004c, 14300 },
+	{ 0x004b, 14400 }, { 0x0049, 14500 }, { 0x0047, 14600 },
+	{ 0x0046, 14700 }, { 0x0044, 14800 }, { 0x0043, 14900 },
+	{ 0x0041, 15000 }, { 0x003f, 15100 }, { 0x003e, 15200 },
+	{ 0x003c, 15300 }, { 0x003b, 15400 }, { 0x003a, 15500 },
+	{ 0x0037, 15700 }, { 0x0036, 15800 }, { 0x0034, 15900 },
+	{ 0x0033, 16000 }, { 0x0032, 16100 }, { 0x0031, 16200 },
+	{ 0x0030, 16300 }, { 0x002f, 16400 }, { 0x002e, 16500 },
+	{ 0x002d, 16600 }, { 0x002c, 16700 }, { 0x002b, 16800 },
+	{ 0x002a, 16900 }, { 0x0029, 17000 }, { 0x0028, 17100 },
+	{ 0x0027, 17200 }, { 0x0026, 17300 }, { 0x0025, 17400 },
+	{ 0x0024, 17500 }, { 0x0023, 17600 }, { 0x0022, 17800 },
+	{ 0x0021, 17900 }, { 0x0020, 18000 }, { 0x001f, 18200 },
+	{ 0x001e, 18300 }, { 0x001d, 18500 }, { 0x001c, 18700 },
+	{ 0x001b, 18900 }, { 0x001a, 19000 }, { 0x0019, 19200 },
+	{ 0x0018, 19300 }, { 0x0017, 19500 }, { 0x0016, 19700 },
+	{ 0x0015, 19900 }, { 0x0014, 20000 },
+};
+
+static const struct cxd2841er_cnr_data s2_cn_data[] = {
+	{ 0x05af, 0 }, { 0x0597, 100 }, { 0x057e, 200 },
+	{ 0x0567, 300 }, { 0x0550, 400 }, { 0x0539, 500 },
+	{ 0x0522, 600 }, { 0x050c, 700 }, { 0x04f6, 800 },
+	{ 0x04e1, 900 }, { 0x04cc, 1000 }, { 0x04b6, 1100 },
+	{ 0x04a1, 1200 }, { 0x048c, 1300 }, { 0x0477, 1400 },
+	{ 0x0463, 1500 }, { 0x044f, 1600 }, { 0x043c, 1700 },
+	{ 0x0428, 1800 }, { 0x0416, 1900 }, { 0x0403, 2000 },
+	{ 0x03ef, 2100 }, { 0x03dc, 2200 }, { 0x03c9, 2300 },
+	{ 0x03b6, 2400 }, { 0x03a4, 2500 }, { 0x0392, 2600 },
+	{ 0x0381, 2700 }, { 0x036f, 2800 }, { 0x035f, 2900 },
+	{ 0x034e, 3000 }, { 0x033d, 3100 }, { 0x032d, 3200 },
+	{ 0x031d, 3300 }, { 0x030d, 3400 }, { 0x02fd, 3500 },
+	{ 0x02ee, 3600 }, { 0x02df, 3700 }, { 0x02d0, 3800 },
+	{ 0x02c2, 3900 }, { 0x02b4, 4000 }, { 0x02a6, 4100 },
+	{ 0x0299, 4200 }, { 0x028c, 4300 }, { 0x027f, 4400 },
+	{ 0x0272, 4500 }, { 0x0265, 4600 }, { 0x0259, 4700 },
+	{ 0x024d, 4800 }, { 0x0241, 4900 }, { 0x0236, 5000 },
+	{ 0x022b, 5100 }, { 0x0220, 5200 }, { 0x0215, 5300 },
+	{ 0x020a, 5400 }, { 0x0200, 5500 }, { 0x01f6, 5600 },
+	{ 0x01ec, 5700 }, { 0x01e2, 5800 }, { 0x01d8, 5900 },
+	{ 0x01cf, 6000 }, { 0x01c6, 6100 }, { 0x01bc, 6200 },
+	{ 0x01b3, 6300 }, { 0x01aa, 6400 }, { 0x01a2, 6500 },
+	{ 0x0199, 6600 }, { 0x0191, 6700 }, { 0x0189, 6800 },
+	{ 0x0181, 6900 }, { 0x0179, 7000 }, { 0x0171, 7100 },
+	{ 0x0169, 7200 }, { 0x0161, 7300 }, { 0x015a, 7400 },
+	{ 0x0153, 7500 }, { 0x014b, 7600 }, { 0x0144, 7700 },
+	{ 0x013d, 7800 }, { 0x0137, 7900 }, { 0x0130, 8000 },
+	{ 0x012a, 8100 }, { 0x0124, 8200 }, { 0x011e, 8300 },
+	{ 0x0118, 8400 }, { 0x0112, 8500 }, { 0x010c, 8600 },
+	{ 0x0107, 8700 }, { 0x0101, 8800 }, { 0x00fc, 8900 },
+	{ 0x00f7, 9000 }, { 0x00f2, 9100 }, { 0x00ec, 9200 },
+	{ 0x00e7, 9300 }, { 0x00e2, 9400 }, { 0x00dd, 9500 },
+	{ 0x00d8, 9600 }, { 0x00d4, 9700 }, { 0x00cf, 9800 },
+	{ 0x00ca, 9900 }, { 0x00c6, 10000 }, { 0x00c2, 10100 },
+	{ 0x00be, 10200 }, { 0x00b9, 10300 }, { 0x00b5, 10400 },
+	{ 0x00b1, 10500 }, { 0x00ae, 10600 }, { 0x00aa, 10700 },
+	{ 0x00a6, 10800 }, { 0x00a3, 10900 }, { 0x009f, 11000 },
+	{ 0x009b, 11100 }, { 0x0098, 11200 }, { 0x0095, 11300 },
+	{ 0x0091, 11400 }, { 0x008e, 11500 }, { 0x008b, 11600 },
+	{ 0x0088, 11700 }, { 0x0085, 11800 }, { 0x0082, 11900 },
+	{ 0x007f, 12000 }, { 0x007c, 12100 }, { 0x007a, 12200 },
+	{ 0x0077, 12300 }, { 0x0074, 12400 }, { 0x0072, 12500 },
+	{ 0x006f, 12600 }, { 0x006d, 12700 }, { 0x006b, 12800 },
+	{ 0x0068, 12900 }, { 0x0066, 13000 }, { 0x0064, 13100 },
+	{ 0x0061, 13200 }, { 0x005f, 13300 }, { 0x005d, 13400 },
+	{ 0x005b, 13500 }, { 0x0059, 13600 }, { 0x0057, 13700 },
+	{ 0x0055, 13800 }, { 0x0053, 13900 }, { 0x0051, 14000 },
+	{ 0x004f, 14100 }, { 0x004e, 14200 }, { 0x004c, 14300 },
+	{ 0x004a, 14400 }, { 0x0049, 14500 }, { 0x0047, 14600 },
+	{ 0x0045, 14700 }, { 0x0044, 14800 }, { 0x0042, 14900 },
+	{ 0x0041, 15000 }, { 0x003f, 15100 }, { 0x003e, 15200 },
+	{ 0x003c, 15300 }, { 0x003b, 15400 }, { 0x003a, 15500 },
+	{ 0x0038, 15600 }, { 0x0037, 15700 }, { 0x0036, 15800 },
+	{ 0x0034, 15900 }, { 0x0033, 16000 }, { 0x0032, 16100 },
+	{ 0x0031, 16200 }, { 0x0030, 16300 }, { 0x002f, 16400 },
+	{ 0x002e, 16500 }, { 0x002d, 16600 }, { 0x002c, 16700 },
+	{ 0x002b, 16800 }, { 0x002a, 16900 }, { 0x0029, 17000 },
+	{ 0x0028, 17100 }, { 0x0027, 17200 }, { 0x0026, 17300 },
+	{ 0x0025, 17400 }, { 0x0024, 17500 }, { 0x0023, 17600 },
+	{ 0x0022, 17800 }, { 0x0021, 17900 }, { 0x0020, 18000 },
+	{ 0x001f, 18200 }, { 0x001e, 18300 }, { 0x001d, 18500 },
+	{ 0x001c, 18700 }, { 0x001b, 18900 }, { 0x001a, 19000 },
+	{ 0x0019, 19200 }, { 0x0018, 19300 }, { 0x0017, 19500 },
+	{ 0x0016, 19700 }, { 0x0015, 19900 }, { 0x0014, 20000 },
+};
+
+#define MAKE_IFFREQ_CONFIG(iffreq) ((u32)(((iffreq)/41.0)*16777216.0 + 0.5))
+#define MAKE_IFFREQ_CONFIG_XTAL(xtal, iffreq) ((xtal == SONY_XTAL_24000) ? \
+		(u32)(((iffreq)/48.0)*16777216.0 + 0.5) : \
+		(u32)(((iffreq)/41.0)*16777216.0 + 0.5))
+
+static void cxd2841er_i2c_debug(struct cxd2841er_priv *priv,
+				u8 addr, u8 reg, u8 write,
+				const u8 *data, u32 len)
+{
+	dev_dbg(&priv->i2c->dev,
+		"cxd2841er: I2C %s addr %02x reg 0x%02x size %d\n",
+		(write == 0 ? "read" : "write"), addr, reg, len);
+	print_hex_dump_bytes("cxd2841er: I2C data: ",
+		DUMP_PREFIX_OFFSET, data, len);
+}
+
+static int cxd2841er_write_regs(struct cxd2841er_priv *priv,
+				u8 addr, u8 reg, const u8 *data, u32 len)
+{
+	int ret;
+	u8 buf[MAX_WRITE_REGSIZE + 1];
+	u8 i2c_addr = (addr == I2C_SLVX ?
+		priv->i2c_addr_slvx : priv->i2c_addr_slvt);
+	struct i2c_msg msg[1] = {
+		{
+			.addr = i2c_addr,
+			.flags = 0,
+			.len = len + 1,
+			.buf = buf,
+		}
+	};
+
+	if (len + 1 >= sizeof(buf)) {
+		dev_warn(&priv->i2c->dev, "wr reg=%04x: len=%d is too big!\n",
+			 reg, len + 1);
+		return -E2BIG;
+	}
+
+	cxd2841er_i2c_debug(priv, i2c_addr, reg, 1, data, len);
+	buf[0] = reg;
+	memcpy(&buf[1], data, len);
+
+	ret = i2c_transfer(priv->i2c, msg, 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c wr failed=%d addr=%02x reg=%02x len=%d\n",
+			KBUILD_MODNAME, ret, i2c_addr, reg, len);
+		return ret;
+	}
+	return 0;
+}
+
+static int cxd2841er_write_reg(struct cxd2841er_priv *priv,
+			       u8 addr, u8 reg, u8 val)
+{
+	return cxd2841er_write_regs(priv, addr, reg, &val, 1);
+}
+
+static int cxd2841er_read_regs(struct cxd2841er_priv *priv,
+			       u8 addr, u8 reg, u8 *val, u32 len)
+{
+	int ret;
+	u8 i2c_addr = (addr == I2C_SLVX ?
+		priv->i2c_addr_slvx : priv->i2c_addr_slvt);
+	struct i2c_msg msg[2] = {
+		{
+			.addr = i2c_addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &reg,
+		}, {
+			.addr = i2c_addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val,
+		}
+	};
+
+	ret = i2c_transfer(priv->i2c, &msg[0], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c rw failed=%d addr=%02x reg=%02x\n",
+			KBUILD_MODNAME, ret, i2c_addr, reg);
+		return ret;
+	}
+	ret = i2c_transfer(priv->i2c, &msg[1], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c rd failed=%d addr=%02x reg=%02x\n",
+			KBUILD_MODNAME, ret, i2c_addr, reg);
+		return ret;
+	}
+	cxd2841er_i2c_debug(priv, i2c_addr, reg, 0, val, len);
+	return 0;
+}
+
+static int cxd2841er_read_reg(struct cxd2841er_priv *priv,
+			      u8 addr, u8 reg, u8 *val)
+{
+	return cxd2841er_read_regs(priv, addr, reg, val, 1);
+}
+
+static int cxd2841er_set_reg_bits(struct cxd2841er_priv *priv,
+				  u8 addr, u8 reg, u8 data, u8 mask)
+{
+	int res;
+	u8 rdata;
+
+	if (mask != 0xff) {
+		res = cxd2841er_read_reg(priv, addr, reg, &rdata);
+		if (res)
+			return res;
+		data = ((data & mask) | (rdata & (mask ^ 0xFF)));
+	}
+	return cxd2841er_write_reg(priv, addr, reg, data);
+}
+
+static int cxd2841er_dvbs2_set_symbol_rate(struct cxd2841er_priv *priv,
+					   u32 symbol_rate)
+{
+	u32 reg_value = 0;
+	u8 data[3] = {0, 0, 0};
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	/*
+	 * regValue = (symbolRateKSps * 2^14 / 1000) + 0.5
+	 *          = ((symbolRateKSps * 2^14) + 500) / 1000
+	 *          = ((symbolRateKSps * 16384) + 500) / 1000
+	 */
+	reg_value = DIV_ROUND_CLOSEST(symbol_rate * 16384, 1000);
+	if ((reg_value == 0) || (reg_value > 0xFFFFF)) {
+		dev_err(&priv->i2c->dev,
+			"%s(): reg_value is out of range\n", __func__);
+		return -EINVAL;
+	}
+	data[0] = (u8)((reg_value >> 16) & 0x0F);
+	data[1] = (u8)((reg_value >>  8) & 0xFF);
+	data[2] = (u8)(reg_value & 0xFF);
+	/* Set SLV-T Bank : 0xAE */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x20, data, 3);
+	return 0;
+}
+
+static void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,
+					u8 system);
+
+static int cxd2841er_sleep_s_to_active_s(struct cxd2841er_priv *priv,
+					 u8 system, u32 symbol_rate)
+{
+	int ret;
+	u8 data[4] = { 0, 0, 0, 0 };
+
+	if (priv->state != STATE_SLEEP_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, (int)priv->state);
+		return -EINVAL;
+	}
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBS);
+	/* Set demod mode */
+	if (system == SYS_DVBS) {
+		data[0] = 0x0A;
+	} else if (system == SYS_DVBS2) {
+		data[0] = 0x0B;
+	} else {
+		dev_err(&priv->i2c->dev, "%s(): invalid delsys %d\n",
+			__func__, system);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, data[0]);
+	/* DVB-S/S2 */
+	data[0] = 0x00;
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable S/S2 auto detection 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2d, data[0]);
+	/* Set SLV-T Bank : 0xAE */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);
+	/* Enable S/S2 auto detection 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, data[0]);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x01);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	/* Enable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x3f);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Enable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0xA3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa3);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xac, 0x00);
+	data[0] = 0x07;
+	data[1] = 0x3B;
+	data[2] = 0x08;
+	data[3] = 0xC5;
+	/* Set SLV-T Bank : 0xAB */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xab);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x98, data, 4);
+	data[0] = 0x05;
+	data[1] = 0x80;
+	data[2] = 0x0A;
+	data[3] = 0x80;
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xa8, data, 4);
+	data[0] = 0x0C;
+	data[1] = 0xCC;
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xc3, data, 2);
+	/* Set demod parameter */
+	ret = cxd2841er_dvbs2_set_symbol_rate(priv, symbol_rate);
+	if (ret != 0)
+		return ret;
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x10);
+	/* disable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_S;
+	return 0;
+}
+
+static int cxd2841er_init_tc(struct dvb_frontend *fe);
+
+static int cxd2841er_sleep_tc_to_active_t_band(struct cxd2841er_priv *priv,
+					       u32 bandwidth);
+
+static int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,
+						u32 bandwidth);
+
+static int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,
+					       u32 bandwidth);
+
+static int cxd2841er_sleep_tc_to_active_i(struct cxd2841er_priv *priv,
+		u32 bandwidth);
+
+static int cxd2841er_active_i_to_sleep_tc(struct cxd2841er_priv *priv);
+
+static int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv);
+
+static int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv);
+
+static int cxd2841er_retune_active(struct cxd2841er_priv *priv,
+				   struct dtv_frontend_properties *p)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_S &&
+			priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	if (priv->state == STATE_ACTIVE_S)
+		return cxd2841er_dvbs2_set_symbol_rate(
+				priv, p->symbol_rate / 1000);
+	else if (priv->state == STATE_ACTIVE_TC) {
+		switch (priv->system) {
+		case SYS_DVBT:
+			return cxd2841er_sleep_tc_to_active_t_band(
+					priv, p->bandwidth_hz);
+		case SYS_DVBT2:
+			return cxd2841er_sleep_tc_to_active_t2_band(
+					priv, p->bandwidth_hz);
+		case SYS_DVBC_ANNEX_A:
+			return cxd2841er_sleep_tc_to_active_c_band(
+					priv, p->bandwidth_hz);
+		case SYS_ISDBT:
+			cxd2841er_active_i_to_sleep_tc(priv);
+			cxd2841er_sleep_tc_to_shutdown(priv);
+			cxd2841er_shutdown_to_sleep_tc(priv);
+			return cxd2841er_sleep_tc_to_active_i(
+					priv, p->bandwidth_hz);
+		}
+	}
+	dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+		__func__, priv->system);
+	return -EINVAL;
+}
+
+static int cxd2841er_active_s_to_sleep_s(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x00);
+	/* disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	/* disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);
+	/* SADC Bias ON */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);
+	/* disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	/* Set SLV-T Bank : 0xAE */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);
+	/* disable S/S2 auto detection1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable S/S2 auto detection2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2d, 0x00);
+	priv->state = STATE_SLEEP_S;
+	return 0;
+}
+
+static int cxd2841er_sleep_s_to_shutdown(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SLEEP_S) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable DSQOUT */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* Disable DSQIN */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9c, 0x00);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Disable oscillator */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);
+	priv->state = STATE_SHUTDOWN;
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SLEEP_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Disable oscillator */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);
+	priv->state = STATE_SHUTDOWN;
+	return 0;
+}
+
+static int cxd2841er_active_t_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_active_t2_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Cancel DVB-T2 setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x40);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x21);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xfb);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x00, 0x0f);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x00, 0x3f);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_active_c_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Cancel DVB-C setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa3, 0x00, 0x1f);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_active_i_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+
+	/* TODO: Cancel demod parameter */
+
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_shutdown_to_sleep_s(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SHUTDOWN) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Clear all demodulator registers */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);
+	usleep_range(3000, 5000);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);
+
+	switch (priv->xtal) {
+	case SONY_XTAL_20500:
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x00);
+		break;
+	case SONY_XTAL_24000:
+		/* Select demod frequency */
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x03);
+		break;
+	case SONY_XTAL_41000:
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x01);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod xtal %d\n",
+				__func__, priv->xtal);
+		return -EINVAL;
+	}
+
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x0a);
+	/* Clear demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);
+	usleep_range(1000, 2000);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* enable DSQOUT */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1F);
+	/* enable DSQIN */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9C, 0x40);
+	/* TADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* SADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);
+	priv->state = STATE_SLEEP_S;
+	return 0;
+}
+
+static int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	u8 data = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SHUTDOWN) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Clear all demodulator registers */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);
+	usleep_range(3000, 5000);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);
+  /* Select ADC clock mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x13, 0x00);
+
+	switch (priv->xtal) {
+	case SONY_XTAL_20500:
+		data = 0x0;
+		break;
+	case SONY_XTAL_24000:
+		/* Select demod frequency */
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);
+		data = 0x3;
+		break;
+	case SONY_XTAL_41000:
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);
+		data = 0x1;
+		break;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x14, data);
+	/* Clear demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);
+	usleep_range(1000, 2000);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* SADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_tune_done(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0, 0);
+	/* SW Reset */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xfe, 0x01);
+	/* Enable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x00);
+	return 0;
+}
+
+/* Set TS parallel mode */
+static void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,
+					u8 system)
+{
+	u8 serial_ts, ts_rate_ctrl_off, ts_in_off;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0xc4, &serial_ts);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0xd3, &ts_rate_ctrl_off);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0xde, &ts_in_off);
+	dev_dbg(&priv->i2c->dev, "%s(): ser_ts=0x%02x rate_ctrl_off=0x%02x in_off=0x%02x\n",
+		__func__, serial_ts, ts_rate_ctrl_off, ts_in_off);
+
+	/*
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     D9h     [7:0]  8'h08      OTSCKPERIOD
+	 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xd9, 0x08);
+	/*
+	 * Disable TS IF Clock
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     32h     [0]    1'b1       OREG_CK_TSIF_EN
+	 */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x00, 0x01);
+	/*
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     33h     [1:0]  2'b01      OREG_CKSEL_TSIF
+	 */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x33, 0x00, 0x03);
+	/*
+	 * Enable TS IF Clock
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     32h     [0]    1'b1       OREG_CK_TSIF_EN
+	 */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x01, 0x01);
+
+	if (system == SYS_DVBT) {
+		/* Enable parity period for DVB-T */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);
+	} else if (system == SYS_DVBC_ANNEX_A) {
+		/* Enable parity period for DVB-C */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);
+	}
+}
+
+static u8 cxd2841er_chip_id(struct cxd2841er_priv *priv)
+{
+	u8 chip_id = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (cxd2841er_write_reg(priv, I2C_SLVT, 0, 0) == 0)
+		cxd2841er_read_reg(priv, I2C_SLVT, 0xfd, &chip_id);
+	else if (cxd2841er_write_reg(priv, I2C_SLVX, 0, 0) == 0)
+		cxd2841er_read_reg(priv, I2C_SLVX, 0xfd, &chip_id);
+
+	return chip_id;
+}
+
+static int cxd2841er_read_status_s(struct dvb_frontend *fe,
+				   enum fe_status *status)
+{
+	u8 reg = 0;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	*status = 0;
+	if (priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0xA0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       11h       [2]      ITSLOCK
+	 */
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x11, &reg);
+	if (reg & 0x04) {
+		*status = FE_HAS_SIGNAL
+			| FE_HAS_CARRIER
+			| FE_HAS_VITERBI
+			| FE_HAS_SYNC
+			| FE_HAS_LOCK;
+	}
+	dev_dbg(&priv->i2c->dev, "%s(): result 0x%x\n", __func__, *status);
+	return 0;
+}
+
+static int cxd2841er_read_status_t_t2(struct cxd2841er_priv *priv,
+				      u8 *sync, u8 *tslock, u8 *unlock)
+{
+	u8 data = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC)
+		return -EINVAL;
+	if (priv->system == SYS_DVBT) {
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	} else {
+		/* Set SLV-T Bank : 0x20 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	}
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);
+	if ((data & 0x07) == 0x07) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid hardware state detected\n", __func__);
+		*sync = 0;
+		*tslock = 0;
+		*unlock = 0;
+	} else {
+		*sync = ((data & 0x07) == 0x6 ? 1 : 0);
+		*tslock = ((data & 0x20) ? 1 : 0);
+		*unlock = ((data & 0x10) ? 1 : 0);
+	}
+	return 0;
+}
+
+static int cxd2841er_read_status_c(struct cxd2841er_priv *priv, u8 *tslock)
+{
+	u8 data;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC)
+		return -EINVAL;
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x88, &data);
+	if ((data & 0x01) == 0) {
+		*tslock = 0;
+	} else {
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);
+		*tslock = ((data & 0x20) ? 1 : 0);
+	}
+	return 0;
+}
+
+static int cxd2841er_read_status_i(struct cxd2841er_priv *priv,
+		u8 *sync, u8 *tslock, u8 *unlock)
+{
+	u8 data = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC)
+		return -EINVAL;
+	/* Set SLV-T Bank : 0x60 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);
+	dev_dbg(&priv->i2c->dev,
+			"%s(): lock=0x%x\n", __func__, data);
+	*sync = ((data & 0x02) ? 1 : 0);
+	*tslock = ((data & 0x01) ? 1 : 0);
+	*unlock = ((data & 0x10) ? 1 : 0);
+	return 0;
+}
+
+static int cxd2841er_read_status_tc(struct dvb_frontend *fe,
+				    enum fe_status *status)
+{
+	int ret = 0;
+	u8 sync = 0;
+	u8 tslock = 0;
+	u8 unlock = 0;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	*status = 0;
+	if (priv->state == STATE_ACTIVE_TC) {
+		if (priv->system == SYS_DVBT || priv->system == SYS_DVBT2) {
+			ret = cxd2841er_read_status_t_t2(
+				priv, &sync, &tslock, &unlock);
+			if (ret)
+				goto done;
+			if (unlock)
+				goto done;
+			if (sync)
+				*status = FE_HAS_SIGNAL |
+					FE_HAS_CARRIER |
+					FE_HAS_VITERBI |
+					FE_HAS_SYNC;
+			if (tslock)
+				*status |= FE_HAS_LOCK;
+		} else if (priv->system == SYS_ISDBT) {
+			ret = cxd2841er_read_status_i(
+					priv, &sync, &tslock, &unlock);
+			if (ret)
+				goto done;
+			if (unlock)
+				goto done;
+			if (sync)
+				*status = FE_HAS_SIGNAL |
+					FE_HAS_CARRIER |
+					FE_HAS_VITERBI |
+					FE_HAS_SYNC;
+			if (tslock)
+				*status |= FE_HAS_LOCK;
+		} else if (priv->system == SYS_DVBC_ANNEX_A) {
+			ret = cxd2841er_read_status_c(priv, &tslock);
+			if (ret)
+				goto done;
+			if (tslock)
+				*status = FE_HAS_SIGNAL |
+					FE_HAS_CARRIER |
+					FE_HAS_VITERBI |
+					FE_HAS_SYNC |
+					FE_HAS_LOCK;
+		}
+	}
+done:
+	dev_dbg(&priv->i2c->dev, "%s(): status 0x%x\n", __func__, *status);
+	return ret;
+}
+
+static int cxd2841er_get_carrier_offset_s_s2(struct cxd2841er_priv *priv,
+					     int *offset)
+{
+	u8 data[3];
+	u8 is_hs_mode;
+	s32 cfrl_ctrlval;
+	s32 temp_div, temp_q, temp_r;
+
+	if (priv->state != STATE_ACTIVE_S) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/*
+	 * Get High Sampling Rate mode
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       10h       [0]      ITRL_LOCK
+	 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data[0]);
+	if (data[0] & 0x01) {
+		/*
+		 *  slave     Bank      Addr      Bit      Signal name
+		 * <SLV-T>    A0h       50h       [4]      IHSMODE
+		 */
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x50, &data[0]);
+		is_hs_mode = (data[0] & 0x10 ? 1 : 0);
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): unable to detect sampling rate mode\n",
+			__func__);
+		return -EINVAL;
+	}
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       45h       [4:0]    ICFRL_CTRLVAL[20:16]
+	 * <SLV-T>    A0h       46h       [7:0]    ICFRL_CTRLVAL[15:8]
+	 * <SLV-T>    A0h       47h       [7:0]    ICFRL_CTRLVAL[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x45, data, 3);
+	cfrl_ctrlval = sign_extend32((((u32)data[0] & 0x1F) << 16) |
+				(((u32)data[1] & 0xFF) <<  8) |
+				((u32)data[2] & 0xFF), 20);
+	temp_div = (is_hs_mode ? 1048576 : 1572864);
+	if (cfrl_ctrlval > 0) {
+		temp_q = div_s64_rem(97375LL * cfrl_ctrlval,
+			temp_div, &temp_r);
+	} else {
+		temp_q = div_s64_rem(-97375LL * cfrl_ctrlval,
+			temp_div, &temp_r);
+	}
+	if (temp_r >= temp_div / 2)
+		temp_q++;
+	if (cfrl_ctrlval > 0)
+		temp_q *= -1;
+	*offset = temp_q;
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_i(struct cxd2841er_priv *priv,
+					   u32 bandwidth, int *offset)
+{
+	u8 data[4];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_ISDBT) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));
+	*offset = -1 * sign_extend32(
+		((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |
+		((u32)data[2] << 8) | (u32)data[3], 29);
+
+	switch (bandwidth) {
+	case 6000000:
+		*offset = -1 * ((*offset) * 8/264);
+		break;
+	case 7000000:
+		*offset = -1 * ((*offset) * 8/231);
+		break;
+	case 8000000:
+		*offset = -1 * ((*offset) * 8/198);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",
+				__func__, bandwidth);
+		return -EINVAL;
+	}
+
+	dev_dbg(&priv->i2c->dev, "%s(): bandwidth %d offset %d\n",
+			__func__, bandwidth, *offset);
+
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_t(struct cxd2841er_priv *priv,
+					   u32 bandwidth, int *offset)
+{
+	u8 data[4];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_DVBT) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));
+	*offset = -1 * sign_extend32(
+		((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |
+		((u32)data[2] << 8) | (u32)data[3], 29);
+	*offset *= (bandwidth / 1000000);
+	*offset /= 235;
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_t2(struct cxd2841er_priv *priv,
+					   u32 bandwidth, int *offset)
+{
+	u8 data[4];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_DVBT2) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));
+	*offset = -1 * sign_extend32(
+		((u32)(data[0] & 0x0F) << 24) | ((u32)data[1] << 16) |
+		((u32)data[2] << 8) | (u32)data[3], 27);
+	switch (bandwidth) {
+	case 1712000:
+		*offset /= 582;
+		break;
+	case 5000000:
+	case 6000000:
+	case 7000000:
+	case 8000000:
+		*offset *= (bandwidth / 1000000);
+		*offset /= 940;
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",
+			__func__, bandwidth);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_c(struct cxd2841er_priv *priv,
+					  int *offset)
+{
+	u8 data[2];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_DVBC_ANNEX_A) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x15, data, sizeof(data));
+	*offset = div_s64(41000LL * sign_extend32((((u32)data[0] & 0x3f) << 8)
+						| (u32)data[1], 13), 16384);
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_c(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[3];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));
+	if (data[2] & 0x01)
+		*penum = ((u32)data[0] << 8) | (u32)data[1];
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_t(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[3];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));
+	if (data[2] & 0x01)
+		*penum = ((u32)data[0] << 8) | (u32)data[1];
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_t2(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[3];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xfd, data, sizeof(data));
+	if (data[0] & 0x01)
+		*penum = ((u32)data[1] << 8) | (u32)data[2];
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_i(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[2];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA1, data, 1);
+
+	if (!(data[0] & 0x01))
+		return 0;
+
+	/* Layer A */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA2, data, sizeof(data));
+	*penum = ((u32)data[0] << 8) | (u32)data[1];
+
+	/* Layer B */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA4, data, sizeof(data));
+	*penum += ((u32)data[0] << 8) | (u32)data[1];
+
+	/* Layer C */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA6, data, sizeof(data));
+	*penum += ((u32)data[0] << 8) | (u32)data[1];
+
+	return 0;
+}
+
+static int cxd2841er_read_ber_c(struct cxd2841er_priv *priv,
+		u32 *bit_error, u32 *bit_count)
+{
+	u8 data[3];
+	u32 bit_err, period_exp;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x62, data, sizeof(data));
+	if (!(data[0] & 0x80)) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): no valid BER data\n", __func__);
+		return -EINVAL;
+	}
+	bit_err = ((u32)(data[0] & 0x3f) << 16) |
+		((u32)data[1] << 8) |
+		(u32)data[2];
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x60, data);
+	period_exp = data[0] & 0x1f;
+
+	if ((period_exp <= 11) && (bit_err > (1 << period_exp) * 204 * 8)) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): period_exp(%u) or bit_err(%u)  not in range. no valid BER data\n",
+				__func__, period_exp, bit_err);
+		return -EINVAL;
+	}
+
+	dev_dbg(&priv->i2c->dev,
+			"%s(): period_exp(%u) or bit_err(%u) count=%d\n",
+			__func__, period_exp, bit_err,
+			((1 << period_exp) * 204 * 8));
+
+	*bit_error = bit_err;
+	*bit_count = ((1 << period_exp) * 204 * 8);
+
+	return 0;
+}
+
+static int cxd2841er_mon_read_ber_s(struct cxd2841er_priv *priv,
+				    u32 *bit_error, u32 *bit_count)
+{
+	u8 data[11];
+
+	/* Set SLV-T Bank : 0xA0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       35h       [0]      IFVBER_VALID
+	 * <SLV-T>    A0h       36h       [5:0]    IFVBER_BITERR[21:16]
+	 * <SLV-T>    A0h       37h       [7:0]    IFVBER_BITERR[15:8]
+	 * <SLV-T>    A0h       38h       [7:0]    IFVBER_BITERR[7:0]
+	 * <SLV-T>    A0h       3Dh       [5:0]    IFVBER_BITNUM[21:16]
+	 * <SLV-T>    A0h       3Eh       [7:0]    IFVBER_BITNUM[15:8]
+	 * <SLV-T>    A0h       3Fh       [7:0]    IFVBER_BITNUM[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x35, data, 11);
+	if (data[0] & 0x01) {
+		*bit_error = ((u32)(data[1]  & 0x3F) << 16) |
+			     ((u32)(data[2]  & 0xFF) <<  8) |
+			     (u32)(data[3]  & 0xFF);
+		*bit_count = ((u32)(data[8]  & 0x3F) << 16) |
+			     ((u32)(data[9]  & 0xFF) <<  8) |
+			     (u32)(data[10] & 0xFF);
+		if ((*bit_count == 0) || (*bit_error > *bit_count)) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): invalid bit_error %d, bit_count %d\n",
+				__func__, *bit_error, *bit_count);
+			return -EINVAL;
+		}
+		return 0;
+	}
+	dev_dbg(&priv->i2c->dev, "%s(): no data available\n", __func__);
+	return -EINVAL;
+}
+
+
+static int cxd2841er_mon_read_ber_s2(struct cxd2841er_priv *priv,
+				     u32 *bit_error, u32 *bit_count)
+{
+	u8 data[5];
+	u32 period;
+
+	/* Set SLV-T Bank : 0xB2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xb2);
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    B2h       30h       [0]      IFLBER_VALID
+	 * <SLV-T>    B2h       31h       [3:0]    IFLBER_BITERR[27:24]
+	 * <SLV-T>    B2h       32h       [7:0]    IFLBER_BITERR[23:16]
+	 * <SLV-T>    B2h       33h       [7:0]    IFLBER_BITERR[15:8]
+	 * <SLV-T>    B2h       34h       [7:0]    IFLBER_BITERR[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x30, data, 5);
+	if (data[0] & 0x01) {
+		/* Bit error count */
+		*bit_error = ((u32)(data[1] & 0x0F) << 24) |
+			     ((u32)(data[2] & 0xFF) << 16) |
+			     ((u32)(data[3] & 0xFF) <<  8) |
+			     (u32)(data[4] & 0xFF);
+
+		/* Set SLV-T Bank : 0xA0 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x7a, data);
+		/* Measurement period */
+		period = (u32)(1 << (data[0] & 0x0F));
+		if (period == 0) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): period is 0\n", __func__);
+			return -EINVAL;
+		}
+		if (*bit_error > (period * 64800)) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): invalid bit_err 0x%x period 0x%x\n",
+				__func__, *bit_error, period);
+			return -EINVAL;
+		}
+		*bit_count = period * 64800;
+
+		return 0;
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no data available\n", __func__);
+	}
+	return -EINVAL;
+}
+
+static int cxd2841er_read_ber_t2(struct cxd2841er_priv *priv,
+				 u32 *bit_error, u32 *bit_count)
+{
+	u8 data[4];
+	u32 period_exp, n_ldpc;
+
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x39, data, sizeof(data));
+	if (!(data[0] & 0x10)) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no valid BER data\n", __func__);
+		return -EINVAL;
+	}
+	*bit_error = ((u32)(data[0] & 0x0f) << 24) |
+		     ((u32)data[1] << 16) |
+		     ((u32)data[2] << 8) |
+		     (u32)data[3];
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);
+	period_exp = data[0] & 0x0f;
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x22);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x5e, data);
+	n_ldpc = ((data[0] & 0x03) == 0 ? 16200 : 64800);
+	if (*bit_error > ((1U << period_exp) * n_ldpc)) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid BER value\n", __func__);
+		return -EINVAL;
+	}
+
+	/*
+	 * FIXME: the right thing would be to return bit_error untouched,
+	 * but, as we don't know the scale returned by the counters, let's
+	 * at least preserver BER = bit_error/bit_count.
+	 */
+	if (period_exp >= 4) {
+		*bit_count = (1U << (period_exp - 4)) * (n_ldpc / 200);
+		*bit_error *= 3125ULL;
+	} else {
+		*bit_count = (1U << period_exp) * (n_ldpc / 200);
+		*bit_error *= 50000ULL;
+	}
+	return 0;
+}
+
+static int cxd2841er_read_ber_t(struct cxd2841er_priv *priv,
+				u32 *bit_error, u32 *bit_count)
+{
+	u8 data[2];
+	u32 period;
+
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x39, data);
+	if (!(data[0] & 0x01)) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no valid BER data\n", __func__);
+		return 0;
+	}
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x22, data, sizeof(data));
+	*bit_error = ((u32)data[0] << 8) | (u32)data[1];
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);
+	period = ((data[0] & 0x07) == 0) ? 256 : (4096 << (data[0] & 0x07));
+
+	/*
+	 * FIXME: the right thing would be to return bit_error untouched,
+	 * but, as we don't know the scale returned by the counters, let's
+	 * at least preserver BER = bit_error/bit_count.
+	 */
+	*bit_count = period / 128;
+	*bit_error *= 78125ULL;
+	return 0;
+}
+
+static u32 cxd2841er_dvbs_read_snr(struct cxd2841er_priv *priv,
+		u8 delsys, u32 *snr)
+{
+	u8 data[3];
+	u32 res = 0, value;
+	int min_index, max_index, index;
+	static const struct cxd2841er_cnr_data *cn_data;
+
+	/* Set SLV-T Bank : 0xA1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa1);
+	/*
+	 *  slave     Bank      Addr      Bit     Signal name
+	 * <SLV-T>    A1h       10h       [0]     ICPM_QUICKRDY
+	 * <SLV-T>    A1h       11h       [4:0]   ICPM_QUICKCNDT[12:8]
+	 * <SLV-T>    A1h       12h       [7:0]   ICPM_QUICKCNDT[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x10, data, 3);
+	if (data[0] & 0x01) {
+		value = ((u32)(data[1] & 0x1F) << 8) | (u32)(data[2] & 0xFF);
+		min_index = 0;
+		if (delsys == SYS_DVBS) {
+			cn_data = s_cn_data;
+			max_index = sizeof(s_cn_data) /
+				sizeof(s_cn_data[0]) - 1;
+		} else {
+			cn_data = s2_cn_data;
+			max_index = sizeof(s2_cn_data) /
+				sizeof(s2_cn_data[0]) - 1;
+		}
+		if (value >= cn_data[min_index].value) {
+			res = cn_data[min_index].cnr_x1000;
+			goto done;
+		}
+		if (value <= cn_data[max_index].value) {
+			res = cn_data[max_index].cnr_x1000;
+			goto done;
+		}
+		while ((max_index - min_index) > 1) {
+			index = (max_index + min_index) / 2;
+			if (value == cn_data[index].value) {
+				res = cn_data[index].cnr_x1000;
+				goto done;
+			} else if (value > cn_data[index].value)
+				max_index = index;
+			else
+				min_index = index;
+			if ((max_index - min_index) <= 1) {
+				if (value == cn_data[max_index].value) {
+					res = cn_data[max_index].cnr_x1000;
+					goto done;
+				} else {
+					res = cn_data[min_index].cnr_x1000;
+					goto done;
+				}
+			}
+		}
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no data available\n", __func__);
+		return -EINVAL;
+	}
+done:
+	*snr = res;
+	return 0;
+}
+
+static uint32_t sony_log(uint32_t x)
+{
+	return (((10000>>8)*(intlog2(x)>>16) + LOG2_E_100X/2)/LOG2_E_100X);
+}
+
+static int cxd2841er_read_snr_c(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+	enum sony_dvbc_constellation_t qam = SONY_DVBC_CONSTELLATION_16QAM;
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+
+	/*
+	 * Freeze registers: ensure multiple separate register reads
+	 * are from the same snapshot
+	 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x01);
+
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x19, data, 1);
+	qam = (enum sony_dvbc_constellation_t) (data[0] & 0x07);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4C, data, 2);
+
+	reg = ((u32)(data[0]&0x1f) << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+
+	switch (qam) {
+	case SONY_DVBC_CONSTELLATION_16QAM:
+	case SONY_DVBC_CONSTELLATION_64QAM:
+	case SONY_DVBC_CONSTELLATION_256QAM:
+		/* SNR(dB) = -9.50 * ln(IREG_SNR_ESTIMATE / (24320)) */
+		if (reg < 126)
+			reg = 126;
+		*snr = -95 * (int32_t)sony_log(reg) + 95941;
+		break;
+	case SONY_DVBC_CONSTELLATION_32QAM:
+	case SONY_DVBC_CONSTELLATION_128QAM:
+		/* SNR(dB) = -8.75 * ln(IREG_SNR_ESTIMATE / (20800)) */
+		if (reg < 69)
+			reg = 69;
+		*snr = -88 * (int32_t)sony_log(reg) + 86999;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cxd2841er_read_snr_t(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));
+	reg = ((u32)data[0] << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+	if (reg > 4996)
+		reg = 4996;
+	*snr = 10000 * ((intlog10(reg) - intlog10(5350 - reg)) >> 24) + 28500;
+	return 0;
+}
+
+static int cxd2841er_read_snr_t2(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));
+	reg = ((u32)data[0] << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+	if (reg > 10876)
+		reg = 10876;
+	*snr = 10000 * ((intlog10(reg) -
+		intlog10(12600 - reg)) >> 24) + 32000;
+	return 0;
+}
+
+static int cxd2841er_read_snr_i(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): invalid state %d\n", __func__,
+				priv->state);
+		return -EINVAL;
+	}
+
+	/* Freeze all registers */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x01);
+
+
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));
+	reg = ((u32)data[0] << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+	if (reg > 4996)
+		reg = 4996;
+	*snr = 100 * intlog10(reg) - 9031;
+	return 0;
+}
+
+static u16 cxd2841er_read_agc_gain_c(struct cxd2841er_priv *priv,
+					u8 delsys)
+{
+	u8 data[2];
+
+	cxd2841er_write_reg(
+		priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x49, data, 2);
+	dev_dbg(&priv->i2c->dev,
+			"%s(): AGC value=%u\n",
+			__func__, (((u16)data[0] & 0x0F) << 8) |
+			(u16)(data[1] & 0xFF));
+	return ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;
+}
+
+static u16 cxd2841er_read_agc_gain_t_t2(struct cxd2841er_priv *priv,
+					u8 delsys)
+{
+	u8 data[2];
+
+	cxd2841er_write_reg(
+		priv, I2C_SLVT, 0x00, (delsys == SYS_DVBT ? 0x10 : 0x20));
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);
+	dev_dbg(&priv->i2c->dev,
+			"%s(): AGC value=%u\n",
+			__func__, (((u16)data[0] & 0x0F) << 8) |
+			(u16)(data[1] & 0xFF));
+	return ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;
+}
+
+static u16 cxd2841er_read_agc_gain_i(struct cxd2841er_priv *priv,
+		u8 delsys)
+{
+	u8 data[2];
+
+	cxd2841er_write_reg(
+			priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);
+
+	dev_dbg(&priv->i2c->dev,
+			"%s(): AGC value=%u\n",
+			__func__, (((u16)data[0] & 0x0F) << 8) |
+			(u16)(data[1] & 0xFF));
+	return ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;
+}
+
+static u16 cxd2841er_read_agc_gain_s(struct cxd2841er_priv *priv)
+{
+	u8 data[2];
+
+	/* Set SLV-T Bank : 0xA0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	/*
+	 *  slave     Bank      Addr      Bit       Signal name
+	 * <SLV-T>    A0h       1Fh       [4:0]     IRFAGC_GAIN[12:8]
+	 * <SLV-T>    A0h       20h       [7:0]     IRFAGC_GAIN[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x1f, data, 2);
+	return ((((u16)data[0] & 0x1F) << 8) | (u16)(data[1] & 0xFF)) << 3;
+}
+
+static void cxd2841er_read_ber(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	u32 ret, bit_error = 0, bit_count = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		ret = cxd2841er_read_ber_c(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBS:
+		ret = cxd2841er_mon_read_ber_s(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBS2:
+		ret = cxd2841er_mon_read_ber_s2(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBT:
+		ret = cxd2841er_read_ber_t(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBT2:
+		ret = cxd2841er_read_ber_t2(priv, &bit_error, &bit_count);
+		break;
+	default:
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+
+	if (!ret) {
+		p->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_error.stat[0].uvalue += bit_error;
+		p->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_count.stat[0].uvalue += bit_count;
+	} else {
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+}
+
+static void cxd2841er_read_signal_strength(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	s32 strength;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		strength = cxd2841er_read_agc_gain_t_t2(priv,
+							p->delivery_system);
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		/* Formula was empirically determinated @ 410 MHz */
+		p->strength.stat[0].uvalue = strength * 366 / 100 - 89520;
+		break;	/* Code moved out of the function */
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		strength = cxd2841er_read_agc_gain_c(priv,
+							p->delivery_system);
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		/*
+		 * Formula was empirically determinated via linear regression,
+		 * using frequencies: 175 MHz, 410 MHz and 800 MHz, and a
+		 * stream modulated with QAM64
+		 */
+		p->strength.stat[0].uvalue = strength * 4045 / 1000 - 85224;
+		break;
+	case SYS_ISDBT:
+		strength = cxd2841er_read_agc_gain_i(priv, p->delivery_system);
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		/*
+		 * Formula was empirically determinated via linear regression,
+		 * using frequencies: 175 MHz, 410 MHz and 800 MHz.
+		 */
+		p->strength.stat[0].uvalue = strength * 3775 / 1000 - 90185;
+		break;
+	case SYS_DVBS:
+	case SYS_DVBS2:
+		strength = 65535 - cxd2841er_read_agc_gain_s(priv);
+		p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+		p->strength.stat[0].uvalue = strength;
+		break;
+	default:
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	}
+}
+
+static void cxd2841er_read_snr(struct dvb_frontend *fe)
+{
+	u32 tmp = 0;
+	int ret = 0;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		ret = cxd2841er_read_snr_c(priv, &tmp);
+		break;
+	case SYS_DVBT:
+		ret = cxd2841er_read_snr_t(priv, &tmp);
+		break;
+	case SYS_DVBT2:
+		ret = cxd2841er_read_snr_t2(priv, &tmp);
+		break;
+	case SYS_ISDBT:
+		ret = cxd2841er_read_snr_i(priv, &tmp);
+		break;
+	case SYS_DVBS:
+	case SYS_DVBS2:
+		ret = cxd2841er_dvbs_read_snr(priv, p->delivery_system, &tmp);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): unknown delivery system %d\n",
+			__func__, p->delivery_system);
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+
+	if (!ret) {
+		p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		p->cnr.stat[0].svalue = tmp;
+	} else {
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+}
+
+static void cxd2841er_read_ucblocks(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	u32 ucblocks;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		cxd2841er_read_packet_errors_c(priv, &ucblocks);
+		break;
+	case SYS_DVBT:
+		cxd2841er_read_packet_errors_t(priv, &ucblocks);
+		break;
+	case SYS_DVBT2:
+		cxd2841er_read_packet_errors_t2(priv, &ucblocks);
+		break;
+	case SYS_ISDBT:
+		cxd2841er_read_packet_errors_i(priv, &ucblocks);
+		break;
+	default:
+		p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+
+	p->block_error.stat[0].scale = FE_SCALE_COUNTER;
+	p->block_error.stat[0].uvalue = ucblocks;
+}
+
+static int cxd2841er_dvbt2_set_profile(
+	struct cxd2841er_priv *priv, enum cxd2841er_dvbt2_profile_t profile)
+{
+	u8 tune_mode;
+	u8 seq_not2d_time;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (profile) {
+	case DVBT2_PROFILE_BASE:
+		tune_mode = 0x01;
+		/* Set early unlock time */
+		seq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x0E:0x0C;
+		break;
+	case DVBT2_PROFILE_LITE:
+		tune_mode = 0x05;
+		/* Set early unlock time */
+		seq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;
+		break;
+	case DVBT2_PROFILE_ANY:
+		tune_mode = 0x00;
+		/* Set early unlock time */
+		seq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;
+		break;
+	default:
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x2E */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2e);
+	/* Set profile and tune mode */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x10, tune_mode, 0x07);
+	/* Set SLV-T Bank : 0x2B */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	/* Set early unlock detection time */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9d, seq_not2d_time);
+	return 0;
+}
+
+static int cxd2841er_dvbt2_set_plp_config(struct cxd2841er_priv *priv,
+					  u8 is_auto, u8 plp_id)
+{
+	if (is_auto) {
+		dev_dbg(&priv->i2c->dev,
+			"%s() using auto PLP selection\n", __func__);
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s() using manual PLP selection, ID %d\n",
+			__func__, plp_id);
+	}
+	/* Set SLV-T Bank : 0x23 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);
+	if (!is_auto) {
+		/* Manual PLP selection mode. Set the data PLP Id. */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xaf, plp_id);
+	}
+	/* Auto PLP select (Scanning mode = 0x00). Data PLP select = 0x01. */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xad, (is_auto ? 0x00 : 0x01));
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,
+						u32 bandwidth)
+{
+	u32 iffreq;
+	u8 data[MAX_WRITE_REGSIZE];
+
+	const uint8_t nominalRate8bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x15, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate7bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x14, 0x80, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x18, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x14, 0x80, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate6bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}, /* 20.5MHz XTal */
+		{0x1C, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate5bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}, /* 20.5MHz XTal */
+		{0x21, 0x99, 0x99, 0x99, 0x99}, /* 24MHz XTal */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate17bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x58, 0xE2, 0xAF, 0xE0, 0xBC}, /* 20.5MHz XTal */
+		{0x68, 0x0F, 0xA2, 0x32, 0xD0}, /* 24MHz XTal */
+		{0x58, 0xE2, 0xAF, 0xE0, 0xBC}  /* 41MHz XTal */
+	};
+
+	const uint8_t itbCoef8bw[3][14] = {
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,
+			0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8}, /* 20.5MHz XTal */
+		{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1,
+			0x29, 0xA5, 0x2A, 0xAC, 0x29, 0xB5}, /* 24MHz XTal   */
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,
+			0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef7bw[3][14] = {
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,
+			0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5}, /* 20.5MHz XTal */
+		{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0,
+			0x29, 0xA2, 0x2B, 0xA6, 0x2B, 0xAD}, /* 24MHz XTal   */
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,
+			0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef6bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,
+			0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef5bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,
+			0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef17bw[3][14] = {
+		{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,
+			0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99}, /* 20.5MHz XTal */
+		{0x33, 0x8E, 0x2B, 0x97, 0x2D, 0x95, 0x37, 0x8B,
+			0x30, 0x97, 0x2D, 0x9A, 0x21, 0xA4}, /* 24MHz XTal   */
+		{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,
+			0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99}  /* 41MHz XTal   */
+	};
+
+	/* Set SLV-T Bank : 0x20 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+
+	switch (bandwidth) {
+	case 8000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate8bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef8bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.80);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x00, 0x07);
+		break;
+	case 7000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate7bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef7bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.20);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x02, 0x07);
+		break;
+	case 6000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate6bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef6bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x04, 0x07);
+		break;
+	case 5000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate5bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef5bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x06, 0x07);
+		break;
+	case 1712000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate17bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x03, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef17bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.50);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x03, 0x07);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t_band(
+		struct cxd2841er_priv *priv, u32 bandwidth)
+{
+	u8 data[MAX_WRITE_REGSIZE];
+	u32 iffreq;
+	u8 nominalRate8bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x15, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+	u8 nominalRate7bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x14, 0x80, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x18, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x14, 0x80, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+	u8 nominalRate6bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}, /* 20.5MHz XTal */
+		{0x1C, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}  /* 41MHz XTal */
+	};
+	u8 nominalRate5bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}, /* 20.5MHz XTal */
+		{0x21, 0x99, 0x99, 0x99, 0x99}, /* 24MHz XTal */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}  /* 41MHz XTal */
+	};
+
+	u8 itbCoef8bw[3][14] = {
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,
+			0x1F, 0xA8, 0x2C, 0xC8}, /* 20.5MHz XTal */
+		{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29, 0xA5,
+			0x2A, 0xAC, 0x29, 0xB5}, /* 24MHz XTal   */
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,
+			0x1F, 0xA8, 0x2C, 0xC8}  /* 41MHz XTal   */
+	};
+	u8 itbCoef7bw[3][14] = {
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,
+			0x26, 0xA9, 0x21, 0xA5}, /* 20.5MHz XTal */
+		{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29, 0xA2,
+			0x2B, 0xA6, 0x2B, 0xAD}, /* 24MHz XTal   */
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,
+			0x26, 0xA9, 0x21, 0xA5}  /* 41MHz XTal   */
+	};
+	u8 itbCoef6bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,
+			0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+	u8 itbCoef5bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,
+			0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+
+	/* Set SLV-T Bank : 0x13 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);
+	/* Echo performance optimization setting */
+	data[0] = 0x01;
+	data[1] = 0x14;
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x9C, data, 2);
+
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+	switch (bandwidth) {
+	case 8000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate8bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef8bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.80);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x00, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x15;
+			data[1] = 0x28;
+		} else {
+			data[0] = 0x01;
+			data[1] = 0xE0;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x01;
+		data[1] = 0x02;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	case 7000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate7bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef7bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.20);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x02, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x1F;
+			data[1] = 0xF8;
+		} else {
+			data[0] = 0x12;
+			data[1] = 0xF8;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x00;
+		data[1] = 0x03;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	case 6000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate6bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef6bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x04, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x25;
+			data[1] = 0x4C;
+		} else {
+			data[0] = 0x1F;
+			data[1] = 0xDC;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x00;
+		data[1] = 0x03;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	case 5000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate5bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef5bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x06, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x2C;
+			data[1] = 0xC2;
+		} else {
+			data[0] = 0x26;
+			data[1] = 0x3C;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x00;
+		data[1] = 0x03;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	}
+
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_i_band(
+		struct cxd2841er_priv *priv, u32 bandwidth)
+{
+	u32 iffreq;
+	u8 data[3];
+
+	/* TRCG Nominal Rate */
+	u8 nominalRate8bw[3][5] = {
+		{0x00, 0x00, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x11, 0xB8, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x00, 0x00, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	u8 nominalRate7bw[3][5] = {
+		{0x00, 0x00, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x14, 0x40, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x00, 0x00, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	u8 nominalRate6bw[3][5] = {
+		{0x14, 0x2E, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x17, 0xA0, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x14, 0x2E, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	u8 itbCoef8bw[3][14] = {
+		{0x00}, /* 20.5MHz XTal */
+		{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29,
+			0xA5, 0x2A, 0xAC, 0x29, 0xB5}, /* 24MHz Xtal */
+		{0x0}, /* 41MHz XTal   */
+	};
+
+	u8 itbCoef7bw[3][14] = {
+		{0x00}, /* 20.5MHz XTal */
+		{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29,
+			0xA2, 0x2B, 0xA6, 0x2B, 0xAD}, /* 24MHz Xtal */
+		{0x00}, /* 41MHz XTal   */
+	};
+
+	u8 itbCoef6bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,
+			0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29,
+			0xA4, 0x29, 0xA2, 0x29, 0xA8}, /* 24MHz Xtal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,
+			0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 41MHz XTal   */
+	};
+
+	dev_dbg(&priv->i2c->dev, "%s() bandwidth=%u\n", __func__, bandwidth);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+	/*  20.5/41MHz Xtal support is not available
+	 *  on ISDB-T 7MHzBW and 8MHzBW
+	*/
+	if (priv->xtal != SONY_XTAL_24000 && bandwidth > 6000000) {
+		dev_err(&priv->i2c->dev,
+			"%s(): bandwidth %d supported only for 24MHz xtal\n",
+			__func__, bandwidth);
+		return -EINVAL;
+	}
+
+	switch (bandwidth) {
+	case 8000000:
+		/* TRCG Nominal Rate */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate8bw[priv->xtal], 5);
+		/*  Group delay equaliser settings for ASCOT tuners optimized */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef8bw[priv->xtal], 14);
+
+		/* IF freq setting */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.75);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x0, 0x7);
+
+		/* Demod core latency setting */
+		data[0] = 0x13;
+		data[1] = 0xFC;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Acquisition optimization setting */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x03);
+		break;
+	case 7000000:
+		/* TRCG Nominal Rate */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate7bw[priv->xtal], 5);
+		/*  Group delay equaliser settings for ASCOT tuners optimized */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef7bw[priv->xtal], 14);
+
+		/* IF freq setting */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.15);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x02, 0x7);
+
+		/* Demod core latency setting */
+		data[0] = 0x1A;
+		data[1] = 0xFA;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Acquisition optimization setting */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);
+		break;
+	case 6000000:
+		/* TRCG Nominal Rate */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate6bw[priv->xtal], 5);
+		/*  Group delay equaliser settings for ASCOT tuners optimized */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef6bw[priv->xtal], 14);
+
+		/* IF freq setting */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.55);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x04, 0x7);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x1F;
+			data[1] = 0x79;
+		} else {
+			data[0] = 0x1A;
+			data[1] = 0xE2;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Acquisition optimization setting */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x07, 0x07);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",
+				__func__, bandwidth);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,
+					       u32 bandwidth)
+{
+	u8 bw7_8mhz_b10_a6[] = {
+		0x2D, 0xC7, 0x04, 0xF4, 0x07, 0xC5, 0x2A, 0xB8,
+		0x27, 0x9E, 0x27, 0xA4, 0x29, 0xAB };
+	u8 bw6mhz_b10_a6[] = {
+		0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+		0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4 };
+	u8 b10_b6[3];
+	u32 iffreq;
+
+	dev_dbg(&priv->i2c->dev, "%s() bw=%d\n", __func__, bandwidth);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	switch (bandwidth) {
+	case 8000000:
+	case 7000000:
+		cxd2841er_write_regs(
+			priv, I2C_SLVT, 0xa6,
+			bw7_8mhz_b10_a6, sizeof(bw7_8mhz_b10_a6));
+		iffreq = MAKE_IFFREQ_CONFIG(4.9);
+		break;
+	case 6000000:
+		cxd2841er_write_regs(
+			priv, I2C_SLVT, 0xa6,
+			bw6mhz_b10_a6, sizeof(bw6mhz_b10_a6));
+		iffreq = MAKE_IFFREQ_CONFIG(3.7);
+		break;
+	default:
+		dev_err(&priv->i2c->dev, "%s(): unsupported bandwidth %d\n",
+			__func__, bandwidth);
+		return -EINVAL;
+	}
+	/* <IF freq setting> */
+	b10_b6[0] = (u8) ((iffreq >> 16) & 0xff);
+	b10_b6[1] = (u8)((iffreq >> 8) & 0xff);
+	b10_b6[2] = (u8)(iffreq & 0xff);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xb6, b10_b6, sizeof(b10_b6));
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	switch (bandwidth) {
+	case 8000000:
+	case 7000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xa3, 0x00, 0x1f);
+		break;
+	case 6000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xa3, 0x14, 0x1f);
+		break;
+	}
+	/* Set SLV-T Bank : 0x40 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	switch (bandwidth) {
+	case 8000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0x26, 0x0b, 0x0f);
+		cxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0x3e);
+		break;
+	case 7000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0x26, 0x09, 0x0f);
+		cxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0xd6);
+		break;
+	case 6000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0x26, 0x08, 0x0f);
+		cxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0x6e);
+		break;
+	}
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t(struct cxd2841er_priv *priv,
+					  u32 bandwidth)
+{
+	u8 data[2] = { 0x09, 0x54 };
+	u8 data24m[3] = {0xDC, 0x6C, 0x00};
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBT);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+	/* Enable ADC 2 & 3 */
+	if (priv->xtal == SONY_XTAL_41000) {
+		data[0] = 0x0A;
+		data[1] = 0xD4;
+	}
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* IFAGC gain settings */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	/* BBAGC TARGET level setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x18 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);
+	/* Pre-RS BER moniter setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x36, 0x40, 0x07);
+	/* FEC Auto Recovery setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TSIF setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);
+
+	if (priv->xtal == SONY_XTAL_24000) {
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBF, 0x60);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x24, data24m, 3);
+	}
+
+	cxd2841er_sleep_tc_to_active_t_band(priv, bandwidth);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t2(struct cxd2841er_priv *priv,
+					   u32 bandwidth)
+{
+	u8 data[MAX_WRITE_REGSIZE];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBT2);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x02);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x00);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+
+	if (priv->xtal == SONY_XTAL_41000) {
+		data[0] = 0x0A;
+		data[1] = 0xD4;
+	} else {
+		data[0] = 0x09;
+		data[1] = 0x54;
+	}
+
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* IFAGC gain settings */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	/* BBAGC TARGET level setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x20 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	/* Acquisition optimization setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x8b, 0x3c);
+	/* Set SLV-T Bank : 0x2b */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x76, 0x20, 0x70);
+	/* Set SLV-T Bank : 0x23 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);
+	/* L1 Control setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE6, 0x00, 0x03);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TSIF setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);
+	/* DVB-T2 initial setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x10);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x34);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xd8);
+	/* Set SLV-T Bank : 0x2a */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x04, 0x0f);
+	/* Set SLV-T Bank : 0x2b */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x20, 0x3f);
+
+	/* 24MHz Xtal setting */
+	if (priv->xtal == SONY_XTAL_24000) {
+		/* Set SLV-T Bank : 0x11 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+		data[0] = 0xEB;
+		data[1] = 0x03;
+		data[2] = 0x3B;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x33, data, 3);
+
+		/* Set SLV-T Bank : 0x20 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+		data[0] = 0x5E;
+		data[1] = 0x5E;
+		data[2] = 0x47;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x95, data, 3);
+
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x99, 0x18);
+
+		data[0] = 0x3F;
+		data[1] = 0xFF;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Set SLV-T Bank : 0x24 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);
+		data[0] = 0x0B;
+		data[1] = 0x72;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x34, data, 2);
+
+		data[0] = 0x93;
+		data[1] = 0xF3;
+		data[2] = 0x00;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD2, data, 3);
+
+		data[0] = 0x05;
+		data[1] = 0xB8;
+		data[2] = 0xD8;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xDD, data, 3);
+
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xE0, 0x00);
+
+		/* Set SLV-T Bank : 0x25 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x25);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xED, 0x60);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xFA, 0x34);
+
+		/* Set SLV-T Bank : 0x2B */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2B);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x4B, 0x2F);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x9E, 0x0E);
+
+		/* Set SLV-T Bank : 0x2D */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2D);
+		data[0] = 0x89;
+		data[1] = 0x89;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x24, data, 2);
+
+		/* Set SLV-T Bank : 0x5E */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x5E);
+		data[0] = 0x24;
+		data[1] = 0x95;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x8C, data, 2);
+	}
+
+	cxd2841er_sleep_tc_to_active_t2_band(priv, bandwidth);
+
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+/* ISDB-Tb part */
+static int cxd2841er_sleep_tc_to_active_i(struct cxd2841er_priv *priv,
+		u32 bandwidth)
+{
+	u8 data[2] = { 0x09, 0x54 };
+	u8 data24m[2] = {0x60, 0x00};
+	u8 data24m2[3] = {0xB7, 0x1B, 0x00};
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBT);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x06);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Enable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x01);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x01);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+	/* xtal freq 20.5MHz or 24M */
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* FEC Auto Recovery setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x00, 0x01);
+	/* ISDB-T initial setting */
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x00, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x00, 0x01);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x69, 0x04, 0x07);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x6B, 0x03, 0x07);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9D, 0x50, 0xFF);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xD3, 0x06, 0x1F);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xED, 0x00, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE2, 0xCE, 0x80);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xF2, 0x13, 0x10);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x2E, 0x3F);
+	/* Set SLV-T Bank : 0x15 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x02, 0x03);
+	/* Set SLV-T Bank : 0x1E */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x1E);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x73, 0x68, 0xFF);
+	/* Set SLV-T Bank : 0x63 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x63);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x81, 0x00, 0x01);
+
+	/* for xtal 24MHz */
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xBF, data24m, 2);
+	/* Set SLV-T Bank : 0x60 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xA8, data24m2, 3);
+
+	cxd2841er_sleep_tc_to_active_i_band(priv, bandwidth);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_c(struct cxd2841er_priv *priv,
+					  u32 bandwidth)
+{
+	u8 data[2] = { 0x09, 0x54 };
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBC_ANNEX_A);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x04);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+	/* xtal freq 20.5MHz */
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* IFAGC gain settings */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x09, 0x1f);
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	/* BBAGC TARGET level setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x48);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x40 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	/* Demod setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc3, 0x00, 0x04);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TSIF setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);
+
+	cxd2841er_sleep_tc_to_active_c_band(priv, bandwidth);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+static int cxd2841er_get_frontend(struct dvb_frontend *fe)
+{
+	enum fe_status status = 0;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state == STATE_ACTIVE_S)
+		cxd2841er_read_status_s(fe, &status);
+	else if (priv->state == STATE_ACTIVE_TC)
+		cxd2841er_read_status_tc(fe, &status);
+
+	cxd2841er_read_signal_strength(fe);
+
+	if (status & FE_HAS_LOCK) {
+		cxd2841er_read_snr(fe);
+		cxd2841er_read_ucblocks(fe);
+
+		cxd2841er_read_ber(fe);
+	} else {
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+	return 0;
+}
+
+static int cxd2841er_set_frontend_s(struct dvb_frontend *fe)
+{
+	int ret = 0, i, timeout, carr_offset;
+	enum fe_status status;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 symbol_rate = p->symbol_rate/1000;
+
+	dev_dbg(&priv->i2c->dev, "%s(): %s frequency=%d symbol_rate=%d xtal=%d\n",
+		__func__,
+		(p->delivery_system == SYS_DVBS ? "DVB-S" : "DVB-S2"),
+		 p->frequency, symbol_rate, priv->xtal);
+	switch (priv->state) {
+	case STATE_SLEEP_S:
+		ret = cxd2841er_sleep_s_to_active_s(
+			priv, p->delivery_system, symbol_rate);
+		break;
+	case STATE_ACTIVE_S:
+		ret = cxd2841er_retune_active(priv, p);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		ret = -EINVAL;
+		goto done;
+	}
+	if (ret) {
+		dev_dbg(&priv->i2c->dev, "%s(): tune failed\n", __func__);
+		goto done;
+	}
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	cxd2841er_tune_done(priv);
+	timeout = ((3000000 + (symbol_rate - 1)) / symbol_rate) + 150;
+	for (i = 0; i < timeout / CXD2841ER_DVBS_POLLING_INVL; i++) {
+		usleep_range(CXD2841ER_DVBS_POLLING_INVL*1000,
+			(CXD2841ER_DVBS_POLLING_INVL + 2) * 1000);
+		cxd2841er_read_status_s(fe, &status);
+		if (status & FE_HAS_LOCK)
+			break;
+	}
+	if (status & FE_HAS_LOCK) {
+		if (cxd2841er_get_carrier_offset_s_s2(
+				priv, &carr_offset)) {
+			ret = -EINVAL;
+			goto done;
+		}
+		dev_dbg(&priv->i2c->dev, "%s(): carrier_offset=%d\n",
+			__func__, carr_offset);
+	}
+done:
+	/* Reset stats */
+	p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+	p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+	return ret;
+}
+
+static int cxd2841er_set_frontend_tc(struct dvb_frontend *fe)
+{
+	int ret = 0, timeout;
+	enum fe_status status;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	
+	dev_dbg(&priv->i2c->dev, "%s() delivery_system=%d bandwidth_hz=%d\n",
+		 __func__, p->delivery_system, p->bandwidth_hz);
+		 
+	
+	cxd2841er_active_t_to_sleep_tc(priv);
+	cxd2841er_sleep_tc_to_shutdown(priv);
+	cxd2841er_init_tc(fe);
+	
+	if (p->delivery_system == SYS_DVBT) {
+		priv->system = SYS_DVBT;
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_t(
+				priv, p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else if (p->delivery_system == SYS_DVBT2) {
+		priv->system = SYS_DVBT2;
+		cxd2841er_dvbt2_set_plp_config(priv,
+			(int)(p->stream_id > 255), p->stream_id);
+		cxd2841er_dvbt2_set_profile(priv, DVBT2_PROFILE_BASE);
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_t2(priv,
+				p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else if (p->delivery_system == SYS_ISDBT) {
+		priv->system = SYS_ISDBT;
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_i(
+					priv, p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+					__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else if (p->delivery_system == SYS_DVBC_ANNEX_A ||
+			p->delivery_system == SYS_DVBC_ANNEX_C) {
+		priv->system = SYS_DVBC_ANNEX_A;
+		/* correct bandwidth */
+		if (p->bandwidth_hz != 6000000 &&
+				p->bandwidth_hz != 7000000 &&
+				p->bandwidth_hz != 8000000) {
+			p->bandwidth_hz = 8000000;
+			dev_dbg(&priv->i2c->dev, "%s(): forcing bandwidth to %d\n",
+					__func__, p->bandwidth_hz);
+		}
+
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_c(
+				priv, p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid delivery system %d\n",
+			__func__, p->delivery_system);
+		ret = -EINVAL;
+	}
+	if (ret)
+		goto done;
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	cxd2841er_tune_done(priv);
+	timeout = 2500;
+	while (timeout > 0) {
+		ret = cxd2841er_read_status_tc(fe, &status);
+		if (ret)
+			goto done;
+		if (status & FE_HAS_LOCK)
+			break;
+		msleep(20);
+		timeout -= 20;
+	}
+	if (timeout < 0)
+		dev_dbg(&priv->i2c->dev,
+			"%s(): LOCK wait timeout\n", __func__);
+done:
+	return ret;
+}
+
+static int cxd2841er_tune_s(struct dvb_frontend *fe,
+			    bool re_tune,
+			    unsigned int mode_flags,
+			    unsigned int *delay,
+			    enum fe_status *status)
+{
+	int ret, carrier_offset;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s() re_tune=%d\n", __func__, re_tune);
+	if (re_tune) {
+		ret = cxd2841er_set_frontend_s(fe);
+		if (ret)
+			return ret;
+		cxd2841er_read_status_s(fe, status);
+		if (*status & FE_HAS_LOCK) {
+			if (cxd2841er_get_carrier_offset_s_s2(
+					priv, &carrier_offset))
+				return -EINVAL;
+			p->frequency += carrier_offset;
+			ret = cxd2841er_set_frontend_s(fe);
+			if (ret)
+				return ret;
+		}
+	}
+	*delay = HZ / 5;
+	return cxd2841er_read_status_s(fe, status);
+}
+
+static int cxd2841er_tune_tc(struct dvb_frontend *fe,
+			     bool re_tune,
+			     unsigned int mode_flags,
+			     unsigned int *delay,
+			     enum fe_status *status)
+{
+	int ret, carrier_offset;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s(): re_tune %d bandwidth=%d\n", __func__,
+			re_tune, p->bandwidth_hz);
+	if (re_tune) {
+		ret = cxd2841er_set_frontend_tc(fe);
+		if (ret)
+			return ret;
+		cxd2841er_read_status_tc(fe, status);
+		if (*status & FE_HAS_LOCK) {
+			switch (priv->system) {
+			case SYS_ISDBT:
+				ret = cxd2841er_get_carrier_offset_i(
+						priv, p->bandwidth_hz,
+						&carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			case SYS_DVBT:
+				ret = cxd2841er_get_carrier_offset_t(
+					priv, p->bandwidth_hz,
+					&carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			case SYS_DVBT2:
+				ret = cxd2841er_get_carrier_offset_t2(
+					priv, p->bandwidth_hz,
+					&carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			case SYS_DVBC_ANNEX_A:
+				ret = cxd2841er_get_carrier_offset_c(
+					priv, &carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			default:
+				dev_dbg(&priv->i2c->dev,
+					"%s(): invalid delivery system %d\n",
+					__func__, priv->system);
+				return -EINVAL;
+			}
+			dev_dbg(&priv->i2c->dev, "%s(): carrier offset %d\n",
+				__func__, carrier_offset);
+			p->frequency += carrier_offset;
+			ret = cxd2841er_set_frontend_tc(fe);
+			if (ret)
+				return ret;
+		}
+	}
+	*delay = HZ / 5;
+	return cxd2841er_read_status_tc(fe, status);
+}
+
+static int cxd2841er_sleep_s(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_active_s_to_sleep_s(fe->demodulator_priv);
+	cxd2841er_sleep_s_to_shutdown(fe->demodulator_priv);
+	return 0;
+}
+
+static int cxd2841er_sleep_tc(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state == STATE_ACTIVE_TC) {
+		switch (priv->system) {
+		case SYS_DVBT:
+			cxd2841er_active_t_to_sleep_tc(priv);
+			break;
+		case SYS_DVBT2:
+			cxd2841er_active_t2_to_sleep_tc(priv);
+			break;
+		case SYS_ISDBT:
+			cxd2841er_active_i_to_sleep_tc(priv);
+			break;
+		case SYS_DVBC_ANNEX_A:
+			cxd2841er_active_c_to_sleep_tc(priv);
+			break;
+		default:
+			dev_warn(&priv->i2c->dev,
+				"%s(): unknown delivery system %d\n",
+				__func__, priv->system);
+		}
+	}
+	if (priv->state != STATE_SLEEP_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_sleep_tc_to_shutdown(priv);
+	return 0;
+}
+
+static int cxd2841er_send_burst(struct dvb_frontend *fe,
+				enum fe_sec_mini_cmd burst)
+{
+	u8 data;
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): burst mode %s\n", __func__,
+		(burst == SEC_MINI_A ? "A" : "B"));
+	if (priv->state != STATE_SLEEP_S &&
+			priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	data = (burst == SEC_MINI_A ? 0 : 1);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x34, 0x01);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x35, data);
+	return 0;
+}
+
+static int cxd2841er_set_tone(struct dvb_frontend *fe,
+			      enum fe_sec_tone_mode tone)
+{
+	u8 data;
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): tone %s\n", __func__,
+		(tone == SEC_TONE_ON ? "On" : "Off"));
+	if (priv->state != STATE_SLEEP_S &&
+			priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	data = (tone == SEC_TONE_ON ? 1 : 0);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x36, data);
+	return 0;
+}
+
+static int cxd2841er_send_diseqc_msg(struct dvb_frontend *fe,
+				     struct dvb_diseqc_master_cmd *cmd)
+{
+	int i;
+	u8 data[12];
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	if (priv->state != STATE_SLEEP_S &&
+			priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	dev_dbg(&priv->i2c->dev,
+		"%s(): cmd->len %d\n", __func__, cmd->msg_len);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);
+	/* DiDEqC enable */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x33, 0x01);
+	/* cmd1 length & data */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x3d, cmd->msg_len);
+	memset(data, 0, sizeof(data));
+	for (i = 0; i < cmd->msg_len && i < sizeof(data); i++)
+		data[i] = cmd->msg[i];
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x3e, data, sizeof(data));
+	/* repeat count for cmd1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x37, 1);
+	/* repeat count for cmd2: always 0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x38, 0);
+	/* start transmit */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x32, 0x01);
+	/* wait for 1 sec timeout */
+	for (i = 0; i < 50; i++) {
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x10, data);
+		if (!data[0]) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): DiSEqC cmd has been sent\n", __func__);
+			return 0;
+		}
+		msleep(20);
+	}
+	dev_dbg(&priv->i2c->dev,
+		"%s(): DiSEqC cmd transmit timeout\n", __func__);
+	return -ETIMEDOUT;
+}
+
+static void cxd2841er_release(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	kfree(priv);
+}
+
+static int cxd2841er_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): enable=%d\n", __func__, enable);
+	cxd2841er_set_reg_bits(
+		priv, I2C_SLVX, 0x8, (enable ? 0x01 : 0x00), 0x01);
+	return 0;
+}
+
+static enum dvbfe_algo cxd2841er_get_algo(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	return DVBFE_ALGO_HW;
+}
+
+static void cxd2841er_init_stats(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	p->strength.len = 1;
+	p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+	p->cnr.len = 1;
+	p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_error.len = 1;
+	p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_error.len = 1;
+	p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_count.len = 1;
+	p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+}
+
+
+static int cxd2841er_init_s(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	/* sanity. force demod to SHUTDOWN state */
+	if (priv->state == STATE_SLEEP_S) {
+		dev_dbg(&priv->i2c->dev, "%s() forcing sleep->shutdown\n",
+				__func__);
+		cxd2841er_sleep_s_to_shutdown(priv);
+	} else if (priv->state == STATE_ACTIVE_S) {
+		dev_dbg(&priv->i2c->dev, "%s() forcing active->sleep->shutdown\n",
+				__func__);
+		cxd2841er_active_s_to_sleep_s(priv);
+		cxd2841er_sleep_s_to_shutdown(priv);
+	}
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_shutdown_to_sleep_s(priv);
+	/* SONY_DEMOD_CONFIG_SAT_IFAGCNEG set to 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xb9, 0x01, 0x01);
+
+	cxd2841er_init_stats(fe);
+
+	return 0;
+}
+
+static int cxd2841er_init_tc(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s() bandwidth_hz=%d\n",
+			__func__, p->bandwidth_hz);
+	cxd2841er_shutdown_to_sleep_tc(priv);
+	/* SONY_DEMOD_CONFIG_IFAGCNEG = 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcb, 
+						priv->config->if_agc ? 0x40 : 0x00, 0x40);
+	/* SONY_DEMOD_CONFIG_IFAGC_ADC_FS = 0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xcd, 
+						priv->config->ifagc_adc_range);
+	/* SONY_DEMOD_CONFIG_PARALLEL_SEL = 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xCB, 
+					priv->config->ts_error_polarity ? 0x00 : 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xC5, 
+					priv->config->clock_polarity ? 0x01 : 0x00, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc4, 0x00, 0x80);
+
+	cxd2841er_init_stats(fe);
+
+	return 0;
+}
+
+static struct dvb_frontend_ops cxd2841er_dvbs_s2_ops;
+static struct dvb_frontend_ops cxd2841er_t_c_ops;
+
+static struct dvb_frontend *cxd2841er_attach(struct cxd2841er_config *cfg,
+					     struct i2c_adapter *i2c,
+					     u8 system)
+{
+	u8 chip_id = 0;
+	const char *type;
+	const char *name;
+	struct cxd2841er_priv *priv = NULL;
+
+	/* allocate memory for the internal state */
+	priv = kzalloc(sizeof(struct cxd2841er_priv), GFP_KERNEL);
+	if (!priv)
+		return NULL;
+	priv->i2c = i2c;
+	priv->config = cfg;
+	priv->i2c_addr_slvx = cfg->i2c_addr + 2;
+	priv->i2c_addr_slvt = cfg->i2c_addr;
+	priv->xtal = cfg->xtal;
+	priv->frontend.demodulator_priv = priv;
+	dev_info(&priv->i2c->dev,
+		"%s(): I2C adapter %p SLVX addr %x SLVT addr %x\n",
+		__func__, priv->i2c,
+		priv->i2c_addr_slvx, priv->i2c_addr_slvt);
+	chip_id = cxd2841er_chip_id(priv);
+	switch (chip_id) {
+	case CXD2837ER_CHIP_ID:
+		snprintf(cxd2841er_t_c_ops.info.name, 128,
+				"Sony CXD2837ER DVB-T/T2/C demodulator");
+		name = "CXD2837ER";
+		break;
+	case CXD2841ER_CHIP_ID:
+		snprintf(cxd2841er_t_c_ops.info.name, 128,
+				"Sony CXD2841ER DVB-T/T2/C demodulator");
+		name = "CXD2841ER";
+		break;
+	case CXD2854ER_CHIP_ID:
+		snprintf(cxd2841er_t_c_ops.info.name, 128,
+				"Sony CXD2854ER DVB-T/T2/C and ISDB-T demodulator");
+		cxd2841er_t_c_ops.delsys[3] = SYS_ISDBT;
+		name = "CXD2854ER";
+		break;
+	default:
+		dev_err(&priv->i2c->dev, "%s(): invalid chip ID 0x%02x\n",
+				__func__, chip_id);
+		priv->frontend.demodulator_priv = NULL;
+		kfree(priv);
+		return NULL;
+	}
+
+	/* create dvb_frontend */
+	if (system == SYS_DVBS) {
+		memcpy(&priv->frontend.ops,
+			&cxd2841er_dvbs_s2_ops,
+			sizeof(struct dvb_frontend_ops));
+		type = "S/S2";
+	} else {
+		memcpy(&priv->frontend.ops,
+			&cxd2841er_t_c_ops,
+			sizeof(struct dvb_frontend_ops));
+		type = "T/T2/C/ISDB-T";
+	}
+
+	dev_info(&priv->i2c->dev,
+		"%s(): attaching %s DVB-%s frontend\n",
+		__func__, name, type);
+	dev_info(&priv->i2c->dev, "%s(): chip ID 0x%02x OK.\n",
+		__func__, chip_id);
+	return &priv->frontend;
+}
+
+struct dvb_frontend *cxd2841er_attach_s(struct cxd2841er_config *cfg,
+					struct i2c_adapter *i2c)
+{
+	return cxd2841er_attach(cfg, i2c, SYS_DVBS);
+}
+//EXPORT_SYMBOL(cxd2841er_attach_s);
+
+struct dvb_frontend *cxd2841er_attach_wetek(struct cxd2841er_config *cfg,
+					struct i2c_adapter *i2c)
+{
+	return cxd2841er_attach(cfg, i2c, 0);
+}
+EXPORT_SYMBOL(cxd2841er_attach_wetek);
+
+static struct dvb_frontend_ops cxd2841er_dvbs_s2_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 },
+	.info = {
+		.name		= "Sony CXD2841ER DVB-S/S2 demodulator",
+		.frequency_min	= 500000,
+		.frequency_max	= 2500000,
+		.frequency_stepsize	= 0,
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.symbol_rate_tolerance = 500,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK,
+	},
+	.init = cxd2841er_init_s,
+	.sleep = cxd2841er_sleep_s,
+	.release = cxd2841er_release,
+	.set_frontend = cxd2841er_set_frontend_s,
+	.get_frontend = cxd2841er_get_frontend,
+	.read_status = cxd2841er_read_status_s,
+	.i2c_gate_ctrl = cxd2841er_i2c_gate_ctrl,
+	.get_frontend_algo = cxd2841er_get_algo,
+	.set_tone = cxd2841er_set_tone,
+	.diseqc_send_burst = cxd2841er_send_burst,
+	.diseqc_send_master_cmd = cxd2841er_send_diseqc_msg,
+	.tune = cxd2841er_tune_s
+};
+
+static struct  dvb_frontend_ops cxd2841er_t_c_ops = {
+	.delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
+	.info = {
+		.name	= "", /* will set in attach function */
+		.caps = FE_CAN_FEC_1_2 |
+			FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 |
+			FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK |
+			FE_CAN_QAM_16 |
+			FE_CAN_QAM_32 |
+			FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 |
+			FE_CAN_QAM_256 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_MUTE_TS |
+			FE_CAN_2G_MODULATION,
+		.frequency_min = 42000000,
+		.frequency_max = 1002000000
+	},
+	.init = cxd2841er_init_tc,
+	.sleep = cxd2841er_sleep_tc,
+	.release = cxd2841er_release,
+	.set_frontend = cxd2841er_set_frontend_tc,
+	.get_frontend = cxd2841er_get_frontend,
+	.read_status = cxd2841er_read_status_tc,
+	.tune = cxd2841er_tune_tc,
+	.i2c_gate_ctrl = cxd2841er_i2c_gate_ctrl,
+	.get_frontend_algo = cxd2841er_get_algo
+};
+
+MODULE_DESCRIPTION("Sony CXD2841ER/CXD2854ER DVB-C/C2/T/T2/S/S2 demodulator driver");
+MODULE_AUTHOR("Sergey Kozlov <serjk@netup.ru>, Abylay Ospan <aospan@netup.ru>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/cxd2841er_wetek.h b/drivers/amlogic/wetek/cxd2841er_wetek.h
new file mode 100644
index 0000000..1c4dbe1
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2841er_wetek.h
@@ -0,0 +1,50 @@
+/*
+ * cxd2841er.h
+ *
+ * Sony CXD2441ER digital demodulator driver public definitions
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#ifndef CXD2841ER_H
+#define CXD2841ER_H
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+
+enum cxd2841er_xtal {
+	SONY_XTAL_20500, /* 20.5 MHz */
+	SONY_XTAL_24000, /* 24 MHz */
+	SONY_XTAL_41000 /* 41 MHz */
+};
+
+struct cxd2841er_config {
+	u8	i2c_addr;
+	u8 	if_agc;
+	u8	ifagc_adc_range;
+	u8	ts_error_polarity;
+	u8	clock_polarity;
+	u8	mxl603;
+	enum cxd2841er_xtal	xtal;
+};
+
+extern struct dvb_frontend *cxd2841er_attach_s(struct cxd2841er_config *cfg,
+					       struct i2c_adapter *i2c);
+
+extern struct dvb_frontend *cxd2841er_attach_wetek(struct cxd2841er_config *cfg,
+					       struct i2c_adapter *i2c);
+
+#endif
diff --git a/drivers/amlogic/wetek/mn88436.c b/drivers/amlogic/wetek/mn88436.c
new file mode 100644
index 0000000..755e51e
--- /dev/null
+++ b/drivers/amlogic/wetek/mn88436.c
@@ -0,0 +1,380 @@
+/*
+ * Driver for the Panasonic MN88436 ATSC demodulator
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+#include <linux/dvb/frontend.h>
+#include "dvb_frontend.h"
+#include "mn88436.h"
+
+struct mn88436_state { 
+	struct dvb_frontend frontend;
+	struct i2c_adapter   *i2c;
+	enum fe_modulation current_modulation;
+	u32 current_frequency;	
+	u8 mn88436_bank[DMD_REG_BANK];
+	bool boot;
+};
+static int mn88436_write_reg(struct mn88436_state *state, u8 id, u8 reg, u8 val)
+{
+	int ret;
+	u8 buf[] = { reg, val };
+	struct i2c_msg msg = {	.addr = state->mn88436_bank[id], 
+							.flags = 0,
+							.buf = buf, 
+							.len = 2 
+						};
+	
+		
+	ret = i2c_transfer(state->i2c, &msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d reg=%02x "
+				, ret, reg);				
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+static int mn88436_read_reg(struct mn88436_state *state, u8 id, u8 reg, u8 *val)
+{	
+	int ret;
+	u8 buf[] = { reg };
+	struct i2c_msg msg[] = {
+		{	.addr = state->mn88436_bank[id], 
+			.flags = 0,
+			.buf = buf, 
+			.len = 1 
+		},
+		{ 	.addr = state->mn88436_bank[id], 
+			.flags = I2C_M_RD,
+			.buf = val, 
+			.len = 1 
+		}, 
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d reg=%02x "
+				, ret, reg);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+static int mn88436_write_reg_mask(struct mn88436_state *state, u8 id,
+								u8 reg , u8 mask , u8 data)
+{
+	int ret;
+	u8 rd;
+	
+	ret = mn88436_read_reg(state, id, reg, &rd);
+	if (ret)
+		goto err;
+	
+	rd |= mask & data;
+	rd &= (mask ^ 0xff) | data;
+	
+	ret = mn88436_write_reg(state, id, reg, rd);
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+
+static int mn88436_read_status(struct dvb_frontend* fe, enum fe_status* status)
+{
+	struct mn88436_state* state = fe->demodulator_priv;	
+	int ret;
+	u8 locked;
+	*status = 0;
+	
+	ret = mn88436_read_reg(state, 0, DMD_MAIN_STSMON1, &locked);
+	if (ret)
+		goto err;
+
+	if (locked & 1) 
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | 
+				FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+static int mn88436_set_frontend(struct dvb_frontend* fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct mn88436_state* state = fe->demodulator_priv;
+	int cnt = 50, ret;
+	u8 locked;
+	
+	if (!state->boot) {
+		ret = -EAGAIN;
+		goto err;
+	}
+
+	if (fe->ops.tuner_ops.set_params) {
+		ret = fe->ops.tuner_ops.set_params(fe);
+		if (ret)
+			goto err;
+	}
+	
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_RSTSET1, 0x77);
+	if (ret)
+		goto err;
+			
+		
+	do {
+		ret = mn88436_read_reg(state, 0, DMD_MAIN_STSMON1, &locked);
+
+		if (!ret && (locked & 1))
+				break;
+
+		msleep(10);   
+		
+	} while (--cnt);
+	
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	dev_dbg(&state->i2c->dev, "Service locked!!!\n");
+	
+	state->current_frequency = p->frequency;
+	state->current_modulation = p->modulation;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mn88436_get_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct mn88436_state *state = fe->demodulator_priv;
+
+	p->modulation = state->current_modulation;
+	p->frequency = state->current_frequency;
+	
+	return 0;
+}
+
+
+static int mn88436_init(struct dvb_frontend* fe)
+{
+	struct mn88436_state* state = fe->demodulator_priv;
+	const struct firmware *fw = NULL;	
+	int ret, i;
+	u8 d;
+	
+	if (state->boot)
+		return 0;
+		
+	dev_dbg(&state->i2c->dev, "Uploading demod firmware (%s)...\n", MN88436_DEMOD_ATSC);
+	
+	ret = request_firmware(&fw, MN88436_DEMOD_ATSC, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Firmware upload failed. Timeout or file not found\n");
+		goto err1;
+	}    
+	
+	for (i = 0;;) {
+	
+		if (fw->data[i] == 0xff) 
+			break;
+			
+		ret = mn88436_write_reg(state, fw->data[i], fw->data[i + 1], fw->data[i + 2]);
+		if (ret)
+			goto err2;
+					
+		i = i + 3;		
+	}
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	dev_dbg(&state->i2c->dev, "Uploading demod pseq (%s)...\n", MN88436_DEMOD_PSEQ);
+	ret = request_firmware(&fw, MN88436_DEMOD_PSEQ, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Pseq upload failed. Timeout or file not found\n");
+		goto err1;
+	}    
+	
+	/* Load PSEQ Program */
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_PSEQSET , 0x03);
+	if (ret)
+		goto err2;
+	
+	for (i = 0; i < fw->size; i++) {
+		ret = mn88436_write_reg(state, 0, DMD_MAIN_PSEQPRG , fw->data[i]);
+		if (ret)
+			goto err2;
+	}
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	/* Check Parity bit */
+	ret = mn88436_read_reg(state, 0, DMD_MAIN_PSEQSET , &d);
+	if (ret)
+		goto err1;
+	
+	if (d & 0x20) {
+		ret = -EAGAIN;
+		goto err1;
+	}
+	
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_PSEQSET , 0x00);
+	if (ret)
+		goto err1;
+		
+		
+	/* TS parallel (Fixed clock mode) */
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_CPOSET2, 0xc1);
+	if (ret)
+		goto err1;
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_GPSET1, 0xff);
+	if (ret)
+		goto err1;
+		
+
+	/* Set TCB Through Mode */
+	ret = mn88436_write_reg_mask(state, 0, DMD_MAIN_TCBSET, 0x7f, 0x53);	
+	if (ret)
+		goto err1;		
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_TCBADR, 0x00);
+	if (ret)
+		goto err1;
+	
+	
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_VEQSET2, 0x80);
+	if (ret)
+		goto err1;
+		
+	state->boot = true;
+	
+	return 0;
+	
+err2:
+	release_firmware(fw);
+	fw = NULL;
+err1:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+static void mn88436_release(struct dvb_frontend* fe)
+{
+	struct mn88436_state* state = fe->demodulator_priv;
+	kfree(state);
+}
+
+
+static struct dvb_frontend_ops mn88436_ops = {
+	.delsys = { SYS_ATSC },
+	.info = {
+		.name = "Panasonic MN88436",		
+		.frequency_min = 51000000,
+		.frequency_max = 858000000,
+		.caps = FE_CAN_8VSB
+	},
+	.init = mn88436_init,
+	.release = mn88436_release,	
+	.set_frontend = mn88436_set_frontend,
+	.get_frontend = mn88436_get_frontend,	
+	.read_status = mn88436_read_status,
+	
+};
+
+struct dvb_frontend *mn88436_attach(struct i2c_adapter *i2c, 
+									u8 device_id)
+{
+	struct mn88436_state *state = NULL;
+	int ret;
+	
+	
+	state = kzalloc(sizeof(struct mn88436_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+
+	state->i2c = i2c;
+	
+	switch (device_id) {
+	case 0:
+	default:
+		state->mn88436_bank[0] = 0x18;
+		state->mn88436_bank[1] = 0x10;
+		break;
+	case 1:
+		state->mn88436_bank[0] = 0x19;
+		state->mn88436_bank[1] = 0x11;
+		break;
+	case 2:
+		state->mn88436_bank[0] = 0x1A;
+		state->mn88436_bank[1] = 0x12;
+		break;
+	case 3:
+		state->mn88436_bank[0] = 0x1B;
+		state->mn88436_bank[1] = 0x13;
+		break;		
+	}
+	/* Try SOFT reset */
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_RSTSET1, 0x77);
+	if (ret)
+		goto err2;
+	
+	dev_info(&i2c->dev, "MN88436 ATSC successfully attached\n");						
+		
+	memcpy(&state->frontend.ops, &mn88436_ops,
+		       sizeof(struct dvb_frontend_ops));
+			   
+	state->frontend.demodulator_priv = state;
+	
+	return &state->frontend;
+	
+err2:	
+	kfree(state);
+err1:	
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);	
+	return NULL;
+}
+EXPORT_SYMBOL(mn88436_attach);
+
+MODULE_DESCRIPTION("Panasonic MN88436 ATSC demod driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/mn88436.h b/drivers/amlogic/wetek/mn88436.h
new file mode 100644
index 0000000..d1194b1
--- /dev/null
+++ b/drivers/amlogic/wetek/mn88436.h
@@ -0,0 +1,47 @@
+/*
+ * Driver for the Panasonic MN88436 ATSC demodulator
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __MN88436_H_
+#define __MN88436_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+
+#define MN88436_DEMOD_ATSC 		"dvb-fe-mn88436-atsc.fw" 
+#define MN88436_DEMOD_PSEQ 		"dvb-fe-mn88436-pseq.fw" 
+
+#define DMD_REG_BANK    		2
+
+#define DMD_MAIN_CPOSET2		0x2
+#define DMD_MAIN_GPSET1			0x5
+#define DMD_MAIN_RSTSET1		0x10
+#define DMD_MAIN_TCBSET			0x15
+#define DMD_MAIN_TCBADR			0x17
+#define DMD_MAIN_VEQSET2		0x69
+#define DMD_MAIN_STSMON1		0xC4
+#define DMD_MAIN_PSEQSET		0xF0
+#define DMD_MAIN_PSEQPRG		0xF1
+
+
+extern struct dvb_frontend *mn88436_attach(struct i2c_adapter *i2c,
+											u8 device_id);
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/wetek/mxl603.c b/drivers/amlogic/wetek/mxl603.c
new file mode 100644
index 0000000..bc7018c
--- /dev/null
+++ b/drivers/amlogic/wetek/mxl603.c
@@ -0,0 +1,1096 @@
+/*
+ * Driver for the MaxLinear MxL603 tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include "tuner-i2c.h"
+#include "mxl603.h"
+
+
+enum mxl603_mode {
+	MxL603_MODE_CABLE,
+	MxL603_MODE_ISDBT_ATSC,
+	MxL603_MODE_DVBT,
+};
+
+enum mxl603_bw_mhz {
+	MxL603_CABLE_BW_6MHz = 0x00,
+	MxL603_CABLE_BW_7MHz = 0x01,
+	MxL603_CABLE_BW_8MHz = 0x02,
+	MxL603_TERR_BW_6MHz = 0x20,
+	MxL603_TERR_BW_7MHz = 0x21,
+	MxL603_TERR_BW_8MHz = 0x22,
+};
+
+struct reg_pair_t {
+	u8 reg;
+	u8 val;
+};
+
+struct freq_table {
+	u32 center_freq;
+	u8 reg1;
+	u8 reg2;
+};
+
+static struct freq_table MxL603_Cable[] = {
+	{ 1        , 0x00, 0xD8 },
+	{ 695000000, 0x20, 0xD7 },
+	{ 0, 0, 0 },
+};
+
+static struct freq_table MxL603_Digital[] = {
+	{ 1, 0x00, 0xD8 },
+	{ 0, 0, 0 },
+};
+
+static struct reg_pair_t MxL603_DigitalDvbc[] = {
+	{ 0x0C, 0x00 },
+	{ 0x13, 0x04 },
+	{ 0x53, 0x7E },
+	{ 0x57, 0x91 },
+	{ 0x5C, 0xB1 },
+	{ 0x62, 0xF2 },
+	{ 0x6E, 0x03 },
+	{ 0x6F, 0xD1 },
+	{ 0x87, 0x77 },
+	{ 0x88, 0x55 },
+	{ 0x93, 0x33 },
+	{ 0x97, 0x03 },
+	{ 0xBA, 0x40 },
+	{ 0x98, 0xAF },
+	{ 0x9B, 0x20 },
+	{ 0x9C, 0x1E },
+	{ 0xA0, 0x18 },
+	{ 0xA5, 0x09 },
+	{ 0xC2, 0xA9 },
+	{ 0xC5, 0x7C },
+	{ 0xCD, 0x64 },
+	{ 0xCE, 0x7C },
+	{ 0xD5, 0x05 },
+	{ 0xD9, 0x00 },
+	{ 0xEA, 0x00 },
+	{ 0xDC, 0x1C },
+	{ 0, 0 }
+};
+
+static struct reg_pair_t MxL603_DigitalIsdbtAtsc[] = {
+	{ 0x0C, 0x00 },
+	{ 0x13, 0x04 },
+	{ 0x53, 0xFE },
+	{ 0x57, 0x91 },
+	{ 0x62, 0xC2 },
+	{ 0x6E, 0x01 },
+	{ 0x6F, 0x51 },
+	{ 0x87, 0x77 },
+	{ 0x88, 0x55 },
+	{ 0x93, 0x22 },
+	{ 0x97, 0x02 },
+	{ 0xBA, 0x30 },
+	{ 0x98, 0xAF },
+	{ 0x9B, 0x20 },
+	{ 0x9C, 0x1E },
+	{ 0xA0, 0x18 },
+	{ 0xA5, 0x09 },
+	{ 0xC2, 0xA9 },
+	{ 0xC5, 0x7C },
+	{ 0xCD, 0xEB },
+	{ 0xCE, 0x7F },
+	{ 0xD5, 0x03 },
+	{ 0xD9, 0x04 },
+	{ 0, 0 }
+};
+
+static struct reg_pair_t MxL603_DigitalDvbt[] = {
+	{ 0x0C, 0x00 },
+	{ 0x13, 0x04 },
+	{ 0x53, 0xFE },
+	{ 0x57, 0x91 },
+	{ 0x62, 0xC2 },
+	{ 0x6E, 0x01 },
+	{ 0x6F, 0x51 },
+	{ 0x87, 0x77 },
+	{ 0x88, 0x55 },
+	{ 0x93, 0x22 },
+	{ 0x97, 0x02 },
+	{ 0xBA, 0x30 },
+	{ 0x98, 0xAF },
+	{ 0x9B, 0x20 },
+	{ 0x9C, 0x1E },
+	{ 0xA0, 0x18 },
+	{ 0xA5, 0x09 },
+	{ 0xC2, 0xA9 },
+	{ 0xC5, 0x7C },
+	{ 0xCD, 0x64 },
+	{ 0xCE, 0x7C },
+	{ 0xD5, 0x03 },
+	{ 0xD9, 0x04 },
+	{ 0, 0 }
+};
+
+struct mxl603_state {
+	struct mxl603_config *config;
+	struct i2c_adapter   *i2c;
+	u8 addr;
+	u32 frequency;
+	u32 bandwidth;
+};
+
+static int mxl603_write_reg(struct mxl603_state *state, u8 reg, u8 val)
+{
+	
+	u8 buf[] = { reg, val };
+	struct i2c_msg msg = { .addr = state->addr, .flags = 0,
+			       .buf = buf, .len = 2 };
+	int ret;
+		
+	ret = i2c_transfer(state->i2c, &msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d reg=%02x "
+				, ret, reg);				
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+
+static int mxl603_write_regs(struct mxl603_state *state,
+			       struct reg_pair_t *reg_pair)
+{
+	unsigned int i = 0;
+	int ret = 0;
+
+	while ((ret == 0) && (reg_pair[i].reg || reg_pair[i].val)) {
+		ret = mxl603_write_reg(state,
+					 reg_pair[i].reg, reg_pair[i].val);
+		i++;
+	}
+	return ret;
+}
+static int mxl603_read_reg(struct mxl603_state *state, u8 reg, u8 *val)
+{
+	
+	u8 buf[2] = { 0xfb, reg };
+	struct i2c_msg msg[] = {
+		{ .addr = state->addr, .flags = 0,
+		  .buf = buf, .len = 2 },
+		{ .addr = state->addr, .flags = I2C_M_RD,
+		  .buf = val, .len = 1 },
+	};
+	int ret;
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d reg=%02x "
+				, ret, reg);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+static int mxl603_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+
+	*frequency = 0;
+
+	switch (state->config->if_freq_hz) {
+	case MXL603_IF_3_65MHz:
+		*frequency = 3650000;
+		break;
+	case MXL603_IF_4MHz:
+		*frequency = 4000000;
+		break;
+	case MXL603_IF_4_1MHz:
+		*frequency = 4100000;
+		break;
+	case MXL603_IF_4_15MHz:
+		*frequency = 4150000;
+		break;
+	case MXL603_IF_4_5MHz:
+		*frequency = 4500000;
+		break;
+	case MXL603_IF_4_57MHz:
+		*frequency = 4570000;
+		break;
+	case MXL603_IF_5MHz:
+		*frequency = 5000000;
+		break;
+	case MXL603_IF_5_38MHz:
+		*frequency = 5380000;
+		break;
+	case MXL603_IF_6MHz:
+		*frequency = 6000000;
+		break;
+	case MXL603_IF_6_28MHz:
+		*frequency = 6280000;
+		break;
+	case MXL603_IF_7_2MHz:
+		*frequency = 7200000;
+		break;
+	case MXL603_IF_8_25MHz:
+		*frequency = 8250000;
+		break;
+	case MXL603_IF_35_25MHz:
+		*frequency = 35250000;
+		break;
+	case MXL603_IF_36MHz:
+		*frequency = 36000000;
+		break;
+	case MXL603_IF_36_15MHz:
+		*frequency = 36150000;
+		break;
+	case MXL603_IF_36_65MHz:
+		*frequency = 36650000;
+		break;
+	case MXL603_IF_44MHz:
+		*frequency = 44000000;
+		break;
+	}
+	return 0;
+}
+
+static int mxl603_set_freq(struct mxl603_state *state,
+						   int freq,
+						   enum mxl603_mode mode,
+						   enum mxl603_bw_mhz bw,
+						   struct freq_table *ftable)
+{
+	u8 d = 0, d1 = 0, d2 = 0, d3 = 0;
+	u16 f;
+	u32 tmp, div;
+	int ret;
+	int i;
+
+	ret = mxl603_write_reg(state, 0x12, 0x00);
+	if (ret)
+		goto err;
+
+	if (freq < 700000000) {
+		ret = mxl603_write_reg(state, 0x7C, 0x1F);
+		if (ret)
+			goto err;
+
+		if (mode == MxL603_MODE_CABLE)
+			d = 0xC1;
+		else
+			d = 0x81;
+
+	} else {
+		ret = mxl603_write_reg(state, 0x7C, 0x9F);
+		if (ret)
+			goto err;
+
+		if (mode == MxL603_MODE_CABLE)
+			d = 0xD1;
+		else
+			d = 0x91;
+	}
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x31, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	for (i = 0; 0 != ftable->center_freq; i++, ftable++) {
+
+		if (ftable->center_freq == 1) {
+			d1 = ftable->reg1;
+			d2 = ftable->reg2;
+			break;
+		}
+	}
+
+	for (i = 0; 0 != ftable->center_freq; i++, ftable++) {
+
+		if ((ftable->center_freq - 500000) <= freq &&
+			(ftable->center_freq + 500000) >= freq) {
+			d1 = ftable->reg1;
+			d2 = ftable->reg2;
+			break;
+		}
+	}
+
+	ret = mxl603_write_reg(state, 0xEA, d1);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0xEB, d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x0F, bw);
+	if (ret)
+		goto err;
+
+	 /* convert freq to 10.6 fixed point float [MHz] */
+	f = freq / 1000000;
+	tmp = freq % 1000000;
+	div = 1000000;
+	for (i = 0; i < 6; i++) {
+		f <<= 1;
+		div >>= 1;
+			if (tmp > div) {
+				tmp -= div;
+				f |= 1;
+			}
+	}
+	if (tmp > 7812)
+		f++;
+
+	d1 = f & 0xFF;
+	d2 = f >> 8;
+
+	ret = mxl603_write_reg(state, 0x10, d1);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x11, d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x0B, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x96, &d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0xB6, &d1);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x60, &d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x5F, &d3);
+	if (ret)
+		goto err;
+
+	if ((d & 0x10) == 0x10) {
+
+		d1 &= 0xBF;
+		d1 |= 0x0E;
+
+		d2 &= 0xC0;
+		d2 |= 0x0E;
+
+		d3 &= 0xC0;
+		d3 |= 0x0E;
+	} else {
+
+		d1 |= 0x40;
+		d1 &= 0xC0;
+
+		d2 &= 0xC0;
+		d2 |= 0x37;
+
+		d3 &= 0xC0;
+		d3 |= 0x37;
+
+	}
+
+	ret = mxl603_write_reg(state, 0x60, d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x5F, d3);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0xB6, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x12, 0x01);
+	if (ret)
+		goto err;
+
+	msleep(20);
+
+	d |= 0x40;
+
+	ret = mxl603_write_reg(state, 0xB6, d);
+	if (ret)
+		goto err;
+
+	msleep(20);
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_set_mode(struct dvb_frontend *fe,
+						struct mxl603_state *state,
+						enum mxl603_mode mode)
+{
+
+	u8 cfg_0, cfg_1, pwr, dfe;
+	int ret;
+	u32 if_out_freq;
+	struct reg_pair_t *reg_table;
+
+	ret = mxl603_get_if_frequency(fe, &if_out_freq);
+	if (!if_out_freq)
+		goto err;
+
+	if_out_freq /= 1000;
+
+	switch (mode) {
+	case MxL603_MODE_CABLE:
+		reg_table = MxL603_DigitalDvbc;
+		pwr = 0;
+		dfe = 0xFF;
+
+		if (if_out_freq <  35250) {
+			cfg_0 = 0xFE;
+			cfg_1 = 0x10;
+
+		} else {
+			cfg_0 = 0xD9;
+			cfg_1 = 0x16;
+		}
+		
+		break;
+	case MxL603_MODE_ISDBT_ATSC:
+		reg_table = MxL603_DigitalIsdbtAtsc;
+		dfe = 0x1C;
+
+		if (if_out_freq <  35250) {
+			cfg_0 = 0xF9;
+			cfg_1 = 0x18;
+			pwr = 0xF1;
+		} else {
+			cfg_0 = 0xD9;
+			cfg_1 = 0x16;
+			pwr = 0xB1;
+		}
+		switch(state->config->if_out_gain_level)
+		{
+			case 0x09: dfe = 0x44; break;
+			case 0x08: dfe = 0x43; break;
+			case 0x07: dfe = 0x42; break;
+			case 0x06: dfe = 0x41; break;
+			case 0x05: dfe = 0x40; break;
+			default: break;
+		}
+
+		break;
+	case MxL603_MODE_DVBT:
+		reg_table = MxL603_DigitalDvbt;
+		dfe = 0;
+		if (if_out_freq <  35250) {
+			cfg_0 = 0xFE;
+			cfg_1 = 0x18;
+			pwr = 0xF1;
+		} else {
+			cfg_0 = 0xD9;
+			cfg_1 = 0x16;
+			pwr = 0xB1;
+		}
+		switch(state->config->if_out_gain_level)
+		{
+			case 0x09: dfe = 0x44; break;
+			case 0x08: dfe = 0x43; break;
+			case 0x07: dfe = 0x42; break;
+			case 0x06: dfe = 0x41; break;
+			case 0x05: dfe = 0x40; break;
+			default: break;
+		}
+		break;
+	default:
+			return -EINVAL;
+	}
+
+	ret = mxl603_write_regs(state, reg_table);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x5A, cfg_0);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x5B, cfg_1);
+	if (ret)
+		goto err;
+
+	if (pwr) {
+		ret = mxl603_write_reg(state, 0x5C, pwr);
+		if (ret)
+			goto err;
+	}
+
+	ret = mxl603_write_reg(state, 0xEA,
+				state->config->xtal_freq_hz ? 0x0E : 0x0D);
+	if (ret)
+		goto err;
+
+	if (dfe != 0xFF) {
+		ret = mxl603_write_reg(state, 0xDC, dfe);
+		if (ret)
+			goto err;
+	}
+
+	ret = mxl603_write_reg(state, 0x03, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x03, 0x01);
+	if (ret)
+		goto err;
+
+	msleep(50);
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_set_agc(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+
+	ret = mxl603_read_reg(state, 0x08, &d);
+	if (ret)
+		goto err;
+
+	d &= 0xF2;
+	d = (u8) (d | (state->config->agc_type << 2) | 0x01);
+	ret = mxl603_write_reg(state, 0x08, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x09, &d);
+	if (ret)
+		goto err;
+
+	d &= 0x80;
+	d |= (u8)(state->config->agc_set_point & 0xff);	
+	ret = mxl603_write_reg(state, 0x09, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x5E, &d);
+	if (ret)
+		goto err;
+
+	d &= 0xEF;
+	d |= (state->config->agc_invert_pol << 4);
+	ret = mxl603_write_reg(state, 0x5E, d);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_set_if_out(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+
+	ret = mxl603_read_reg(state, 0x04, &d);
+	if (ret)
+		goto err;
+
+	d |= state->config->if_freq_hz;
+
+	ret = mxl603_write_reg(state, 0x04, d);
+	if (ret)
+		goto err;
+
+	d = 0;
+	if (state->config->invert_if)
+		d = 0x3 << 6;
+
+	d += (state->config->gain_level & 0x0F);	
+	d |= 0x20;
+	ret = mxl603_write_reg(state, 0x05, d);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_set_xtal(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+
+	d = (u8)((state->config->xtal_freq_hz << 5)
+			| (state->config->xtal_cap & 0x1F));
+	d |= (state->config->clk_out_enable << 7);
+
+	ret = mxl603_write_reg(state, 0x01, d);
+	if (ret)
+		goto err;
+
+	d = (0x01 & (u8)state->config->clk_out_div);
+
+	if (state->config->xtal_sharing_mode) {
+		d |= 0x40;
+
+		ret = mxl603_write_reg(state, 0x02, d);
+		if (ret)
+			goto err;
+		ret = mxl603_write_reg(state, 0x6D, 0x80);
+		if (ret)
+			goto err;
+	} else {
+		d &= 0x01;
+		ret = mxl603_write_reg(state, 0x02, d);
+		if (ret)
+			goto err;
+		ret = mxl603_write_reg(state, 0x6D, 0x0A);
+		if (ret)
+			goto err;
+	}
+
+	if (state->config->single_supply_3_3V) {
+		ret = mxl603_write_reg(state, 0x0E, 0x14);
+		if (ret)
+			goto err;
+	}
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_tuner_init_default(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+	
+	ret = mxl603_write_reg(state, 0xFF, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_regs(state, MxL603_DigitalDvbc);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x31, &d);
+	if (ret)
+		goto err;
+
+	d &= 0x2F;
+	d |= 0xD0;
+
+	ret = mxl603_write_reg(state, 0x31, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	if (state->config->single_supply_3_3V) {
+		ret = mxl603_write_reg(state, 0x0E, 0x04);
+		if (ret)
+			goto err;
+	}
+
+	mdelay(1);
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_synth_lock_status(struct mxl603_state *state,
+				      int *rf_locked, int *ref_locked)
+{
+	u8 d = 0;
+	int ret;
+
+	*rf_locked = 0;
+	*ref_locked = 0;
+
+	ret = mxl603_read_reg(state, 0x2B, &d);
+	if (ret)
+		goto err;
+
+	if ((d & 0x02) == 0x02)
+		*rf_locked = 1;
+
+	if ((d & 0x01) == 0x01)
+		*ref_locked = 1;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_get_status(struct dvb_frontend *fe, u32 *status)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	int rf_locked, ref_locked, ret;
+
+	*status = 0;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = mxl603_synth_lock_status(state, &rf_locked, &ref_locked);
+	if (ret)
+		goto err;
+
+	dev_dbg(&state->i2c->dev, "%s%s", rf_locked ? "rf locked " : "",
+			ref_locked ? "ref locked" : "");
+
+	if ((rf_locked) || (ref_locked))
+		*status |= TUNER_STATUS_LOCKED;
+
+		
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_set_params(struct dvb_frontend *fe)
+{	
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct mxl603_state *state = fe->tuner_priv;	
+	struct freq_table *ftable;
+	enum mxl603_bw_mhz bw;
+	enum mxl603_mode mode;
+	int ret;
+	u32 freq = c->frequency;
+	
+	dev_dbg(&state->i2c->dev, 
+		"%s: delivery_system=%d frequency=%d bandwidth_hz=%d\n", 
+		__func__, c->delivery_system, c->frequency, c->bandwidth_hz);		
+			
+
+	switch (c->delivery_system) {
+	case SYS_ATSC:
+		mode = MxL603_MODE_ISDBT_ATSC;
+		bw = MxL603_TERR_BW_6MHz;
+		ftable = MxL603_Digital;
+		break;
+	case SYS_DVBC_ANNEX_A:
+		mode = MxL603_MODE_CABLE;
+		ftable = MxL603_Cable;
+		bw = MxL603_CABLE_BW_8MHz;	
+		break;
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		mode = MxL603_MODE_DVBT;
+		ftable = MxL603_Digital;
+		switch (c->bandwidth_hz) {
+		case 6000000:
+			bw = MxL603_TERR_BW_6MHz;
+			break;
+		case 7000000:
+			bw = MxL603_TERR_BW_7MHz;
+			break;
+		case 8000000:
+			bw = MxL603_TERR_BW_8MHz;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		 dev_dbg(&state->i2c->dev, "%s: err state=%d\n", 
+			__func__, fe->dtv_property_cache.delivery_system);
+		return -EINVAL;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	
+	ret = mxl603_tuner_init_default(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_xtal(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_if_out(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_agc(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_mode(fe, state, mode);
+	if (ret)
+		goto err;
+		
+	ret = mxl603_set_freq(state, freq, mode, bw, ftable);
+	if (ret)
+		goto err;
+
+	state->frequency = freq;
+	state->bandwidth = c->bandwidth_hz;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	msleep(15);
+		
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	*frequency = state->frequency;
+	return 0;
+}
+
+static int mxl603_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	*bandwidth = state->bandwidth;
+	return 0;
+}
+
+static int mxl603_init(struct dvb_frontend *fe)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	int ret;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	/* wake from standby */
+	ret = mxl603_write_reg(state, 0x0B, 0x01);
+	if (ret)
+		goto err;
+	ret = mxl603_write_reg(state, 0x12, 0x01);
+	if (ret)
+		goto err;
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	if (state->config->loop_thru_enable)
+		ret = mxl603_write_reg(state, 0x60, 0x0E);
+	else
+		ret = mxl603_write_reg(state, 0x60, 0x37);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_sleep(struct dvb_frontend *fe)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	int ret;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	/* enter standby mode */
+	ret = mxl603_write_reg(state, 0x12, 0x00);
+	if (ret)
+		goto err;
+		
+	ret = mxl603_write_reg(state, 0x0B, 0x00);
+	if (ret)
+		goto err;
+		
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_release(struct dvb_frontend *fe)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+
+	fe->tuner_priv = NULL;
+	kfree(state);
+	
+	return 0;
+}
+static struct dvb_tuner_ops mxl603_tuner_ops = {
+	.info = {
+		.name = "MaxLinear MxL603",
+		.frequency_min = 1000000,
+		.frequency_max = 1200000000,
+		.frequency_step = 25000,
+	},
+	.init              = mxl603_init,
+	.sleep             = mxl603_sleep,
+	.set_params        = mxl603_set_params,
+	.get_status        = mxl603_get_status,
+	.get_frequency     = mxl603_get_frequency,
+	.get_bandwidth     = mxl603_get_bandwidth,
+	.release           = mxl603_release,
+	.get_if_frequency  = mxl603_get_if_frequency,
+};
+static int mxl603_get_chip_id(struct mxl603_state *state)
+{
+	int ret;
+	u8 id;
+
+	ret = mxl603_read_reg(state, 0x18, &id);
+	if (ret)
+		goto err;
+
+	if (id != 0x02) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	dev_info(&state->i2c->dev, "MxL603 detected id(%02x)\n"
+			, id);
+			
+	return ret;
+
+err:
+	dev_warn(&state->i2c->dev, "MxL603 unable to identify device(%02x)\n"
+			, id);
+	return ret;
+}
+struct dvb_frontend *mxl603_attach(struct dvb_frontend *fe,
+				     struct i2c_adapter *i2c, u8 addr,
+				     struct mxl603_config *config)
+{
+	struct mxl603_state *state = NULL;
+	int ret = 0;
+
+	state = kzalloc(sizeof(struct mxl603_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+	
+	state->config = config;
+	state->i2c = i2c;
+	state->addr = addr;
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = mxl603_get_chip_id(state);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	/* check return value of mxl603_get_chip_id */
+	if (ret)
+		goto err2;
+	
+	dev_info(&i2c->dev, "Attaching MxL603\n");
+	
+	fe->tuner_priv = state;
+
+	memcpy(&fe->ops.tuner_ops, &mxl603_tuner_ops,
+	       sizeof(struct dvb_tuner_ops));
+
+	return fe;
+	
+err2:
+	kfree(state);
+err1:
+	return NULL;
+}
+EXPORT_SYMBOL(mxl603_attach);
+
+MODULE_DESCRIPTION("MaxLinear MxL603 tuner driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/mxl603.h b/drivers/amlogic/wetek/mxl603.h
new file mode 100644
index 0000000..ee4f9fb
--- /dev/null
+++ b/drivers/amlogic/wetek/mxl603.h
@@ -0,0 +1,83 @@
+/*
+ * Driver for the MaxLinear MxL603 tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __MXL603_H__
+#define __MXL603_H__
+
+#include <linux/dvb/version.h>
+#include "dvb_frontend.h"
+
+enum mxl603_if_freq {
+	MXL603_IF_3_65MHz,
+	MXL603_IF_4MHz,
+	MXL603_IF_4_1MHz,
+	MXL603_IF_4_15MHz,
+	MXL603_IF_4_5MHz, 
+	MXL603_IF_4_57MHz,
+	MXL603_IF_5MHz,
+	MXL603_IF_5_38MHz, 
+	MXL603_IF_6MHz,
+	MXL603_IF_6_28MHz,
+	MXL603_IF_7_2MHz, 
+	MXL603_IF_8_25MHz,
+	MXL603_IF_35_25MHz,
+	MXL603_IF_36MHz, 
+	MXL603_IF_36_15MHz, 
+	MXL603_IF_36_65MHz,
+	MXL603_IF_44MHz,
+};
+
+enum mxl603_xtal_freq {
+	MXL603_XTAL_16MHz,
+	MXL603_XTAL_24MHz,
+};
+
+enum mxl603_agc {
+	MXL603_AGC_SELF,   
+	MXL603_AGC_EXTERNAL,
+};
+
+struct mxl603_config {
+	enum mxl603_xtal_freq xtal_freq_hz;
+	enum mxl603_if_freq if_freq_hz;
+	enum mxl603_agc agc_type;
+	
+	u8 xtal_cap;
+	u8 gain_level;
+	u8 if_out_gain_level;
+	u8 agc_set_point;
+	
+	u8 agc_invert_pol;
+	u8 invert_if;
+	u8 loop_thru_enable;
+	u8 clk_out_enable;
+	u8 clk_out_div;
+	u8 clk_out_ext;
+	u8 xtal_sharing_mode;
+	u8 single_supply_3_3V;
+};
+
+
+
+extern struct dvb_frontend *mxl603_attach(struct dvb_frontend *fe,
+					    struct i2c_adapter *i2c, u8 addr,
+					    struct mxl603_config *cfg);
+
+#endif /* __MXL603_H__ */
diff --git a/drivers/amlogic/wetek/nimdetect.c b/drivers/amlogic/wetek/nimdetect.c
new file mode 100644
index 0000000..5752b2d
--- /dev/null
+++ b/drivers/amlogic/wetek/nimdetect.c
@@ -0,0 +1,584 @@
+/*
+ * Wetek NIMs/DVB detection
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#ifndef CONFIG_ARM64
+#include <mach/am_regs.h>
+#else
+#include <linux/reset.h>
+#endif
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/usb.h>
+#include "nimdetect.h"
+
+#include "ascot3.h"
+#include "cxd2837.h"
+#include "cxd2841er_wetek.h"
+#include "mxl603.h"
+#include "avl6211.h"
+#include "mn88436.h"
+
+#ifdef CONFIG_ARM64
+static struct reset_control *dvb_demux_reset_ctl;
+static struct reset_control *dvb_afifo_reset_ctl;
+static struct reset_control *dvb_ahbarb0_reset_ctl;
+static struct reset_control *dvb_uparsertop_reset_ctl;
+#define TOTAL_I2C		 	1
+#define TOTAL_DEMODS 		1
+#else
+#define TOTAL_I2C		 	2
+#define TOTAL_DEMODS 		2
+#endif
+#define TOTAL_AML_INPUTS 	3
+
+
+static struct wetek_nims weteknims;
+#ifndef CONFIG_ARM64
+static struct cxd2837_cfg cxd2837cfg = {
+		.adr = 0x6C,
+		.if_agc_polarity = 1,
+		.rfain_monitoring = 0,
+		.ts_error_polarity = 0,
+		.clock_polarity = 1,
+		.ifagc_adc_range = 0,
+		.spec_inv = 0,
+		.xtal = XTAL_20500KHz,
+		.ts_clock = SERIAL_TS_CLK_MID_FULL,
+};
+#endif
+static struct cxd2841er_config cxd2841cfg = {
+		.i2c_addr = 0x6C,
+		.if_agc = 0,
+		.ifagc_adc_range = 0x39,
+		.ts_error_polarity = 0,
+		.clock_polarity = 1,
+		.mxl603	= 0,
+		.xtal = SONY_XTAL_20500,
+};
+struct ascot3_config ascot3cfg = {
+		.i2c_address = 0x60,
+};
+static struct mxl603_config mxl603cfg = {
+		.xtal_freq_hz = MXL603_XTAL_24MHz,
+		.if_freq_hz = MXL603_IF_5MHz,
+		.agc_type = MXL603_AGC_SELF,
+		.xtal_cap = 16,
+		.gain_level = 11,
+		.if_out_gain_level = 11,
+		.agc_set_point = 66,
+		.agc_invert_pol = 0,
+		.invert_if = 1,
+		.loop_thru_enable = 0,
+		.clk_out_enable = 1,
+		.clk_out_div = 0,
+		.clk_out_ext = 0,
+		.xtal_sharing_mode = 0,
+		.single_supply_3_3V = 1,
+};
+static struct mxl603_config mxl603cfg_atsc = {
+		.xtal_freq_hz = MXL603_XTAL_24MHz,
+		.if_freq_hz = MXL603_IF_5MHz,
+		.agc_type = MXL603_AGC_EXTERNAL,
+		.xtal_cap = 31,
+		.gain_level = 11,
+		.if_out_gain_level = 11,
+		.agc_set_point = 66,
+		.agc_invert_pol = 0,
+		.invert_if = 0,
+		.loop_thru_enable = 0,
+		.clk_out_enable = 1,
+		.clk_out_div = 0,
+		.clk_out_ext = 0,
+		.xtal_sharing_mode = 0,
+		.single_supply_3_3V = 1,
+};
+static struct avl6211_config avl6211cfg[] = {
+	{
+#ifndef CONFIG_ARM64
+		.tuner_address = 0xC2,
+#else		
+		.tuner_address = 0xC4,
+#endif
+		.tuner_i2c_clock = 200,	
+		.demod_address = 0x0C,
+		.mpeg_pol = 1,
+		.mpeg_mode = 0,
+		.mpeg_format = 0,
+		.demod_refclk = 9,
+		.mpeg_pin = 0,
+		.tuner_rfagc = 1,
+		.tuner_spectrum = 0,
+		.use_lnb_pin59 = 1,
+		.use_lnb_pin60 = 0,
+		.set_external_vol_gpio = set_external_vol_gpio,
+	},
+	{
+		.tuner_address = 0xC2,
+		.tuner_i2c_clock = 200,		
+		.demod_address = 0x0C,
+		.mpeg_pol = 1,
+		.mpeg_mode = 0,
+		.mpeg_format = 0,
+		.demod_refclk = 9,
+		.mpeg_pin = 0,
+		.tuner_rfagc = 1,
+		.tuner_spectrum = 0,
+		.use_lnb_pin59 = 1,
+		.use_lnb_pin60 = 0,
+		.set_external_vol_gpio = set_external_vol_gpio,
+	}
+};
+
+#ifndef CONFIG_ARM64
+
+#define EXPORT_SYMBOL_AS(sym, name)					\
+	extern typeof(sym) sym;						\
+	__CRC_SYMBOL(sym, "")						\
+	static const char __kstrtab_##name[]				\
+	__attribute__((section("__ksymtab_strings"), aligned(1)))	\
+	= VMLINUX_SYMBOL_STR(name);					\
+	extern const struct kernel_symbol __ksymtab_##name;		\
+	__visible const struct kernel_symbol __ksymtab_##name		\
+	__used								\
+	__attribute__((section("___ksymtab" "+" #name), unused))	\
+	= { (unsigned long)&sym, __kstrtab_##name }
+
+
+extern struct list_head usb_bus_list;
+extern struct mutex usb_bus_list_lock;
+extern struct usb_device *usb_hub_find_child(struct usb_device *hdev, int port1);
+extern struct usb_device *usb_get_dev(struct usb_device *dev);
+extern int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,
+                     __u8 requesttype, __u16 value, __u16 index, void *data,
+                     __u16 size, int timeout);
+
+EXPORT_SYMBOL_AS(usb_bus_list, wtk_bus_list);
+EXPORT_SYMBOL_AS(usb_bus_list_lock, wtk_bus_list_lock);
+EXPORT_SYMBOL_AS(usb_hub_find_child, wtk_hub_find_child);
+EXPORT_SYMBOL_AS(usb_get_dev, wtk_get_dev);
+EXPORT_SYMBOL_AS(usb_control_msg, wtk_control_msg);
+
+#endif
+
+
+int kc_class_register(struct class *cls)
+{
+	return class_register(cls);
+}
+EXPORT_SYMBOL(kc_class_register);
+void kc_class_unregister(struct class *cls)
+{
+	class_unregister(cls);
+}
+EXPORT_SYMBOL(kc_class_unregister);
+const struct cpumask *aml_get_cpu_mask(unsigned int cpu)
+{
+	const unsigned long *p = cpu_bit_bitmap[1 + cpu % BITS_PER_LONG];
+	p -= cpu / BITS_PER_LONG;
+	return to_cpumask(p);
+}
+EXPORT_SYMBOL(aml_get_cpu_mask);
+
+void get_nims_infos(struct wetek_nims *p)
+{
+	memcpy(p, &weteknims, sizeof(struct wetek_nims));
+}
+EXPORT_SYMBOL(get_nims_infos);
+int set_external_vol_gpio(int *demod_id, int on)
+{
+	if (on) {
+		if (*demod_id == 0 )
+#ifdef CONFIG_ARM64
+			gpio_direction_output(weteknims.power_ctrl, 1);
+#else		
+			amlogic_gpio_direction_output(GPIOAO_8, 1, "nimdetect");		
+#endif	
+#ifndef CONFIG_ARM64		
+        else if (*demod_id == 1)
+			amlogic_gpio_direction_output(GPIOAO_9, 1, "nimdetect");
+#endif			
+	} else if (!on) {
+		if (*demod_id == 0 )
+#ifdef CONFIG_ARM64
+			gpio_direction_output(weteknims.power_ctrl, 0);
+#else		
+			amlogic_gpio_direction_output(GPIOAO_8, 0, "nimdetect");		
+#endif
+#ifndef CONFIG_ARM64
+        else if (*demod_id == 1)		
+			amlogic_gpio_direction_output(GPIOAO_9, 0, "nimdetect");
+#endif			
+    }
+	return 0;
+}
+#ifndef CONFIG_ARM64
+static void nim_dvb_pinctrl_put(struct wetek_nims *p)
+{
+	if (p->ts[0].pinctrl) {
+		devm_pinctrl_put(p->ts[0].pinctrl);
+		p->ts[0].pinctrl = NULL;
+	}
+}
+static struct pinctrl * __must_check nim_dvb_pinctrl_get_select(
+		struct device *dev, struct wetek_nims *p, const char *name)
+{
+	/*all dvb pinctrls share the ts[0]'s pinctrl.*/
+	struct pinctrl *pctl = p->ts[0].pinctrl;
+	
+	struct pinctrl_state *s;
+	int ret;
+
+	if (!pctl) {
+		pctl = devm_pinctrl_get(dev);
+		if (IS_ERR(pctl))
+			return pctl;
+			
+		p->ts[0].pinctrl = pctl;
+	}
+
+	s = pinctrl_lookup_state(pctl, name);
+	if (IS_ERR(s)) {
+		devm_pinctrl_put(pctl);
+		return ERR_CAST(s);
+	}
+
+	ret = pinctrl_select_state(pctl, s);
+	if (ret < 0) {
+		devm_pinctrl_put(pctl);
+		return ERR_PTR(ret);
+	}
+
+	return pctl;
+}
+#endif
+
+#ifndef CONFIG_ARCH_MESON6
+#define GPIOD_8 103
+#endif
+
+void reset_demod(void)
+{
+#ifdef CONFIG_ARM64
+	gpio_direction_output(weteknims.fec_reset, 0);
+	msleep(600);
+	gpio_direction_output(weteknims.fec_reset, 1);
+	msleep(200);
+#else
+	amlogic_gpio_direction_output(GPIOD_8, 0, "nimdetect");
+	msleep(600);
+	amlogic_gpio_direction_output(GPIOD_8, 1, "nimdetect");
+	msleep(200);
+#endif
+
+}
+static int nim_dvb_probe(struct platform_device *pdev)
+{
+	int i;
+	int ret = 0;
+#ifdef CONFIG_ARM64
+    struct gpio_desc *desc;
+#endif	 
+	weteknims.pdev = pdev;
+	weteknims.dev  = &pdev->dev;
+
+#ifdef CONFIG_ARM64
+	for (i = 0; i < TOTAL_I2C; i++) {
+	
+		weteknims.i2c[i] = i2c_get_adapter(1); //tuner1 on I2C_D
+			
+		if (weteknims.i2c[i] != NULL)
+			dev_info(&pdev->dev, "Found Wetek i2c-1 adapter ...\n");
+		else {
+			dev_info(&pdev->dev, "Failed to acquire Wetek i2c-1 adapter ...\n");	
+			return 0;
+		}	
+	}
+#else
+	/* tuner0 on I2C_A
+	   tuner1 on I2C_B
+	*/
+	for (i = 0; i < TOTAL_I2C; i++) {
+		weteknims.i2c[i] = i2c_get_adapter(i + 1);
+		if (weteknims.i2c[i] != NULL)
+			dev_info(&pdev->dev, "Found Wetek i2c-%d adapter ...\n", i + 1);
+		else {
+			dev_info(&pdev->dev, "Failed to acquire Wetek i2c-%d adapter ...\n", i + 1);	
+			return 0;
+		}	
+	}
+#endif	
+	if (pdev->dev.of_node) {
+		for (i = 0; i <  TOTAL_AML_INPUTS; i++) {
+			char buf[32];
+			const char *str;
+
+			snprintf(buf, sizeof(buf), "ts%d", i);
+			ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+			if (!ret) {
+				if (!strcmp(str, "parallel")) {
+					dev_info(&pdev->dev, "%s: parallel\n", buf);
+					snprintf(buf, sizeof(buf), "p_ts%d", i);
+					weteknims.ts[i].mode    = 1;
+#ifdef CONFIG_ARM64					
+					weteknims.ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
+#else					
+					weteknims.ts[i].pinctrl = nim_dvb_pinctrl_get_select(&pdev->dev, &weteknims, buf);
+#endif					
+				}
+			}
+		}
+	}
+#ifdef CONFIG_ARM64
+
+	dvb_demux_reset_ctl = devm_reset_control_get(&pdev->dev, "demux");
+	dev_info(&pdev->dev, "dmx rst ctl = %p\n", dvb_demux_reset_ctl);
+	reset_control_deassert(dvb_demux_reset_ctl);
+
+	dvb_afifo_reset_ctl = devm_reset_control_get(&pdev->dev, "asyncfifo");
+	dev_info(&pdev->dev, "asyncfifo rst ctl = %p\n", dvb_afifo_reset_ctl);
+	reset_control_deassert(dvb_afifo_reset_ctl);
+	
+	dvb_ahbarb0_reset_ctl = devm_reset_control_get(&pdev->dev, "ahbarb0");
+	dev_info(&pdev->dev, "ahbarb0 rst ctl = %p\n", dvb_ahbarb0_reset_ctl);
+	reset_control_deassert(dvb_ahbarb0_reset_ctl);
+	
+	dvb_uparsertop_reset_ctl = devm_reset_control_get(&pdev->dev, "uparsertop");
+	dev_info(&pdev->dev, "uparsertop rst ctl = %p\n", dvb_uparsertop_reset_ctl);
+	reset_control_deassert(dvb_uparsertop_reset_ctl);
+	
+	desc = of_get_named_gpiod_flags(pdev->dev.of_node, "fec_reset_gpio-gpios", 0, NULL);
+    weteknims.fec_reset = desc_to_gpio(desc);
+	 
+	desc = of_get_named_gpiod_flags(pdev->dev.of_node, "power_ctrl_gpio-gpios", 0, NULL);
+    weteknims.power_ctrl = desc_to_gpio(desc);
+	/* FEC_RESET  GPIOY 13*/
+	gpio_request(weteknims.fec_reset, "nimdetect"); 
+	
+	/* INPUT1 POWER CTRL GPIOY 15*/
+	gpio_request(weteknims.power_ctrl, "nimdetect"); 
+	
+	
+	/* RESET DEMOD(s) */
+	reset_demod();
+#else
+	/* FEC_RESET */
+	amlogic_gpio_request(GPIOD_8, "nimdetect"); 
+	
+	/* INPUT1 POWER CTRL */
+	amlogic_gpio_request(GPIOAO_8, "nimdetect");
+	
+	/* INPUT2 POWER CTRL */
+	amlogic_gpio_request(GPIOAO_9, "nimdetect");
+
+	amlogic_gpio_direction_output(GPIOAO_8, 0, "nimdetect"); //SWITCH OFF INPUT1 POWER		
+	amlogic_gpio_direction_output(GPIOAO_9, 0, "nimdetect"); //SWITCH OFF INPUT2 POWER		
+
+	/* RESET DEMOD(s) */
+	reset_demod();
+#endif
+
+	dev_info(&pdev->dev, "Wetek NIM(s) detection in progress ...\n");
+
+	for (i = 0; i < TOTAL_DEMODS; i++) {		
+
+#ifndef CONFIG_ARM64
+		dev_info(&pdev->dev, "Checking for Sony CXD2837 DVB-C/T/T2 demod ...\n");
+
+		weteknims.fe[i] =  cxd2837_attach(weteknims.i2c[i], &cxd2837cfg);
+
+		if (weteknims.fe[i] != NULL) {
+			if (mxl603_attach(weteknims.fe[i], weteknims.i2c[i], 0x60, &mxl603cfg) == NULL) {
+				dev_info(&pdev->dev, "Failed to find MxL603 tuner!\n");
+				dev_info(&pdev->dev, "Detaching Sony CXD2837 DVB-C/T/T2 frontend!\n");
+				dvb_frontend_detach(weteknims.fe[i]);
+				goto panasonic;
+			}
+
+			weteknims.total_nims++;
+			dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+			return 0;
+		}
+#else
+		dev_info(&pdev->dev, "Checking for Sony CXD2841ER DVB-C/T/T2 demod ...\n");
+
+		weteknims.fe[i] =  cxd2841er_attach_wetek(&cxd2841cfg, weteknims.i2c[i]);
+
+		if (weteknims.fe[i] != NULL) {
+			if (mxl603_attach(weteknims.fe[i], weteknims.i2c[i], 0x60, &mxl603cfg) == NULL) {
+				dev_info(&pdev->dev, "Failed to find MxL603 tuner!\n");
+				cxd2841cfg.if_agc = 1;
+				cxd2841cfg.ifagc_adc_range = 0x50;
+				if (ascot3_attach(weteknims.fe[i], &ascot3cfg, weteknims.i2c[i]) == NULL) {
+					dev_info(&pdev->dev, "Failed to find Sony ASCOT3 tuner!\n");
+					dvb_frontend_detach(weteknims.fe[i]);
+					goto panasonic;
+				}
+			} else 
+				cxd2841cfg.mxl603 = 1;
+
+			weteknims.total_nims++;
+			dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+			return 0;
+		}
+#endif
+
+panasonic:			
+		reset_demod();
+		dev_info(&pdev->dev, "Checking for Panasonic MN88436 ATSC demod ...\n");	
+			
+		weteknims.fe[i] =  mn88436_attach(weteknims.i2c[i], 0);
+
+		if (weteknims.fe[i] != NULL) {			
+												
+			if (mxl603_attach(weteknims.fe[i], weteknims.i2c[i], 0x60, &mxl603cfg_atsc) == NULL) {
+				dev_info(&pdev->dev, "Failed to find MxL603 tuner!\n");
+				dev_info(&pdev->dev, "Detaching Panasonic MN88436 ATSC frontend!\n");
+				dvb_frontend_detach(weteknims.fe[i]);
+				goto avl6211;
+			}
+				
+			weteknims.total_nims++;
+			dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+			return 0;
+		}
+avl6211:		
+		reset_demod();
+		dev_info(&pdev->dev, "Checking for AVL6211 DVB-S/S2 demod ...\n");
+		weteknims.fe[i] = avl6211_attach( weteknims.i2c[i], &avl6211cfg[i], i);
+		if (i == 0 && weteknims.fe[i] == NULL) {
+			dev_info(&pdev->dev, "No available NIM(s) found ...\n");
+			return 0;			
+		}
+		if (weteknims.fe[i] != NULL)
+			weteknims.total_nims++;		
+	}
+	
+	if (weteknims.total_nims > 0)
+		dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+	
+	return 0;
+}
+static int nim_dvb_remove(struct platform_device *pdev)
+{
+	int i;
+	
+	for (i = 0; i < TOTAL_DEMODS; i++) {
+		if (weteknims.fe[i] != NULL) 
+			dvb_frontend_detach(weteknims.fe[i]);
+	}
+
+	for (i = 0; i < TOTAL_I2C; i++) {
+		if (weteknims.i2c[i] != NULL)
+			i2c_put_adapter(weteknims.i2c[i]);
+	}
+#ifdef CONFIG_ARM64
+	gpio_free(weteknims.fec_reset);
+	gpio_free(weteknims.power_ctrl);
+#else
+	amlogic_gpio_free(GPIOD_8, "nimdetect");
+	amlogic_gpio_free(GPIOAO_8, "nimdetect");
+	amlogic_gpio_free(GPIOAO_9, "nimdetect");
+#endif	
+#ifdef CONFIG_ARM64
+	devm_pinctrl_put(weteknims.ts[0].pinctrl);
+	reset_control_assert(dvb_uparsertop_reset_ctl);
+	reset_control_assert(dvb_ahbarb0_reset_ctl);
+	reset_control_assert(dvb_afifo_reset_ctl);
+	reset_control_assert(dvb_demux_reset_ctl);
+#else	
+	nim_dvb_pinctrl_put(&weteknims);
+#endif	
+	return 0;
+}
+#ifndef CONFIG_ARM64
+static int wetekcard_probe(struct platform_device *pdev)
+{
+	if (pdev->dev.of_node)
+		weteknims.card_pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+
+	return 0;
+}
+static int wetekcard_remove(struct platform_device *pdev)
+{
+	if(weteknims.card_pinctrl)
+		devm_pinctrl_put(weteknims.card_pinctrl);
+	return 0;
+}
+#endif
+static const struct of_device_id nim_dvb_dt_match[] = {
+	{
+		.compatible = "amlogic,dvb",
+	},
+	{},
+};
+static struct platform_driver nim_dvb_detection = {
+	.probe		= nim_dvb_probe,
+	.remove		= nim_dvb_remove,
+	.driver		= {
+		.name	= "wetek-dvb",
+		.owner	= THIS_MODULE,
+		.of_match_table = nim_dvb_dt_match,
+	}
+};
+#ifndef CONFIG_ARM64
+static const struct of_device_id wetekcard_dt_match[]={
+	{	.compatible = "amlogic,smartcard",
+	},
+	{},
+};
+
+static struct platform_driver wetekcard_driver = {
+	.probe		= wetekcard_probe,
+    .remove		= wetekcard_remove,
+	.driver		= {
+		.name	= "wetek-card",
+		.owner	= THIS_MODULE,
+		.of_match_table = wetekcard_dt_match,
+	}
+};
+#endif
+
+int __init nim_dvb_init(void)
+{
+	int ret;
+	
+	memset(&weteknims, 0, sizeof(struct wetek_nims));
+	
+	ret = platform_driver_register(&nim_dvb_detection);
+#ifndef CONFIG_ARM64	
+	if (!ret)
+		return platform_driver_register(&wetekcard_driver);
+#endif		
+	return ret;
+}
+void __exit nim_dvb_exit(void)
+{
+	platform_driver_unregister(&nim_dvb_detection);
+#ifndef CONFIG_ARM64
+	platform_driver_unregister(&wetekcard_driver);
+#endif	
+}
+
+module_init(nim_dvb_init);
+module_exit(nim_dvb_exit);
+
+MODULE_DESCRIPTION("Wetek NIMs DVB detection");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/nimdetect.h b/drivers/amlogic/wetek/nimdetect.h
new file mode 100644
index 0000000..ea38c82
--- /dev/null
+++ b/drivers/amlogic/wetek/nimdetect.h
@@ -0,0 +1,54 @@
+/*
+ * Wetek NIM tuner(s) detection
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __NIMDETECT_H
+#define __NIMDETECT_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/dvb/version.h>
+#include <linux/platform_device.h>
+#include "dvb_frontend.h"
+
+struct ts_input {
+	int                  mode;
+	struct pinctrl      *pinctrl;
+	int                  control;
+};
+
+struct wetek_nims {
+	struct dvb_frontend 	*fe[2];
+	struct i2c_adapter 		*i2c[2];	
+	struct ts_input	   		ts[3];
+	struct device       	*dev;
+	struct platform_device  *pdev;
+	struct pinctrl      	*card_pinctrl;
+	u32 total_nims;
+#ifdef CONFIG_ARM64
+	int fec_reset;
+	int power_ctrl;
+#endif
+};
+
+void get_nims_infos(struct wetek_nims *p);
+int set_external_vol_gpio(int *demod_id, int on);
+
+#endif /* __NIMDETECT_H */
diff --git a/drivers/amlogic/wetek/wetek_amports_config.h b/drivers/amlogic/wetek/wetek_amports_config.h
new file mode 100644
index 0000000..49a05b2
--- /dev/null
+++ b/drivers/amlogic/wetek/wetek_amports_config.h
@@ -0,0 +1,112 @@
+/*
+ * drivers/amlogic/amports/amports_config.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef AMPORTS_CONFIG_HHH
+#define AMPORTS_CONFIG_HHH
+#include <linux/kconfig.h>
+#include <linux/amlogic/cpu_version.h>
+/*
+value seem:
+arch\arm\plat-meson\include\plat\cpu.h
+*/
+/*
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV
+#define HAS_VPU_PROT  0
+#define HAS_VDEC2     0
+#define HAS_HEVC_VDEC 1
+#define HAS_HDEC      1
+
+#elif MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+#define HAS_VPU_PROT  0
+#define HAS_VDEC2     0
+#define HAS_HEVC_VDEC 1
+#define HAS_HDEC      1
+
+#elif MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#define HAS_VPU_PROT  1
+#define HAS_VDEC2     (IS_MESON_M8_CPU ? 1 : 0)
+#define HAS_HEVC_VDEC (IS_MESON_M8_CPU ? 0 : 1)
+#define HAS_HDEC      1
+
+#elif  MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TVD
+#define HAS_VPU_PROT  0
+#define HAS_VDEC2     1
+#define HAS_HDEC      1
+#define HAS_HEVC_VDEC 0
+
+#else
+#define HAS_VPU_PROT  0
+#define HAS_VDEC2     0
+#define HAS_HEVC_VDEC 0
+#define HAS_HDEC      0
+
+#endif
+
+#ifndef CONFIG_AM_VDEC_H265
+#undef HAS_HEVC_VDEC
+#define HAS_HEVC_VDEC   0
+#endif
+*/
+#define HAS_VPU_PROT 0
+/*
+has vpu prot Later than m8;
+except g9tv,mtvd,m8b.
+*/
+static inline bool has_Vpu_prot(void)
+{
+	if (is_meson_g9tv_cpu() || is_meson_mtvd_cpu() || is_meson_m8b_cpu())
+		return 0;
+	else if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)
+		return 1;
+	return 0;
+}
+
+/*
+only mtvd,m8 has vdec2;
+others all don't have it.
+*/
+static inline bool has_vdec2(void)
+{
+	if (is_meson_mtvd_cpu() || is_meson_m8_cpu())
+		return 1;
+	return 0;
+}
+
+static inline bool has_hevc_vdec(void)
+{
+#ifndef CONFIG_AM_VDEC_H265
+	return 0;
+#endif
+	/*only tvd not have hevc,when later than m8 */
+	if (is_meson_mtvd_cpu())
+		return 0;
+	else if (get_cpu_type() > MESON_CPU_MAJOR_ID_M8)
+		return 1;
+	return 0;
+}
+
+static inline bool has_hdec(void)
+{
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)
+		return 1;
+	return 0;
+}
+
+
+
+#endif				/* AMPORTS_CONFIG_HHH */
+
diff --git a/drivers/amlogic/wetek/wetek_dmx.c b/drivers/amlogic/wetek/wetek_dmx.c
new file mode 100644
index 0000000..7646a1c
--- /dev/null
+++ b/drivers/amlogic/wetek/wetek_dmx.c
@@ -0,0 +1,4227 @@
+/*
+ * AMLOGIC demux driver.
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <linux/dma-mapping.h>
+#include "wetek_stb_define.h"
+#include "wetek_stb_regs_define.h"
+
+#define DMX_USE_SWFILTER    0x100
+
+#include <linux/pinctrl/pinmux.h>
+
+#include "wetek_streambuf.h"
+#include "wetek_dvb.h"
+#include "wetek_dvb_reg.h"
+
+
+#include <linux/vmalloc.h>
+
+#define ENABLE_SEC_BUFF_WATCHDOG
+#define USE_AHB_MODE
+
+#define pr_dbg_flag(_f, fmt, _args...)\
+	do {\
+		if (debug_dmx&(_f))\
+			printk("DMX: %s: "fmt, __func__, ## _args);\
+	} while (0)
+#define pr_dbg_irq_flag(_f, fmt, _args...)\
+	do {\
+		if (debug_irq&(_f))\
+			printk("DMX: %s: "fmt, __func__, ## _args);\
+	} while (0)
+#define pr_dbg(fmt, args...)	pr_dbg_flag(0x1, fmt, ## args)
+#define pr_dbg_sf(fmt, args...) pr_dbg_flag(0x4, fmt, ## args)
+#define pr_dbg_ss(fmt, args...) pr_dbg_flag(0x8, fmt, ## args)
+#define pr_dbg_irq(fmt, args...)pr_dbg_irq_flag(0x1, fmt, ## args)
+#define pr_dbg_irq_dvr(fmt, args...)pr_dbg_irq_flag(0x2, fmt, ## args)
+#define pr_dbg_irq_sf(fmt, args...) pr_dbg_irq_flag(0x4, fmt, ## args)
+#define pr_dbg_irq_ss(fmt, args...) pr_dbg_irq_flag(0x8, fmt, ## args)
+
+#define pr_error(fmt, args...) printk("DMX: " fmt, ## args)
+#define pr_inf(fmt, args...)  printk("DMX: " fmt, ## args)
+
+#define dump(b, l) \
+	do { \
+		int i; \
+		printk("dump: "); \
+		for (i = 0; i < (l); i++) {\
+			if (!(i&0xf)) \
+				printk("\n\t"); \
+			printk("%02x ", *(((unsigned char *)(b))+i)); \
+		} \
+		printk("\n"); \
+	} while (0)
+
+MODULE_PARM_DESC(debug_dmx, "\n\t\t Enable demux debug information");
+static int debug_dmx;
+module_param(debug_dmx, int, 0644);
+
+MODULE_PARM_DESC(debug_irq, "\n\t\t Enable demux IRQ debug information");
+static int debug_irq;
+module_param(debug_irq, int, 0644);
+
+static int npids = CHANNEL_COUNT;
+#define MOD_PARAM_DECLARE_CHANPIDS(_dmx) \
+MODULE_PARM_DESC(debug_dmx##_dmx##_chanpids, "\n\t\t pids of dmx channels"); \
+static short debug_dmx##_dmx##_chanpids[CHANNEL_COUNT] = \
+					{[0 ... (CHANNEL_COUNT - 1)] = -1}; \
+module_param_array(debug_dmx##_dmx##_chanpids, short, &npids, 0444)
+
+MOD_PARAM_DECLARE_CHANPIDS(0);
+MOD_PARAM_DECLARE_CHANPIDS(1);
+MOD_PARAM_DECLARE_CHANPIDS(2);
+
+#define set_debug_dmx_chanpids(_dmx, _idx, _pid)\
+	do { \
+		if ((_dmx) == 0) \
+			debug_dmx0_chanpids[(_idx)] = (_pid); \
+		else if ((_dmx) == 1) \
+			debug_dmx1_chanpids[(_idx)] = (_pid); \
+		else if ((_dmx) == 2) \
+			debug_dmx2_chanpids[(_idx)] = (_pid); \
+	} while (0)
+
+MODULE_PARM_DESC(debug_sf_user, "\n\t\t only for sf mode check");
+static int debug_sf_user;
+module_param(debug_sf_user, int, 0644);
+
+MODULE_PARM_DESC(force_sec_sf, "\n\t\t force sf mode for sec filter");
+static int force_sec_sf;
+module_param(force_sec_sf, int, 0644);
+
+MODULE_PARM_DESC(force_pes_sf, "\n\t\t force sf mode for pes filter");
+static int force_pes_sf;
+module_param(force_pes_sf, int, 0644);
+
+#define DMX_READ_REG(i, r)\
+	((i)?((i == 1)?READ_MPEG_REG(r##_2) :\
+	READ_MPEG_REG(r##_3)) : READ_MPEG_REG(r))
+
+#define DMX_WRITE_REG(i, r, d)\
+	do {\
+		if (i == 1) {\
+			WRITE_MPEG_REG(r##_2, d);\
+		} else if (i == 2) {\
+			WRITE_MPEG_REG(r##_3, d);\
+		} \
+		else {\
+			WRITE_MPEG_REG(r, d);\
+		} \
+	} while (0)
+
+#define READ_PERI_REG			READ_CBUS_REG
+#define WRITE_PERI_REG			WRITE_CBUS_REG
+
+#define READ_ASYNC_FIFO_REG(i, r)\
+	((i) ? READ_PERI_REG(ASYNC_FIFO2_##r) : READ_PERI_REG(ASYNC_FIFO_##r))
+
+#define WRITE_ASYNC_FIFO_REG(i, r, d)\
+	do {\
+		if (i == 1) {\
+			WRITE_PERI_REG(ASYNC_FIFO2_##r, d);\
+		} else {\
+			WRITE_PERI_REG(ASYNC_FIFO_##r, d);\
+		} \
+	} while (0)
+
+#define CLEAR_ASYNC_FIFO_REG_MASK(i, reg, mask) \
+	WRITE_ASYNC_FIFO_REG(i, reg, \
+	(READ_ASYNC_FIFO_REG(i, reg)&(~(mask))))
+
+#define DVR_FEED(f) \
+	((f) && ((f)->type == DMX_TYPE_TS) &&	\
+	(((f)->ts_type & (TS_PACKET | TS_DEMUX)) == TS_PACKET))
+
+#define MOD_PARAM_DECLARE_CHANREC(_dmx) \
+MODULE_PARM_DESC(dmx##_dmx##_chanrec_enable, \
+	       "\n\t\t record by channel, one time use in the beginning"); \
+static int dmx##_dmx##_chanrec_enable; \
+module_param(dmx##_dmx##_chanrec_enable, int, 0644); \
+MODULE_PARM_DESC(dmx##_dmx##_chanrec, "\n\t\t record channels bits"); \
+static int dmx##_dmx##_chanrec; \
+module_param(dmx##_dmx##_chanrec, int, 0644)
+
+MOD_PARAM_DECLARE_CHANREC(0);
+MOD_PARAM_DECLARE_CHANREC(1);
+MOD_PARAM_DECLARE_CHANREC(2);
+
+#define MOD_PARAM_DECLARE_CHANPROC(_dmx) \
+MODULE_PARM_DESC(dmx##_dmx##_chanproc_enable, "channel further processing"); \
+static int dmx##_dmx##_chanproc_enable; \
+module_param(dmx##_dmx##_chanproc_enable, int, 0644); \
+MODULE_PARM_DESC(dmx##_dmx##_chanproc, "further process channels bits"); \
+static int dmx##_dmx##_chanproc; \
+module_param(dmx##_dmx##_chanproc, int, 0644)
+
+MOD_PARAM_DECLARE_CHANPROC(0);
+MOD_PARAM_DECLARE_CHANPROC(1);
+MOD_PARAM_DECLARE_CHANPROC(2);
+
+#define DMX_CH_OP_CHANREC  0
+#define DMX_CH_OP_CHANPROC 1
+
+static inline int _setbit(int v, int b) { return v|(1<<b); }
+static inline int _clrbit(int v, int b) { return v&~(1<<b); }
+static inline int _set(int v, int b) { return b; }
+static void dmxn_op_chan(int dmx, int ch, int(*op)(int, int), int ch_op)
+{
+	int enable_0, enable_1, enable_2;
+	int *set_0, *set_1, *set_2;
+	int reg;
+
+	if (ch_op == DMX_CH_OP_CHANREC) {
+		enable_0 = dmx0_chanrec_enable;
+		enable_1 = dmx1_chanrec_enable;
+		enable_2 = dmx2_chanrec_enable;
+		set_0 = &dmx0_chanrec;
+		set_1 = &dmx1_chanrec;
+		set_2 = &dmx2_chanrec;
+		reg = DEMUX_CHAN_RECORD_EN;
+	} else if (ch_op == DMX_CH_OP_CHANPROC) {
+		enable_0 = dmx0_chanproc_enable;
+		enable_1 = dmx1_chanproc_enable;
+		enable_2 = dmx2_chanproc_enable;
+		set_0 = &dmx0_chanproc;
+		set_1 = &dmx1_chanproc;
+		set_2 = &dmx2_chanproc;
+		reg = DEMUX_CHAN_PROCESS_EN;
+	} else {
+		return;
+	}
+	if (dmx == 0) {
+		if (enable_0) {
+			*set_0 = op(*set_0, ch);
+			WRITE_MPEG_REG(reg+DEMUX_1_OFFSET, *set_0);
+		}
+	} else if (dmx == 1) {
+		if (enable_1) {
+			*set_1 = op(*set_1, ch);
+			WRITE_MPEG_REG(reg+DEMUX_2_OFFSET, *set_1);
+		}
+	} else if (dmx == 2) {
+		if (enable_2) {
+			*set_2 = op(*set_2, ch);
+			WRITE_MPEG_REG(reg+DEMUX_3_OFFSET, *set_2);
+		}
+	}
+}
+#define dmx_add_recchan(_dmx, _chid) \
+	do { \
+		pr_dbg("dmx[%d]_add_recchan[%d]\n", _dmx, _chid); \
+		dmxn_op_chan(_dmx, _chid, _setbit, DMX_CH_OP_CHANREC); \
+	} while (0)
+#define dmx_rm_recchan(_dmx, _chid) \
+	do { \
+		pr_dbg("dmx[%d]_rm_recchan[%ld]\n", _dmx, _chid); \
+		dmxn_op_chan(_dmx, _chid, _clrbit, DMX_CH_OP_CHANREC); \
+	} while (0)
+#define dmx_set_recchan(_dmx, _chs) \
+	do { \
+		pr_dbg("dmx[%d]_set_recchan[%d]\n", _dmx, _chs); \
+		dmxn_op_chan(_dmx, _chs, _set, DMX_CH_OP_CHANREC); \
+	} while (0)
+
+#define dmx_add_procchan(_dmx, _chid) \
+	do { \
+		pr_dbg("dmx[%d]_add_procchan[%d]\n", _dmx, _chid); \
+		dmxn_op_chan(_dmx, _chid, _setbit, DMX_CH_OP_CHANPROC); \
+	} while (0)
+#define dmx_rm_procchan(_dmx, _chid) \
+	do { \
+		pr_dbg("dmx[%d]_rm_procchan[%ld]\n", _dmx, _chid); \
+		dmxn_op_chan(_dmx, _chid, _clrbit, DMX_CH_OP_CHANPROC); \
+	} while (0)
+#define dmx_set_procchan(_dmx, _chs) \
+	do { \
+		pr_dbg("dmx[%d]_set_procchan[%d]\n", _dmx, _chs); \
+		dmxn_op_chan(_dmx, _chs, _set, DMX_CH_OP_CHANPROC); \
+	} while (0)
+
+#define NO_SUB
+
+#define SYS_CHAN_COUNT    (4)
+#define SEC_GRP_LEN_0     (0xc)
+#define SEC_GRP_LEN_1     (0xc)
+#define SEC_GRP_LEN_2     (0xc)
+#define SEC_GRP_LEN_3     (0xc)
+#define LARGE_SEC_BUFF_MASK  0xFFFFFFFF
+#define LARGE_SEC_BUFF_COUNT 32
+#define WATCHDOG_TIMER    250
+#define ASYNCFIFO_PACKETS 2048
+#define ASYNCFIFO_BUFFER_SIZE_DEFAULT (188 * ASYNCFIFO_PACKETS)
+
+#define DEMUX_INT_MASK\
+			((0<<(AUDIO_SPLICING_POINT))    |\
+			(0<<(VIDEO_SPLICING_POINT))     |\
+			(0<<(OTHER_PES_READY))          |\
+			(1<<(SUB_PES_READY))            |\
+			(1<<(SECTION_BUFFER_READY))     |\
+			(0<<(OM_CMD_READ_PENDING))      |\
+			(1<<(TS_ERROR_PIN))             |\
+			(1<<(NEW_PDTS_READY))           |\
+			(0<<(DUPLICATED_PACKET))        |\
+			(0<<(DIS_CONTINUITY_PACKET)))
+
+#define TS_SRC_MAX 3
+
+/*Reset the demux device*/
+#define RESET_DEMUX2      (1<<15)
+#define RESET_DEMUX1      (1<<14)
+#define RESET_DEMUX0      (1<<13)
+#define RESET_S2P1        (1<<12)
+#define RESET_S2P0        (1<<11)
+#define RESET_DES         (1<<10)
+#define RESET_TOP         (1<<9)
+
+static int dmx_remove_feed(struct wetek_dmx *dmx, struct dvb_demux_feed *feed);
+static void reset_async_fifos(struct wetek_dvb *dvb);
+static int dmx_add_feed(struct wetek_dmx *dmx, struct dvb_demux_feed *feed);
+static int dmx_smallsec_set(struct wetek_smallsec *ss, int enable, int bufsize,
+				int force);
+static int dmx_timeout_set(struct wetek_dmxtimeout *dto, int enable,
+				int timeout, int ch_dis, int nomatch,
+				int force);
+
+/*Audio & Video PTS value*/
+static u32 video_pts;
+static u32 audio_pts;
+static u32 first_video_pts;
+static u32 first_audio_pts;
+static int demux_skipbyte;
+static int tsfile_clkdiv = 4;
+
+#define SF_DMX_ID 2
+#define SF_AFIFO_ID 1
+
+#define sf_dmx_sf(_dmx) \
+	(((_dmx)->id == SF_DMX_ID) \
+	&& ((struct wetek_dvb *)(_dmx)->demux.priv)->swfilter.user)
+#define sf_afifo_sf(_afifo) \
+	(((_afifo)->id == SF_AFIFO_ID) && (_afifo)->dvb->swfilter.user)
+#define dmx_get_dev(dmx) (((struct wetek_dvb *)((dmx)->demux.priv))->dev)
+#define asyncfifo_get_dev(afifo) ((afifo)->dvb->dev)
+
+/*Section buffer watchdog*/
+static void section_buffer_watchdog_func(unsigned long arg)
+{
+	struct wetek_dvb *dvb = (struct wetek_dvb *)arg;
+	struct wetek_dmx *dmx;
+	u32 section_busy32 = 0, om_cmd_status32 = 0,
+	    demux_channel_activity32 = 0;
+	u16 demux_int_status1 = 0;
+	u32 device_no = 0;
+	u32 filter_number = 0;
+	u32 i = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	for (device_no = 0; device_no < DMX_DEV_COUNT; device_no++) {
+
+		dmx = &dvb->dmx[device_no];
+
+		if (dvb->dmx_watchdog_disable[device_no])
+			continue;
+
+		if (!dmx->init)
+			continue;
+
+		om_cmd_status32 =
+		    DMX_READ_REG(device_no, OM_CMD_STATUS);
+		demux_channel_activity32 =
+		    DMX_READ_REG(device_no, DEMUX_CHANNEL_ACTIVITY);
+		section_busy32 =
+			DMX_READ_REG(device_no, SEC_BUFF_BUSY);
+
+		if (om_cmd_status32 & 0x8fc2) {
+			/* bit 15:12 -- om_cmd_count */
+			/* bit  11:9 -- overflow_count */
+			/* bit   8:6 -- om_overwrite_count */
+			/* bit     1 -- om_cmd_overflow */
+			/*BUG: If the recoder is running, return */
+			if (dmx->record)
+				goto end;
+			/*Reset the demux */
+			pr_dbg("reset the demux\n"
+			"%04x\t%03x\t%03x\t%03x\t%01x\t%01x\t"
+			"%x\t%x\tdmx%d:status:0x%x\n",
+			(om_cmd_status32 >> 12) & 0xf,
+			(om_cmd_status32 >> 9) & 0x7,
+			(om_cmd_status32 >> 6) & 0x7,
+			(om_cmd_status32 >> 3) & 0x7,
+			(om_cmd_status32 >> 2) & 0x1,
+			(om_cmd_status32 >> 1) & 0x1,
+			demux_channel_activity32, section_busy32,
+			dmx->id, om_cmd_status32);
+
+			dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+			goto end;
+		}
+		section_busy32 =
+			DMX_READ_REG(device_no, SEC_BUFF_BUSY);
+		if (LARGE_SEC_BUFF_MASK ==
+				(section_busy32 & LARGE_SEC_BUFF_MASK)) {
+			/*All the largest section buffers occupied,
+			 * clear buffers */
+			DMX_WRITE_REG(device_no,
+					SEC_BUFF_READY, section_busy32);
+		} else {
+			for (i = 0; i < SEC_BUF_COUNT; i++) {
+				if (!(section_busy32 & (1 << i)))
+					continue;
+				DMX_WRITE_REG(device_no, SEC_BUFF_NUMBER, i);
+				filter_number =	DMX_READ_REG(device_no,
+							SEC_BUFF_NUMBER);
+				filter_number >>= 8;
+				if ((filter_number >= FILTER_COUNT)
+					/* >=31, do not handle this case */
+					|| ((filter_number < FILTER_COUNT)
+					&& dmx->filter[filter_number].used))
+					section_busy32 &= ~(1 << i);
+			}
+			if (section_busy32 & (dmx->smallsec.enable ?
+						0x7FFFFFFF :
+						LARGE_SEC_BUFF_MASK)) {
+				/*Clear invalid buffers */
+				DMX_WRITE_REG(device_no,
+						SEC_BUFF_READY,
+						section_busy32);
+				pr_error("clear invalid buffer 0x%x\n",
+						section_busy32);
+			}
+		}
+		demux_int_status1 =
+			DMX_READ_REG(device_no, STB_INT_STATUS) & 0xfff7;
+		if (demux_int_status1 & (1 << TS_ERROR_PIN)) {
+			DMX_WRITE_REG(device_no,
+				STB_INT_STATUS,
+				(1 << TS_ERROR_PIN));
+		}
+	}
+
+end:
+	spin_unlock_irqrestore(&dvb->slock, flags);
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	mod_timer(&dvb->watchdog_timer,
+		  jiffies + msecs_to_jiffies(WATCHDOG_TIMER));
+#endif
+	return;
+}
+
+static inline int sec_filter_match(struct wetek_dmx *dmx, struct wetek_filter *f,
+				   u8 *p)
+{
+	int b;
+	u8 neq = 0;
+
+	if (!f->used || !dmx->channel[f->chan_id].used)
+		return 0;
+
+	for (b = 0; b < FILTER_LEN; b++) {
+		u8 xor = p[b] ^ f->value[b];
+
+		if (xor & f->maskandmode[b])
+			return 0;
+
+		if (xor & f->maskandnotmode[b])
+			neq = 1;
+	}
+
+	if (f->neq && !neq)
+		return 0;
+
+	return 1;
+}
+
+static int section_crc(struct wetek_dmx *dmx, struct wetek_filter *f, u8 *p)
+{
+	int sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
+	struct dvb_demux_feed *feed = dmx->channel[f->chan_id].feed;
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+
+	if (feed->feed.sec.check_crc) {
+		struct dvb_demux *demux = feed->demux;
+		struct dmx_section_feed *sec = &feed->feed.sec;
+		int section_syntax_indicator;
+
+		section_syntax_indicator = ((p[1] & 0x80) != 0);
+		sec->seclen = sec_len;
+		sec->crc_val = ~0;
+		if (demux->check_crc32(feed, p, sec_len)) {
+			pr_error("section CRC check failed!\n");
+			dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static void section_notify(struct wetek_dmx *dmx, struct wetek_filter *f, u8 *p)
+{
+	int sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
+	struct dvb_demux_feed *feed = dmx->channel[f->chan_id].feed;
+
+	if (feed && feed->cb.sec)
+		feed->cb.sec(p, sec_len, NULL, 0, f->filter, DMX_OK);
+}
+
+static void hardware_match_section(struct wetek_dmx *dmx,
+						u16 sec_num, u16 buf_num)
+{
+	u8 *p = (u8 *) dmx->sec_buf[buf_num].addr;
+	struct wetek_filter *f;
+	int chid, i;
+	int need_crc = 1;
+
+	if (sec_num >= FILTER_COUNT) {
+		pr_dbg("sec_num invalid: %d\n", sec_num);
+		return;
+	}
+
+	dma_sync_single_for_cpu(dmx_get_dev(dmx),
+				dmx->sec_pages_map + (buf_num << 0x0c),
+				(1 << 0x0c), DMA_FROM_DEVICE);
+
+	f = &dmx->filter[sec_num];
+	chid = f->chan_id;
+
+	for (i = 0; i < FILTER_COUNT; i++) {
+		f = &dmx->filter[i];
+		if (f->chan_id != chid)
+			continue;
+		if (sec_filter_match(dmx, f, p)) {
+			if (need_crc) {
+				if (!section_crc(dmx, f, p))
+					return;
+				need_crc = 0;
+			}
+
+			section_notify(dmx, f, p);
+		}
+	}
+}
+
+static void software_match_section(struct wetek_dmx *dmx, u16 buf_num)
+{
+	u8 *p = (u8 *) dmx->sec_buf[buf_num].addr;
+	struct wetek_filter *f, *fmatch = NULL;
+	int i, fid = -1;
+
+	dma_sync_single_for_cpu(dmx_get_dev(dmx),
+				dmx->sec_pages_map + (buf_num << 0x0c),
+				(1 << 0x0c), DMA_FROM_DEVICE);
+
+	for (i = 0; i < FILTER_COUNT; i++) {
+		f = &dmx->filter[i];
+
+		if (sec_filter_match(dmx, f, p)) {
+			pr_dbg("[software match]filter %d match, pid %d\n",
+			       i, dmx->channel[f->chan_id].pid);
+			if (!fmatch) {
+				fmatch = f;
+				fid = i;
+			} else {
+				pr_dbg("software match]Muli-filter match this\n"
+					"section, will skip this section\n");
+				return;
+			}
+		}
+	}
+
+	if (fmatch) {
+		pr_dbg("[software match]dispatch\n"
+			"section to filter %d pid %d\n",
+			fid, dmx->channel[fmatch->chan_id].pid);
+		if (section_crc(dmx, fmatch, p))
+			section_notify(dmx, fmatch, p);
+	} else {
+		pr_dbg("[software match]this section do not\n"
+			"match any filter!!!\n");
+	}
+}
+
+
+static int _rbuf_write(struct dvb_ringbuffer *buf, const u8 *src, size_t len)
+{
+	ssize_t free;
+
+	if (!len)
+		return 0;
+	if (!buf->data)
+		return 0;
+
+	free = dvb_ringbuffer_free(buf);
+	if (len > free) {
+		pr_error("sf: buffer overflow\n");
+		return -EOVERFLOW;
+	}
+
+	return dvb_ringbuffer_write(buf, src, len);
+}
+
+static int _rbuf_filter_pkts(struct dvb_ringbuffer *rb,
+			u8 *wrapbuf,
+			void (*swfilter_packets)(struct dvb_demux *demux,
+						const u8 *buf,
+						size_t count),
+			struct dvb_demux *demux)
+{
+	ssize_t len1 = 0;
+	ssize_t len2 = 0;
+	size_t off;
+	size_t count;
+	size_t size;
+
+	if (debug_irq & 0x4)
+		dump(&rb->data[rb->pread], (debug_irq & 0xFFF00) >> 8);
+
+	/*
+	   rb|====--------===[0x47]====|
+	   ^             ^
+	   wr            rd
+	 */
+
+	len1 = rb->pwrite - rb->pread;
+	if (len1 < 0) {
+		len1 = rb->size - rb->pread;
+		len2 = rb->pwrite;
+	}
+
+	for (off = 0; off < len1; off++) {
+		if (rb->data[rb->pread + off] == 0x47)
+			break;
+	}
+
+	if (off)
+		pr_dbg_irq_sf("off ->|%zd\n", off);
+
+	len1 -= off;
+	rb->pread = (rb->pread + off) % rb->size;
+
+	count = len1 / 188;
+	if (count) {
+		pr_dbg_irq_sf("pkt >> 1[%zd<->%zd]\n", rb->pread, rb->pwrite);
+		swfilter_packets(demux, rb->data + rb->pread, count);
+
+		size = count * 188;
+		len1 -= size;
+		rb->pread += size;
+	}
+
+	if (len2 && len1 && ((len1 + len2) > 188)) {
+		pr_dbg_irq_sf("pkt >> 2[%zd<->%zd]\n", rb->pread, rb->pwrite);
+		size = 188 - len1;
+		memcpy(wrapbuf, rb->data + rb->pread, len1);
+		memcpy(wrapbuf + len1, rb->data, size);
+		swfilter_packets(demux, wrapbuf, 1);
+		rb->pread = size;
+		len2 -= size;
+	}
+
+	if (len2) {
+		pr_dbg_irq_sf("pkt >> 3[%zd<->%zd]\n", rb->pread, rb->pwrite);
+		count = len2 / 188;
+		if (count) {
+			swfilter_packets(demux, rb->data + rb->pread, count);
+			rb->pread += count * 188;
+		}
+	}
+	return 0;
+}
+
+static void smallsection_match_section(struct wetek_dmx *dmx, u8 *p, u16 sec_num)
+{
+	struct wetek_filter *f;
+	int chid, i;
+	int need_crc = 1;
+
+	if (sec_num >= FILTER_COUNT) {
+		pr_dbg("sec_num invalid: %d\n", sec_num);
+		return;
+	}
+
+	f = &dmx->filter[sec_num];
+	chid = f->chan_id;
+
+	for (i = 0; i < FILTER_COUNT; i++) {
+		f = &dmx->filter[i];
+		if (f->chan_id != chid)
+			continue;
+		if (sec_filter_match(dmx, f, p)) {
+			if (need_crc) {
+				if (!section_crc(dmx, f, p))
+					return;
+				need_crc = 0;
+			}
+
+			section_notify(dmx, f, p);
+		}
+	}
+
+}
+static void process_smallsection(struct wetek_dmx *dmx)
+{
+
+	u32 v, wr, rd;
+	u32 data32;
+	struct wetek_smallsec *ss = &dmx->smallsec;
+
+	v = DMX_READ_REG(dmx->id, DEMUX_SMALL_SEC_CTL);
+	wr = (v >> 8) & 0xff;
+	rd = (v >> 16) & 0xff;
+
+	if (rd != wr) {
+		int n1 = wr - rd,
+		    n2 = 0,
+		    max = (ss->bufsize>>8);
+		int i;
+		u8 *p;
+		int sec_len;
+
+		pr_dbg_irq_ss("secbuf[31] ctrl:0x%x\n", v);
+
+		if (n1 < 0) {
+			n1 = max - rd;
+			n2 = wr;
+		}
+		if (n1) {
+			pr_dbg_irq_ss("n1:%d\n", n1);
+			dma_sync_single_for_cpu(dmx_get_dev(dmx),
+						ss->buf_map+(rd<<8),
+						n1<<8,
+						DMA_FROM_DEVICE);
+			for (i = 0; i < n1; i++) {
+				p = (u8 *)ss->buf+((rd+i)<<8);
+				sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
+				smallsection_match_section(dmx, p,
+							*(p+sec_len+1));
+			}
+		}
+		if (n2) {
+			pr_dbg_irq_ss("n2:%d\n", n2);
+			dma_sync_single_for_cpu(dmx_get_dev(dmx),
+						ss->buf_map,
+						n2<<8,
+						DMA_FROM_DEVICE);
+			for (i = 0; i < n2; i++) {
+				p = (u8 *)ss->buf+(i<<8);
+				sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
+				smallsection_match_section(dmx, p,
+							*(p+sec_len+1));
+			}
+		}
+
+		rd = wr;
+		data32 = (DMX_READ_REG(dmx->id,	DEMUX_SMALL_SEC_CTL)
+				& 0xff00ffff)
+				| (rd << 16);
+		DMX_WRITE_REG(dmx->id, DEMUX_SMALL_SEC_CTL, data32);
+	}
+}
+
+
+static void process_section(struct wetek_dmx *dmx)
+{
+	u32 ready, i, sec_busy;
+	u16 sec_num;
+
+	ready = DMX_READ_REG(dmx->id, SEC_BUFF_READY);
+	if (ready) {
+	pr_dbg("section ready:%08x\n",ready); 
+
+		if ((ready & (1<<31)) && dmx->smallsec.enable) {
+			u32 v, wr, rd;
+			v = DMX_READ_REG(dmx->id, DEMUX_SMALL_SEC_CTL);
+			wr = (v >> 8) & 0xff;
+			rd = (v >> 16) & 0xff;
+			if ((wr < rd) && (5 > (rd - wr)))
+				pr_error("warning: small ss buf [w%dr%d]\n",
+					wr, rd);
+			pr_dbg_irq_ss("ss>%x\n",
+				DMX_READ_REG(dmx->id, DEMUX_SMALL_SEC_CTL));
+			process_smallsection(dmx);
+			/*tasklet_hi_schedule(&dmx->dmx_tasklet);*/
+			/*tasklet_schedule(&dmx->dmx_tasklet);*/
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, (1<<31));
+			return;
+		}
+
+		for (i = 0; i < SEC_BUF_COUNT; i++) {
+
+			if (!(ready & (1 << i)))
+				continue;
+
+			/* get section busy */
+			sec_busy = DMX_READ_REG(dmx->id, SEC_BUFF_BUSY);
+			/* get filter number */
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_NUMBER, i);
+			sec_num = (DMX_READ_REG(dmx->id, SEC_BUFF_NUMBER) >> 8);
+			pr_dbg("%d. sec_busy:%08x sec_num:%d\n", i, sec_busy, sec_num);
+
+			/*
+			 * sec_buf_watchdog_count dispatch:
+			 * byte0 -- always busy=0 's watchdog count
+			 * byte1 -- always busy=1 & filter_num=31 's
+			 * watchdog count
+			 */
+
+			/* sec_busy is not set, check busy=0 watchdog count */
+			if (!(sec_busy & (1 << i))) {
+				/* clear other wd count	of this buffer */
+				dmx->sec_buf_watchdog_count[i] &= 0x000000ff;
+				dmx->sec_buf_watchdog_count[i] += 0x1;
+				pr_dbg("bit%d ready=1, busy=0,\n"
+					"sec_num=%d for %d times\n",
+					i, sec_num,
+					dmx->sec_buf_watchdog_count[i]);
+				if (dmx->sec_buf_watchdog_count[i] >= 5) {
+					pr_dbg("busy=0 reach the max count,\n"
+						"try software match.\n");
+					software_match_section(dmx, i);
+					dmx->sec_buf_watchdog_count[i] = 0;
+					DMX_WRITE_REG(dmx->id, SEC_BUFF_READY,
+							(1 << i));
+				}
+				continue;
+			}
+
+			/* filter_num == 31 && busy == 1,check watchdog count */
+			if (sec_num >= FILTER_COUNT) {
+				/* clear other wd count	of this buffer */
+				dmx->sec_buf_watchdog_count[i] &= 0x0000ff00;
+				dmx->sec_buf_watchdog_count[i] += 0x100;
+				pr_dbg("bit%d ready=1,busy=1,\n"
+					"sec_num=%d for %d times\n",
+					i, sec_num,
+					dmx->sec_buf_watchdog_count[i] >> 8);
+				if (dmx->sec_buf_watchdog_count[i] >= 0x500) {
+					pr_dbg("busy=1&filter_num=31\n"
+					" reach the max count, clear\n"
+					" the buf ready & busy!\n");
+					software_match_section(dmx, i);
+					dmx->sec_buf_watchdog_count[i] = 0;
+					DMX_WRITE_REG(dmx->id,
+						      SEC_BUFF_READY,
+						      (1 << i));
+					DMX_WRITE_REG(dmx->id,
+						      SEC_BUFF_BUSY,
+						      (1 << i));
+				}
+				continue;
+			}
+
+			/* now, ready & busy are both set and
+			 filter number is valid */
+			if (dmx->sec_buf_watchdog_count[i] != 0)
+				dmx->sec_buf_watchdog_count[i] = 0;
+
+			/* process this section */
+			hardware_match_section(dmx, sec_num, i);
+
+			/* clear the ready & busy bit */
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, (1 << i));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_BUSY, (1 << i));
+		}
+	}
+}
+
+#ifdef NO_SUB
+static void process_sub(struct wetek_dmx *dmx)
+{
+
+	u32 rd_ptr = 0;
+
+	u32 wr_ptr = READ_MPEG_REG(PARSER_SUB_WP);
+	u32 start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
+	u32 end_ptr = READ_MPEG_REG(PARSER_SUB_END_PTR);
+
+	u32 buffer1 = 0, buffer2 = 0;
+	unsigned char *buffer1_virt = 0, *buffer2_virt = 0;
+	u32 len1 = 0, len2 = 0;
+
+	rd_ptr = READ_MPEG_REG(PARSER_SUB_RP);
+	if (!rd_ptr)
+		return;
+	if (rd_ptr > wr_ptr) {
+		len1 = end_ptr - rd_ptr + 8;
+		buffer1 = rd_ptr;
+
+		len2 = wr_ptr - start_ptr;
+		buffer2 = start_ptr;
+
+		rd_ptr = start_ptr + len2;
+	} else if (rd_ptr < wr_ptr) {
+		len1 = wr_ptr - rd_ptr;
+		buffer1 = rd_ptr;
+		rd_ptr += len1;
+		len2 = 0;
+	} else if (rd_ptr == wr_ptr) {
+		pr_dbg("no data\n");
+	}
+
+	if (buffer1)
+		buffer1_virt = phys_to_virt(buffer1);
+	if (buffer2)
+		buffer2_virt = phys_to_virt(buffer2);
+
+	if (len1)
+		dma_sync_single_for_cpu(dmx_get_dev(dmx),
+					(dma_addr_t) buffer1, len1,
+					DMA_FROM_DEVICE);
+	if (len2)
+		dma_sync_single_for_cpu(dmx_get_dev(dmx),
+					(dma_addr_t) buffer2, len2,
+					DMA_FROM_DEVICE);
+
+	if (dmx->channel[2].used) {
+		if (dmx->channel[2].feed && dmx->channel[2].feed->cb.ts) {
+			dmx->channel[2].feed->cb.ts(buffer1_virt, len1,
+						buffer2_virt, len2,
+						&dmx->channel[2].feed->feed.ts, DMX_OK);
+		}
+	}
+	WRITE_MPEG_REG(PARSER_SUB_RP, rd_ptr);
+}
+#endif
+
+static void process_pes(struct wetek_dmx *dmx)
+{
+}
+
+static void process_om_read(struct wetek_dmx *dmx)
+{
+	unsigned i;
+	unsigned short om_cmd_status_data_0 = 0;
+	unsigned short om_cmd_status_data_1 = 0;
+/*      unsigned short om_cmd_status_data_2 = 0;*/
+	unsigned short om_cmd_data_out = 0;
+
+	om_cmd_status_data_0 = DMX_READ_REG(dmx->id, OM_CMD_STATUS);
+	om_cmd_status_data_1 = DMX_READ_REG(dmx->id, OM_CMD_DATA);
+/*      om_cmd_status_data_2 = DMX_READ_REG(dmx->id, OM_CMD_DATA2);*/
+
+	if (om_cmd_status_data_0 & 1) {
+		DMX_WRITE_REG(dmx->id, OM_DATA_RD_ADDR,
+			(1 << 15) | ((om_cmd_status_data_1 & 0xff) << 2));
+		for (i = 0; i < (((om_cmd_status_data_1 >> 7) & 0x1fc) >> 1);
+		     i++) {
+			om_cmd_data_out = DMX_READ_REG(dmx->id, OM_DATA_RD);
+		}
+
+		om_cmd_data_out = DMX_READ_REG(dmx->id, OM_DATA_RD_ADDR);
+		DMX_WRITE_REG(dmx->id, OM_DATA_RD_ADDR, 0);
+		DMX_WRITE_REG(dmx->id, OM_CMD_STATUS, 1);
+	}
+}
+
+static void dmx_irq_bh_handler(unsigned long arg)
+{
+	struct wetek_dmx *dmx = (struct wetek_dmx *)arg;
+
+	pr_dbg_irq("demux %d irq dmx:%p\n", dmx->id, dmx);
+	process_smallsection(dmx);
+	return;
+}
+
+static irqreturn_t dmx_irq_handler(int irq_number, void *para)
+{
+	struct wetek_dmx *dmx = (struct wetek_dmx *)para;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	u32 status, pdts_status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	status = DMX_READ_REG(dmx->id, STB_INT_STATUS);
+	if (!status)
+		goto irq_handled;
+
+	pr_dbg_irq("demux %d irq:%d status: %04x\n", dmx->id, irq_number, status);
+
+	if (status & (1 << SECTION_BUFFER_READY)) {
+		process_section(dmx);
+	}
+	if (status & (1 << TS_ERROR_PACKAGE)) {
+	DMX_WRITE_REG(dmx->id, STB_INT_STATUS, status);
+		goto irq_handled;
+	}
+#ifdef NO_SUB
+	if (status & (1 << SUB_PES_READY)) {
+		/*If the subtitle is set by tsdemux,
+		do not parser in demux driver. */
+		if (dmx->sub_chan == -1)
+			process_sub(dmx);
+	}
+#endif
+	if (status & (1 << OTHER_PES_READY))  {
+		process_pes(dmx);
+	}
+	if (status & (1 << OM_CMD_READ_PENDING))
+		process_om_read(dmx);
+	if (status & (1 << NEW_PDTS_READY)) {
+		pdts_status = DMX_READ_REG(dmx->id, STB_PTS_DTS_STATUS);
+
+		if (pdts_status & (1 << VIDEO_PTS_READY)) {
+			video_pts = DMX_READ_REG(dmx->id, VIDEO_PTS_DEMUX);
+			if (!first_video_pts
+			    || 0 > (int)(video_pts - first_video_pts))
+				first_video_pts = video_pts;
+		}
+
+		if (pdts_status & (1 << AUDIO_PTS_READY)) {
+			audio_pts = DMX_READ_REG(dmx->id, AUDIO_PTS_DEMUX);
+			if (!first_audio_pts
+			    || 0 > (int)(audio_pts - first_audio_pts))
+				first_audio_pts = audio_pts;
+		}
+	}
+
+	if (dmx->irq_handler)
+		dmx->irq_handler(dmx->dmx_irq, (void *)(long)dmx->id);
+
+	DMX_WRITE_REG(dmx->id, STB_INT_STATUS, status);
+
+	/*tasklet_schedule(&dmx->dmx_tasklet);*/
+
+	{
+		if (!dmx->int_check_time) {
+			dmx->int_check_time = jiffies;
+			dmx->int_check_count = 0;
+		}
+
+		if (jiffies_to_msecs(jiffies - dmx->int_check_time) >= 100
+		    || dmx->int_check_count > 1000) {
+			if (dmx->int_check_count > 1000) {
+				struct wetek_dvb *dvb =
+				    (struct wetek_dvb *)dmx->demux.priv;
+				pr_error("Too many interrupts "
+					"(%d interrupts in %d ms)!\n",
+					dmx->int_check_count,
+					jiffies_to_msecs(jiffies -
+						      dmx->int_check_time));
+				if (dmx->fe && !dmx->in_tune) {
+					DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+//					dvb_frontend_retune(dmx->fe);
+				}
+				dmx_reset_hw_ex(dvb, 0);
+			}
+			dmx->int_check_time = 0;
+		}
+
+		dmx->int_check_count++;
+
+		if (dmx->in_tune) {
+			dmx->error_check++;
+			if (dmx->error_check > 200)
+				DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+		}
+	}
+
+irq_handled:
+	spin_unlock_irqrestore(&dvb->slock, flags);
+	return IRQ_HANDLED;
+}
+
+static inline int dmx_get_order(unsigned long size)
+{
+	int order;
+
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+
+	return order;
+}
+
+static void dvr_process_channel(struct wetek_asyncfifo *afifo,
+				struct wetek_channel *channel,
+				u32 total, u32 size,
+				struct wetek_swfilter *sf)
+{
+	int cnt;
+	int ret = 0;
+	pr_dbg_irq_dvr("buf_read:%d buf_toggle:%d\n", afifo->buf_read, afifo->buf_toggle);
+
+	if (afifo->buf_read > afifo->buf_toggle) {
+		cnt = total - afifo->buf_read;
+		dma_sync_single_for_cpu(asyncfifo_get_dev(afifo),
+				afifo->pages_map+afifo->buf_read*size,
+				cnt*size,
+				DMA_FROM_DEVICE);
+		pr_dbg_irq_dvr("DMA_sync_single_for_cpu cnt:%d size:%d\n", cnt, size);
+		if (sf)
+			ret = _rbuf_write(&sf->rbuf,
+					(u8 *)afifo->pages+afifo->buf_read*size,
+					cnt*size);
+		else
+			channel->dvr_feed->cb.ts(
+					(u8 *)afifo->pages+afifo->buf_read*size,
+					cnt*size, NULL, 0,
+					&channel->dvr_feed->feed.ts, DMX_OK);
+		afifo->buf_read = 0;
+	}
+
+	if (afifo->buf_toggle > afifo->buf_read) {
+		cnt = afifo->buf_toggle - afifo->buf_read;
+		dma_sync_single_for_cpu(asyncfifo_get_dev(afifo),
+				afifo->pages_map+afifo->buf_read*size,
+				cnt*size,
+				DMA_FROM_DEVICE);
+		pr_dbg_irq_dvr("dma_sync_single_for_cpu cnt:%d size:%d\n", cnt, size);
+		if (sf) {
+			if (ret >= 0)
+				ret = _rbuf_write(&sf->rbuf,
+					(u8 *)afifo->pages+afifo->buf_read*size,
+					cnt*size);
+		} else
+			channel->dvr_feed->cb.ts(
+					(u8 *)afifo->pages+afifo->buf_read*size,
+					cnt*size, NULL, 0,
+					&channel->dvr_feed->feed.ts, DMX_OK);
+		afifo->buf_read = afifo->buf_toggle;
+	}
+
+	if (sf && ret > 0) {
+		_rbuf_filter_pkts(&sf->rbuf, sf->wrapbuf,
+				dvb_dmx_swfilter_packets,
+				channel->dvr_feed->demux);
+	} else if (sf && ret <= 0)
+		pr_error("sf rbuf write error[%d]\n", ret);
+	else
+		pr_dbg_irq_dvr("write data to dvr\n");
+}
+
+static void dvr_irq_bh_handler(unsigned long arg)
+{
+	struct wetek_asyncfifo *afifo = (struct wetek_asyncfifo *)arg;
+	struct wetek_dvb *dvb = afifo->dvb;
+	struct wetek_dmx *dmx;
+	u32 size, total;
+	int i, factor;
+	unsigned long flags;
+
+	pr_dbg_irq_dvr("async fifo %d irq:%d, %d source:%d\n", afifo->id, afifo->asyncfifo_irq, afifo->buf_toggle, afifo->source);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dvb && afifo->source >= AM_DMX_0 && afifo->source < AM_DMX_MAX) {
+		dmx = &dvb->dmx[afifo->source];
+		if (dmx->init && dmx->record) {
+			struct wetek_swfilter *sf = &dvb->swfilter;
+			int issf = 0;
+
+			total = afifo->buf_len / afifo->flush_size;
+			factor = dmx_get_order(total);
+			size = afifo->buf_len >> factor;
+
+			if (sf->user && (sf->afifo == afifo))
+				issf = 1;
+
+			for (i = 0; i < CHANNEL_COUNT; i++) {
+				if (dmx->channel[i].used && dmx->channel[i].dvr_feed) {
+					dvr_process_channel(afifo,
+							&dmx->channel[i],
+							total,
+							size,
+							issf?sf:NULL);
+				    break;
+				}
+			}
+
+		}
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+	return;
+}
+
+static irqreturn_t dvr_irq_handler(int irq_number, void *para)
+{
+	struct wetek_asyncfifo *afifo = (struct wetek_asyncfifo *)para;
+	int factor = dmx_get_order(afifo->buf_len / afifo->flush_size);
+
+	afifo->buf_toggle++;
+	afifo->buf_toggle %= (1 << factor);
+	tasklet_schedule(&afifo->asyncfifo_tasklet);
+	return IRQ_HANDLED;
+}
+
+/*Enable the STB*/
+static void stb_enable(struct wetek_dvb *dvb)
+{
+	int out_src, des_in = 0, en_des = 0, fec_clk, hiu, dec_clk_en = 0;
+	int src, tso_src, i;
+	u32 fec_s0, fec_s1;
+	u32 invert0, invert1;
+
+	u32 data;
+	switch (dvb->stb_source) {
+	case AM_TS_SRC_DMX0:
+		src = dvb->dmx[0].source;
+		break;
+	case AM_TS_SRC_DMX1:
+		src = dvb->dmx[1].source;
+		break;
+	case AM_TS_SRC_DMX2:
+		src = dvb->dmx[2].source;
+		break;
+	default:
+		src = dvb->stb_source;
+		break;
+	}
+
+	switch (src) {
+	case AM_TS_SRC_TS0:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_TS1:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_TS2:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_S_TS0:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_S_TS1:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_S_TS2:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_HIU:
+		fec_clk = tsfile_clkdiv;
+		hiu = 1;
+		break;
+	default:
+		fec_clk = 0;
+		hiu = 0;
+		break;
+	}
+
+	switch (dvb->tso_source) {
+	case AM_TS_SRC_DMX0:
+		tso_src = dvb->dmx[0].source;
+		break;
+	case AM_TS_SRC_DMX1:
+		tso_src = dvb->dmx[1].source;
+		break;
+	case AM_TS_SRC_DMX2:
+		tso_src = dvb->dmx[2].source;
+		break;
+	default:
+		tso_src = dvb->tso_source;
+		break;
+	}
+
+	switch (tso_src) {
+	case AM_TS_SRC_TS0:
+		out_src = 0;
+		break;
+	case AM_TS_SRC_TS1:
+		out_src = 1;
+		break;
+	case AM_TS_SRC_TS2:
+		out_src = 2;
+		break;
+	case AM_TS_SRC_S_TS0:
+		out_src = 6;
+		break;
+	case AM_TS_SRC_S_TS1:
+	case AM_TS_SRC_S_TS2:
+		out_src = 5;
+		break;
+	case AM_TS_SRC_HIU:
+		out_src = 7;
+		break;
+	default:
+		out_src = 0;
+		break;
+	}
+
+	pr_dbg("[stb]src:%d tso:%d out_src:%d\n", src, tso_src, out_src);
+
+	fec_s0 = 0;
+	fec_s1 = 0;
+	invert0 = 0;
+	invert1 = 0;
+
+	for (i = 0; i < TS_IN_COUNT; i++) {
+		if (dvb->ts[i].s2p_id == 0)
+			fec_s0 = i;
+		else if (dvb->ts[i].s2p_id == 1)
+			fec_s1 = i;
+	}
+
+	invert0 = dvb->s2p[0].invert;
+	invert1 = dvb->s2p[1].invert;
+	pr_dbg("fec_s0:%d, invert0:%d fec_s1:%d invert1:%d en_des:%d\n", fec_s0, invert0, fec_s1, invert1, en_des);
+
+	WRITE_MPEG_REG(STB_TOP_CONFIG,
+		       (invert1 << INVERT_S2P1_FEC_CLK) |
+		       (fec_s1 << S2P1_FEC_SERIAL_SEL) |
+		       (out_src << TS_OUTPUT_SOURCE) |
+		       (des_in << DES_INPUT_SEL) |
+		       (en_des << ENABLE_DES_PL) |
+		       (dec_clk_en << ENABLE_DES_PL_CLK) |
+		       (invert0 << INVERT_S2P0_FEC_CLK) |
+		       (fec_s0 << S2P0_FEC_SERIAL_SEL));
+
+	if (dvb->reset_flag)
+		hiu = 0;
+	/* invert ts out clk,add ci model need add this*/
+	if (dvb->ts_out_invert) {
+		/*printk("ts out invert ---\r\n");*/
+		data = READ_MPEG_REG(TS_TOP_CONFIG);
+		data |= 1 << TS_OUT_CLK_INVERT;
+		WRITE_MPEG_REG(TS_TOP_CONFIG, data);
+	}
+	/* invert ts out clk  end */
+	WRITE_MPEG_REG(TS_FILE_CONFIG,
+		       (demux_skipbyte << 16) |
+		       (6 << DES_OUT_DLY) |
+		       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
+		       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD_2) |
+		       (hiu << TS_HIU_ENABLE) | (fec_clk << FEC_FILE_CLK_DIV));
+}
+
+/*Set section buffer*/
+static int dmx_alloc_sec_buffer(struct wetek_dmx *dmx)
+{
+	unsigned long base;
+	unsigned long grp_addr[SEC_BUF_GRP_COUNT];
+	int grp_len[SEC_BUF_GRP_COUNT];
+	int i;
+
+	if (dmx->sec_pages)
+		return 0;
+
+	grp_len[0] = (1 << SEC_GRP_LEN_0) * 8;
+	grp_len[1] = (1 << SEC_GRP_LEN_1) * 8;
+	grp_len[2] = (1 << SEC_GRP_LEN_2) * 8;
+	grp_len[3] = (1 << SEC_GRP_LEN_3) * 8;
+
+	dmx->sec_total_len = grp_len[0] + grp_len[1] + grp_len[2] + grp_len[3];
+	dmx->sec_pages =
+	    __get_free_pages(GFP_KERNEL, get_order(dmx->sec_total_len));
+	if (!dmx->sec_pages) {
+		pr_error("cannot allocate section buffer %d bytes %d order\n",
+			 dmx->sec_total_len, get_order(dmx->sec_total_len));
+		return -1;
+	}
+	dmx->sec_pages_map =
+	    dma_map_single(dmx_get_dev(dmx), (void *)dmx->sec_pages,
+					 dmx->sec_total_len, DMA_FROM_DEVICE);
+
+	grp_addr[0] = dmx->sec_pages_map;
+
+	grp_addr[1] = grp_addr[0] + grp_len[0];
+	grp_addr[2] = grp_addr[1] + grp_len[1];
+	grp_addr[3] = grp_addr[2] + grp_len[2];
+
+	dmx->sec_buf[0].addr = dmx->sec_pages;
+	dmx->sec_buf[0].len = grp_len[0] / 8;
+
+	for (i = 1; i < SEC_BUF_COUNT; i++) {
+		dmx->sec_buf[i].addr =
+		    dmx->sec_buf[i - 1].addr + dmx->sec_buf[i - 1].len;
+		dmx->sec_buf[i].len = grp_len[i / 8] / 8;
+	}
+
+	base = grp_addr[0] & 0xFFFF0000;
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base >> 16);
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START,
+		      (((grp_addr[0] - base) >> 8) << 16) |
+		       ((grp_addr[1] - base) >> 8));
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START,
+		      (((grp_addr[2] - base) >> 8) << 16) |
+		       ((grp_addr[3] - base) >> 8));
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE,
+			SEC_GRP_LEN_0 |
+			(SEC_GRP_LEN_1 << 4) |
+			(SEC_GRP_LEN_2 << 8) |
+			(SEC_GRP_LEN_3 << 12));
+
+	return 0;
+}
+
+#ifdef NO_SUB
+/*Set subtitle buffer*/
+static int dmx_alloc_sub_buffer(struct wetek_dmx *dmx)
+{
+	unsigned long addr;
+
+	if (dmx->sub_pages)
+		return 0;
+
+	dmx->sub_buf_len = 64 * 1024;
+	dmx->sub_pages =
+	    __get_free_pages(GFP_KERNEL, get_order(dmx->sub_buf_len));
+	if (!dmx->sub_pages) {
+		pr_error("cannot allocate subtitle buffer\n");
+		return -1;
+	}
+	dmx->sub_pages_map =
+	    dma_map_single(dmx_get_dev(dmx), (void *)dmx->sub_pages,
+					dmx->sub_buf_len, DMA_FROM_DEVICE);
+
+	addr = virt_to_phys((void *)dmx->sub_pages);
+	DMX_WRITE_REG(dmx->id, SB_START, addr >> 12);
+	DMX_WRITE_REG(dmx->id, SB_LAST_ADDR, (dmx->sub_buf_len >> 3) - 1);
+	return 0;
+}
+#endif /*NO_SUB */
+
+/*Set PES buffer*/
+static int dmx_alloc_pes_buffer(struct wetek_dmx *dmx)
+{
+	unsigned long addr;
+
+	if (dmx->pes_pages)
+		return 0;
+
+	dmx->pes_buf_len = 64 * 1024;
+	dmx->pes_pages =
+	    __get_free_pages(GFP_KERNEL, get_order(dmx->pes_buf_len));
+	if (!dmx->pes_pages) {
+		pr_error("cannot allocate pes buffer\n");
+		return -1;
+	}
+	dmx->pes_pages_map =
+	    dma_map_single(dmx_get_dev(dmx), (void *)dmx->pes_pages,
+					dmx->pes_buf_len, DMA_FROM_DEVICE);
+
+	addr = virt_to_phys((void *)dmx->pes_pages);
+	DMX_WRITE_REG(dmx->id, OB_START, addr >> 12);
+	DMX_WRITE_REG(dmx->id, OB_LAST_ADDR, (dmx->pes_buf_len >> 3) - 1);
+	return 0;
+}
+
+/*Allocate ASYNC FIFO Buffer*/
+static unsigned long asyncfifo_alloc_buffer(int len)
+{
+	unsigned long pages = __get_free_pages(GFP_KERNEL, get_order(len));
+	if (!pages) {
+		pr_error("cannot allocate async fifo buffer\n");
+		return 0;
+	}
+	return pages;
+}
+static void asyncfifo_free_buffer(unsigned long buf, int len)
+{
+	free_pages(buf, get_order(len));
+}
+
+static int asyncfifo_set_buffer(struct wetek_asyncfifo *afifo,
+					int len, unsigned long buf)
+{
+	if (afifo->pages)
+		return -1;
+
+	afifo->buf_toggle = 0;
+	afifo->buf_read   = 0;
+	afifo->buf_len = len;
+	pr_error("async fifo %d buf size %d, flush size %d\n",
+			afifo->id, afifo->buf_len, afifo->flush_size);
+
+	if (afifo->flush_size <= 0)
+		afifo->flush_size = afifo->buf_len>>1;
+
+	afifo->pages = buf;
+	if (!afifo->pages)
+		return -1;
+
+	afifo->pages_map = dma_map_single(asyncfifo_get_dev(afifo),
+			(void *)afifo->pages, afifo->buf_len, DMA_FROM_DEVICE);
+
+	return 0;
+}
+static void asyncfifo_put_buffer(struct wetek_asyncfifo *afifo)
+{
+	if (afifo->pages) {
+		dma_unmap_single(asyncfifo_get_dev(afifo),
+			afifo->pages_map, afifo->buf_len, DMA_FROM_DEVICE);
+		asyncfifo_free_buffer(afifo->pages, afifo->buf_len);
+		afifo->pages_map = 0;
+		afifo->pages = 0;
+	}
+}
+
+int async_fifo_init(struct wetek_asyncfifo *afifo, int initirq,
+			int buf_len, unsigned long buf)
+{
+	int ret = 0;
+	int irq;
+
+	if (afifo->init)
+		return -1;
+
+	afifo->source  = AM_DMX_MAX;
+	afifo->pages = 0;
+	afifo->buf_toggle = 0;
+	afifo->buf_read = 0;
+	afifo->buf_len = 0;
+
+	tasklet_init(&afifo->asyncfifo_tasklet,
+			dvr_irq_bh_handler, (unsigned long)afifo);
+	if (initirq)
+		irq = request_irq(afifo->asyncfifo_irq,	dvr_irq_handler,
+				IRQF_SHARED|IRQF_TRIGGER_RISING,
+				"dvr irq", afifo);
+	else
+		enable_irq(afifo->asyncfifo_irq);
+
+	/*alloc buffer*/
+	ret = asyncfifo_set_buffer(afifo, buf_len, buf);
+
+	afifo->init = 1;
+
+	return ret;
+}
+
+int async_fifo_deinit(struct wetek_asyncfifo *afifo, int freeirq)
+{
+	if (!afifo->init)
+		return 0;
+
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG1, 1 << ASYNC_FIFO_FLUSH_EN);
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG2, 1 << ASYNC_FIFO_FILL_EN);
+
+	asyncfifo_put_buffer(afifo);
+
+	afifo->source  = AM_DMX_MAX;
+	afifo->buf_toggle = 0;
+	afifo->buf_read = 0;
+	afifo->buf_len = 0;
+
+	if (afifo->asyncfifo_irq != -1) {
+		if (freeirq)
+			free_irq(afifo->asyncfifo_irq, afifo);
+		else
+			disable_irq(afifo->asyncfifo_irq);
+	}
+	tasklet_kill(&afifo->asyncfifo_tasklet);
+
+	afifo->init = 0;
+
+	return 0;
+}
+
+static int _dmx_smallsec_enable(struct wetek_smallsec *ss, int bufsize)
+{
+	if (!ss->buf) {
+
+		ss->buf = __get_free_pages(GFP_KERNEL,
+					get_order(bufsize));
+		if (!ss->buf) {
+			pr_error("cannot allocate smallsec buffer\n"
+				"%d bytes %d order\n",
+				 bufsize, get_order(bufsize));
+			return -1;
+		}
+		ss->buf_map = dma_map_single(dmx_get_dev(ss->dmx),
+						(void *)ss->buf,
+						 bufsize, DMA_FROM_DEVICE);
+	}
+
+	DMX_WRITE_REG(ss->dmx->id, DEMUX_SMALL_SEC_ADDR,
+				ss->buf_map);
+	DMX_WRITE_REG(ss->dmx->id, DEMUX_SMALL_SEC_CTL,
+				((((bufsize>>8)-1)&0xff)<<24) |
+				(1<<1) |/*enable reset the wr ptr*/
+				(1<<0));
+
+	ss->bufsize = bufsize;
+	ss->enable = 1;
+
+	pr_inf("demux%d smallsec buf start: %lx, size: %d\n",
+		ss->dmx->id, ss->buf, ss->bufsize);
+	return 0;
+}
+
+static int _dmx_smallsec_disable(struct wetek_smallsec *ss)
+{
+	DMX_WRITE_REG(ss->dmx->id, DEMUX_SMALL_SEC_CTL, 0);
+	if (ss->buf) {
+		dma_unmap_single(dmx_get_dev(ss->dmx), ss->buf_map,
+				ss->bufsize, DMA_FROM_DEVICE);
+		free_pages(ss->buf, get_order(ss->bufsize));
+		ss->buf = 0;
+		ss->buf_map = 0;
+	}
+	ss->enable = 0;
+	pr_inf("demux%d smallsec buf disable\n", ss->dmx->id);
+	return 0;
+}
+
+static int dmx_smallsec_set(struct wetek_smallsec *ss, int enable, int bufsize,
+				int force)
+{
+	if (!enable) {/*disable*/
+
+		if (ss->enable || force)
+			_dmx_smallsec_disable(ss);
+
+	} else {/*enable*/
+
+		if (bufsize < 0)
+			bufsize = SS_BUFSIZE_DEF;
+		else if (!bufsize)
+			bufsize = ss->bufsize;
+		else {
+			/*unit:FF max:FF00*/
+			bufsize &= ~0xFF;
+			bufsize &= 0x1FF00;
+		}
+
+		if ((ss->enable && (bufsize != ss->bufsize)) || force)
+			_dmx_smallsec_disable(ss);
+
+		if (!ss->enable)
+			_dmx_smallsec_enable(ss, bufsize);
+	}
+
+	return 0;
+}
+
+static int _dmx_timeout_enable(struct wetek_dmxtimeout *dto, int timeout,
+						int ch_dis, int match)
+{
+
+	DMX_WRITE_REG(dto->dmx->id, DEMUX_INPUT_TIMEOUT_C, ch_dis);
+	DMX_WRITE_REG(dto->dmx->id, DEMUX_INPUT_TIMEOUT,
+				((!!match)<<31) |
+				(timeout&0x7fffffff));
+
+	dto->ch_disable = ch_dis;
+	dto->match = match;
+	dto->timeout = timeout;
+	dto->trigger = 0;
+	dto->enable = 1;
+
+	pr_inf("demux%d timeout enable:timeout(%d),ch(0x%x),match(%d)\n",
+		dto->dmx->id, dto->timeout, dto->ch_disable, dto->match);
+
+	return 0;
+}
+static int _dmx_timeout_disable(struct wetek_dmxtimeout *dto)
+{
+
+	DMX_WRITE_REG(dto->dmx->id, DEMUX_INPUT_TIMEOUT, 0);
+	dto->enable = 0;
+	dto->trigger = 0;
+	pr_inf("demux%d timeout disable\n", dto->dmx->id);
+
+	return 0;
+}
+
+static int dmx_timeout_set(struct wetek_dmxtimeout *dto, int enable,
+				int timeout, int ch_dis, int match,
+				int force)
+{
+
+	if (!enable) {/*disable*/
+
+		if (dto->enable || force)
+			_dmx_timeout_disable(dto);
+
+	} else {/*enable*/
+
+		if (timeout < 0) {
+			timeout = DTO_TIMEOUT_DEF;
+			ch_dis = DTO_CHDIS_VAS;
+			match = dto->match;
+		} else if (!timeout) {
+			timeout = dto->timeout;
+			ch_dis = dto->ch_disable;
+			match = dto->match;
+		}
+
+		if ((dto->enable && (timeout != dto->timeout))
+			|| force)
+			_dmx_timeout_disable(dto);
+
+		if (!dto->enable)
+			_dmx_timeout_enable(dto, timeout, ch_dis, match);
+	}
+
+	return 0;
+}
+
+/*Initalize the registers*/
+static int dmx_init(struct wetek_dmx *dmx)
+{
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+	int irq;
+
+	if (dmx->init) {
+		return 0;
+	}
+
+	/*Register irq handlers */
+	if (dmx->dmx_irq != -1) {
+		tasklet_init(&dmx->dmx_tasklet,
+				dmx_irq_bh_handler,
+				(unsigned long)dmx);
+		irq = request_irq(dmx->dmx_irq,	dmx_irq_handler,
+				IRQF_SHARED|IRQF_TRIGGER_RISING,
+				"dmx irq", dmx);
+		pr_dbg("request_irq:%d\n", dmx->dmx_irq);
+	}
+
+	/*Allocate buffer */
+	if (dmx_alloc_sec_buffer(dmx) < 0)
+		return -1;
+#ifdef NO_SUB
+	if (dmx_alloc_sub_buffer(dmx) < 0)
+		return -1;
+#endif
+	if (dmx_alloc_pes_buffer(dmx) < 0)
+		return -1;
+
+	/*Reset the hardware */
+	if (!dvb->dmx_init) {
+		init_timer(&dvb->watchdog_timer);
+		dvb->watchdog_timer.function = section_buffer_watchdog_func;
+		dvb->watchdog_timer.expires =
+		    jiffies + msecs_to_jiffies(WATCHDOG_TIMER);
+		dvb->watchdog_timer.data = (unsigned long)dvb;
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+		add_timer(&dvb->watchdog_timer);
+#endif
+		dmx_reset_hw(dvb);
+	}
+
+	dvb->dmx_init++;
+
+	memset(dmx->sec_buf_watchdog_count, 0,
+	       sizeof(dmx->sec_buf_watchdog_count));
+
+	dmx->init = 1;
+
+	return 0;
+}
+
+/*Release the resource*/
+static int dmx_deinit(struct wetek_dmx *dmx)
+{
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+
+	if (!dmx->init)
+		return 0;
+
+	DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0);
+
+	dvb->dmx_init--;
+
+	/*Reset the hardware */
+	if (!dvb->dmx_init) {
+		dmx_reset_hw(dvb);
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+		del_timer_sync(&dvb->watchdog_timer);
+#endif
+	}
+
+	if (dmx->sec_pages) {
+		dma_unmap_single(dmx_get_dev(dmx), dmx->sec_pages_map,
+				dmx->sec_total_len, DMA_FROM_DEVICE);
+		free_pages(dmx->sec_pages, get_order(dmx->sec_total_len));
+		dmx->sec_pages = 0;
+		dmx->sec_pages_map = 0;
+	}
+#ifdef NO_SUB
+	if (dmx->sub_pages) {
+		dma_unmap_single(dmx_get_dev(dmx), dmx->sub_pages_map,
+				dmx->sub_buf_len, DMA_FROM_DEVICE);
+		free_pages(dmx->sub_pages, get_order(dmx->sub_buf_len));
+		dmx->sub_pages = 0;
+	}
+#endif
+	if (dmx->pes_pages) {
+		dma_unmap_single(dmx_get_dev(dmx), dmx->pes_pages_map,
+				dmx->pes_buf_len, DMA_FROM_DEVICE);
+		free_pages(dmx->pes_pages, get_order(dmx->pes_buf_len));
+		dmx->pes_pages = 0;
+	}
+
+	if (dmx->dmx_irq != -1) {
+		free_irq(dmx->dmx_irq, dmx);
+		tasklet_kill(&dmx->dmx_tasklet);
+	}
+
+	dmx->init = 0;
+
+	return 0;
+}
+
+/*Check the record flag*/
+static int dmx_get_record_flag(struct wetek_dmx *dmx)
+{
+	int i, linked = 0, record_flag = 0;
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+
+	/*Check whether a async fifo connected to this dmx */
+	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+		if (!dvb->asyncfifo[i].init)
+			continue;
+		if ((dvb->asyncfifo[i].source == dmx->id)
+		    /*&& !(dvb->swfilter.user && (i==SF_AFIFO_ID)) */
+		    /*sf mode reserved */
+		    ) {
+			linked = 1;
+			break;
+		}
+	}
+
+	for (i = 0; i < CHANNEL_COUNT; i++) {
+		if (dmx->channel[i].used && dmx->channel[i].dvr_feed) {
+			if (!dmx->record) {
+				dmx->record = 1;
+
+				if (linked) {
+					/*A new record will start,
+					   must reset the async fifos for
+					 linking the right demux */
+					reset_async_fifos(dvb);
+				}
+			}
+			if (linked)
+				record_flag = 1;
+			goto find_done;
+		}
+	}
+
+	if (dmx->record) {
+		dmx->record = 0;
+		if (linked) {
+			/*A record will stop, reset the async fifos
+			for linking the right demux */
+			reset_async_fifos(dvb);
+		}
+	}
+
+find_done:
+	pr_dbg("channel:%d record_flag:%d linked:%d\n", i, record_flag, linked);
+	return record_flag;
+}
+
+/*Enable the demux device*/
+static int dmx_enable(struct wetek_dmx *dmx)
+{
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;// 	x20 
+	int fec_sel, hi_bsf, fec_ctrl, record;			//	w21, w22, w23, w25, w24
+	int fec_core_sel = 0;
+	int set_stb = 0, fec_s = 0;
+	int s2p_id;
+	u32 invert0 = 0, invert1 = 0, fec_s0 = 0, fec_s1 = 0;
+
+	record = dmx_get_record_flag(dmx);
+
+	switch (dmx->source) {
+	case AM_TS_SRC_TS0:
+		fec_sel = 0;
+		fec_ctrl = dvb->ts[0].control;
+		record = record ? 1 : 0;
+		break;
+	case AM_TS_SRC_TS1:
+		fec_sel = 1;
+		fec_ctrl = dvb->ts[1].control;
+		record = record ? 1 : 0;
+		break;
+	case AM_TS_SRC_TS2:
+		fec_sel = 2;
+		fec_ctrl = dvb->ts[2].control;
+		record = record ? 1 : 0;
+		break;
+	case AM_TS_SRC_S_TS0:
+	case AM_TS_SRC_S_TS1:
+	case AM_TS_SRC_S_TS2:
+		s2p_id = 0;
+		fec_ctrl = 0;
+		if (dmx->source == AM_TS_SRC_S_TS0) {
+			s2p_id = dvb->ts[0].s2p_id;
+			fec_ctrl = dvb->ts[0].control;
+		} else if (dmx->source == AM_TS_SRC_S_TS1) {
+			s2p_id = dvb->ts[1].s2p_id;
+			fec_ctrl = dvb->ts[1].control;
+		} else if (dmx->source == AM_TS_SRC_S_TS2) {
+			s2p_id = dvb->ts[2].s2p_id;
+			fec_ctrl = dvb->ts[2].control;
+		}
+		fec_sel = (s2p_id == 1) ? 5 : 6;
+		record = record ? 1 : 0;
+		set_stb = 1;
+		fec_s = dmx->source - AM_TS_SRC_S_TS0;
+		break;
+	case AM_TS_SRC_HIU:
+		fec_sel = 7;
+		fec_ctrl = 0;
+		record = 0;
+		break;
+	default:
+		fec_sel = 0;
+		fec_ctrl = 0;
+		record = 0;
+		break;
+	}
+
+	if (dmx->channel[0].used || dmx->channel[1].used)
+		hi_bsf = 1;
+	else
+		hi_bsf = 0;
+
+	if (dmx->chan_count) {
+	    if (set_stb) {
+		u32 v = READ_MPEG_REG(STB_TOP_CONFIG);
+		int i;
+
+		for (i = 0; i < TS_IN_COUNT; i++) {
+		    if (dvb->ts[i].s2p_id == 0)
+			fec_s0 = i;
+		    else if (dvb->ts[i].s2p_id == 1)
+			fec_s1 = i;
+		}
+		v &= ~((0x3 << S2P0_FEC_SERIAL_SEL) |
+		       (0x1f << INVERT_S2P0_FEC_CLK) |
+		       (0x3 << S2P1_FEC_SERIAL_SEL) |
+		       (0x1f << INVERT_S2P1_FEC_CLK));
+
+		v |= (fec_s0 << S2P0_FEC_SERIAL_SEL) |
+		     (invert0 << INVERT_S2P0_FEC_CLK) |
+		     (fec_s1 << S2P1_FEC_SERIAL_SEL) |
+		     (invert1 << INVERT_S2P1_FEC_CLK);
+		WRITE_MPEG_REG(STB_TOP_CONFIG, v);
+	    }
+
+	    /*Initialize the registers */
+	    DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	    DMX_WRITE_REG(dmx->id, DEMUX_MEM_REQ_EN,
+#ifdef USE_AHB_MODE
+			  (1 << SECTION_AHB_DMA_EN) |
+			  (0 << SUB_AHB_DMA_EN) |
+			  (1 << OTHER_PES_AHB_DMA_EN) |
+#endif
+			  (1 << SECTION_PACKET) |
+			  (1 << VIDEO_PACKET) |
+			  (1 << AUDIO_PACKET) |
+			  (1 << SUB_PACKET) |
+			  (1 << SCR_ONLY_PACKET) |
+			  (1 << OTHER_PES_PACKET));
+	    DMX_WRITE_REG(dmx->id, PES_STRONG_SYNC, 0x1234);
+
+		DMX_WRITE_REG(dmx->id, DEMUX_ENDIAN,
+			      (1<<SEPERATE_ENDIAN) |
+			      (0<<OTHER_PES_ENDIAN) |
+			      (7<<SCR_ENDIAN) |
+			      (7<<SUB_ENDIAN) |
+			      (7<<AUDIO_ENDIAN) |
+			      (7<<VIDEO_ENDIAN) |
+			      (7 << OTHER_ENDIAN) |
+			      (7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
+//	    DMX_WRITE_REG(dmx->id, DEMUX_ENDIAN,
+//		          (7 << OTHER_ENDIAN) |
+//			  (7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
+
+	    DMX_WRITE_REG(dmx->id, TS_HIU_CTL,
+		          (0 << LAST_BURST_THRESHOLD) |
+			  (hi_bsf << USE_HI_BSF_INTERFACE));
+
+	    DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
+			      (fec_core_sel << FEC_CORE_SEL) |
+			      (fec_sel << FEC_SEL) | (fec_ctrl << 0));
+	    DMX_WRITE_REG(dmx->id, STB_OM_CTL,
+			      (0x40 << MAX_OM_DMA_COUNT) |
+			      (0x7f << LAST_OM_ADDR));
+	    DMX_WRITE_REG(dmx->id, DEMUX_CONTROL,
+			      (0 << BYPASS_USE_RECODER_PATH) |
+			      (0 << INSERT_AUDIO_PES_STRONG_SYNC) |
+			      (0 << INSERT_VIDEO_PES_STRONG_SYNC) |
+			      (0 << OTHER_INT_AT_PES_BEGINING) |
+			      (0 << DISCARD_AV_PACKAGE) |
+			      ((!!dmx->dump_ts_select) << TS_RECORDER_SELECT) |
+			      (record << TS_RECORDER_ENABLE) |
+			      (1 << KEEP_DUPLICATE_PACKAGE) |
+			      (1 << SECTION_END_WITH_TABLE_ID) |
+			      (1 << ENABLE_FREE_CLK_FEC_DATA_VALID) |
+			      (1 << ENABLE_FREE_CLK_STB_REG) |
+			      (1 << STB_DEMUX_ENABLE) |
+			      (1 << NOT_USE_OF_SOP_INPUT));
+	} else {
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL, 0);
+		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0);
+	}
+
+	return 0;
+}
+
+static int dmx_set_misc(struct wetek_dmx *dmx, int hi_bsf)
+{
+	if (hi_bsf >= 0) {
+		DMX_WRITE_REG(dmx->id, TS_HIU_CTL,
+					hi_bsf ?
+					(DMX_READ_REG(dmx->id, TS_HIU_CTL) |
+					(1 << USE_HI_BSF_INTERFACE))
+					:
+					(DMX_READ_REG(dmx->id, TS_HIU_CTL) &
+					(~(1 << USE_HI_BSF_INTERFACE))));
+	}
+
+	return 0;
+}
+
+static int dmx_set_misc_id(struct wetek_dvb *dvb, int id, int hi_bsf)
+{
+	return dmx_set_misc(&dvb->dmx[id], hi_bsf);
+}
+
+/*Get the channel's ID by its PID*/
+static int dmx_get_chan(struct wetek_dmx *dmx, int pid)
+{
+	int id;
+
+	for (id = 0; id < CHANNEL_COUNT; id++) {
+		if (dmx->channel[id].used && dmx->channel[id].pid == pid)
+			return id;
+	}
+
+	return -1;
+}
+
+/*Get the channel's target*/
+static u32 dmx_get_chan_target(struct wetek_dmx *dmx, int cid)
+{
+	u32 type;
+
+	if (!dmx->channel[cid].used)
+		return 0xFFFF;
+
+	if (dmx->channel[cid].type == DMX_TYPE_SEC) {
+		type = SECTION_PACKET;
+	} else {
+		switch (dmx->channel[cid].pes_type) {
+		case DMX_PES_AUDIO:
+			type = AUDIO_PACKET;
+			break;
+		case DMX_PES_VIDEO:
+			type = VIDEO_PACKET;
+			break;
+		case DMX_PES_SUBTITLE:
+		case DMX_PES_TELETEXT:
+			type = SUB_PACKET;
+			break;
+		case DMX_PES_PCR:
+			type = SCR_ONLY_PACKET;
+			break;
+		default:
+			type = OTHER_PES_PACKET;
+			break;
+		}
+	}
+
+	return (type << PID_TYPE) | dmx->channel[cid].pid;
+}
+
+/*Get the advance value of the channel*/
+static inline u32 dmx_get_chan_advance(struct wetek_dmx *dmx, int cid)
+{
+	return 0;
+}
+
+/*Set the channel registers*/
+static int dmx_set_chan_regs(struct wetek_dmx *dmx, int cid)
+{
+	u32 data, addr, advance, max;
+
+	while (DMX_READ_REG(dmx->id, FM_WR_ADDR) & 0x8000)
+		udelay(1);
+
+	if (cid & 1) {
+		data =
+		    (dmx_get_chan_target(dmx, cid - 1) << 16) |
+		    dmx_get_chan_target(dmx, cid);
+		advance =
+		    (dmx_get_chan_advance(dmx, cid) << 8) |
+		    dmx_get_chan_advance(dmx, cid - 1);
+	} else {
+		data =
+		    (dmx_get_chan_target(dmx, cid) << 16) |
+		    dmx_get_chan_target(dmx, cid + 1);
+		advance =
+		    (dmx_get_chan_advance(dmx, cid + 1) << 8) |
+		    dmx_get_chan_advance(dmx, cid);
+	}
+	addr = cid >> 1;
+	DMX_WRITE_REG(dmx->id, FM_WR_DATA, data);
+	DMX_WRITE_REG(dmx->id, FM_WR_ADDR, (advance << 16) | 0x8000 | addr);
+
+	for (max = CHANNEL_COUNT - 1; max > 0; max--) {
+		if (dmx->channel[max].used)
+			break;
+	}
+
+	data = DMX_READ_REG(dmx->id, MAX_FM_COMP_ADDR) & 0xF0;
+	DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, data | (max >> 1));
+
+	if (DMX_READ_REG(dmx->id, OM_CMD_STATUS) & 0x8e00) {
+		pr_error("error send cmd %x\n",
+			 DMX_READ_REG(dmx->id, OM_CMD_STATUS));
+	}
+
+	if (cid == 0)
+		first_video_pts = 0;
+	else if (cid == 1)
+		first_audio_pts = 0;
+
+	return 0;
+}
+
+/*Get the filter target*/
+static int dmx_get_filter_target(struct wetek_dmx *dmx, int fid, u32 *target,
+				 u8 *advance)
+{
+	struct dmx_section_filter *filter;
+	struct wetek_filter *f;
+	int i, cid, neq_bytes;
+
+	fid = fid & 0xFFFF;
+	f = &dmx->filter[fid];
+
+	if (!f->used) {
+		target[0] = 0x1fff;
+		advance[0] = 0;
+		for (i = 1; i < FILTER_LEN; i++) {
+			target[i] = 0x9fff;
+			advance[i] = 0;
+		}
+		return 0;
+	}
+
+	cid = f->chan_id;
+	filter = f->filter;
+
+	neq_bytes = 0;
+	if (filter->filter_mode[0] != 0xFF) {
+		neq_bytes = 2;
+	} else {
+		for (i = 3; i < FILTER_LEN; i++) {
+			if (filter->filter_mode[i] != 0xFF)
+				neq_bytes++;
+		}
+	}
+
+	f->neq = 0;
+
+	for (i = 0; i < FILTER_LEN; i++) {
+		u8 value = filter->filter_value[i];
+		u8 mask = filter->filter_mask[i];
+		u8 mode = filter->filter_mode[i];
+		u8 mb, mb1, nb, v, t, adv = 0;
+
+		if (!i) {
+			mb = 1;
+			mb1 = 1;
+			v = 0;
+			if ((mode == 0xFF) && mask) {
+				t = mask & 0xF0;
+				if (t) {
+					mb1 = 0;
+					adv |= t^0xF0;
+				}
+				v |= (value & 0xF0) | adv;
+
+				t = mask & 0x0F;
+				if (t) {
+					mb  = 0;
+					adv |= t^0x0F;
+				}
+				v |= (value & 0x0F) | adv;
+			}
+
+			target[i] = (mb << SECTION_FIRSTBYTE_MASKLOW) |
+			    (mb1 << SECTION_FIRSTBYTE_MASKHIGH) |
+			    (0 << SECTION_FIRSTBYTE_DISABLE_PID_CHECK) |
+			    (cid << SECTION_FIRSTBYTE_PID_INDEX) | v;
+			advance[i] = adv;
+		} else {
+			if (i < 3) {
+				value = 0;
+				mask = 0;
+				mode = 0xff;
+			}
+			mb = 1;
+			nb = 0;
+			v = 0;
+
+			if ((i >= 3) && mask) {
+				if (mode == 0xFF) {
+					mb = 0;
+					nb = 0;
+					adv = mask ^ 0xFF;
+					v = value | adv;
+				} else {
+					if (neq_bytes == 1) {
+						mb = 0;
+						nb = 1;
+						adv = mask ^ 0xFF;
+						v = value & ~adv;
+					}
+				}
+			}
+			target[i] = (mb << SECTION_RESTBYTE_MASK) |
+			    (nb << SECTION_RESTBYTE_MASK_EQ) |
+			    (0 << SECTION_RESTBYTE_DISABLE_PID_CHECK) |
+			    (cid << SECTION_RESTBYTE_PID_INDEX) | v;
+			advance[i] = adv;
+		}
+
+		f->value[i] = value;
+		f->maskandmode[i] = mask & mode;
+		f->maskandnotmode[i] = mask & ~mode;
+
+		if (f->maskandnotmode[i])
+			f->neq = 1;
+	}
+
+	return 0;
+}
+
+/*Set the filter registers*/
+static int dmx_set_filter_regs(struct wetek_dmx *dmx, int fid)
+{
+	u32 t1[FILTER_LEN], t2[FILTER_LEN];
+	u8 advance1[FILTER_LEN], advance2[FILTER_LEN];
+	u32 addr, data, max, adv;
+	int i;
+
+	pr_dbg("set filter (id:%d) registers %x\n", fid, MAX_FM_COMP_ADDR);
+
+	if (fid & 1) {
+		dmx_get_filter_target(dmx, fid - 1, t1, advance1);
+		dmx_get_filter_target(dmx, fid, t2, advance2);
+	} else {
+		dmx_get_filter_target(dmx, fid, t1, advance1);
+		dmx_get_filter_target(dmx, fid + 1, t2, advance2);
+	}
+
+	for (i = 0; i < FILTER_LEN; i++) {
+		while (DMX_READ_REG(dmx->id, FM_WR_ADDR) & 0x8000)
+			udelay(1);
+
+		data = (t1[i] << 16) | t2[i];
+		addr = (fid >> 1) | ((i + 1) << 4);
+		adv = (advance1[i] << 8) | advance2[i];
+
+		DMX_WRITE_REG(dmx->id, FM_WR_DATA, data);
+		DMX_WRITE_REG(dmx->id, FM_WR_ADDR, (adv << 16) | 0x8000 | addr);
+
+		pr_dbg("write fm %x:%x\n", (adv << 16) | 0x8000 | addr, data);
+	}
+
+	for (max = FILTER_COUNT - 1; max > 0; max--) {
+		if (dmx->filter[max].used)
+			break;
+	}
+
+	data = DMX_READ_REG(dmx->id, MAX_FM_COMP_ADDR) & 0xF;
+	DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, data | ((max >> 1) << 4));
+
+	pr_dbg("write fm comp %x\n", data | ((max >> 1) << 4));
+
+	if (DMX_READ_REG(dmx->id, OM_CMD_STATUS) & 0x8e00) {
+		pr_error("error send cmd %x\n",
+			 DMX_READ_REG(dmx->id, OM_CMD_STATUS));
+	}
+
+	return 0;
+}
+
+/*Clear the filter's buffer*/
+static void dmx_clear_filter_buffer(struct wetek_dmx *dmx, int fid)
+{
+	u32 section_busy32 = DMX_READ_REG(dmx->id, SEC_BUFF_READY);
+	u32 filter_number;
+	int i;
+
+	if (!section_busy32)
+		return;
+
+	for (i = 0; i < SEC_BUF_COUNT; i++) {
+		if (section_busy32 & (1 << i)) {
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_NUMBER, i);
+			filter_number =
+			    (DMX_READ_REG(dmx->id, SEC_BUFF_NUMBER) >> 8);
+			if (filter_number != fid)
+				section_busy32 &= ~(1 << i);
+		}
+	}
+
+	if (section_busy32)
+		DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, section_busy32);
+}
+
+static void async_fifo_set_regs(struct wetek_asyncfifo *afifo, int source_val)
+{
+	u32 start_addr = virt_to_phys((void *)afifo->pages);
+	u32 size = afifo->buf_len;
+	u32 flush_size = afifo->flush_size;
+	int factor = dmx_get_order(size / flush_size);
+
+	pr_dbg("ASYNC FIFO id=%d, link to DMX%d, afifo->pages:%p start_addr 0x%08x, buf_size %d,"
+		"source value 0x%x, factor %d\n",
+		afifo->id, afifo->source, (void *)afifo->pages, start_addr, size, source_val, factor);
+	/* Destination address */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG0, start_addr);
+
+	/* Setup flush parameters */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+			(0 << ASYNC_FIFO_TO_HIU) |
+			(0 << ASYNC_FIFO_FLUSH) |
+			/* don't flush the path */
+			(1 << ASYNC_FIFO_RESET) |
+			/* reset the path */
+			(1 << ASYNC_FIFO_WRAP_EN) |
+			/* wrap enable */
+			(0 << ASYNC_FIFO_FLUSH_EN) |
+			/* disable the flush path */
+			/*(0x3 << ASYNC_FIFO_FLUSH_CNT_LSB);
+			// flush 3 x 32  32-bit words */
+			/*(0x7fff << ASYNC_FIFO_FLUSH_CNT_LSB);
+			// flush 4MBytes of data */
+			(((size >> 7) & 0x7fff) << ASYNC_FIFO_FLUSH_CNT_LSB));
+			/* number of 128-byte blocks to flush */
+
+	/* clear the reset signal */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+		     READ_ASYNC_FIFO_REG(afifo->id,
+					REG1) & ~(1 << ASYNC_FIFO_RESET));
+	/* Enable flush */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+		     READ_ASYNC_FIFO_REG(afifo->id,
+				REG1) | (1 << ASYNC_FIFO_FLUSH_EN));
+
+	/*Setup Fill parameters */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+			     (1 << ASYNC_FIFO_ENDIAN_LSB) |
+			     (0 << ASYNC_FIFO_FILL_EN) |
+			     /* disable fill path to reset fill path */
+			     /*(96 << ASYNC_FIFO_FILL_CNT_LSB);
+				// 3 x 32  32-bit words */
+			     (0 << ASYNC_FIFO_FILL_CNT_LSB));
+				/* forever FILL; */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+			READ_ASYNC_FIFO_REG(afifo->id, REG2) |
+				(1 << ASYNC_FIFO_FILL_EN));/*Enable fill path*/
+
+	/* generate flush interrupt */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG3,
+			(READ_ASYNC_FIFO_REG(afifo->id, REG3) & 0xffff0000) |
+				((((size >> (factor + 7)) - 1) & 0x7fff) <<
+					ASYNC_FLUSH_SIZE_IRQ_LSB));
+
+	/* Connect the STB DEMUX to ASYNC_FIFO */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+			READ_ASYNC_FIFO_REG(afifo->id, REG2) |
+			(source_val << ASYNC_FIFO_SOURCE_LSB));
+}
+
+/*Reset the ASYNC FIFOS when a ASYNC FIFO connect to a different DMX*/
+static void reset_async_fifos(struct wetek_dvb *dvb)
+{
+	struct wetek_asyncfifo *low_dmx_fifo = NULL;
+	struct wetek_asyncfifo *high_dmx_fifo = NULL;
+	int i, j;
+	int record_enable;
+
+	pr_dbg("reset ASYNC FIFOs\n");
+	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+		if (!dvb->asyncfifo[i].init)
+			continue;
+		pr_dbg("Disable ASYNC FIFO id=%d\n", dvb->asyncfifo[i].id);
+		CLEAR_ASYNC_FIFO_REG_MASK(dvb->asyncfifo[i].id, REG1,
+					  1 << ASYNC_FIFO_FLUSH_EN);
+		CLEAR_ASYNC_FIFO_REG_MASK(dvb->asyncfifo[i].id, REG2,
+					  1 << ASYNC_FIFO_FILL_EN);
+		if (READ_ASYNC_FIFO_REG(dvb->asyncfifo[i].id, REG2) &
+				(1 << ASYNC_FIFO_FILL_EN) ||
+			READ_ASYNC_FIFO_REG(dvb->asyncfifo[i].id, REG1) &
+				(1 << ASYNC_FIFO_FLUSH_EN)) {
+			pr_dbg("Set reg failed\n");
+		} else
+			pr_dbg("Set reg ok\n");
+		dvb->asyncfifo[i].buf_toggle = 0;
+		dvb->asyncfifo[i].buf_read = 0;
+	}
+
+	if (dvb->ts[0].mode == AM_TS_SERIAL)
+		dvb->dmx[0].source = AM_TS_SRC_S_TS0;
+
+	for (j = 0; j < DMX_DEV_COUNT; j++) {
+		if (!dvb->dmx[j].init)
+			continue;
+		record_enable = 0;
+		for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+			if (!dvb->asyncfifo[i].init)
+				continue;
+
+			if (dvb->dmx[j].record
+			    && dvb->dmx[j].id == dvb->asyncfifo[i].source) {
+				/*This dmx is linked to the async fifo,
+				Enable the TS_RECORDER_ENABLE */
+				record_enable = 1;
+				if (!low_dmx_fifo) {
+					low_dmx_fifo = &dvb->asyncfifo[i];
+				} else if (low_dmx_fifo->source >
+					   dvb->asyncfifo[i].source) {
+					high_dmx_fifo = low_dmx_fifo;
+					low_dmx_fifo = &dvb->asyncfifo[i];
+				} else if (low_dmx_fifo->source <
+					   dvb->asyncfifo[i].source) {
+					high_dmx_fifo = &dvb->asyncfifo[i];
+				}
+
+				break;
+			}
+		}
+		pr_dbg("Set DMX%d TS_RECORDER_ENABLE: %s mode:%d\n", dvb->dmx[j].id,
+		       record_enable ? "yes" : "no", dvb->ts[j].mode);
+		if (record_enable) {
+			/*DMX_SET_REG_MASK(dvb->dmx[j].id,
+			DEMUX_CONTROL, 1<<TS_RECORDER_ENABLE); */
+			DMX_WRITE_REG(dvb->dmx[j].id, DEMUX_CONTROL,
+				DMX_READ_REG(dvb->dmx[j].id, DEMUX_CONTROL) |
+				(1 << TS_RECORDER_ENABLE));
+		} else {
+			/*DMX_CLEAR_REG_MASK(dvb->dmx[j].id,
+			DEMUX_CONTROL, 1<<TS_ECORDER_ENABLE); */
+			DMX_WRITE_REG(dvb->dmx[j].id, DEMUX_CONTROL,
+				DMX_READ_REG(dvb->dmx[j].id, DEMUX_CONTROL) &
+				(~(1 <<	TS_RECORDER_ENABLE)));
+		}
+	}
+
+	/*Set the async fifo regs */
+	if (low_dmx_fifo) {
+		async_fifo_set_regs(low_dmx_fifo, 0x3);
+
+		if (high_dmx_fifo)
+			async_fifo_set_regs(high_dmx_fifo, 0x2);
+	}
+}
+
+/*Reset the demux device*/
+void dmx_reset_hw(struct wetek_dvb *dvb)
+{
+	dmx_reset_hw_ex(dvb, 1);
+}
+
+/*Reset the demux device*/
+void dmx_reset_hw_ex(struct wetek_dvb *dvb, int reset_irq)
+{
+	int id, times;
+
+	pr_dbg("demux reset begin\n");
+
+	for (id = 0; id < DMX_DEV_COUNT; id++) {
+		if (!dvb->dmx[id].init)
+			continue;
+		if (reset_irq) {
+			if (dvb->dmx[id].dmx_irq != -1)
+				disable_irq(dvb->dmx[id].dmx_irq);
+			if (dvb->dmx[id].dvr_irq != -1)
+				disable_irq(dvb->dmx[id].dvr_irq);
+		}
+	}
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if (reset_irq)
+		del_timer_sync(&dvb->watchdog_timer);
+#endif
+
+	WRITE_MPEG_REG(RESET1_REGISTER, RESET_DEMUXSTB);
+
+	for (id = 0; id < DMX_DEV_COUNT; id++) {
+		times = 0;
+		while (times++ < 1000000) {
+			if (!(DMX_READ_REG(id, OM_CMD_STATUS) & 0x01))
+				break;
+		}
+	}
+
+	WRITE_MPEG_REG(STB_TOP_CONFIG, 0);
+
+	for (id = 0; id < DMX_DEV_COUNT; id++) {
+		u32 version, data;
+
+		if (!dvb->dmx[id].init)
+			continue;
+
+		if (reset_irq) {
+			if (dvb->dmx[id].dmx_irq != -1)
+				enable_irq(dvb->dmx[id].dmx_irq);
+			if (dvb->dmx[id].dvr_irq != -1)
+				enable_irq(dvb->dmx[id].dvr_irq);
+		}
+		DMX_WRITE_REG(id, DEMUX_CONTROL, 0x0000);
+		version = DMX_READ_REG(id, STB_VERSION);
+		DMX_WRITE_REG(id, STB_TEST_REG, version);
+		pr_dbg("STB %d hardware version : %d\n", id, version);
+		DMX_WRITE_REG(id, STB_TEST_REG, 0x5550);
+		data = DMX_READ_REG(id, STB_TEST_REG);
+		if (data != 0x5550)
+			pr_error("STB %d register access failed\n", id);
+		DMX_WRITE_REG(id, STB_TEST_REG, 0xaaa0);
+		data = DMX_READ_REG(id, STB_TEST_REG);
+		if (data != 0xaaa0)
+			pr_error("STB %d register access failed\n", id);
+		DMX_WRITE_REG(id, MAX_FM_COMP_ADDR, 0x0000);
+		DMX_WRITE_REG(id, STB_INT_MASK, 0);
+		DMX_WRITE_REG(id, STB_INT_STATUS, 0xffff);
+		DMX_WRITE_REG(id, FEC_INPUT_CONTROL, 0);
+	}
+
+	stb_enable(dvb);
+
+	for (id = 0; id < DMX_DEV_COUNT; id++) {
+		struct wetek_dmx *dmx = &dvb->dmx[id];
+		int n;
+		unsigned long addr;
+		unsigned long base;
+		unsigned long grp_addr[SEC_BUF_GRP_COUNT];
+		int grp_len[SEC_BUF_GRP_COUNT];
+		if (!dvb->dmx[id].init)
+			continue;
+
+		if (dmx->sec_pages) {
+			grp_len[0] = (1 << SEC_GRP_LEN_0) * 8;
+			grp_len[1] = (1 << SEC_GRP_LEN_1) * 8;
+			grp_len[2] = (1 << SEC_GRP_LEN_2) * 8;
+			grp_len[3] = (1 << SEC_GRP_LEN_3) * 8;
+
+			grp_addr[0] = virt_to_phys((void *)dmx->sec_pages);
+			grp_addr[1] = grp_addr[0] + grp_len[0];
+			grp_addr[2] = grp_addr[1] + grp_len[1];
+			grp_addr[3] = grp_addr[2] + grp_len[2];
+
+			base = grp_addr[0] & 0xFFFF0000;
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base >> 16);
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START,
+					(((grp_addr[0] - base) >> 8) << 16) |
+					 ((grp_addr[1] - base) >> 8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START,
+					(((grp_addr[2] - base) >> 8) << 16) |
+					 ((grp_addr[3] - base) >> 8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE,
+					SEC_GRP_LEN_0 |
+					(SEC_GRP_LEN_1 << 4) |
+					(SEC_GRP_LEN_2 << 8) |
+					(SEC_GRP_LEN_3 << 12));
+		}
+
+		if (dmx->sub_pages) {
+			addr = virt_to_phys((void *)dmx->sub_pages);
+			DMX_WRITE_REG(dmx->id, SB_START, addr >> 12);
+			DMX_WRITE_REG(dmx->id, SB_LAST_ADDR,
+				      (dmx->sub_buf_len >> 3) - 1);
+		}
+
+		if (dmx->pes_pages) {
+			addr = virt_to_phys((void *)dmx->pes_pages);
+			DMX_WRITE_REG(dmx->id, OB_START, addr >> 12);
+			DMX_WRITE_REG(dmx->id, OB_LAST_ADDR,
+				      (dmx->pes_buf_len >> 3) - 1);
+		}
+
+		for (n = 0; n < CHANNEL_COUNT; n++) {
+			struct wetek_channel *chan = &dmx->channel[n];
+
+			if (chan->used)
+			{
+				dmx_set_chan_regs(dmx, n);
+			}
+		}
+
+		for (n = 0; n < FILTER_COUNT; n++) {
+			struct wetek_filter *filter = &dmx->filter[n];
+
+			if (filter->used)
+				dmx_set_filter_regs(dmx, n);
+		}
+
+		dmx_enable(&dvb->dmx[id]);
+
+		dmx_smallsec_set(&dmx->smallsec,
+				dmx->smallsec.enable,
+				dmx->smallsec.bufsize,
+				1);
+
+		dmx_timeout_set(&dmx->timeout,
+				dmx->timeout.enable,
+				dmx->timeout.timeout,
+				dmx->timeout.ch_disable,
+				dmx->timeout.match,
+				1);
+	}
+
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if (reset_irq) {
+		mod_timer(&dvb->watchdog_timer,
+			  jiffies + msecs_to_jiffies(WATCHDOG_TIMER));
+	}
+#endif
+
+	pr_dbg("demux reset end\n");
+}
+
+/*Reset the individual demux*/
+void dmx_reset_dmx_hw_ex_unlock(struct wetek_dvb *dvb, struct wetek_dmx *dmx,
+				int reset_irq)
+{
+	{
+		if (!dmx->init)
+			return;
+		if (reset_irq) {
+			if (dmx->dmx_irq != -1)
+				disable_irq(dmx->dmx_irq);
+			if (dmx->dvr_irq != -1)
+				disable_irq(dmx->dvr_irq);
+		}
+	}
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if (reset_irq) {
+		/*del_timer_sync(&dvb->watchdog_timer); */
+		dvb->dmx_watchdog_disable[dmx->id] = 1;
+	}
+#endif
+
+	WRITE_MPEG_REG(RESET3_REGISTER,
+		       (dmx->id) ? ((dmx->id ==
+				     1) ? RESET_DEMUX1 : RESET_DEMUX2) :
+		       RESET_DEMUX0);
+	WRITE_MPEG_REG(RESET3_REGISTER, RESET_DES);
+
+	{
+		int times;
+
+		times = 0;
+		while (times++ < 1000000) {
+			if (!(DMX_READ_REG(dmx->id, OM_CMD_STATUS) & 0x01))
+				break;
+		}
+	}
+
+	/*WRITE_MPEG_REG(STB_TOP_CONFIG, 0); */
+
+	{
+		u32 version, data;
+
+		if (!dmx->init)
+			return;
+
+		if (reset_irq) {
+			if (dmx->dmx_irq != -1)
+				enable_irq(dmx->dmx_irq);
+			if (dmx->dvr_irq != -1)
+				enable_irq(dmx->dvr_irq);
+		}
+		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0x0000);
+		version = DMX_READ_REG(dmx->id, STB_VERSION);
+		DMX_WRITE_REG(dmx->id, STB_TEST_REG, version);
+		pr_dbg("STB %d hardware version : %d\n", dmx->id, version);
+		DMX_WRITE_REG(dmx->id, STB_TEST_REG, 0x5550);
+		data = DMX_READ_REG(dmx->id, STB_TEST_REG);
+		if (data != 0x5550)
+			pr_error("STB %d register access failed\n", dmx->id);
+		DMX_WRITE_REG(dmx->id, STB_TEST_REG, 0xaaa0);
+		data = DMX_READ_REG(dmx->id, STB_TEST_REG);
+		if (data != 0xaaa0)
+			pr_error("STB %d register access failed\n", dmx->id);
+		DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, 0x0000);
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+		DMX_WRITE_REG(dmx->id, STB_INT_STATUS, 0xffff);
+		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL, 0);
+	}
+
+	stb_enable(dvb);
+
+	{
+		int n;
+		unsigned long addr;
+		unsigned long base;
+		unsigned long grp_addr[SEC_BUF_GRP_COUNT];
+		int grp_len[SEC_BUF_GRP_COUNT];
+
+		if (!dmx->init)
+			return;
+
+		if (dmx->sec_pages) {
+			grp_len[0] = (1 << SEC_GRP_LEN_0) * 8;
+			grp_len[1] = (1 << SEC_GRP_LEN_1) * 8;
+			grp_len[2] = (1 << SEC_GRP_LEN_2) * 8;
+			grp_len[3] = (1 << SEC_GRP_LEN_3) * 8;
+
+			grp_addr[0] = virt_to_phys((void *)dmx->sec_pages);
+			grp_addr[1] = grp_addr[0] + grp_len[0];
+			grp_addr[2] = grp_addr[1] + grp_len[1];
+			grp_addr[3] = grp_addr[2] + grp_len[2];
+
+			base = grp_addr[0] & 0xFFFF0000;
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base >> 16);
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START,
+					(((grp_addr[0] - base) >> 8) << 16) |
+					 ((grp_addr[1] - base) >> 8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START,
+					(((grp_addr[2] - base) >> 8) << 16) |
+					 ((grp_addr[3] - base) >> 8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE,
+					SEC_GRP_LEN_0 |
+					(SEC_GRP_LEN_1 << 4) |
+					(SEC_GRP_LEN_2 << 8) |
+					(SEC_GRP_LEN_3 << 12));
+		}
+
+		if (dmx->sub_pages) {
+			addr = virt_to_phys((void *)dmx->sub_pages);
+			DMX_WRITE_REG(dmx->id, SB_START, addr >> 12);
+			DMX_WRITE_REG(dmx->id, SB_LAST_ADDR,
+				      (dmx->sub_buf_len >> 3) - 1);
+		}
+
+		if (dmx->pes_pages) {
+			addr = virt_to_phys((void *)dmx->pes_pages);
+			DMX_WRITE_REG(dmx->id, OB_START, addr >> 12);
+			DMX_WRITE_REG(dmx->id, OB_LAST_ADDR,
+				      (dmx->pes_buf_len >> 3) - 1);
+		}
+
+		for (n = 0; n < CHANNEL_COUNT; n++) {
+			struct wetek_channel *chan = &dmx->channel[n];
+
+			if (chan->used)
+			{
+				dmx_set_chan_regs(dmx, n);
+			}
+		}
+
+		for (n = 0; n < FILTER_COUNT; n++) {
+			struct wetek_filter *filter = &dmx->filter[n];
+
+			if (filter->used)
+				dmx_set_filter_regs(dmx, n);
+		}
+
+		dmx_enable(dmx);
+
+		dmx_smallsec_set(&dmx->smallsec,
+				dmx->smallsec.enable,
+				dmx->smallsec.bufsize,
+				1);
+
+		dmx_timeout_set(&dmx->timeout,
+				dmx->timeout.enable,
+				dmx->timeout.timeout,
+				dmx->timeout.ch_disable,
+				dmx->timeout.match,
+				1);
+	}
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if (reset_irq) {
+		/*mod_timer(&dvb->watchdog_timer,
+		jiffies+msecs_to_jiffies(WATCHDOG_TIMER)); */
+		dvb->dmx_watchdog_disable[dmx->id] = 0;
+	}
+#endif
+}
+
+void dmx_reset_dmx_id_hw_ex_unlock(struct wetek_dvb *dvb, int id, int reset_irq)
+{
+	dmx_reset_dmx_hw_ex_unlock(dvb, &dvb->dmx[id], reset_irq);
+}
+
+void dmx_reset_dmx_hw_ex(struct wetek_dvb *dvb, struct wetek_dmx *dmx,
+			 int reset_irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dmx_reset_dmx_hw_ex_unlock(dvb, dmx, reset_irq);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void dmx_reset_dmx_id_hw_ex(struct wetek_dvb *dvb, int id, int reset_irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dmx_reset_dmx_id_hw_ex_unlock(dvb, id, reset_irq);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void dmx_reset_dmx_hw(struct wetek_dvb *dvb, int id)
+{
+	dmx_reset_dmx_id_hw_ex(dvb, id, 1);
+}
+
+void wetek_reset_dmx_sw(void)
+{
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	int i;
+
+	for (i = 0; i < DMX_DEV_COUNT; i++)
+		dmx_reset_dmx_id_hw_ex(dvb, i, 0);
+}
+EXPORT_SYMBOL(wetek_reset_dmx_sw);
+
+/*Allocate subtitle pes buffer*/
+static int alloc_subtitle_pes_buffer(struct wetek_dmx *dmx)
+{
+	int start_ptr = 0;
+	struct stream_buf_s *sbuff = 0;
+	u32 phy_addr;
+	start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
+	if (start_ptr) {
+		WRITE_MPEG_REG(PARSER_SUB_RP, start_ptr);
+		goto exit;
+	}
+	sbuff = get_stream_buffer(BUF_TYPE_SUBTITLE);
+	if (sbuff) {
+		if (sbuff->flag & BUF_FLAG_IOMEM)
+			phy_addr = sbuff->buf_start;
+		else
+			phy_addr = virt_to_phys((void *)sbuff->buf_start);
+
+		WRITE_MPEG_REG(PARSER_SUB_RP, phy_addr);
+		WRITE_MPEG_REG(PARSER_SUB_START_PTR, phy_addr);
+		WRITE_MPEG_REG(PARSER_SUB_END_PTR,
+			       phy_addr + sbuff->buf_size - 8);
+
+		pr_dbg("pes buff=:%x %x\n", phy_addr, sbuff->buf_size);
+	} else
+		pr_dbg("Error stream buffer\n");
+exit:
+	return 0;
+}
+
+/*Allocate a new channel*/
+int dmx_alloc_chan(struct wetek_dmx *dmx, int type, int pes_type, int pid)
+{
+	int id = -1;
+	int ret;
+
+	if (type == DMX_TYPE_TS) {
+		switch (pes_type) {
+		case DMX_PES_VIDEO:
+			if (!dmx->channel[0].used)
+				id = 0;
+			break;
+		case DMX_PES_AUDIO:
+			if (!dmx->channel[1].used)
+				id = 1;
+			break;
+		case DMX_PES_SUBTITLE:
+		case DMX_PES_TELETEXT:
+			if (!dmx->channel[2].used)
+				id = 2;
+			alloc_subtitle_pes_buffer(dmx);
+			break;
+		case DMX_PES_PCR:
+			if (!dmx->channel[3].used)
+				id = 3;
+			break;
+		case DMX_PES_OTHER:
+			{
+				int i;
+				for (i = SYS_CHAN_COUNT;
+						i < CHANNEL_COUNT; i++) {
+					if (!dmx->channel[i].used) {
+						id = i;
+						break;
+					}
+				}
+			}
+			break;
+		default:
+			break;
+		}
+	} else {
+		int i;
+		for (i = SYS_CHAN_COUNT; i < CHANNEL_COUNT; i++) {
+			if (!dmx->channel[i].used) {
+				id = i;
+				break;
+			}
+		}
+	}
+
+	if (id == -1) {
+		int i;
+		for (i = 0; i < CHANNEL_COUNT; i++) {
+			if (dmx->channel[i].pid == pid) {
+				dmx_free_chan(dmx, i);
+				id = i;
+				break;
+			}
+		}
+		if (id == -1) {
+			pr_error("too many channels\n");
+			return -1;
+		}
+	}
+
+	pr_dbg("allocate channel(id:%d PID:%d)\n", id, pid);
+
+	if (id <= 3) {
+		ret = dmx_get_chan(dmx, pid);
+		if (ret >= 0 && DVR_FEED(dmx->channel[ret].feed)) {
+			dmx_remove_feed(dmx, dmx->channel[ret].feed);
+			dmx->channel[id].dvr_feed = dmx->channel[ret].feed;
+			dmx->channel[id].dvr_feed->priv = (void *)(long)id;
+		} else {
+			dmx->channel[id].dvr_feed = NULL;
+		}
+	}
+
+	dmx->channel[id].type = type;
+	dmx->channel[id].pes_type = pes_type;
+	dmx->channel[id].pid = pid;
+	dmx->channel[id].used = 1;
+	dmx->channel[id].filter_count = 0;
+
+	dmx_set_chan_regs(dmx, id);
+
+	set_debug_dmx_chanpids(dmx->id, id, pid);
+
+	dmx->chan_count++;
+
+	dmx_enable(dmx);
+
+	return id;
+}
+
+/*Free a channel*/
+void dmx_free_chan(struct wetek_dmx *dmx, int cid)
+{
+	pr_dbg("free channel(id:%d PID:0x%x)\n", cid, dmx->channel[cid].pid);
+
+	dmx->channel[cid].used = 0;
+	dmx_set_chan_regs(dmx, cid);
+
+	if (cid == 2) {
+		u32 parser_sub_start_ptr;
+
+		parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
+		WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_start_ptr);
+		WRITE_MPEG_REG(PARSER_SUB_WP, parser_sub_start_ptr);
+	}
+
+	set_debug_dmx_chanpids(dmx->id, cid, -1);
+	dmx->chan_count--;
+
+	dmx_enable(dmx);
+
+	/*Special pes type channel, check its dvr feed */
+	if (cid <= 3 && dmx->channel[cid].dvr_feed) {
+		/*start the dvr feed */
+		dmx_add_feed(dmx, dmx->channel[cid].dvr_feed);
+	}
+}
+
+/*Add a section*/
+static void dmx_remove_filter(struct wetek_dmx *dmx, int cid, int fid);
+
+static int dmx_chan_add_filter(struct wetek_dmx *dmx, int cid,
+			       struct dvb_demux_filter *filter)
+{
+	int id = -1, cont = 0;
+	int i, j;
+
+get_fid:
+	for (i = 0; i < FILTER_COUNT; i++) {
+		if (!dmx->filter[i].used) {
+			id = i;
+			break;
+		}
+	}
+
+	if (id == -1) {
+		for (i = 0; i < FILTER_COUNT; i++)
+			dmx_remove_filter(dmx, dmx->filter[i].chan_id, i);
+		if(!cont) {
+			cont = 1;
+			goto get_fid;
+		}
+		if (id == -1) {
+			pr_error("too many filters\n");
+			return -1;
+		}
+	}
+
+	for (i = SYS_CHAN_COUNT; i < CHANNEL_COUNT; i++) {
+		if ((dmx->channel[i].used) && (i == cid)) {
+			for (j = 0; j < FILTER_COUNT; j++)
+				if(dmx->filter[j].chan_id == cid)
+					dmx_remove_filter(dmx, cid, j);
+		}
+	}
+
+	pr_dbg("channel(id:%d PID:0x%x) add filter(id:%d)\n", cid,
+	       filter->feed->pid, id);
+
+	dmx->filter[id].chan_id = cid;
+	dmx->filter[id].used = 1;
+	dmx->filter[id].filter = (struct dmx_section_filter *)filter;
+	dmx->channel[cid].filter_count++;
+
+	dmx_set_filter_regs(dmx, id);
+
+	return id;
+}
+
+static void dmx_remove_filter(struct wetek_dmx *dmx, int cid, int fid)
+{
+	pr_dbg("channel(id:%d PID:0x%x) remove filter(id:%d)\n", cid,
+	       dmx->channel[cid].pid, fid);
+
+	dmx->filter[fid].used = 0;
+	dmx->channel[cid].filter_count--;
+
+	dmx_set_filter_regs(dmx, fid);
+	dmx_clear_filter_buffer(dmx, fid);
+}
+
+static int sf_add_feed(struct wetek_dmx *src_dmx, struct dvb_demux_feed *feed)
+{
+	int ret;
+
+	struct wetek_dvb *dvb = (struct wetek_dvb *)src_dmx->demux.priv;
+	struct wetek_swfilter *sf = &dvb->swfilter;
+
+	pr_dbg_sf("sf add pid[%d]\n", feed->pid);
+
+	/*init sf */
+	if (!sf->user) {
+		void *mem;
+		mem = vmalloc(SF_BUFFER_SIZE);
+		if (!mem)
+			return -ENOMEM;
+		dvb_ringbuffer_init(&sf->rbuf, mem, SF_BUFFER_SIZE);
+
+		sf->dmx = &dvb->dmx[SF_DMX_ID];
+		sf->afifo = &dvb->asyncfifo[SF_AFIFO_ID];
+
+		sf->dmx->source = src_dmx->source;
+		sf->afifo->source = sf->dmx->id;
+		sf->track_dmx = src_dmx->id;
+		/*sf->afifo->flush_size = 188*10; */
+
+		pr_dbg_sf("init sf mode.\n");
+
+	} else if (sf->dmx->source != src_dmx->source) {
+		pr_error(" pid=%d[src:%d] already used with sfdmx%d[src:%d]\n",
+			 feed->pid, src_dmx->source, sf->dmx->id,
+			 sf->dmx->source);
+		return -EBUSY;
+	}
+
+	/*setup feed */
+	ret = dmx_get_chan(sf->dmx, feed->pid);
+	if (ret >= 0) {
+		pr_error(" pid=%d[dmx:%d] already used [dmx:%d].\n",
+			 feed->pid, src_dmx->id,
+			 ((struct wetek_dmx *)sf->dmx->channel[ret].feed->
+			 demux)->id);
+		return -EBUSY;
+	}
+	ret =
+	     dmx_alloc_chan(sf->dmx, DMX_TYPE_TS, DMX_PES_OTHER,
+			    feed->pid);
+	if (ret < 0) {
+		pr_error(" %s: alloc chan error, ret=%d\n", __func__, ret);
+		return ret;
+	}
+	sf->dmx->channel[ret].feed = feed;
+	feed->priv = (void *)(long)ret;
+
+	sf->dmx->channel[ret].dvr_feed = feed;
+
+	sf->user++;
+	debug_sf_user = sf->user;
+
+	dmx_enable(sf->dmx);
+
+	return 0;
+}
+
+static int sf_remove_feed(struct wetek_dmx *src_dmx, struct dvb_demux_feed *feed)
+{
+	int ret;
+
+	struct wetek_dvb *dvb = (struct wetek_dvb *)src_dmx->demux.priv;
+	struct wetek_swfilter *sf = &dvb->swfilter;
+
+	if (!sf->user || (sf->dmx->source != src_dmx->source))
+		return 0;
+
+	ret = dmx_get_chan(sf->dmx, feed->pid);
+	if (ret < 0)
+		return 0;
+
+	pr_dbg_sf("sf remove pid[%d]\n", feed->pid);
+
+	dmx_free_chan(sf->dmx, (long)feed->priv);
+
+	sf->dmx->channel[ret].feed = NULL;
+	sf->dmx->channel[ret].dvr_feed = NULL;
+
+	sf->user--;
+	debug_sf_user = sf->user;
+
+	if (!sf->user) {
+		sf->dmx->source = -1;
+		sf->afifo->source = AM_DMX_MAX;
+		sf->track_dmx = -1;
+		/*sf->afifo->flush_size = sf->afifo->buf_len>>1; */
+
+		if (sf->rbuf.data) {
+			void *mem = sf->rbuf.data;
+			sf->rbuf.data = NULL;
+			vfree(mem);
+		}
+		pr_dbg_sf("exit sf mode.\n");
+	}
+
+	return 0;
+}
+
+static int sf_feed_sf(struct wetek_dmx *dmx, struct dvb_demux_feed *feed,
+		      int add_not_remove)
+{
+	int sf = 0;
+
+	if (sf_dmx_sf(dmx)) {
+		pr_error("%s: demux %d is in sf mode\n", __func__, dmx->id);
+		return -EINVAL;
+	}
+
+	switch (feed->type) {
+	case DMX_TYPE_TS:{
+			struct dmxdev_filter *dmxdevfilter =
+							 feed->feed.ts.priv;
+	pr_dbg("[pid:%d] ts_type:%x %x, %x\n", feed->pid, feed->ts_type, dmxdevfilter->params.pes.flags, DMX_USE_SWFILTER);
+			if (!DVR_FEED(feed)) {
+				if (dmxdevfilter->params.pes.
+				    flags & DMX_USE_SWFILTER)
+					sf = 1;
+				if (force_pes_sf)
+					sf = 1;
+			}
+		}
+		break;
+
+	case DMX_TYPE_SEC:{
+			struct dvb_demux_filter *filter;
+			for (filter = feed->filter; filter;
+			     filter = filter->next) {
+				struct dmxdev_filter *dmxdevfilter =
+				    filter->filter.priv;
+				if (dmxdevfilter->params.sec.
+				    flags & DMX_USE_SWFILTER)
+					sf = 1;
+				if (add_not_remove)
+					filter->hw_handle = (u16)-1;
+			}
+			if (force_sec_sf)
+				sf = 1;
+		}
+		break;
+	}
+
+	return sf ? 0 : 1;
+}
+
+static int sf_check_feed(struct wetek_dmx *dmx, struct dvb_demux_feed *feed,
+			 int add_not_remove)
+{
+	int ret = 0;
+
+	ret = sf_feed_sf(dmx, feed, add_not_remove);
+	if (ret)
+		return ret;
+
+	pr_dbg_sf("%s [pid:%d] %s\n",
+		  (feed->type == DMX_TYPE_TS) ? "DMX_TYPE_TS" : "DMX_TYPE_SEC",
+		  feed->pid, add_not_remove ? "-> sf mode" : "sf mode ->");
+
+	if (add_not_remove)
+		ret = sf_add_feed(dmx, feed);
+	else
+		ret = sf_remove_feed(dmx, feed);
+
+	if (ret < 0) {
+		pr_error("sf %s feed fail[%d]\n",
+			 add_not_remove ? "add" : "remove", ret);
+	}
+	return ret;
+}
+
+static int dmx_add_feed(struct wetek_dmx *dmx, struct dvb_demux_feed *feed)
+{
+	int id, ret = 0;
+	struct dvb_demux_filter *filter;
+	struct dvb_demux_feed *dfeed = NULL;
+	int sf_ret = 0;		/*<0:error, =0:sf_on, >0:sf_off */
+
+	sf_ret = sf_check_feed(dmx, feed, 1/*SF_FEED_OP_ADD */);
+	if (sf_ret < 0)
+		return sf_ret;
+
+	switch (feed->type) {
+	case DMX_TYPE_TS:
+
+		ret = dmx_get_chan(dmx, feed->pid);
+		pr_dbg("DMX_TYPE_TS pid:%d pes:%d ret:%d sf_ret:%d\n", feed->pid, feed->pes_type, ret, sf_ret);
+		if (ret >= 0) {
+			if (DVR_FEED(dmx->channel[ret].feed)) {
+				if (DVR_FEED(feed)) {
+					/*dvr feed already work */
+					pr_error("PID %d already used(DVR)\n",
+						 feed->pid);
+					return -EBUSY;
+				}
+				if (sf_ret) {
+					/*if sf_on, we do not reset the
+					previous dvr feed, just load the pes
+					feed on the sf, a diffrent data path.*/
+					dfeed = dmx->channel[ret].feed;
+					dmx_remove_feed(dmx, dfeed);
+				}
+			} else {
+				if (DVR_FEED(feed)
+				    && (!dmx->channel[ret].dvr_feed)) {
+					/*just store the dvr_feed */
+					dmx->channel[ret].dvr_feed = feed;
+					feed->priv = (void *)(long)ret;
+					if (!dmx->record)
+						dmx_enable(dmx);
+					dmx_add_recchan(dmx->id, ret);
+					return 0;
+				} else {
+					pr_error("PID %d already used\n",
+						 feed->pid);
+					return -EBUSY;
+				}
+			}
+		}
+
+		if (sf_ret) {	/*not sf feed. */
+			ret =
+			     dmx_alloc_chan(dmx, feed->type,
+						feed->pes_type, feed->pid);
+//			pr_dbg("alloc chan=%d\n", ret);
+			if (ret < 0) {
+				pr_dbg("alloc chan error, ret=%d\n", ret);
+				return ret;
+			}
+			dmx->channel[ret].feed = feed;
+			feed->priv = (void *)(long)ret;
+			dmx->channel[ret].dvr_feed = NULL;
+		}
+		/*dvr */
+		if (DVR_FEED(feed)) {
+			dmx->channel[ret].dvr_feed = feed;
+			feed->priv = (void *)(long)ret;
+			if (!dmx->record)
+				dmx_enable(dmx);
+			dmx_add_recchan(dmx->id, ret);
+		} else if (dfeed && sf_ret) {
+			dmx->channel[ret].dvr_feed = dfeed;
+			dfeed->priv = (void *)(long)ret;
+			if (!dmx->record)
+				dmx_enable(dmx);
+			dmx_add_recchan(dmx->id, ret);
+		}
+
+		break;
+	case DMX_TYPE_SEC: 
+		ret = dmx_get_chan(dmx, feed->pid);
+		pr_dbg("%s: DMX_TYPE_SEC ret:%d sf_ret:%d\n", __func__, ret, sf_ret);
+
+		if (ret >= 0) {
+			if (DVR_FEED(dmx->channel[ret].feed)) {
+				if (sf_ret) {
+					/*if sf_on, we do not reset the
+					previous dvr feed, just load the pes
+					feed on the sf,a diffrent data path.*/
+					dfeed = dmx->channel[ret].feed;
+					dmx_remove_feed(dmx, dfeed);
+				}
+			} else {
+				pr_error("PID %d already used\n", feed->pid);
+				return -EBUSY;
+			}
+		}
+
+		if (sf_ret) {	/*not sf feed. */
+			id = dmx_alloc_chan(dmx, feed->type,
+				feed->pes_type, feed->pid);
+//			pr_dbg("alloc chan=%d\n", id);
+			if (id < 0) {
+				pr_dbg("alloc chan error, ret=%d\n", id);
+				return id;
+			}
+			for (filter = feed->filter; filter;
+				filter = filter->next) {
+				ret = dmx_chan_add_filter(dmx, id, filter);
+				if (ret >= 0)
+					filter->hw_handle = ret;
+				else
+					filter->hw_handle = (u16)-1;
+			}
+			dmx->channel[id].feed = feed;
+			feed->priv = (void *)(long)id;
+			dmx->channel[id].dvr_feed = NULL;
+
+			if (dfeed) {
+				dmx->channel[id].dvr_feed = dfeed;
+				dfeed->priv = (void *)(long)id;
+				if (!dmx->record)
+					dmx_enable(dmx);
+				dmx_add_recchan(dmx->id, id);
+			}
+		}
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	dmx->feed_count++;
+
+	return 0;
+}
+
+static int dmx_remove_feed(struct wetek_dmx *dmx, struct dvb_demux_feed *feed)
+{
+	struct dvb_demux_filter *filter;
+	struct dvb_demux_feed *dfeed = NULL;
+
+	int sf_ret = 0;		/*<0:error, =0:sf_on, >0:sf_off */
+
+	sf_ret = sf_check_feed(dmx, feed, 0/*SF_FEED_OP_RM */);
+	if (sf_ret <= 0)
+		return sf_ret;
+
+	switch (feed->type) {
+	case DMX_TYPE_TS:
+		if (dmx->channel[(long)feed->priv].feed ==
+		    dmx->channel[(long)feed->priv].dvr_feed) {
+			dmx_rm_recchan(dmx->id, (long)feed->priv);
+			dmx_free_chan(dmx, (long)feed->priv);
+		} else {
+			if (feed == dmx->channel[(long)feed->priv].feed) {
+				dfeed = dmx->channel[(long)feed->priv].dvr_feed;
+				dmx_rm_recchan(dmx->id, (long)feed->priv);
+				dmx_free_chan(dmx, (long)feed->priv);
+				if (dfeed) {
+					/*start the dvr feed */
+					dmx_add_feed(dmx, dfeed);
+				}
+			} else if (feed ==
+				   dmx->channel[(long)feed->priv].dvr_feed) {
+				/*just remove the dvr_feed */
+				dmx->channel[(long)feed->priv].dvr_feed = NULL;
+				dmx_rm_recchan(dmx->id,	(long)feed->priv);
+				if (dmx->record) {
+					dmx_enable(dmx);
+				}
+			} else {
+				/*This must never happen */
+				pr_error("%s: unknown feed\n", __func__);
+				return -EINVAL;
+			}
+		}
+
+		break;
+	case DMX_TYPE_SEC:
+		for (filter = feed->filter; filter; filter = filter->next) {
+			if (filter->hw_handle != (u16)-1)
+				dmx_remove_filter(dmx, (long)feed->priv,
+						  (int)filter->hw_handle);
+		}
+
+		dfeed = dmx->channel[(long)feed->priv].dvr_feed;
+		dmx_rm_recchan(dmx->id, (long)feed->priv);
+		dmx_free_chan(dmx, (long)feed->priv);
+		if (dfeed) {
+			/*start the dvr feed */
+			dmx_add_feed(dmx, dfeed);
+		}
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	dmx->feed_count--;
+	return 0;
+}
+
+int wetek_dmx_hw_init(struct wetek_dmx *dmx)
+{
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+	unsigned long flags;
+	int ret;
+
+	/*Demux initialize */
+	spin_lock_irqsave(&dvb->slock, flags);
+	ret = dmx_init(dmx);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int wetek_dmx_hw_deinit(struct wetek_dmx *dmx)
+{
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+	unsigned long flags;
+	int ret;
+	spin_lock_irqsave(&dvb->slock, flags);
+	ret = dmx_deinit(dmx);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+/*extern void afifo_reset(int v);*/
+
+int wetek_asyncfifo_hw_init(struct wetek_asyncfifo *afifo)
+{
+
+/*
+	struct wetek_dvb *dvb = afifo->dvb;
+	unsigned long flags;
+*/
+	int ret;
+
+	int len = ASYNCFIFO_BUFFER_SIZE_DEFAULT;
+	unsigned long buf = asyncfifo_alloc_buffer(len);
+	if (!buf)
+		return -1;
+
+	/*Async FIFO initialize*/
+
+	afifo->init = 0;
+	afifo->flush_size = ASYNCFIFO_BUFFER_SIZE_DEFAULT / 32;
+
+	/*afifo_reset(0);*/
+
+	WRITE_MPEG_REG(RESET6_REGISTER, (1<<11)|(1<<12));
+
+	ret = async_fifo_init(afifo, 1, len, buf);
+/*
+	spin_unlock_irqrestore(&dvb->slock, flags);
+*/
+	if (ret < 0)
+		asyncfifo_free_buffer(buf, len);
+
+	return ret;
+}
+
+int wetek_asyncfifo_hw_deinit(struct wetek_asyncfifo *afifo)
+{
+	struct wetek_dvb *dvb = afifo->dvb;
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	ret = async_fifo_deinit(afifo, 1);
+/*
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	CLK_GATE_OFF(ASYNC_FIFO);
+#endif
+*/
+	/*afifo_reset(1);*/
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int wetek_asyncfifo_hw_reset(struct wetek_asyncfifo *afifo)
+{
+	struct wetek_dvb *dvb = afifo->dvb;
+	unsigned long flags;
+	int ret, src = -1;
+
+	int len = ASYNCFIFO_BUFFER_SIZE_DEFAULT;
+	unsigned long buf = asyncfifo_alloc_buffer(len);
+	if (!buf)
+		return -1;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	if (afifo->init) {
+		src = afifo->source;
+		async_fifo_deinit(afifo, 0);
+	}
+	ret = async_fifo_init(afifo, 0, len, buf);
+	/* restore the source */
+	if (src != -1)
+		afifo->source = src;
+
+	if ((ret == 0) && afifo->dvb)
+		reset_async_fifos(afifo->dvb);
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if (ret < 0)
+		asyncfifo_free_buffer(buf, len);
+
+	return ret;
+}
+#define XPID 8191
+int wetek_dmx_hw_start_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	struct wetek_dmx *dmx = (struct wetek_dmx *)dvbdmxfeed->demux;
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+	unsigned long flags;
+	int ret = 0, pid = dvbdmxfeed->pid;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (!dmx->channel[SYS_CHAN_COUNT].used) {
+		dvbdmxfeed->pid = XPID;
+		dvbdmxfeed->priv = (void *)SYS_CHAN_COUNT;
+		ret = dmx_add_feed(dmx, dvbdmxfeed);
+	}
+	if (pid != XPID) {
+		dvbdmxfeed->pid = pid;
+		ret = dmx_add_feed(dmx, dvbdmxfeed);
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int wetek_dmx_hw_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	struct wetek_dmx *dmx = (struct wetek_dmx *)dvbdmxfeed->demux;
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	if (dvbdmxfeed->pid != XPID)
+		dmx_remove_feed(dmx, dvbdmxfeed);
+	
+	if (dmx->channel[SYS_CHAN_COUNT].used) {
+		dvbdmxfeed->pid = XPID;
+		dvbdmxfeed->priv = (void *)SYS_CHAN_COUNT; 
+		dmx_remove_feed(dmx, dvbdmxfeed);
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+int sf_dmx_track_source(struct wetek_dmx *dmx)
+{
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+	struct wetek_swfilter *sf = &dvb->swfilter;
+	if (sf->user && (dmx->id == sf->track_dmx)) {
+		pr_dbg_sf("tracking dmx src [%d -> %d]\n",
+			  sf->dmx->source, dmx->source);
+		sf->dmx->source = dmx->source;
+		dmx_reset_dmx_hw_ex_unlock(dvb, sf->dmx, 0);
+	}
+	return 0;
+}
+
+int wetek_dmx_hw_set_source(struct dmx_demux *demux, dmx_source_t src)
+{
+	struct wetek_dmx *dmx = (struct wetek_dmx *)demux;
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+	int ret = 0;
+	int hw_src;
+	unsigned long flags;
+
+	if (sf_dmx_sf(dmx)) {
+		pr_error("%s: demux %d is in sf mode\n", __func__, dmx->id);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	hw_src = dmx->source;
+
+	switch (src) {
+	case DMX_SOURCE_FRONT0:
+		hw_src =
+		    (dvb->ts[0].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
+		break;
+	case DMX_SOURCE_FRONT1:
+		hw_src =
+		    (dvb->ts[1].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
+		break;
+	case DMX_SOURCE_FRONT2:
+		hw_src =
+		    (dvb->ts[2].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
+		break;
+	case DMX_SOURCE_DVR0:
+		hw_src = AM_TS_SRC_HIU;
+		break;
+	default:
+		pr_error("illegal demux source %d\n", src);
+		ret = -EINVAL;
+		break;
+	}
+	pr_dbg("src:%d hw_src:%d dmx->source:%d\n",
+						src, hw_src, dmx->source);
+
+	if (hw_src != dmx->source) {
+		dmx->source = hw_src;
+		dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+		sf_dmx_track_source(dmx);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+#define IS_SRC_DMX(_src) ((_src) >= AM_TS_SRC_DMX0 && (_src) <= AM_TS_SRC_DMX2)
+
+int wetek_stb_hw_set_source(struct wetek_dvb *dvb, dmx_source_t src)
+{
+	unsigned long flags;
+	int hw_src;
+	int ret;
+	ret = 0;
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	hw_src = dvb->stb_source;
+
+	switch (src) {
+	case DMX_SOURCE_FRONT0:
+		hw_src =
+		    (dvb->ts[0].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
+		break;
+	case DMX_SOURCE_FRONT1:
+		hw_src =
+		    (dvb->ts[1].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
+		break;
+	case DMX_SOURCE_FRONT2:
+		hw_src =
+		    (dvb->ts[2].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
+		break;
+	case DMX_SOURCE_DVR0:
+		hw_src = AM_TS_SRC_HIU;
+		break;
+	case DMX_SOURCE_FRONT0_OFFSET:
+		hw_src = AM_TS_SRC_DMX0;
+		break;
+	case DMX_SOURCE_FRONT1_OFFSET:
+		hw_src = AM_TS_SRC_DMX1;
+		break;
+	case DMX_SOURCE_FRONT2_OFFSET:
+		hw_src = AM_TS_SRC_DMX2;
+		break;
+	default:
+		pr_error("illegal demux source %d\n", src);
+		ret = -EINVAL;
+		break;
+	}
+	pr_dbg("src:%d hw_src:%d dvb->stb_source:%d\n",
+						src, hw_src, dvb->stb_source);
+
+	if (dvb->stb_source != hw_src) {
+		int old_source = dvb->stb_source;
+		dvb->stb_source = hw_src;
+
+		if (IS_SRC_DMX(old_source)) {
+			dmx_set_misc_id(dvb,
+				(old_source - AM_TS_SRC_DMX0), 0);
+		} else {
+			/*which dmx for av-play is unknown,
+			can't avoid reset-all */
+			dmx_reset_hw_ex(dvb, 0);
+		}
+
+		if (IS_SRC_DMX(dvb->stb_source)) {
+			dmx_set_misc_id(dvb,
+				(dvb->stb_source - AM_TS_SRC_DMX0), 1);
+			/*dmx_reset_dmx_id_hw_ex_unlock
+			   (dvb, (dvb->stb_source-AM_TS_SRC_DMX0), 0); */
+		} else {
+			/*which dmx for av-play is unknown,
+			can't avoid reset-all */
+			dmx_reset_hw_ex(dvb, 0);
+		}
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int wetek_tso_hw_set_source(struct wetek_dvb *dvb, dmx_source_t src)
+{
+	int ret = 0;
+	unsigned long flags;
+	int hw_src;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	hw_src = dvb->tso_source;
+
+	switch (src) {
+	case DMX_SOURCE_FRONT0:
+		hw_src = (dvb->ts[0].mode == AM_TS_SERIAL)
+		    ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
+		break;
+	case DMX_SOURCE_FRONT1:
+		hw_src = (dvb->ts[1].mode == AM_TS_SERIAL)
+		    ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
+		break;
+	case DMX_SOURCE_FRONT2:
+		hw_src = (dvb->ts[2].mode == AM_TS_SERIAL)
+		    ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
+		break;
+	case DMX_SOURCE_DVR0:
+		hw_src = AM_TS_SRC_HIU;
+		break;
+	case DMX_SOURCE_FRONT0_OFFSET:
+		hw_src = AM_TS_SRC_DMX0;
+		break;
+	case DMX_SOURCE_FRONT1_OFFSET:
+		hw_src = AM_TS_SRC_DMX1;
+		break;
+	case DMX_SOURCE_FRONT2_OFFSET:
+		hw_src = AM_TS_SRC_DMX2;
+		break;
+	default:
+		hw_src = -1;
+		ret = -EINVAL;
+		break;
+	}
+	pr_dbg("src:%d hw_src:%d dvb->tso_source:%d\n",
+						src, hw_src, dvb->tso_source);
+
+	if (hw_src != dvb->tso_source) {
+		dvb->tso_source = hw_src;
+		stb_enable(dvb);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int wetek_asyncfifo_hw_set_source(struct wetek_asyncfifo *afifo,
+				enum wetek_dmx_id_t src)
+{
+	struct wetek_dvb *dvb = afifo->dvb;
+	int ret = -1;
+	unsigned long flags;
+
+	if (sf_afifo_sf(afifo)) {
+		pr_error("%s: afifo %d is in sf mode\n", __func__, afifo->id);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	switch (src) {
+	case AM_DMX_0:
+	case AM_DMX_1:
+	case AM_DMX_2:
+		if (afifo->source != src) {
+			afifo->source = src;
+			ret = 0;
+		}
+		break;
+	default:
+		pr_error("illegal async fifo source %d\n", src);
+		ret = -EINVAL;
+		break;
+	}
+	pr_dbg("asyncfifo %d set source %d->%d\n",
+						afifo->id, afifo->source, src);
+
+	if (ret == 0 && afifo->dvb)
+		reset_async_fifos(afifo->dvb);
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int wetek_dmx_hw_set_dump_ts_select(struct dmx_demux *demux, int dump_ts_select)
+{
+	struct wetek_dmx *dmx = (struct wetek_dmx *)demux;
+	struct wetek_dvb *dvb = (struct wetek_dvb *)dmx->demux.priv;
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dump_ts_select = !!dump_ts_select;
+	if (dmx->dump_ts_select != dump_ts_select) {
+		dmx->dump_ts_select = dump_ts_select;
+		dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+u32 wetek_dmx_get_video_pts(struct wetek_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = video_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+u32 wetek_dmx_get_audio_pts(struct wetek_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = audio_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+u32 wetek_dmx_get_first_video_pts(struct wetek_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = first_video_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+u32 wetek_dmx_get_first_audio_pts(struct wetek_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = first_audio_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+int wetek_dmx_set_skipbyte(struct wetek_dvb *dvb, int skipbyte)
+{
+	if (demux_skipbyte != skipbyte) {
+		pr_dbg("set skip byte %d\n", skipbyte);
+		demux_skipbyte = skipbyte;
+		dmx_reset_hw_ex(dvb, 0);
+	}
+
+	return 0;
+}
+
+int wetek_dmx_set_demux(struct wetek_dvb *dvb, int id)
+{
+	wetek_stb_hw_set_source(dvb, DMX_SOURCE_DVR0);
+	if (id < DMX_DEV_COUNT) {
+		struct wetek_dmx *dmx = &dvb->dmx[id];
+		wetek_dmx_hw_set_source((struct dmx_demux *)dmx,
+							DMX_SOURCE_DVR0);
+	}
+
+	return 0;
+}
+
+int _set_tsfile_clkdiv(struct wetek_dvb *dvb, int clkdiv)
+{
+	if (tsfile_clkdiv != clkdiv) {
+		pr_dbg("set ts file clock div %d\n", clkdiv);
+		tsfile_clkdiv = clkdiv;
+		dmx_reset_hw(dvb);
+	}
+
+	return 0;
+}
+
+static ssize_t stb_set_tsfile_clkdiv(struct class *class,
+				     struct class_attribute *attr,
+				     const char *buf, size_t size)
+{
+	/*int div = (int)simple_strtol(buf, NULL, 10);*/
+	long div;
+	if (kstrtol(buf, 0, &div) == 0)
+		_set_tsfile_clkdiv(wetek_get_dvb_device(), (int)div);
+	return size;
+}
+
+static ssize_t stb_get_tsfile_clkdiv(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+	ssize_t ret;
+	ret = sprintf(buf, "%d\n", tsfile_clkdiv);
+	return ret;
+}
+
+
+static int dmx_id;
+
+static ssize_t dmx_smallsec_show(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+	ssize_t ret;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	ret = sprintf(buf, "%d:%d\n", dvb->dmx[dmx_id].smallsec.enable,
+					dvb->dmx[dmx_id].smallsec.bufsize);
+	return ret;
+}
+static ssize_t dmx_smallsec_store(struct class *class,
+				     struct class_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int i, e, s = 0, f = 0;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+
+	i = sscanf(buf, "%d:%i:%d", &e, &s, &f);
+	if (i <= 0)
+		return size;
+
+	dmx_smallsec_set(&dvb->dmx[dmx_id].smallsec, e, s, f);
+	return size;
+}
+
+static ssize_t dmx_timeout_show(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+	ssize_t ret;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	ret = sprintf(buf, "%d:%d:0x%x:%d:%d\n",
+				dvb->dmx[dmx_id].timeout.enable,
+				dvb->dmx[dmx_id].timeout.timeout,
+				dvb->dmx[dmx_id].timeout.ch_disable,
+				dvb->dmx[dmx_id].timeout.match,
+		(DMX_READ_REG(dmx_id, STB_INT_STATUS)&(1<<INPUT_TIME_OUT)) ?
+			1 : 0);
+	DMX_WRITE_REG(dmx_id, STB_INT_STATUS, (1<<INPUT_TIME_OUT));
+	return ret;
+}
+static ssize_t dmx_timeout_store(struct class *class,
+				     struct class_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int i, e, t = 0, c = 0, m = 0, f = 0;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+
+	i = sscanf(buf, "%d:%i:%i:%d:%d", &e, &t, &c, &m, &f);
+	if (i <= 0)
+		return size;
+
+	dmx_timeout_set(&dvb->dmx[dmx_id].timeout, e, t, c, m, f);
+	return size;
+}
+
+static ssize_t dmx_reg_addr_show_source(struct class *class,
+					struct class_attribute *attr,
+					char *buf);
+static ssize_t dmx_reg_addr_store_source(struct class *class,
+					 struct class_attribute *attr,
+					 const char *buf, size_t size);
+static ssize_t dmx_id_show_source(struct class *class,
+				  struct class_attribute *attr, char *buf);
+static ssize_t dmx_id_store_source(struct class *class,
+				   struct class_attribute *attr,
+				   const char *buf, size_t size);
+static ssize_t dmx_reg_value_show_source(struct class *class,
+					 struct class_attribute *attr,
+					 char *buf);
+static ssize_t dmx_reg_value_store_source(struct class *class,
+					  struct class_attribute *attr,
+					  const char *buf, size_t size);
+
+static int reg_addr;
+
+static struct class_attribute wetek_dmx_class_attrs[] = {
+	__ATTR(dmx_id, S_IRUGO | S_IWUSR, dmx_id_show_source,
+	       dmx_id_store_source),
+	__ATTR(register_addr, S_IRUGO | S_IWUSR, dmx_reg_addr_show_source,
+	       dmx_reg_addr_store_source),
+	__ATTR(register_value, S_IRUGO | S_IWUSR, dmx_reg_value_show_source,
+	       dmx_reg_value_store_source),
+	__ATTR(tsfile_clkdiv, S_IRUGO | S_IWUSR, stb_get_tsfile_clkdiv,
+	       stb_set_tsfile_clkdiv),
+
+	__ATTR(dmx_smallsec,  S_IRUGO | S_IWUSR,
+			dmx_smallsec_show,
+			dmx_smallsec_store),
+	__ATTR(dmx_timeout,  S_IRUGO | S_IWUSR,
+			dmx_timeout_show,
+			dmx_timeout_store),
+
+	__ATTR_NULL
+};
+
+static struct class wetek_dmx_class = {
+	.name = "dmx",
+	.class_attrs = wetek_dmx_class_attrs,
+};
+
+static ssize_t dmx_id_show_source(struct class *class,
+				  struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "%d\n", dmx_id);
+	return ret;
+}
+
+static ssize_t dmx_id_store_source(struct class *class,
+				   struct class_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int id = 0;
+	long value = 0;
+	if (kstrtol(buf, 0, &value) == 0)
+		id = (int)value;
+	/*id = simple_strtol(buf, 0, 16);*/
+
+	if (id < 0 || id > 2)
+		pr_dbg("dmx id must 0 ~2\n");
+	else
+		dmx_id = id;
+
+	return size;
+}
+
+static ssize_t dmx_reg_addr_show_source(struct class *class,
+					struct class_attribute *attr,
+					 char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "%x\n", reg_addr);
+	return ret;
+}
+
+static ssize_t dmx_reg_addr_store_source(struct class *class,
+					 struct class_attribute *attr,
+					 const char *buf, size_t size)
+{
+	int addr = 0;
+	/*addr = simple_strtol(buf, 0, 16);*/
+	long value = 0;
+	if (kstrtol(buf, 0, &value) == 0)
+		addr = (int)value;
+	reg_addr = addr;
+	return size;
+}
+
+static ssize_t dmx_reg_value_show_source(struct class *class,
+					 struct class_attribute *attr,
+					 char *buf)
+{
+	int ret, value;
+	value = READ_MPEG_REG(reg_addr);
+	ret = sprintf(buf, "%x\n", value);
+	return ret;
+}
+
+static ssize_t dmx_reg_value_store_source(struct class *class,
+					  struct class_attribute *attr,
+					  const char *buf, size_t size)
+{
+	int value = 0;
+	/*value = simple_strtol(buf, 0, 16);*/
+	long val = 0;
+	if (kstrtol(buf, 0, &val) == 0)
+		value = (int)val;
+	WRITE_MPEG_REG(reg_addr, value);
+	return size;
+}
+
+int wetek_regist_dmx_class(void)
+{
+
+	if (class_register(&wetek_dmx_class) < 0)
+		pr_error("register class error\n");
+
+	return 0;
+}
+
+int wetek_unregist_dmx_class(void)
+{
+
+	class_unregister(&wetek_dmx_class);
+	return 0;
+}
+
+static struct wetek_dmx *get_dmx_from_src(enum wetek_ts_source_t src)
+{
+	int i;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	struct wetek_dmx *dmx = NULL;
+	if (dvb) {
+		switch (src) {
+		case AM_TS_SRC_TS0:
+		case AM_TS_SRC_TS1:
+		case AM_TS_SRC_TS2:
+		case AM_TS_SRC_S_TS0:
+		case AM_TS_SRC_S_TS1:
+		case AM_TS_SRC_S_TS2:
+			for (i = 0; i < DMX_DEV_COUNT; i++) {
+				if (dvb->dmx[i].source == src) {
+					dmx = &dvb->dmx[i];
+					break;
+				}
+				break;
+		case AM_TS_SRC_DMX0:
+				/*if (0 > DMX_DEV_COUNT) */
+				/*dmx = &dvb->dmx[0]; */
+				break;
+		case AM_TS_SRC_DMX1:
+				/*if (1 > DMX_DEV_COUNT) */
+				/*dmx = &dvb->dmx[1]; */
+				break;
+		case AM_TS_SRC_DMX2:
+				/*if (2 > DMX_DEV_COUNT) */
+				/*dmx = &dvb->dmx[2]; */
+				break;
+		default:
+				break;
+			}
+		}
+	}
+	return dmx;
+
+}
+
+void wetek_dmx_register_frontend(enum wetek_ts_source_t src,
+			       struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	struct wetek_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx)
+		dmx->fe = fe;
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void wetek_dmx_before_retune(enum wetek_ts_source_t src, struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	struct wetek_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx) {
+		dmx->fe = fe;
+		dmx->in_tune = 1;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void wetek_dmx_after_retune(enum wetek_ts_source_t src, struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	struct wetek_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx) {
+		dmx->fe = fe;
+		dmx->in_tune = 0;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+//EXPORT_SYMBOL(wetek_dmx_after_retune);
+
+void wetek_dmx_start_error_check(enum wetek_ts_source_t src,
+			       struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	struct wetek_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx) {
+		dmx->fe = fe;
+		dmx->error_check = 0;
+		dmx->int_check_time = 0;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+//EXPORT_SYMBOL(wetek_dmx_start_error_check);
+
+int wetek_dmx_stop_error_check(enum wetek_ts_source_t src, struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	struct wetek_dvb *dvb = wetek_get_dvb_device();
+	struct wetek_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx) {
+		dmx->fe = fe;
+		ret = dmx->error_check;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+//EXPORT_SYMBOL(wetek_dmx_stop_error_check);
diff --git a/drivers/amlogic/wetek/wetek_dvb.c b/drivers/amlogic/wetek/wetek_dvb.c
new file mode 100644
index 0000000..5777b0d
--- /dev/null
+++ b/drivers/amlogic/wetek/wetek_dvb.c
@@ -0,0 +1,1438 @@
+/*
+ * AMLOGIC DVB driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#define ENABLE_DEMUX_DRIVER
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/amstream.h>
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+#include "wetek_stb_define.h"
+#include "wetek_stb_regs_define.h"
+#endif
+
+/*#include <mach/mod_gate.h>*/
+#include <linux/gpio.h>
+#include <linux/spinlock.h>
+#include <linux/amlogic/amdsc.h>
+#include <linux/string.h>
+#include <linux/pinctrl/consumer.h>
+
+#include <linux/reset.h>
+
+#include "linux/amlogic/cpu_version.h"
+
+#include "wetek_dvb.h"
+#include "wetek_dvb_reg.h"
+#include "nimdetect.h"
+
+#define pr_dbg(fmt, args...)\
+	do {\
+		if (debug_dvb)\
+			printk("DVB: %s: " fmt, __func__, ## args);\
+	} while (0)
+#define pr_error(fmt, args...) printk("DVB: %s: " fmt, __func__, ## args)
+#define pr_inf(fmt, args...)   printk("DVB: %s: " fmt, __func__, ## args)
+
+MODULE_PARM_DESC(debug_dvb, "\n\t\t Enable dvb debug information");
+static int debug_dvb;
+module_param(debug_dvb, int, 0644);
+
+#define CARD_NAME "wetek-dvb"
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+static struct wetek_dvb wetek_dvb_device;
+static struct reset_control *wetek_dvb_demux_reset_ctl;
+static struct reset_control *wetek_dvb_afifo_reset_ctl;
+static struct reset_control *wetek_dvb_ahbarb0_reset_ctl;
+static struct reset_control *wetek_dvb_uparsertop_reset_ctl;
+
+static int wetek_tsdemux_reset(void);
+static int wetek_tsdemux_set_reset_flag(void);
+static int wetek_tsdemux_request_irq(irq_handler_t handler, void *data);
+static int wetek_tsdemux_free_irq(void);
+static int wetek_tsdemux_set_vid(int vpid);
+static int wetek_tsdemux_set_aid(int apid);
+static int wetek_tsdemux_set_sid(int spid);
+static int wetek_tsdemux_set_pcrid(int pcrpid);
+static int wetek_tsdemux_set_skipbyte(int skipbyte);
+static int wetek_tsdemux_set_demux(int id);
+
+static struct tsdemux_ops wetek_tsdemux_ops = {
+.reset          = wetek_tsdemux_reset,
+.set_reset_flag = wetek_tsdemux_set_reset_flag,
+.request_irq    = wetek_tsdemux_request_irq,
+.free_irq       = wetek_tsdemux_free_irq,
+.set_vid        = wetek_tsdemux_set_vid,
+.set_aid        = wetek_tsdemux_set_aid,
+.set_sid        = wetek_tsdemux_set_sid,
+.set_pcrid      = wetek_tsdemux_set_pcrid,
+.set_skipbyte   = wetek_tsdemux_set_skipbyte,
+.set_demux      = wetek_tsdemux_set_demux
+};
+static struct class   wetek_stb_class;
+
+static void wetek_dvb_dmx_release(struct wetek_dvb *advb, struct wetek_dmx *dmx)
+{
+	int i;
+
+	dvb_net_release(&dmx->dvb_net);
+	wetek_dmx_hw_deinit(dmx);
+	dmx->demux.dmx.close(&dmx->demux.dmx);
+	dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->mem_fe);
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->hw_fe[i]);
+	}
+
+	dvb_dmxdev_release(&dmx->dmxdev);
+	dvb_dmx_release(&dmx->demux);
+}
+
+static int wetek_dvb_dmx_init(struct wetek_dvb *advb, struct wetek_dmx *dmx, int id)
+{
+	int i, ret;
+#ifndef CONFIG_OF
+	struct resource *res;
+	char buf[32];
+#endif
+	switch(id){
+		case 0:
+			dmx->dmx_irq = INT_DEMUX;
+			break;
+		case 1:
+			dmx->dmx_irq = INT_DEMUX_1;
+			break;
+		case 2:
+			dmx->dmx_irq = INT_DEMUX_2;
+			break;
+	}
+
+#ifndef CONFIG_OF
+	snprintf(buf, sizeof(buf), "demux%d_irq", id);
+	res = platform_get_resource_byname(advb->pdev, IORESOURCE_IRQ, buf);
+	if (res) {
+		dmx->dmx_irq = res->start;
+	}
+#endif
+	pr_dbg("demux%d_irq: %d\n", id, dmx->dmx_irq);
+
+	dmx->source  = 0;
+	dmx->dump_ts_select = 0;
+	dmx->dvr_irq = -1;
+
+	dmx->demux.dmx.capabilities 	= (DMX_TS_FILTERING | DMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING);
+	dmx->demux.filternum 		= dmx->demux.feednum = FILTER_COUNT;
+	dmx->demux.priv 		= advb;
+	dmx->demux.start_feed 		= wetek_dmx_hw_start_feed;
+	dmx->demux.stop_feed 		= wetek_dmx_hw_stop_feed;
+	dmx->demux.write_to_decoder 	= NULL;
+
+	if ((ret = dvb_dmx_init(&dmx->demux)) < 0) {
+		pr_error("dvb_dmx failed: error %d\n",ret);
+		goto error_dmx_init;
+	}
+
+	dmx->dmxdev.filternum = dmx->demux.feednum;
+	dmx->dmxdev.demux = &dmx->demux.dmx;
+	dmx->dmxdev.capabilities = 0;
+	if ((ret = dvb_dmxdev_init(&dmx->dmxdev, &advb->dvb_adapter)) < 0) {
+		pr_error("dvb_dmxdev_init failed: error %d\n",ret);
+		goto error_dmxdev_init;
+	}
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		int source = i+DMX_FRONTEND_0;
+		dmx->hw_fe[i].source = source;
+	pr_dbg("demux%d: source:%d\n", i, source);
+
+		if ((ret = dmx->demux.dmx.add_frontend(&dmx->demux.dmx, &dmx->hw_fe[i])) < 0) {
+			pr_error("adding hw_frontend to dmx failed: error %d",ret);
+			dmx->hw_fe[i].source = 0;
+			goto error_add_hw_fe;
+		}
+	}
+
+	dmx->mem_fe.source = DMX_MEMORY_FE;
+	if ((ret = dmx->demux.dmx.add_frontend(&dmx->demux.dmx, &dmx->mem_fe)) < 0) {
+		pr_error("adding mem_frontend to dmx failed: error %d",ret);
+		goto error_add_mem_fe;
+	}
+
+	if ((ret = dmx->demux.dmx.connect_frontend(&dmx->demux.dmx, &dmx->hw_fe[1])) < 0) {
+		pr_error("connect frontend failed: error %d",ret);
+		goto error_connect_fe;
+	}
+
+	dmx->id = id;
+	dmx->aud_chan = -1;
+	dmx->vid_chan = -1;
+	dmx->sub_chan = -1;
+	dmx->pcr_chan = -1;
+	dmx->smallsec.bufsize   = SS_BUFSIZE_DEF;
+	dmx->smallsec.enable    = 0;
+	dmx->smallsec.dmx       = dmx;
+	dmx->timeout.dmx        =  dmx;
+	dmx->timeout.enable     = 1;
+	dmx->timeout.timeout    = DTO_TIMEOUT_DEF;
+	dmx->timeout.ch_disable = DTO_CHDIS_VAS;
+	dmx->timeout.match      = 1;
+	dmx->timeout.trigger    = 0;
+
+	if ((ret = wetek_dmx_hw_init(dmx)) <0) {
+		pr_error("demux hw init error %d", ret);
+		dmx->id = -1;
+		goto error_dmx_hw_init;
+	}
+pr_dbg("demux%d \n", id);
+
+	dvb_net_init(&advb->dvb_adapter, &dmx->dvb_net, &dmx->demux.dmx);
+
+	return 0;
+error_dmx_hw_init:
+error_connect_fe:
+	dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->mem_fe);
+error_add_mem_fe:
+error_add_hw_fe:
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		if (dmx->hw_fe[i].source)
+			dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->hw_fe[i]);
+	}
+	dvb_dmxdev_release(&dmx->dmxdev);
+error_dmxdev_init:
+	dvb_dmx_release(&dmx->demux);
+error_dmx_init:
+	return ret;
+}
+struct wetek_dvb* wetek_get_dvb_device(void)
+{
+	return &wetek_dvb_device;
+}
+
+EXPORT_SYMBOL(wetek_get_dvb_device);
+
+
+static int wetek_dvb_asyncfifo_init(struct wetek_dvb *advb, struct wetek_asyncfifo *asyncfifo, int id)
+{
+#ifndef CONFIG_OF
+	struct resource *res;
+	char buf[32];
+#endif
+
+	if(id == 0)
+		asyncfifo->asyncfifo_irq = INT_ASYNC_FIFO_FLUSH;
+	else
+		asyncfifo->asyncfifo_irq = INT_ASYNC_FIFO2_FLUSH;
+
+#ifndef CONFIG_OF
+	snprintf(buf, sizeof(buf), "dvr%d_irq", id);
+	res = platform_get_resource_byname(advb->pdev, IORESOURCE_IRQ, buf);
+	if (res) {
+		asyncfifo->asyncfifo_irq = res->start;
+	}
+#endif
+
+	asyncfifo->dvb = advb;
+	asyncfifo->id = id;
+	asyncfifo->init = 0;
+	asyncfifo->flush_size = 188*64;
+
+	return wetek_asyncfifo_hw_init(asyncfifo);
+}
+
+
+static void wetek_dvb_asyncfifo_release(struct wetek_dvb *advb, struct wetek_asyncfifo *asyncfifo)
+{
+	wetek_asyncfifo_hw_deinit(asyncfifo);
+}
+
+
+/*Show the STB input source*/
+static ssize_t stb_show_source(struct class *class, struct class_attribute *attr,char *buf)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	ssize_t ret = 0;
+	char *src;
+
+	switch(dvb->stb_source) {
+		case AM_TS_SRC_TS0:
+		case AM_TS_SRC_S_TS0:
+			src = "ts0";
+		break;
+		case AM_TS_SRC_TS1:
+		case AM_TS_SRC_S_TS1:
+			src = "ts1";
+		break;
+		case AM_TS_SRC_TS2:
+		case AM_TS_SRC_S_TS2:
+			src = "ts2";
+		break;
+		case AM_TS_SRC_HIU:
+			src = "hiu";
+		break;
+		case AM_TS_SRC_DMX0:
+			src = "dmx0";
+		break;
+		case AM_TS_SRC_DMX1:
+			src = "dmx1";
+		break;
+		case AM_TS_SRC_DMX2:
+			src = "dmx2";
+		break;
+		default:
+			src = "disable";
+		break;
+	}
+
+	ret = sprintf(buf, "%s\n", src);
+	return ret;
+}
+
+
+
+/*Set the STB input source*/
+static ssize_t stb_store_source(struct class *class,struct class_attribute *attr, const char *buf, size_t size)
+{
+    dmx_source_t src = -1;
+    if(!strncmp("ts0", buf, 3)) {
+    	src = DMX_SOURCE_FRONT0;
+    } else if(!strncmp("ts1", buf, 3)) {
+    	src = DMX_SOURCE_FRONT1;
+    } else if(!strncmp("ts2", buf, 3)) {
+    	src = DMX_SOURCE_FRONT2;
+    } else if(!strncmp("hiu", buf, 3)) {
+    	src = DMX_SOURCE_DVR0;
+    } else if(!strncmp("dmx0", buf, 4)) {
+        src = DMX_SOURCE_FRONT0+100;
+    } else if(!strncmp("dmx1", buf, 4)) {
+        src = DMX_SOURCE_FRONT1+100;
+    } else if(!strncmp("dmx2", buf, 4)) {
+        src = DMX_SOURCE_FRONT2+100;
+    }
+    if(src!=-1) {
+    	wetek_stb_hw_set_source(&wetek_dvb_device, src);
+    }
+    return size;
+}
+
+/*Show the descrambler's input source*/
+static ssize_t dsc_show_source(struct class *class,struct class_attribute *attr, char *buf)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	ssize_t ret = 0;
+	char *src;
+
+	switch(dvb->dsc_source+7) {
+		case AM_TS_SRC_DMX0:
+			src = "dmx0";
+		break;
+		case AM_TS_SRC_DMX1:
+			src = "dmx1";
+		break;
+		case AM_TS_SRC_DMX2:
+			src = "dmx2";
+		break;
+		default:
+			src = "bypass";
+		break;
+	}
+
+	ret = sprintf(buf, "%s\n", src);
+	return ret;
+}
+
+
+/*Show the TS output source*/
+static ssize_t tso_show_source(struct class *class, struct class_attribute *attr,char *buf)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	ssize_t ret = 0;
+	char *src;
+
+	switch(dvb->tso_source) {
+		case AM_TS_SRC_TS0:
+		case AM_TS_SRC_S_TS0:
+			src = "ts0";
+		break;
+		case AM_TS_SRC_TS1:
+		case AM_TS_SRC_S_TS1:
+			src = "ts1";
+		break;
+		case AM_TS_SRC_TS2:
+		case AM_TS_SRC_S_TS2:
+			src = "ts2";
+		break;
+		case AM_TS_SRC_HIU:
+			src = "hiu";
+		break;
+		case AM_TS_SRC_DMX0:
+			src = "dmx0";
+		break;
+		case AM_TS_SRC_DMX1:
+			src = "dmx1";
+		break;
+		case AM_TS_SRC_DMX2:
+			src = "dmx2";
+		break;
+		default:
+			src = "default";
+		break;
+	}
+
+	ret = sprintf(buf, "%s\n", src);
+	return ret;
+}
+
+
+
+/*Set the TS output source*/
+static ssize_t tso_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+    dmx_source_t src = -1;
+
+    if(!strncmp("ts0", buf, 3)) {
+    	src = DMX_SOURCE_FRONT0;
+    } else if(!strncmp("ts1", buf, 3)) {
+    	src = DMX_SOURCE_FRONT1;
+    } else if(!strncmp("ts2", buf, 3)) {
+    	src = DMX_SOURCE_FRONT2;
+    } else if(!strncmp("hiu", buf, 3)) {
+    	src = DMX_SOURCE_DVR0;
+    } else if(!strncmp("dmx0", buf, 4)) {
+        src = DMX_SOURCE_FRONT0+100;
+    } else if(!strncmp("dmx1", buf, 4)) {
+        src = DMX_SOURCE_FRONT1+100;
+    } else if(!strncmp("dmx2", buf, 4)) {
+        src = DMX_SOURCE_FRONT2+100;
+    }
+
+	wetek_tso_hw_set_source(&wetek_dvb_device, src);
+
+    return size;
+}
+
+/*Show PCR*/
+#define DEMUX_PCR_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_pcr(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	int f = 0;\
+	if(i == 0)\
+		f = READ_MPEG_REG(PCR_DEMUX);\
+	else if(i==1)\
+		f = READ_MPEG_REG(PCR_DEMUX_2);\
+	else if(i==2)\
+		f = READ_MPEG_REG(PCR_DEMUX_3);\
+	return sprintf(buf, "%08x\n", f);\
+}
+
+/*Show the STB input source*/
+#define DEMUX_SOURCE_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_source(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct wetek_dvb *dvb = &wetek_dvb_device;\
+	struct wetek_dmx *dmx = &dvb->dmx[i];\
+	ssize_t ret = 0;\
+	char *src;\
+	switch(dmx->source) {\
+		case AM_TS_SRC_TS0:\
+		case AM_TS_SRC_S_TS0:\
+			src = "ts0";\
+		break;\
+		case AM_TS_SRC_TS1:\
+		case AM_TS_SRC_S_TS1:\
+			src = "ts1";\
+		break;\
+		case AM_TS_SRC_TS2:\
+		case AM_TS_SRC_S_TS2:\
+			src = "ts2";\
+		break;\
+		case AM_TS_SRC_HIU:\
+			src = "hiu";\
+		break;\
+		default:\
+			src = "";\
+		break;\
+	}\
+	ret = sprintf(buf, "%s\n", src);\
+	return ret;\
+}\
+static ssize_t demux##i##_store_source(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    dmx_source_t src = -1;\
+	if(!strncmp("ts0", buf, 3)) {\
+    	src = DMX_SOURCE_FRONT0;\
+    } else if(!strncmp("ts1", buf, 3)) {\
+    	src = DMX_SOURCE_FRONT1;\
+    } else if(!strncmp("ts2", buf, 3)) {\
+    	src = DMX_SOURCE_FRONT2;\
+    } else if(!strncmp("hiu", buf, 3)) {\
+    	src = DMX_SOURCE_DVR0;\
+    }\
+    if(src!=-1) {\
+    	wetek_dmx_hw_set_source(wetek_dvb_device.dmx[i].dmxdev.demux, src);\
+    }\
+    return size;\
+}
+
+/*Show free filters count*/
+#define DEMUX_FREE_FILTERS_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_free_filters(struct class *class,  \
+				struct class_attribute *attr, char *buf)\
+{\
+	struct wetek_dvb *dvb = &wetek_dvb_device;\
+	struct dvb_demux *dmx = &dvb->dmx[i].demux;\
+	int fid, count;\
+	ssize_t ret = 0;\
+	if (mutex_lock_interruptible(&dmx->mutex)) \
+		return -ERESTARTSYS; \
+	count = 0;\
+	for (fid = 0; fid < dmx->filternum; fid++) {\
+		if (!dmx->filter[fid].state != DMX_STATE_FREE)\
+			count++;\
+	} \
+	mutex_unlock(&dmx->mutex);\
+	ret = sprintf(buf, "%d\n", count);\
+	return ret;\
+}
+
+/*Show filter users count*/
+#define DEMUX_FILTER_USERS_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_filter_users(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct wetek_dvb *dvb = &wetek_dvb_device;\
+	struct wetek_dmx *dmx = &dvb->dmx[i];\
+	int dmxdevfid, count;\
+	ssize_t ret = 0;\
+	unsigned long flags;\
+	spin_lock_irqsave(&dvb->slock, flags);\
+	count = 0;\
+	for (dmxdevfid = 0; dmxdevfid < dmx->dmxdev.filternum; dmxdevfid++) {\
+		if (dmx->dmxdev.filter[dmxdevfid].state >= DMXDEV_STATE_ALLOCATED)\
+			count++;\
+	}\
+	if (count > dmx->demux_filter_user) {\
+		count = dmx->demux_filter_user;\
+	} else{\
+		dmx->demux_filter_user = count;\
+	}\
+	spin_unlock_irqrestore(&dvb->slock, flags);\
+	ret = sprintf(buf, "%d\n", count);\
+	return ret;\
+}\
+static ssize_t demux##i##_store_filter_used(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+	struct wetek_dvb *dvb = &wetek_dvb_device;\
+	struct wetek_dmx *dmx = &dvb->dmx[i];\
+	unsigned long filter_used;\
+	unsigned long flags;/*char *endp;*/\
+	/*filter_used = simple_strtol(buf, &endp, 0);*/\
+	int ret = kstrtol(buf, 0, &filter_used);\
+	spin_lock_irqsave(&dvb->slock, flags);\
+	if (ret == 0 && filter_used) {\
+		if(dmx->demux_filter_user < FILTER_COUNT)\
+			dmx->demux_filter_user++;\
+	}else{\
+		if(dmx->demux_filter_user > 0)\
+			dmx->demux_filter_user--;\
+	}\
+	spin_unlock_irqrestore(&dvb->slock, flags);\
+	return size;\
+}
+
+
+/*Show ts header*/
+#define DEMUX_TS_HEADER_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_ts_header(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	int hdr = 0;\
+	if(i == 0)\
+		hdr = READ_MPEG_REG(TS_HEAD_1);\
+	else if(i==1)\
+		hdr = READ_MPEG_REG(TS_HEAD_1_2);\
+	else if(i==2)\
+		hdr = READ_MPEG_REG(TS_HEAD_1_3);\
+	return sprintf(buf, "%08x\n", hdr);\
+}
+
+/*Show channel activity*/
+#define DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_channel_activity(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	int f = 0;\
+	if(i == 0)\
+		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY);\
+	else if(i==1)\
+		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY_2);\
+	else if(i==2)\
+		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY_3);\
+	return sprintf(buf, "%08x\n", f);\
+}
+
+/*DVR record mode*/
+#define DVR_MODE_FUNC_DECL(i)  \
+static ssize_t dvr##i##_show_mode(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct wetek_dvb *dvb = &wetek_dvb_device;\
+	struct wetek_dmx *dmx = &dvb->dmx[i];\
+	ssize_t ret = 0;\
+	char *mode;\
+	if(dmx->dump_ts_select) {\
+		mode = "ts";\
+	}else{\
+		mode = "pid";\
+	}\
+	ret = sprintf(buf, "%s\n", mode);\
+	return ret;\
+}\
+static ssize_t dvr##i##_store_mode(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    struct wetek_dvb *dvb = &wetek_dvb_device;\
+    struct wetek_dmx *dmx = &dvb->dmx[i];\
+    int dump_ts_select = -1;\
+    \
+    if(!strncmp("pid", buf, 3) && dmx->dump_ts_select) {\
+    	dump_ts_select = 0;\
+    } else if(!strncmp("ts", buf, 2) && !dmx->dump_ts_select) {\
+    	dump_ts_select = 1;\
+    }\
+    if(dump_ts_select!=-1) {\
+    	wetek_dmx_hw_set_dump_ts_select(wetek_dvb_device.dmx[i].dmxdev.demux, dump_ts_select);\
+    }\
+    return size;\
+}
+
+#if DMX_DEV_COUNT>0
+	DEMUX_PCR_FUNC_DECL(0)
+	DEMUX_SOURCE_FUNC_DECL(0)
+	DEMUX_FREE_FILTERS_FUNC_DECL(0)
+	DEMUX_FILTER_USERS_FUNC_DECL(0)
+	DVR_MODE_FUNC_DECL(0)
+	DEMUX_TS_HEADER_FUNC_DECL(0)
+	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(0)
+#endif
+#if DMX_DEV_COUNT>1
+	DEMUX_PCR_FUNC_DECL(1)
+	DEMUX_SOURCE_FUNC_DECL(1)
+	DEMUX_FREE_FILTERS_FUNC_DECL(1)
+	DEMUX_FILTER_USERS_FUNC_DECL(1)
+	DVR_MODE_FUNC_DECL(1)
+	DEMUX_TS_HEADER_FUNC_DECL(1)
+	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(1)
+#endif
+#if DMX_DEV_COUNT>2
+	DEMUX_PCR_FUNC_DECL(2)
+	DEMUX_SOURCE_FUNC_DECL(2)
+	DEMUX_FREE_FILTERS_FUNC_DECL(2)
+	DEMUX_FILTER_USERS_FUNC_DECL(2)
+	DVR_MODE_FUNC_DECL(2)
+	DEMUX_TS_HEADER_FUNC_DECL(2)
+	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(2)
+#endif
+
+/*Show the async fifo source*/
+#define ASYNCFIFO_SOURCE_FUNC_DECL(i)  \
+static ssize_t asyncfifo##i##_show_source(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct wetek_dvb *dvb = &wetek_dvb_device;\
+	struct wetek_asyncfifo *afifo = &dvb->asyncfifo[i];\
+	ssize_t ret = 0;\
+	char *src;\
+	switch(afifo->source) {\
+		case AM_DMX_0:\
+			src = "dmx0";\
+		break;\
+		case AM_DMX_1:\
+			src = "dmx1";\
+		break;\
+		case AM_DMX_2:\
+			src = "dmx2";\
+		break;\
+		default:\
+			src = "";\
+		break;\
+	}\
+	ret = sprintf(buf, "%s\n", src);\
+	return ret;\
+}\
+static ssize_t asyncfifo##i##_store_source(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    enum wetek_dmx_id_t src = -1;\
+	if(!strncmp("dmx0", buf, 4)) {\
+    	src = AM_DMX_0;\
+    } else if(!strncmp("dmx1", buf, 4)) {\
+    	src = AM_DMX_1;\
+    } else if(!strncmp("dmx2", buf, 4)) {\
+    	src = AM_DMX_2;\
+    }\
+    if(src!=-1) {\
+    	wetek_asyncfifo_hw_set_source(&wetek_dvb_device.asyncfifo[i], src);\
+    }\
+    return size;\
+}
+
+#if ASYNCFIFO_COUNT>0
+	ASYNCFIFO_SOURCE_FUNC_DECL(0)
+#endif
+#if ASYNCFIFO_COUNT>1
+	ASYNCFIFO_SOURCE_FUNC_DECL(1)
+#endif
+
+/*Show the async fifo flush size*/
+#define ASYNCFIFO_FLUSHSIZE_FUNC_DECL(i)  \
+static ssize_t asyncfifo##i##_show_flush_size(struct class *class,  \
+				struct class_attribute *attr, char *buf)\
+{\
+	struct wetek_dvb *dvb = &wetek_dvb_device;\
+	struct wetek_asyncfifo *afifo = &dvb->asyncfifo[i];\
+	ssize_t ret = 0;\
+	ret = sprintf(buf, "%d\n", afifo->flush_size);\
+	return ret;\
+} \
+static ssize_t asyncfifo##i##_store_flush_size(struct class *class,  \
+					struct class_attribute *attr, \
+					const char *buf, size_t size)\
+{\
+	struct wetek_dvb *dvb = &wetek_dvb_device;\
+	struct wetek_asyncfifo *afifo = &dvb->asyncfifo[i];\
+	/*int fsize = simple_strtol(buf, NULL, 10);*/\
+	int fsize = 0;\
+	long value;\
+	int ret = kstrtol(buf, 0, &value);\
+	if (ret == 0)\
+		fsize = value;\
+	if (fsize != afifo->flush_size) {\
+		afifo->flush_size = fsize;\
+	wetek_asyncfifo_hw_reset(&wetek_dvb_device.asyncfifo[i]);\
+	} \
+	return size;\
+}
+
+#if ASYNCFIFO_COUNT > 0
+ASYNCFIFO_FLUSHSIZE_FUNC_DECL(0)
+#endif
+
+#if ASYNCFIFO_COUNT > 1
+	ASYNCFIFO_FLUSHSIZE_FUNC_DECL(1)
+#endif
+/*Reset the Demux*/
+static ssize_t demux_do_reset(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	if(!strncmp("1", buf, 1)) {
+		struct wetek_dvb *dvb = &wetek_dvb_device;
+		unsigned long flags;
+
+		spin_lock_irqsave(&dvb->slock, flags);
+		pr_dbg("Reset demux, call dmx_reset_hw\n");
+		dmx_reset_hw_ex(dvb, 0);
+		spin_unlock_irqrestore(&dvb->slock, flags);
+	}
+
+	return size;
+}
+
+
+
+
+
+/*Show the Video PTS value*/
+static ssize_t demux_show_video_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", wetek_dmx_get_video_pts(dvb));
+
+	return ret;
+}
+
+
+/*Show the Audio PTS value*/
+static ssize_t demux_show_audio_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", wetek_dmx_get_audio_pts(dvb));
+
+	return ret;
+}
+
+
+
+/*Show the First Video PTS value*/
+static ssize_t demux_show_first_video_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", wetek_dmx_get_first_video_pts(dvb));
+
+	return ret;
+}
+
+
+
+/*Show the First Audio PTS value*/
+static ssize_t demux_show_first_audio_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", wetek_dmx_get_first_audio_pts(dvb));
+
+	return ret;
+}
+
+
+static ssize_t stb_show_hw_setting(struct class *class, struct class_attribute *attr, char *buf)
+{
+	int r, total = 0;
+	int i;
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	int invert, ctrl;
+
+	for(i=0; i<TS_IN_COUNT; i++){
+		struct wetek_ts_input *ts = &dvb->ts[i];
+
+		if(ts->s2p_id != -1){
+			invert = dvb->s2p[ts->s2p_id].invert;
+		}else{
+			invert = 0;
+		}
+
+		ctrl = ts->control;
+
+		r = sprintf(buf, "ts%d %s control: 0x%x invert: 0x%x\n", i,
+				ts->mode==AM_TS_DISABLE?"disable":(ts->mode==AM_TS_SERIAL?"serial":"parallel"),
+				ctrl, invert);
+		buf += r;
+		total += r;
+	}
+
+	return total;
+}
+
+
+
+static ssize_t stb_store_hw_setting(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+	int id, ctrl, invert, r, mode;
+	char mname[32];
+	char pname[32];
+	unsigned long flags;
+	struct wetek_ts_input *ts;
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+
+	r = sscanf(buf, "%d %s %x %x", &id, mname, &ctrl, &invert);
+	if(r != 4)
+		return -EINVAL;
+
+	if(id < 0 || id >= TS_IN_COUNT)
+		return -EINVAL;
+
+	if((mname[0] == 's') || (mname[0] == 'S')){
+		sprintf(pname, "s_ts%d", id);
+		mode = AM_TS_SERIAL;
+	}else if((mname[0] == 'p') || (mname[0] == 'P')){
+		sprintf(pname, "p_ts%d", id);
+		mode = AM_TS_PARALLEL;
+	}else{
+		mode = AM_TS_DISABLE;
+	}
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	ts = &dvb->ts[id];
+
+	if((mode == AM_TS_SERIAL) && (ts->mode != AM_TS_SERIAL)){
+		int i;
+		int scnt = 0;
+
+		for(i = 0; i < TS_IN_COUNT; i++){
+			if(dvb->ts[i].s2p_id != -1){
+				scnt++;
+			}
+		}
+
+		if(scnt >= S2P_COUNT){
+			pr_error("no free s2p\n");
+		}else{
+			ts->s2p_id = scnt;
+		}
+	}
+
+	if((mode != AM_TS_SERIAL) || (ts->s2p_id != -1)){
+		if(ts->pinctrl){
+			devm_pinctrl_put(ts->pinctrl);
+			ts->pinctrl = NULL;
+		}
+
+		ts->pinctrl  = devm_pinctrl_get_select(&dvb->pdev->dev, pname);
+		ts->mode     = mode;
+		ts->control  = ctrl;
+
+		if(mode == AM_TS_SERIAL){
+			dvb->s2p[ts->s2p_id].invert = invert;
+		}else{
+			ts->s2p_id = -1;
+		}
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return count;
+}
+
+/*Get the STB source demux*/
+static struct wetek_dmx* get_stb_dmx(void)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	struct wetek_dmx *dmx = NULL;
+	int i;
+
+	switch(dvb->stb_source){
+		case AM_TS_SRC_DMX0:
+			dmx = &dvb->dmx[0];
+		break;
+		case AM_TS_SRC_DMX1:
+			dmx = &dvb->dmx[1];
+		break;
+		case AM_TS_SRC_DMX2:
+			dmx = &dvb->dmx[2];
+		break;
+		default:
+			for(i=0; i<DMX_DEV_COUNT; i++) {
+				dmx = &dvb->dmx[i];
+				if(dmx->source==dvb->stb_source) {
+					return dmx;
+				}
+			}
+		break;
+	}
+
+	return dmx;
+}
+
+#define DEMUX_RESET_FUNC_DECL(i)  \
+static ssize_t demux##i##_reset_store(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+	if(!strncmp("1", buf, 1)) { \
+		struct wetek_dvb *dvb = &wetek_dvb_device; \
+		pr_info("Reset demux["#i"], call dmx_reset_dmx_hw\n"); \
+		dmx_reset_dmx_id_hw_ex(dvb, i, 0); \
+	} \
+	return size; \
+}
+#if DMX_DEV_COUNT>0
+	DEMUX_RESET_FUNC_DECL(0)
+#endif
+#if DMX_DEV_COUNT>1
+	DEMUX_RESET_FUNC_DECL(1)
+#endif
+#if DMX_DEV_COUNT>2
+	DEMUX_RESET_FUNC_DECL(2)
+#endif
+
+static struct class_attribute wetek_stb_class_attrs[] = {
+	__ATTR(hw_setting, S_IRUGO|S_IWUSR, stb_show_hw_setting, stb_store_hw_setting),
+	__ATTR(source,  S_IRUGO | S_IWUSR | S_IWGRP, stb_show_source, stb_store_source),
+	__ATTR(tso_source,  S_IRUGO | S_IWUSR, tso_show_source, tso_store_source),
+#define DEMUX_SOURCE_ATTR_PCR(i)\
+		__ATTR(demux##i##_pcr,  S_IRUGO | S_IWUSR, demux##i##_show_pcr, NULL)
+#define DEMUX_SOURCE_ATTR_DECL(i)\
+		__ATTR(demux##i##_source,  S_IRUGO | S_IWUSR | S_IWGRP, demux##i##_show_source, demux##i##_store_source)
+#define DEMUX_FREE_FILTERS_ATTR_DECL(i)\
+		__ATTR(demux##i##_free_filters,  S_IRUGO | S_IWUSR, demux##i##_show_free_filters, NULL)
+#define DEMUX_FILTER_USERS_ATTR_DECL(i)\
+		__ATTR(demux##i##_filter_users,  S_IRUGO | S_IWUSR, demux##i##_show_filter_users, demux##i##_store_filter_used)
+#define DVR_MODE_ATTR_DECL(i)\
+		__ATTR(dvr##i##_mode,  S_IRUGO | S_IWUSR, dvr##i##_show_mode, dvr##i##_store_mode)
+#define DEMUX_TS_HEADER_ATTR_DECL(i)\
+		__ATTR(demux##i##_ts_header,  S_IRUGO | S_IWUSR, demux##i##_show_ts_header, NULL)
+#define DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(i)\
+		__ATTR(demux##i##_channel_activity,  S_IRUGO | S_IWUSR, demux##i##_show_channel_activity, NULL)
+#define DMX_RESET_ATTR_DECL(i)\
+		__ATTR(demux##i##_reset,  S_IRUGO | S_IWUSR, NULL, demux##i##_reset_store)
+#if DMX_DEV_COUNT>0
+	DEMUX_SOURCE_ATTR_PCR(0),
+	DEMUX_SOURCE_ATTR_DECL(0),
+	DEMUX_FREE_FILTERS_ATTR_DECL(0),
+	DEMUX_FILTER_USERS_ATTR_DECL(0),
+	DVR_MODE_ATTR_DECL(0),
+	DEMUX_TS_HEADER_ATTR_DECL(0),
+	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(0),
+	DMX_RESET_ATTR_DECL(0),
+#endif
+#if DMX_DEV_COUNT>1
+	DEMUX_SOURCE_ATTR_PCR(1),
+	DEMUX_SOURCE_ATTR_DECL(1),
+	DEMUX_FREE_FILTERS_ATTR_DECL(1),
+	DEMUX_FILTER_USERS_ATTR_DECL(1),
+	DVR_MODE_ATTR_DECL(1),
+	DEMUX_TS_HEADER_ATTR_DECL(1),
+	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(1),
+	DMX_RESET_ATTR_DECL(1),
+#endif
+#if DMX_DEV_COUNT>2
+	DEMUX_SOURCE_ATTR_PCR(2),
+	DEMUX_SOURCE_ATTR_DECL(2),
+	DEMUX_FREE_FILTERS_ATTR_DECL(2),
+	DEMUX_FILTER_USERS_ATTR_DECL(2),
+	DVR_MODE_ATTR_DECL(2),
+	DEMUX_TS_HEADER_ATTR_DECL(2),
+	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(2),
+	DMX_RESET_ATTR_DECL(2),
+#endif
+#define ASYNCFIFO_SOURCE_ATTR_DECL(i)\
+		__ATTR(asyncfifo##i##_source,  S_IRUGO | S_IWUSR | S_IWGRP, asyncfifo##i##_show_source, asyncfifo##i##_store_source)
+#define ASYNCFIFO_FLUSHSIZE_ATTR_DECL(i)\
+		__ATTR(asyncfifo##i##_flush_size,  S_IRUGO | S_IWUSR | S_IWGRP, asyncfifo##i##_show_flush_size, asyncfifo##i##_store_flush_size)
+#if ASYNCFIFO_COUNT>0
+	ASYNCFIFO_SOURCE_ATTR_DECL(0),
+	ASYNCFIFO_FLUSHSIZE_ATTR_DECL(0),
+#endif
+#if ASYNCFIFO_COUNT>1
+	ASYNCFIFO_SOURCE_ATTR_DECL(1),
+	ASYNCFIFO_FLUSHSIZE_ATTR_DECL(1),
+#endif
+	__ATTR(demux_reset,  S_IRUGO | S_IWUSR, NULL, demux_do_reset),
+	__ATTR(video_pts,  S_IRUGO | S_IWUSR | S_IWGRP, demux_show_video_pts, NULL),
+	__ATTR(audio_pts,  S_IRUGO | S_IWUSR | S_IWGRP, demux_show_audio_pts, NULL),
+	__ATTR(first_video_pts,  S_IRUGO | S_IWUSR, demux_show_first_video_pts, NULL),
+	__ATTR(first_audio_pts,  S_IRUGO | S_IWUSR, demux_show_first_audio_pts, NULL),
+	__ATTR_NULL
+};
+
+static struct class wetek_stb_class = {
+	.name = "stb",
+	.class_attrs = wetek_stb_class_attrs,
+};
+
+extern int wetek_regist_dmx_class(void);
+extern int wetek_unregist_dmx_class(void);
+
+int __init wetek_dvb_init(void)
+{
+	struct wetek_nims p;
+	struct platform_device *pdev;
+	struct wetek_dvb *advb;
+	struct devio_wetek_platform_data *pd_dvb;
+	struct dvb_frontend_ops *ops;
+	int i, ret = 0;
+	get_nims_infos(&p);
+	pdev = p.pdev;
+
+	advb = &wetek_dvb_device;
+	memset(advb, 0, sizeof(wetek_dvb_device));
+
+	spin_lock_init(&advb->slock);
+
+	advb->dev = &pdev->dev;
+	advb->pdev = pdev;
+	advb->stb_source = -1;
+	advb->dsc_source = AM_TS_SRC_S_TS0;
+	advb->tso_source = -1;
+
+	for (i = 0; i < DMX_DEV_COUNT; i++) {
+		advb->dmx[i].dmx_irq = -1;
+		advb->dmx[i].dvr_irq = -1;
+	}
+#ifdef CONFIG_OF
+	for (i=0; i<TS_IN_COUNT; i++){
+		advb->ts[i].mode   = AM_TS_DISABLE;
+		advb->ts[i].s2p_id = -1;
+	}
+	advb->ts[0].mode    = AM_TS_PARALLEL;
+	advb->ts[0].pinctrl = p.card_pinctrl;
+#endif
+	pd_dvb = (struct devio_wetek_platform_data *)advb->dev->platform_data;
+
+	ret =
+	    dvb_register_adapter(&advb->dvb_adapter, CARD_NAME, THIS_MODULE,
+				 advb->dev, adapter_nr);
+	if (ret < 0)
+		return ret;
+	pr_inf("Registered adpter: %s\n", CARD_NAME);
+
+	for (i = 0; i < DMX_DEV_COUNT; i++)
+		advb->dmx[i].id = -1;
+
+	advb->dvb_adapter.priv = advb;
+	dev_set_drvdata(advb->dev, advb);
+
+	for (i = 0; i < DMX_DEV_COUNT; i++) {
+		ret = wetek_dvb_dmx_init(advb, &advb->dmx[i], i);
+		if (ret < 0)
+			goto error;
+	}
+	/*Init the async fifos */
+	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+		ret = wetek_dvb_asyncfifo_init(advb, &advb->asyncfifo[i], i);
+		if (ret < 0)
+			goto error;
+
+	}
+	wetek_asyncfifo_hw_set_source(&advb->asyncfifo[0], AM_DMX_0);
+
+	wetek_regist_dmx_class();
+
+	if (class_register(&wetek_stb_class) < 0) {
+		pr_error("register class error\n");
+		goto error;
+	}
+
+	tsdemux_set_ops(&wetek_tsdemux_ops);
+
+	if (dvb_register_frontend(&advb->dvb_adapter, p.fe[0])) {
+		pr_err("Frontend wetek registration failed!!!\n");
+		ops = &p.fe[0]->ops;
+		if (ops->release != NULL)
+			ops->release(p.fe[0]);
+		p.fe[0] = NULL;
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, p.fe[0]);
+
+	pr_inf("WeTeK dvb frontend registered successfully.\n");
+	return ret;
+error:
+	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+		if (advb->asyncfifo[i].id != -1)
+			wetek_dvb_asyncfifo_release(advb, &advb->asyncfifo[i]);
+	}
+
+	for (i = 0; i < DMX_DEV_COUNT; i++) {
+		if (advb->dmx[i].id != -1)
+			wetek_dvb_dmx_release(advb, &advb->dmx[i]);
+	}
+
+	dvb_unregister_adapter(&advb->dvb_adapter);
+
+	return ret;
+}
+
+void __exit wetek_dvb_exit(void)
+{
+	struct wetek_nims p;
+	struct platform_device *pdev;
+	struct wetek_dvb *advb;
+	int i;
+
+	get_nims_infos(&p);
+	pdev = p.pdev;
+	advb = (struct wetek_dvb *)dev_get_drvdata(&pdev->dev);
+
+	tsdemux_set_ops(NULL);
+
+	wetek_unregist_dmx_class();
+	class_unregister(&wetek_stb_class);
+
+
+	for (i = 0; i < DMX_DEV_COUNT; i++)
+		wetek_dvb_dmx_release(advb, &advb->dmx[i]);
+
+	dvb_unregister_adapter(&advb->dvb_adapter);
+
+	for (i = 0; i < TS_IN_COUNT; i++) {
+		if (advb->ts[i].pinctrl)
+			devm_pinctrl_put(advb->ts[i].pinctrl);
+	}
+
+	/*switch_mod_gate_by_name("demux", 0); */
+	reset_control_assert(wetek_dvb_uparsertop_reset_ctl);
+	reset_control_assert(wetek_dvb_ahbarb0_reset_ctl);
+	reset_control_assert(wetek_dvb_afifo_reset_ctl);					
+	reset_control_assert(wetek_dvb_demux_reset_ctl);
+}
+
+static int wetek_tsdemux_reset(void)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	if(dvb->reset_flag) {
+		struct wetek_dmx *dmx = get_stb_dmx();
+		dvb->reset_flag = 0;
+		if(dmx)
+			dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+static int wetek_tsdemux_set_reset_flag(void)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dvb->reset_flag = 1;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+
+}
+
+/*Add the amstream irq handler*/
+static int wetek_tsdemux_request_irq(irq_handler_t handler, void *data)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	struct wetek_dmx *dmx;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+	if(dmx) {
+		dmx->irq_handler = handler;
+		dmx->irq_data = data;
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+/*Free the amstream irq handler*/
+static int wetek_tsdemux_free_irq(void)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	struct wetek_dmx *dmx;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+	if(dmx) {
+		dmx->irq_handler = NULL;
+		dmx->irq_data = NULL;
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+/*Reset the video PID*/
+static int wetek_tsdemux_set_vid(int vpid)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	struct wetek_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dvb->slock, flags);
+
+		if(dmx->vid_chan!=-1) {
+			dmx_free_chan(dmx, dmx->vid_chan);
+			dmx->vid_chan = -1;
+		}
+
+		if((vpid>=0) && (vpid<0x1FFF)) {
+			dmx->vid_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_VIDEO, vpid);
+			if(dmx->vid_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dvb->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+/*Reset the audio PID*/
+static int wetek_tsdemux_set_aid(int apid)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	struct wetek_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dvb->slock, flags);
+
+		if(dmx->aud_chan!=-1) {
+			dmx_free_chan(dmx, dmx->aud_chan);
+			dmx->aud_chan = -1;
+		}
+
+		if((apid>=0) && (apid<0x1FFF)) {
+			dmx->aud_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_AUDIO, apid);
+			if(dmx->aud_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dvb->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+/*Reset the subtitle PID*/
+static int wetek_tsdemux_set_sid(int spid)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	struct wetek_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dvb->slock, flags);
+
+		if(dmx->sub_chan!=-1) {
+			dmx_free_chan(dmx, dmx->sub_chan);
+			dmx->sub_chan = -1;
+		}
+
+		if((spid>=0) && (spid<0x1FFF)) {
+			dmx->sub_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_SUBTITLE, spid);
+			if(dmx->sub_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dvb->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+static int wetek_tsdemux_set_pcrid(int pcrpid)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	struct wetek_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dvb->slock, flags);
+
+		if(dmx->pcr_chan!=-1) {
+			dmx_free_chan(dmx, dmx->pcr_chan);
+			dmx->pcr_chan = -1;
+		}
+
+		if((pcrpid>=0) && (pcrpid<0x1FFF)) {
+			dmx->pcr_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_PCR, pcrpid);
+			if(dmx->pcr_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dvb->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+static int wetek_tsdemux_set_skipbyte(int skipbyte)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	wetek_dmx_set_skipbyte(dvb, skipbyte);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+static int wetek_tsdemux_set_demux(int id)
+{
+	struct wetek_dvb *dvb = &wetek_dvb_device;
+
+	wetek_dmx_set_demux(dvb, id);
+	return 0;
+}
+
+module_init(wetek_dvb_init);
+module_exit(wetek_dvb_exit);
+
+MODULE_DESCRIPTION("driver for WeTeK DVB card");
+MODULE_AUTHOR("afl1");
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/amlogic/wetek/wetek_dvb.h b/drivers/amlogic/wetek/wetek_dvb.h
new file mode 100644
index 0000000..ea5a52f
--- /dev/null
+++ b/drivers/amlogic/wetek/wetek_dvb.h
@@ -0,0 +1,331 @@
+#ifndef _WETEK_DVB_H_
+#define _WETEK_DVB_H_
+
+#include <linux/interrupt.h>
+#include <linux/socket.h>
+#include <linux/netdevice.h>
+#include <linux/i2c.h>
+
+#include <linux/dvb/video.h>
+#include <linux/dvb/audio.h>
+#include <linux/dvb/dmx.h>
+#include <linux/dvb/ca.h>
+#include <linux/dvb/osd.h>
+#include <linux/dvb/net.h>
+#include <linux/dvb/frontend.h>
+
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+
+#include "dvbdev.h"
+#include "demux.h"
+#include "dvb_demux.h"
+#include "dmxdev.h"
+#include "dvb_filter.h"
+#include "dvb_net.h"
+#include "dvb_ringbuffer.h"
+#include "dvb_frontend.h"
+
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+
+#define TS_IN_COUNT       3
+#define S2P_COUNT         2
+
+#define DMX_DEV_COUNT     3
+#define FE_DEV_COUNT      2
+#define CHANNEL_COUNT     31
+#define FILTER_COUNT      31
+#define FILTER_LEN        15
+#define DSC_DEV_COUNT     1
+#define DSC_COUNT         8
+#define SEC_BUF_GRP_COUNT 4
+#define SEC_BUF_BUSY_SIZE 4
+#define SEC_BUF_COUNT     (SEC_BUF_GRP_COUNT*8)
+#define ASYNCFIFO_COUNT   2
+
+
+enum wetek_dmx_id_t {
+	AM_DMX_0 = 0,
+	AM_DMX_1,
+	AM_DMX_2,
+	AM_DMX_MAX,
+};
+
+enum wetek_ts_source_t {
+	AM_TS_SRC_TS0,
+	AM_TS_SRC_TS1,
+	AM_TS_SRC_TS2,
+	AM_TS_SRC_S_TS0,
+	AM_TS_SRC_S_TS1,
+	AM_TS_SRC_S_TS2,
+	AM_TS_SRC_HIU,
+	AM_TS_SRC_DMX0,
+	AM_TS_SRC_DMX1,
+	AM_TS_SRC_DMX2
+};
+
+struct wetek_sec_buf {
+	unsigned long        addr;
+	int                  len;
+};
+
+struct wetek_channel {
+	int                  type;
+	enum dmx_ts_pes	pes_type;
+	int                  pid;
+	int                  used;
+	int                  filter_count;
+	struct dvb_demux_feed     *feed;
+	struct dvb_demux_feed     *dvr_feed;
+};
+
+struct wetek_filter {
+	int                  chan_id;
+	int                  used;
+	struct dmx_section_filter *filter;
+	u8                   value[FILTER_LEN];
+	u8                   maskandmode[FILTER_LEN];
+	u8                   maskandnotmode[FILTER_LEN];
+	u8                   neq;
+};
+
+struct wetek_dsc {
+	int                  pid;
+	u8                   even[8];
+	u8                   odd[8];
+	int                  used;
+	int                  set;
+	int                  id;
+	struct wetek_dvb      *dvb;
+};
+
+struct wetek_smallsec {
+	struct wetek_dmx *dmx;
+
+	int	enable;
+	int	bufsize;
+#define SS_BUFSIZE_DEF (16*4*256) /*16KB*/
+	long	buf;
+	long	buf_map;
+};
+
+struct wetek_dmxtimeout {
+	struct wetek_dmx *dmx;
+
+	int	enable;
+
+	int	timeout;
+#define DTO_TIMEOUT_DEF (9000)       /*0.5s*/
+	u32	ch_disable;
+#define DTO_CHDIS_VAS   (0xfffffff8) /*v/a/s only*/
+	int	match;
+
+	int     trigger;
+};
+
+struct wetek_dmx {
+	struct dvb_demux     demux;
+	struct dmxdev        dmxdev;
+	int                  id;
+	int                  feed_count;
+	int                  chan_count;
+	enum wetek_ts_source_t      source;
+	int                  init;
+	int                  record;
+	struct dmx_frontend  hw_fe[DMX_DEV_COUNT];
+	struct dmx_frontend  mem_fe;
+	struct dvb_net       dvb_net;
+	int                  dmx_irq;
+	int                  dvr_irq;
+	struct tasklet_struct     dmx_tasklet;
+	struct tasklet_struct     dvr_tasklet;
+	unsigned long        sec_pages;
+	unsigned long        sec_pages_map;
+	int                  sec_total_len;
+	struct wetek_sec_buf   sec_buf[SEC_BUF_COUNT];
+	unsigned long        pes_pages;
+	unsigned long        pes_pages_map;
+	int                  pes_buf_len;
+	unsigned long        sub_pages;
+	unsigned long        sub_pages_map;
+	int                  sub_buf_len;
+	struct wetek_channel   channel[CHANNEL_COUNT];
+	struct wetek_filter    filter[FILTER_COUNT];
+	irq_handler_t        irq_handler;
+	void                *irq_data;
+	int                  aud_chan;
+	int                  vid_chan;
+	int                  sub_chan;
+	int                  pcr_chan;
+	u32                  section_busy[SEC_BUF_BUSY_SIZE];
+	struct dvb_frontend *fe;
+	int                  int_check_count;
+	u32                  int_check_time;
+	int                  in_tune;
+	int                  error_check;
+	int                  dump_ts_select;
+	int                  sec_buf_watchdog_count[SEC_BUF_COUNT];
+
+	struct wetek_smallsec  smallsec;
+	struct wetek_dmxtimeout timeout;
+
+	int                  demux_filter_user;
+};
+
+struct wetek_asyncfifo {
+	int	id;
+	int	init;
+	int	asyncfifo_irq;
+	enum wetek_dmx_id_t	source;
+	unsigned long	pages;
+	unsigned long   pages_map;
+	int	buf_len;
+	int	buf_toggle;
+	int buf_read;
+	int flush_size;
+	struct tasklet_struct     asyncfifo_tasklet;
+	struct wetek_dvb *dvb;
+};
+
+enum{
+	AM_TS_DISABLE,
+	AM_TS_PARALLEL,
+	AM_TS_SERIAL
+};
+
+struct wetek_ts_input {
+	int                  mode;
+	struct pinctrl      *pinctrl;
+	int                  control;
+	int                  s2p_id;
+};
+
+struct wetek_s2p {
+	int    invert;
+};
+
+struct wetek_swfilter {
+	int    user;
+	struct wetek_dmx *dmx;
+	struct wetek_asyncfifo *afifo;
+
+	struct dvb_ringbuffer rbuf;
+#define SF_BUFFER_SIZE (10*188*1024)
+
+	u8     wrapbuf[188];
+	int    track_dmx;
+};
+
+struct wetek_dvb {
+	struct dvb_device    dvb_dev;
+	struct wetek_ts_input  ts[TS_IN_COUNT];
+	struct wetek_s2p       s2p[S2P_COUNT];
+	struct wetek_dmx       dmx[DMX_DEV_COUNT];
+	struct wetek_dsc       dsc[DSC_COUNT];
+	struct wetek_asyncfifo asyncfifo[ASYNCFIFO_COUNT];
+	struct dvb_device   *dsc_dev;
+	struct dvb_adapter   dvb_adapter;
+	struct device       *dev;
+	struct platform_device *pdev;
+	enum wetek_ts_source_t      stb_source;
+	enum wetek_ts_source_t      dsc_source;
+	enum wetek_ts_source_t      tso_source;
+	int                  dmx_init;
+	int                  reset_flag;
+	spinlock_t           slock;
+	struct timer_list    watchdog_timer;
+	int                  dmx_watchdog_disable[DMX_DEV_COUNT];
+	struct wetek_swfilter  swfilter;
+	int		     ts_out_invert;
+};
+
+
+/*AMLogic demux interface*/
+extern int wetek_dmx_hw_init(struct wetek_dmx *dmx);
+extern int wetek_dmx_hw_deinit(struct wetek_dmx *dmx);
+extern int wetek_dmx_hw_start_feed(struct dvb_demux_feed *dvbdmxfeed);
+extern int wetek_dmx_hw_stop_feed(struct dvb_demux_feed *dvbdmxfeed);
+extern int wetek_dmx_hw_set_source(struct dmx_demux *demux, dmx_source_t src);
+extern int wetek_stb_hw_set_source(struct wetek_dvb *dvb, dmx_source_t src);
+extern int wetek_dsc_hw_set_source(struct wetek_dvb *dvb, dmx_source_t src);
+extern int wetek_tso_hw_set_source(struct wetek_dvb *dvb, dmx_source_t src);
+
+extern int wetek_dmx_set_skipbyte(struct wetek_dvb *dvb, int skipbyte);
+extern int wetek_dmx_set_demux(struct wetek_dvb *dvb, int id);
+extern int wetek_dmx_hw_set_dump_ts_select
+		(struct dmx_demux *demux, int dump_ts_select);
+
+extern int  dmx_alloc_chan(struct wetek_dmx *dmx, int type,
+				int pes_type, int pid);
+extern void dmx_free_chan(struct wetek_dmx *dmx, int cid);
+
+extern int dmx_get_ts_serial(enum wetek_ts_source_t src);
+
+
+/*AMLogic dsc interface*/
+extern int dsc_set_pid(struct wetek_dsc *dsc, int pid);
+extern int dsc_set_key(struct wetek_dsc *dsc, int type, u8 *key);
+extern int dsc_release(struct wetek_dsc *dsc);
+
+/*AMLogic ASYNC FIFO interface*/
+extern int wetek_asyncfifo_hw_init(struct wetek_asyncfifo *afifo);
+extern int wetek_asyncfifo_hw_deinit(struct wetek_asyncfifo *afifo);
+extern int wetek_asyncfifo_hw_set_source(struct wetek_asyncfifo *afifo,
+					enum wetek_dmx_id_t src);
+extern int wetek_asyncfifo_hw_reset(struct wetek_asyncfifo *afifo);
+
+/*Get the Audio & Video PTS*/
+extern u32 wetek_dmx_get_video_pts(struct wetek_dvb *dvb);
+extern u32 wetek_dmx_get_audio_pts(struct wetek_dvb *dvb);
+extern u32 wetek_dmx_get_first_video_pts(struct wetek_dvb *dvb);
+extern u32 wetek_dmx_get_first_audio_pts(struct wetek_dvb *dvb);
+
+/*Get the DVB device*/
+extern struct wetek_dvb *wetek_get_dvb_device(void);
+
+/*Demod interface*/
+extern void wetek_dmx_register_frontend(enum wetek_ts_source_t src,
+					struct dvb_frontend *fe);
+extern void wetek_dmx_before_retune(enum wetek_ts_source_t src,
+					struct dvb_frontend *fe);
+extern void wetek_dmx_after_retune(enum wetek_ts_source_t src,
+					struct dvb_frontend *fe);
+extern void wetek_dmx_start_error_check(enum wetek_ts_source_t src,
+					struct dvb_frontend *fe);
+extern int  wetek_dmx_stop_error_check(enum wetek_ts_source_t src,
+					struct dvb_frontend *fe);
+extern int wetek_regist_dmx_class(void);
+extern int wetek_unregist_dmx_class(void);
+extern void dvb_frontend_retune(struct dvb_frontend *fe);
+
+struct devio_wetek_platform_data {
+	int (*io_setup)(void *);
+	int (*io_cleanup)(void *);
+	int (*io_power)(void *, int enable);
+	int (*io_reset)(void *, int enable);
+};
+
+/*Reset the demux device*/
+void dmx_reset_hw(struct wetek_dvb *dvb);
+void dmx_reset_hw_ex(struct wetek_dvb *dvb, int reset_irq);
+
+/*Reset the individual demux*/
+void dmx_reset_dmx_hw(struct wetek_dvb *dvb, int id);
+void dmx_reset_dmx_id_hw_ex(struct wetek_dvb *dvb, int id, int reset_irq);
+void dmx_reset_dmx_id_hw_ex_unlock(struct wetek_dvb *dvb, int id, int reset_irq);
+void dmx_reset_dmx_hw_ex(struct wetek_dvb *dvb,
+				struct wetek_dmx *dmx,
+				int reset_irq);
+void dmx_reset_dmx_hw_ex_unlock(struct wetek_dvb *dvb,
+				struct wetek_dmx *dmx,
+				int reset_irq);
+
+#endif
+
diff --git a/drivers/amlogic/wetek/wetek_dvb_reg.h b/drivers/amlogic/wetek/wetek_dvb_reg.h
new file mode 100644
index 0000000..77d5303
--- /dev/null
+++ b/drivers/amlogic/wetek/wetek_dvb_reg.h
@@ -0,0 +1,46 @@
+/*
+ * drivers/amlogic/dvb_tv/dvb_reg.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef _DVB_REG_H_
+#define _DVB_REG_H_
+
+#include <linux/amlogic/iomap.h>
+
+#include "wetek_stb_define.h"
+#include "wetek_stb_regs_define.h"
+
+#define WRITE_MPEG_REG(_r, _v)   aml_write_cbus(_r, _v)
+#define READ_MPEG_REG(_r)        aml_read_cbus(_r)
+
+#define WRITE_CBUS_REG(_r, _v)   aml_write_cbus(_r, _v)
+#define READ_CBUS_REG(_r)        aml_read_cbus(_r)
+
+#define WRITE_VCBUS_REG(_r, _v)  aml_write_vcbus(_r, _v)
+#define READ_VCBUS_REG(_r)       aml_read_vcbus(_r)
+
+#define BASE_IRQ 32
+#define AM_IRQ(reg)             (reg + BASE_IRQ)
+#define INT_DEMUX               AM_IRQ(23)
+#define INT_DEMUX_1             AM_IRQ(5)
+#define INT_DEMUX_2             AM_IRQ(53)
+#define INT_ASYNC_FIFO_FILL     AM_IRQ(18)
+#define INT_ASYNC_FIFO_FLUSH    AM_IRQ(19)
+#define INT_ASYNC_FIFO2_FILL    AM_IRQ(24)
+#define INT_ASYNC_FIFO2_FLUSH   AM_IRQ(25)
+
+#endif
+
diff --git a/drivers/amlogic/wetek/wetek_stb_define.h b/drivers/amlogic/wetek/wetek_stb_define.h
new file mode 100644
index 0000000..5061a89
--- /dev/null
+++ b/drivers/amlogic/wetek/wetek_stb_define.h
@@ -0,0 +1,1163 @@
+/* ----------------------------------------------------------------------*/
+/* This file is automatically generated from the script:*/
+/**/
+/* ./create_stb_define_for_C_code.pl*/
+/**/
+/* and was applied to the file*/
+/**/
+/* ./stb_define.h*/
+/**/
+/* DO NOT EDIT!!!!!*/
+/* ----------------------------------------------------------------------*/
+/**/
+#ifdef C_STB_DEFINE_H
+#else
+#define C_STB_DEFINE_H
+
+/*=================================================*/
+/*  STB Registers Start*/
+/*=================================================*/
+/* -----------------------------------------------*/
+#define STB_CBUS_BASE           0x1600
+/* -----------------------------------------------*/
+/* There are two instantiations under one CBUS slave.
+ * Each CBUS slave can support*/
+/* 256 registers.
+ * Each demux is allocated 128 registers so set the offset in*/
+/* the middle*/
+/* Copy this define but don't add a base address*/
+#define DEMUX_1_OFFSET         0x00
+#define DEMUX_2_OFFSET         0x50
+#define DEMUX_3_OFFSET         0xa0
+/*======================================================*/
+/*  STB TOP Registers                   (8'hf0 - 8'hf7)*/
+/*======================================================*/
+/* bit 30:28 -- ciplus_o_sel*/
+/* bit 27:26 -- ciplus_i_sel*/
+/* bit 25 -- use FAIL fro TS2*/
+/* bit 24 -- use FAIL fro TS1*/
+/* bit 23 -- use FAIL fro TS0*/
+/* bit 22 -- invert fec_error for S2P1*/
+/* bit 21 -- invert fec_data for S2P1*/
+/* bit 20 -- invert fec_sync for S2P1*/
+/* bit 19 -- invert fec_valid for S2P1*/
+/* bit 18 -- invert fec_clk for S2P1*/
+/* bit 17:16 -- fec_s_sel for S2P1
+ * 00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved*/
+/* Bit 15 -- enable_des_pl_clk*/
+/* Bit 14:13 -- reserved*/
+/* Bit 12:10 -- ts_out_select,
+ * 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File*/
+/* bit 9:8 -- des_i_sel 00 -- select demux0 as des input,
+*  01 -- select_demux1, 10 -- select_demux2, 11 - reserved*/
+/* bit 7 -- enable_des_pl*/
+/* bit 6 -- invert fec_error for S2P0*/
+/* bit 5 -- invert fec_data for S2P0*/
+/* bit 4 -- invert fec_sync for S2P0*/
+/* bit 3 -- invert fec_valid for S2P0*/
+/* bit 2 -- invert fec_clk for S2P0*/
+/* bit 1:0 -- fec_s_sel for S2P0
+ * 00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved*/
+/*#define STB_TOP_CONFIG          (STB_CBUS_BASE + 0xf0) // 0x16f0*/
+/*----------- bit define -----------*/
+#define INVERT_S2P1_FEC_ERROR       22
+#define INVERT_S2P1_FEC_DATA        21
+#define INVERT_S2P1_FEC_SYNC        20
+#define INVERT_S2P1_FEC_VALID       19
+#define INVERT_S2P1_FEC_CLK         18
+#define S2P1_FEC_SERIAL_SEL         16
+#define ENABLE_DES_PL_CLK           15
+#define TS_OUTPUT_SOURCE            10
+#define DES_INPUT_SEL               8
+#define ENABLE_DES_PL               7
+#define INVERT_S2P0_FEC_ERROR       6
+#define INVERT_S2P0_FEC_DATA        5
+#define INVERT_S2P0_FEC_SYNC        4
+#define INVERT_S2P0_FEC_VALID       3
+#define INVERT_S2P0_FEC_CLK         2
+#define S2P0_FEC_SERIAL_SEL         0
+
+/* 31:28 - s2p1_clk_div*/
+/* 27:24 - s2p0_clk_div*/
+/* 23    - s2p1_disable*/
+/* 22    - s2p0_disable*/
+/* 21    - Reserved*/
+/* 20 -- TS_OUT_error_INVERT*/
+/* 19 -- TS_OUT_data_INVERT*/
+/* 18 -- TS_OUT_sync_INVERT*/
+/* 17 -- TS_OUT_valid_INVERT*/
+/* 16 -- TS_OUT_clk_INVERT*/
+/* 15:8 -- TS_package_length_sub_1 (default : 187)*/
+/*  7:0 -- fec_sync_byte (default : 0x47)*/
+/*#define TS_TOP_CONFIG           (STB_CBUS_BASE + 0xf1) // 0x16f1*/
+/*----------- bit define -----------*/
+#define TS_OUT_CLK_INVERT	    16
+#define TS_PACKAGE_LENGTH_SUB_1     8
+#define FEC_DEFAULT_SYNC_BYTE       0
+
+/* Bit 25:24 -- transport_scrambling_control_odd_2 // should be 3*/
+/* Bit 23:16 -- file_m2ts_skip_bytes*/
+/* Bit 15:8 -- des_out_dly*/
+/* Bit 7:6 -- transport_scrambling_control_odd // should be 3*/
+/* Bit 5 -- ts_hiu_enable*/
+/* Bit 4:0 -- fec_clk_div*/
+/*#define TS_FILE_CONFIG          (STB_CBUS_BASE + 0xf2) // 0x16f2*/
+/*----------- bit define -----------*/
+#define TRANSPORT_SCRAMBLING_CONTROL_ODD_2 24
+#define FILE_M2TS_SKIP_BYTES        16
+#define DES_OUT_DLY                 8
+#define TRANSPORT_SCRAMBLING_CONTROL_ODD 6
+#define TS_HIU_ENABLE               5
+#define FEC_FILE_CLK_DIV            0
+
+/* Bit 19:14 -- des_2 ts pl state   -- Read Only*/
+/* Bit 13:8 -- des ts pl state   -- Read Only*/
+/* Bit 3:0 PID index to 8 PID to get key-set*/
+/* auto increse after TS_PL_PID_DATA read/write*/
+/*#define TS_PL_PID_INDEX         (STB_CBUS_BASE + 0xf3) // 0x16f3*/
+/*----------- bit define -----------*/
+#define DES_TS_PL_STATE             8
+#define DES_2_TS_PL_STATE           14
+
+/* Bit 13 -- PID match disble*/
+/* Bit 12:0 -- PID*/
+/*#define TS_PL_PID_DATA          (STB_CBUS_BASE + 0xf4) // 0x16f4*/
+/*----------- bit define -----------*/
+#define PID_MATCH_DISABLE_HIGH       29
+#define PID_MATCH_HIGH               16
+#define PID_MATCH_DISABLE_LOW        13
+#define PID_MATCH_LOW                0
+
+/*#define COMM_DESC_KEY0
+ * (STB_CBUS_BASE + 0xf5) // 0x16f5
+ Common descrambler key (key bits[63:32])*/
+/*#define COMM_DESC_KEY1
+ * (STB_CBUS_BASE + 0xf6) // 0x16f6
+ Common descrambler key (key bits[31:0])*/
+/*#define COMM_DESC_KEY_RW
+ * (STB_CBUS_BASE + 0xf7) // 0x16f7 // bits[3:0]
+ * point to the address to write the key
+ * {COMM_DESC_KEY3,...,COMM_DESC_KEY0}*/
+/* Writing this register writes the key to RAM*/
+
+/* bit 15:8 - des_out_dly_2*/
+/* bit   7 - reserved*/
+/* Bit   6-- enable_des_pl_clk_2*/
+/* bit   5 - enable_des_pl_2*/
+/* bit 4:2 -- use_des_2  bit[2] -- demux0, bit[3] -- demux1, bit[4] -- demux2*/
+/* bit 1:0 -- des_i_sel_2 00 -- select_fec_0, 01 -- select_fec_1,
+ *                        10 -- select_fec_2, 11 - reserved*/
+#define COMM_DESC_2_CTL     (STB_CBUS_BASE + 0xff) /*0x16ff*/
+
+/*=======================================================*/
+/*  Multiple STB Registers                  (8'h00 - 8'h45)*/
+/*=======================================================*/
+/* STB registers are 8'h0x*/
+/* Bit 15:0 -- version number : 0x0002  (v0.01)*/
+/*#define STB_VERSION
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x00)  // 0x1600 // read only*/
+/*#define STB_VERSION_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x00)  // 0x1650 // read only*/
+/*#define STB_VERSION_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x00)  // 0x16a0 // read only*/
+
+/*#define STB_TEST_REG
+ *     (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x01)  // 0x1601*/
+/*#define STB_TEST_REG_2
+ *     (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x01)  // 0x1651*/
+/*#define STB_TEST_REG_3
+ *    (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x01)  // 0x16a1*/
+
+/* Bit 15 -- fec_core_select 1 - select descramble output*/
+/* Bit 14:12 -  fec_select
+ * 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File*/
+/* Bit 11 -- FEC_CLK*/
+/* Bit 10 -- SOP*/
+/* Bit 9 -- D_VALID*/
+/* Bit 8 -- D_FAIL*/
+/* Bit 7:0 -- D_DATA 7:0*/
+/*#define FEC_INPUT_CONTROL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x02)  // 0x1602*/
+/*#define FEC_INPUT_CONTROL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x02)  // 0x1652*/
+/*#define FEC_INPUT_CONTROL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x02)  // 0x16a2*/
+/*----------- bit define -----------*/
+#define FEC_CORE_SEL               15
+#define FEC_SEL                    12
+#define FEC_INPUT_FEC_CLK          11
+#define FEC_INPUT_SOP              10
+#define FEC_INPUT_D_VALID           9
+#define FEC_INPUT_D_FAIL            8
+
+/*#define FEC_INPUT_DATA
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x03)  // 0x1603 // read only*/
+/*#define FEC_INPUT_DATA_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x03)  // 0x1653 // read only*/
+/*#define FEC_INPUT_DATA_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x03)  // 0x16a3 // read only*/
+
+/* bit 31 -- enable_free_clk_fec_data_valid*/
+/* bit 30 -- enable_free_clk_stb_reg*/
+/* bit 29 -- always_use_pes_package_length*/
+/* bit 28 -- disable_pre_incomplete_section_fix*/
+/* bit 27 -- pointer_field_multi_pre_en*/
+/* bit 26 -- ignore_pre_incomplete_section*/
+/* bit 25 -- video2_enable*/
+/* bit 24:22 -- video2_type*/
+/* bit 21 -- do_not_trust_pes_package_length*/
+/* bit 20 (bit 4) -- Bypass use recoder path*/
+/* bit 19 (bit 3) -- clear_PID_continuity_counter_valid*/
+/* bit 18 (bit 2) -- Disable Splicing*/
+/* bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES*/
+/* bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES*/
+/* Bit 15 - do not trust section length*/
+/* Bit 14 - om cmd push even zero*/
+/* Bit 13 - reserved*/
+/* Bit 12 - SUB, OTHER PES interrupt at beginning of PES*/
+/* Bit 11 - discard_av_package -- for ts_recorder use only*/
+/* Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter*/
+/* Bit 9 - ts_recorder_enable*/
+/* Bit 8 - (table_id == 0xff) means section_end*/
+/* Bit 7 - do not send uncomplete section*/
+/* Bit 6 - do not discard duplicate package*/
+/* Bit 5 - search SOP when trasport_error_indicator*/
+/* Bit 4 - stb demux enable*/
+/* Bit 3 - do not reset state machine on SOP*/
+/* Bit 2 - search SOP when error happened
+ * ( when ignore_fail_n_sop, will have this case)*/
+/* Bit 1 - do not use SOP input ( check FEC sync byte instead )*/
+/* Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)*/
+/*#define DEMUX_CONTROL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x04)  // 0x1604*/
+/*#define DEMUX_CONTROL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x04)  // 0x1654*/
+/*#define DEMUX_CONTROL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x04)  // 0x16a4*/
+/*----------- bit define -----------*/
+#define ENABLE_FREE_CLK_FEC_DATA_VALID          31
+#define ENABLE_FREE_CLK_STB_REG                 30
+#define BYPASS_USE_RECODER_PATH                 20
+#define CLEAR_PID_CONTINUITY_COUNTER_VALID      19
+#define DISABLE_SPLICING                        18
+#define INSERT_AUDIO_PES_STRONG_SYNC            17
+#define INSERT_VIDEO_PES_STRONG_SYNC            16
+#define SECTION_LENGTH_UNTRUSTY                 15
+#define OM_CMD_PUSH_EVEN_ZERO                   14
+#define OTHER_INT_AT_PES_BEGINING               12
+#define DISCARD_AV_PACKAGE                      11
+#define TS_RECORDER_SELECT                      10
+#define TS_RECORDER_ENABLE                      9
+#define SECTION_END_WITH_TABLE_ID               8
+#define SEND_COMPLETE_SECTION_ONLY              7
+#define KEEP_DUPLICATE_PACKAGE                  6
+#define SEACH_SOP_ON_TRANSPORT_ERROR            5
+#define STB_DEMUX_ENABLE                        4
+#define NO_RESET_ON_SOP                         3
+#define SEARCH_SOP_ON_ERROR                     2
+#define NOT_USE_OF_SOP_INPUT                    1
+#define IGNORE_NONSOP_FEC_ERROR                 0
+
+/* bit 15:8 demux package length - 1 ( default : 187 )*/
+/* bit 7:0 default is 0x47*/
+/*#define FEC_SYNC_BYTE
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x05)  // 0x1605*/
+/*#define FEC_SYNC_BYTE_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x05)  // 0x1655*/
+/*#define FEC_SYNC_BYTE_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x05)  // 0x16a5*/
+
+/****************************************
+ * FM Memory Usage :
+ * 0-15 (32 PID filter target) ---- 15:13-PID type 12:0-PID target or force data
+ * (force data : 1 will mask corespoding bit,
+ * 0 will disable this PID filter channel)
+ * advanced setting --	bit 7:0
+ *                      bit 7 -- PID bit 12:11 compare result force
+ *                      bit 6 -- PID bit 10:9 compare result force
+ *                      bit 5 -- PID bit 8:7 compare result force
+ *                      bit 4 -- PID bit 6:5 compare result force
+ *                      bit 3 -- PID bit 4:3 compare result force
+ *                      bit 2 -- PID bit 2 compare result force
+ *                      bit 1 -- PID bit 1 compare result force
+ *                      bit 0 -- PID bit 0 compare result force
+ * 16-255(15x32 Section filter target)
+ * For first byte : Table_ID
+ * ---- 15-Mask High 4-bits
+ *   14-Mask Low 4-bits
+ *   13-disable_PID_check
+ *   12:8-PIDindex
+ *   7:0-section target (always EQ)
+ * For rest of bytes :
+ * ---- 15-Mask 14-EQ/NE 13-disable_PID_check
+ * ----12:8-PIDindex 7:0-section target (or force data)
+ * advanced setting -- bit 7:0 force compare result
+ **************************************************/
+/*----------- bit define -----------*/
+#define PID_TYPE                                13
+#define PID_TARGET                              0
+
+#define SECTION_FIRSTBYTE_MASKHIGH              15
+#define SECTION_FIRSTBYTE_MASKLOW               14
+#define SECTION_FIRSTBYTE_DISABLE_PID_CHECK     13
+#define SECTION_FIRSTBYTE_PID_INDEX             8
+#define SECTION_TARGET                          0
+
+#define SECTION_RESTBYTE_MASK                   15
+#define SECTION_RESTBYTE_MASK_EQ                14
+#define SECTION_RESTBYTE_DISABLE_PID_CHECK      13
+#define SECTION_RESTBYTE_PID_INDEX              8
+
+/* bit 31:16 -- filter memory write data hi[31:16]*/
+/* bit 15:0 -- filter memory write data low [15:0]*/
+/*#define FM_WR_DATA
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x06)  // 0x1606*/
+/*#define FM_WR_DATA_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x06)  // 0x1656*/
+/*#define FM_WR_DATA_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x06)  // 0x16a6*/
+/*----------- bit define -----------*/
+#define FM_WR_DATA_HI                           16
+
+/* bit 31:24 -- advanced setting hi*/
+/* bit 23:16 -- advanced setting low*/
+/* bit 15 -- filter memory write data request*/
+/* bit 7:0 -- filter memory write addr*/
+/*#define FM_WR_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x07)  // 0x1607*/
+/*#define FM_WR_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x07)  // 0x1657*/
+/*#define FM_WR_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x07)  // 0x16a7*/
+/*----------- bit define -----------*/
+#define FM_ADVANCED_SETTING_HI                  24
+#define FM_ADVANCED_SETTING_LO                  16
+#define FM_WR_DATA_REQUEST                      15
+
+/* bit 13:8 demux state  -- read only*/
+/* bit 7:4 -- maxnum section filter compare address*/
+/* bit 3:0 -- maxnum PID filter compare address*/
+/*#define MAX_FM_COMP_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x08)  // 0x1608*/
+/*#define MAX_FM_COMP_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x08)  // 0x1658*/
+/*#define MAX_FM_COMP_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x08)  // 0x16a8*/
+/*----------- bit define -----------*/
+#define DEMUX_STATE                             8
+#define MAX_FM_SECTION_FILTER_COMP_ADDR         4
+
+/* bit 15 - transport_error_indicator*/
+/* bit 14 - payload_unit_start_indicator*/
+/* bit 13 - transport_priority*/
+/* bit 12:0 - PID*/
+/*#define TS_HEAD_0
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x09)  // 0x1609*/
+/*#define TS_HEAD_0_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x09)  // 0x1659*/
+/*#define TS_HEAD_0_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x09)  // 0x16a9*/
+/*----------- bit define -----------*/
+#define TRANSPORT_ERROR_INDICATOR               15
+#define PAYLOAD_UNIT_START_INDICATOR            14
+#define TRANSPORT_PRIORITY                      13
+
+/* bit 7:6 transport_scrambling_control*/
+/* bit 5:4 adaptation_field_control*/
+/* bit 3:0 continuity_counter*/
+/*#define TS_HEAD_1
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0a)  // 0x160a*/
+/*#define TS_HEAD_1_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0a)  // 0x165a*/
+/*#define TS_HEAD_1_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0a)  // 0x16aa*/
+/*----------- bit define -----------*/
+#define TRANSPORT_SCRAMBLING_CONTROL            6
+#define ADAPTATION_FIELD_CONTROL                4
+
+/* bit 15:12 -- om_cmd_count (read only)*/
+/* bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)*/
+/* bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)*/
+/* bit   5:3 -- type_stb_om_w_rd (read only)*/
+/* bit     2 -- unit_start_stb_om_w_rd (read only)*/
+/* bit     1 -- om_cmd_overflow (read only)*/
+/* bit     0 -- om_cmd_pending (read)*/
+/* bit     0 -- om_cmd_read_finished (write)*/
+/*#define OM_CMD_STATUS
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0b)  // 0x160b*/
+/*#define OM_CMD_STATUS_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0b)  // 0x165b*/
+/*#define OM_CMD_STATUS_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0b)  // 0x16ab*/
+/*----------- bit define -----------*/
+#define OM_CMD_COUNT                            12
+#define OM_OVERFLOW_COUNT                       9
+#define OM_OVERWRITE_COUNT                      6
+#define TYPE_STB_OM_W_RD                        3
+#define UNIT_START_STB_OM_W_RD                  2
+#define OM_CMD_OVERFLOW                         1
+
+/* bit 15:9 -- count_stb_om_w_rd  (read only)*/
+/* bit 8:0 -- start_stb_om_wa_rd (read only)*/
+/*#define OM_CMD_DATA
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0c)  // 0x160c*/
+/*#define OM_CMD_DATA_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0c)  // 0x165c*/
+/*#define OM_CMD_DATA_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0c)  // 0x16ac*/
+/*----------- bit define -----------*/
+#define COUNT_STB_OM_W_RD                       9
+
+/* bit 11:0 -- offset for section data*/
+/*#define OM_CMD_DATA2
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0d)  // 0x160d*/
+/*#define OM_CMD_DATA2_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0d)  // 0x165d*/
+/*#define OM_CMD_DATA2_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0d)  // 0x16ad*/
+
+/* bit 31:16 -- base address for section buffer group 0
+ * (*0x400 to get real address)*/
+/* bit 15:0 -- base address for section buffer group 1
+ * (*0x400 to get real address)*/
+/*#define SEC_BUFF_01_START
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0e)  // 0x160e*/
+/*#define SEC_BUFF_01_START_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0e)  // 0x165e*/
+/*#define SEC_BUFF_01_START_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0e)  // 0x16ae*/
+/*----------- bit define -----------*/
+#define SEC_BUFF_0_BASE_ADDR                    16
+
+/* bit 31:16 -- base address for section buffer group 2
+ * (*0x400 to get real address)*/
+/* bit 15:0 -- base address for section buffer group 3
+ * (*0x400 to get real address)*/
+/*#define SEC_BUFF_23_START
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x0f)  // 0x160f*/
+/*#define SEC_BUFF_23_START_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x0f)  // 0x165f*/
+/*#define SEC_BUFF_23_START_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x0f)  // 0x16af*/
+/*----------- bit define -----------*/
+#define SEC_BUFF_2_BASE_ADDR                    16
+
+/* bit 15:12 -- section buffer size for group 3*/
+/* bit 11:8 -- section buffer size for group 2*/
+/* bit 7:4 -- section buffer size for group 1*/
+/* bit 3:0 -- section buffer size for group 0
+ * (bit used,  for example, 10 means 1K)*/
+/*#define SEC_BUFF_SIZE
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x10)  // 0x1610*/
+/*#define SEC_BUFF_SIZE_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x10)  // 0x1660*/
+/*#define SEC_BUFF_SIZE_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x10)  // 0x16b0*/
+/*----------- bit define -----------*/
+#define SEC_BUFF_3_SIZE                        12
+#define SEC_BUFF_2_SIZE                         8
+#define SEC_BUFF_1_SIZE                         4
+
+/* section buffer busy status for buff 31:0 ( Read Only )*/
+/*#define SEC_BUFF_BUSY
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x11)  // 0x1611*/
+/*#define SEC_BUFF_BUSY_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x11)  // 0x1661*/
+/*#define SEC_BUFF_BUSY_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x11)  // 0x16b1*/
+
+/* section buffer write status for buff 31:0 -- Read*/
+/* clear buffer status ( buff READY and BUSY ) -- write*/
+/*#define SEC_BUFF_READY
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x12)  // 0x1612*/
+/*#define SEC_BUFF_READY_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x12)  // 0x1662*/
+/*#define SEC_BUFF_READY_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x12)  // 0x16b2*/
+
+/* bit 15 -- section_reset_busy (Read Only)*/
+/* bit 14 -- output_section_buffer_valid*/
+/* bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only*/
+/* bit 4:0 -- SEC_BUFFER_INDEX   RW*/
+/*#define SEC_BUFF_NUMBER
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x13)  // 0x1613*/
+/*#define SEC_BUFF_NUMBER_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x13)  // 0x1663*/
+/*#define SEC_BUFF_NUMBER_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x13)  // 0x16b3*/
+/*----------- bit define -----------*/
+#define SECTION_RESET_BUSY                      15
+#define OUTPUT_SECTION_BUFFER_VALID             14
+#define INDEXED_SEC_BUFF_NUMBER                 8
+
+/* bit 9:5 -- BYPASS PID number*/
+/* bit 4:0 -- PCR PID number*/
+/*#define ASSIGN_PID_NUMBER
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x14)  // 0x1614*/
+/*#define ASSIGN_PID_NUMBER_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x14)  // 0x1664*/
+/*#define ASSIGN_PID_NUMBER_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x14)  // 0x16b4*/
+/*----------- bit define -----------*/
+#define BYPASS_PID_NUMBER                       5
+
+/* bit 15:0 -- stream_id filter bit enable*/
+/* bit 7:0 -- stream_id filter target*/
+/*#define VIDEO_STREAM_ID
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x15)  // 0x1615*/
+/*#define VIDEO_STREAM_ID_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x15)  // 0x1665*/
+/*#define VIDEO_STREAM_ID_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x15)  // 0x16b5*/
+
+/*#define AUDIO_STREAM_ID
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x16)  // 0x1616*/
+/*#define AUDIO_STREAM_ID_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x16)  // 0x1666*/
+/*#define AUDIO_STREAM_ID_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x16)  // 0x16b6*/
+
+/*#define SUB_STREAM_ID
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x17)  // 0x1617*/
+/*#define SUB_STREAM_ID_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x17)  // 0x1667*/
+/*#define SUB_STREAM_ID_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x17)  // 0x16b7*/
+
+/*#define OTHER_STREAM_ID
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x18)  // 0x1618*/
+/*#define OTHER_STREAM_ID_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x18)  // 0x1668*/
+/*#define OTHER_STREAM_ID_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x18)  // 0x16b8*/
+
+/* bit 12 -- PCR_EN*/
+/* bit 11:0 -- PCR90K_DIV*/
+/*#define PCR90K_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x19)  // 0x1619*/
+/*#define PCR90K_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x19)  // 0x1669*/
+/*#define PCR90K_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x19)  // 0x16b9*/
+/*----------- bit define -----------*/
+#define PCR_EN                     12
+
+/* bit 15:0 -- PCR[31:0] R/W*/
+/*#define PCR_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1a)  // 0x161a*/
+/*#define PCR_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1a)  // 0x166a*/
+/*#define PCR_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1a)  // 0x16ba*/
+
+/* bit 15:0 -- VPTS[31:0] R/W*/
+/*#define VIDEO_PTS_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1b)  // 0x161b*/
+/*#define VIDEO_PTS_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1b)  // 0x166b*/
+/*#define VIDEO_PTS_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1b)  // 0x16bb*/
+
+/* bit 15:0 -- VDTS[31:0] R/W*/
+/*#define VIDEO_DTS_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1c)  // 0x161c*/
+/*#define VIDEO_DTS_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1c)  // 0x166c*/
+/*#define VIDEO_DTS_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1c)  // 0x16bc*/
+
+/* bit 15:0 -- APTS[31:0] R/W*/
+/*#define AUDIO_PTS_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1d)  // 0x161d*/
+/*#define AUDIO_PTS_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1d)  // 0x166d*/
+/*#define AUDIO_PTS_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1d)  // 0x16bd*/
+
+/* bit 15:0 -- SPTS[31:0] R/W*/
+/*#define SUB_PTS_DEMUX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1e)  // 0x161e*/
+/*#define SUB_PTS_DEMUX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1e)  // 0x166e*/
+/*#define SUB_PTS_DEMUX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1e)  // 0x16be*/
+
+/* read -- status, write 1 clear status*/
+/* bit 15 -- SUB_PTS[32]*/
+/* bit 14 -- AUDIO_PTS[32]*/
+/* bit 13 -- VIDEO_DTS[32]*/
+/* bit 12 -- VIDEO_PTS[32]*/
+/* bit 3 -- sub_pts_ready*/
+/* bit 2 -- audio_pts_ready*/
+/* bit 1 -- video_dts_ready*/
+/* bit 0 -- video_pts_ready*/
+/*#define STB_PTS_DTS_STATUS
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x1f)  // 0x161f*/
+/*#define STB_PTS_DTS_STATUS_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x1f)  // 0x166f*/
+/*#define STB_PTS_DTS_STATUS_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x1f)  // 0x16bf*/
+/*----------- bit define -----------*/
+#define SUB_PTS_BIT32              15
+#define AUDIO_PTS_BIT32            14
+#define VIDEO_DTS_BIT32            13
+#define VIDEO_PTS_BIT32            12
+#define SUB_PTS_READY              3
+#define AUDIO_PTS_READY            2
+#define VIDEO_DTS_READY            1
+#define VIDEO_PTS_READY            0
+
+/* bit 3:0 --*/
+/*  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0]*/
+/*  1 -- stream_id[7:0], pes_header_bytes_left[7:0]*/
+/*  2 -- pes_package_bytes_left[15:0]*/
+/*  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]*/
+/*#define STB_DEBUG_INDEX
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x20)  // 0x1620*/
+/*#define STB_DEBUG_INDEX_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x20)  // 0x1670*/
+/*#define STB_DEBUG_INDEX_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x20)  // 0x16c0*/
+
+/* read only*/
+/*#define STB_DEBUG_DATA_OUT
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x21)  // 0x1621*/
+/*#define STB_DEBUG_DATA_OUT_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x21)  // 0x1671*/
+/*#define STB_DEBUG_DATA_OUT_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x21)  // 0x16c1*/
+
+/* bit[31] -- no_match_record_en*/
+/* bit[30:16] - reserved*/
+/* default : 0x807f*/
+/* bit 15:9  -- MAX OM DMA COUNT  (default: 0x40)*/
+/* bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)*/
+#define STB_OM_CTL \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x22) /* 0x1622*/
+#define STB_OM_CTL_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x22) /* 0x1672*/
+#define STB_OM_CTL_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x22) /* 0x16c2*/
+/*----------- bit define -----------*/
+#define MAX_OM_DMA_COUNT           9
+#define LAST_OM_ADDR               0
+
+/* 15:0  WRITE 1 CLEAR to clear interrupt source*/
+/*12 -- INPUT_TIME_OUT*/
+/*11 -- PCR_ready*/
+/*10 -- audio_splicing_point*/
+/* 9 -- video_splicing_point*/
+/* 8 -- other_PES_int*/
+/* 7 -- sub_PES_int*/
+/* 6 -- discontinuity*/
+/* 5 -- duplicated_pack_found*/
+/* 4 -- New PDTS ready*/
+/* 3 -- om_cmd_buffer ready for access*/
+/* 2 -- section buffer ready*/
+/* 1 -- transport_error_indicator*/
+/* 0 -- TS ERROR PIN*/
+/*#define STB_INT_STATUS
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x23)  // 0x1623*/
+/*#define STB_INT_STATUS_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x23)  // 0x1673*/
+/*#define STB_INT_STATUS_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x23)  // 0x16c3*/
+/*----------- bit define -----------*/
+#define INPUT_TIME_OUT             12
+#define PCR_READY                  11
+#define AUDIO_SPLICING_POINT       10
+#define VIDEO_SPLICING_POINT       9
+#define OTHER_PES_READY            8
+#define SUB_PES_READY              7
+#define DIS_CONTINUITY_PACKET      6
+#define DUPLICATED_PACKET          5
+#define NEW_PDTS_READY             4
+#define OM_CMD_READ_PENDING        3
+#define SECTION_BUFFER_READY       2
+#define TS_ERROR_PACKAGE           1
+#define TS_ERROR_PIN               0
+
+/* When Bit 31 - 1 write will indicate all type use sepertate endian
+ * (Write Only)*/
+/* When Bit 31 - 0 write will indicate all type else use Bit 8:6*/
+/* Bit 23:21 - demux om write endian control for OTHER_PES_PACKET*/
+/* Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET*/
+/* Bit 17:15 - demux om write endian control for SUB_PACKET*/
+/* Bit 14:12 - demux om write endian control for AUDIO_PACKET*/
+/* Bit 11:9  - demux om write endian control for VIDEO_PACKET*/
+/* Bit 8:6 - demux om write endian control for else*/
+/* Bit 5:3 - demux om write endian control for bypass*/
+/* Bit 2:0 - demux om write endian control for section*/
+/*#define DEMUX_ENDIAN
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x24)  // 0x1624*/
+/*#define DEMUX_ENDIAN_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x24)  // 0x1674*/
+/*#define DEMUX_ENDIAN_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x24)  // 0x16c4*/
+/*----------- bit define -----------*/
+#define SEPERATE_ENDIAN            31
+#define OTHER_PES_ENDIAN           21
+#define SCR_ENDIAN                 18
+#define SUB_ENDIAN                 15
+#define AUDIO_ENDIAN               12
+#define VIDEO_ENDIAN               9
+#define OTHER_ENDIAN               6
+#define BYPASS_ENDIAN              3
+#define SECTION_ENDIAN             0
+
+/* Bit 15:8 -- last_burst_threshold*/
+/* Bit 7 -- use hi_bsf interface*/
+/* Bit 6:2 - fec_clk_div*/
+/* Bit 1 ts_source_sel */
+/* Bit 0 - Hiu TS generate enable */
+/*#define TS_HIU_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x25)  // 0x1625*/
+/*#define TS_HIU_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x25)  // 0x1675*/
+/*#define TS_HIU_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x25)  // 0x16c5*/
+/*----------- bit define -----------*/
+#define LAST_BURST_THRESHOLD       8
+#define USE_HI_BSF_INTERFACE       7
+
+/* bit 15:0 -- base address for section buffer start
+ * (*0x10000 to get real base)*/
+/*#define SEC_BUFF_BASE
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x26)  // 0x1626*/
+/*#define SEC_BUFF_BASE_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x26)  // 0x1676*/
+/*#define SEC_BUFF_BASE_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x26)  // 0x16c6*/
+
+/* bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN*/
+/* bit 10 -- mask bit for SUB_AHB_DMA_EN*/
+/* bit 9 -- mask bit for BYPASS_AHB_DMA_EN*/
+/* bit 8 -- mask bit for SECTION_AHB_DMA_EN*/
+/* bit 7 -- mask bit for recoder stream*/
+/* bit 6:0 -- mask bit for each type*/
+/*#define DEMUX_MEM_REQ_EN
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x27)  // 0x1627*/
+/*#define DEMUX_MEM_REQ_EN_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x27)  // 0x1677*/
+/*#define DEMUX_MEM_REQ_EN_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x27)  // 0x16c7*/
+/*----------- bit define -----------*/
+#define VIDEO2_DMA_EN_BIT          12
+#define OTHER_PES_AHB_DMA_EN       11
+#define SUB_AHB_DMA_EN             10
+#define BYPASS_AHB_DMA_EN          9
+#define SECTION_AHB_DMA_EN         8
+#define RECORDER_STREAM            7
+#define OTHER_PES_PACKET           6
+#define SCR_ONLY_PACKET            5  /*will never be used*/
+#define BYPASS_PACKET              4
+#define SECTION_PACKET             3
+#define SUB_PACKET                 2
+#define AUDIO_PACKET               1
+#define VIDEO_PACKET               0
+
+/* bit 31:0 -- vb_wr_ptr for video PDTS*/
+/*#define VIDEO_PDTS_WR_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x28)  // 0x1628*/
+/*#define VIDEO_PDTS_WR_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x28)  // 0x1678*/
+/*#define VIDEO_PDTS_WR_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x28)  // 0x16c8*/
+
+/* bit 31:0 -- ab_wr_ptr for audio PDTS*/
+/*#define AUDIO_PDTS_WR_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x29)  // 0x1629*/
+/*#define AUDIO_PDTS_WR_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x29)  // 0x1679*/
+/*#define AUDIO_PDTS_WR_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x29)  // 0x16c9*/
+
+/* bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)*/
+/*#define SUB_WR_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2a)  // 0x162a*/
+/*#define SUB_WR_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2a)  // 0x167a*/
+/*#define SUB_WR_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2a)  // 0x16ca*/
+
+/* bit 19:0 -- SB_START (sb_start << 12 == byte address);*/
+/*#define SB_START
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2b)  // 0x162b*/
+/*#define SB_START_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2b)  // 0x167b*/
+/*#define SB_START_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2b)  // 0x16cb*/
+
+/* bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun)*/
+/*#define SB_LAST_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2c)  // 0x162c*/
+/*#define SB_LAST_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2c)  // 0x167c*/
+/*#define SB_LAST_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2c)  // 0x16cc*/
+
+/* bit 31:0 -- sb_wr_ptr for sub PES*/
+/*#define SB_PES_WRITE_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2d)  // 0x162d*/
+/*#define SB_PES_WRITE_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2d)  // 0x167d*/
+/*#define SB_PES_WRITE_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2d)  // 0x16cd*/
+
+/* bit 31:16 -- ob_wr_ptr for other PES*/
+/* bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)*/
+/*#define OTHER_WR_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2e)  // 0x162e*/
+/*#define OTHER_WR_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2e)  // 0x167e*/
+/*#define OTHER_WR_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2e)  // 0x16ce*/
+
+/* bit 19:0 -- OB_START (ob_start << 12 == byte address);*/
+/*#define OB_START
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x2f)  // 0x162f*/
+/*#define OB_START_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x2f)  // 0x167f*/
+/*#define OB_START_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x2f)  // 0x16cf*/
+
+/* bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun)*/
+/*#define OB_LAST_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x30)  // 0x1630*/
+/*#define OB_LAST_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x30)  // 0x1680*/
+/*#define OB_LAST_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x30)  // 0x16d0*/
+
+/* bit 31:0 -- ob_wr_ptr for sub PES*/
+/*#define OB_PES_WRITE_PTR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x31)  // 0x1631*/
+/*#define OB_PES_WRITE_PTR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x31)  // 0x1681*/
+/*#define OB_PES_WRITE_PTR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x31)  // 0x16d1*/
+
+/* 15:0  DEMUX interrupt MASK*/
+/* 11 -- PCR_READY*/
+/* 10 -- audio_splicing_point*/
+/* 9 -- video_splicing_point*/
+/* 8 -- other_PES_int*/
+/* 7 -- sub_PES_int*/
+/* 6 -- discontinuity*/
+/* 5 -- duplicated_pack_found*/
+/* 4 -- New PDTS ready*/
+/* 3 -- om_cmd_buffer ready for access*/
+/* 2 -- section buffer ready*/
+/* 1 -- transport_error_indicator*/
+/* 0 -- TS ERROR PIN*/
+/*#define STB_INT_MASK
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x32)  // 0x1632*/
+/*#define STB_INT_MASK_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x32)  // 0x1682*/
+/*#define STB_INT_MASK_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x32)  // 0x16d2*/
+
+/* 31:16 VIDEO PID filter data*/
+/*15 -- splicing VIDEO PID change enable*/
+/*14:10 -- VIDEO PID FILTER ADDRESS*/
+/* 9 -- PES splicing active (Read Only)*/
+/* 8 -- splicing active (Read Only)*/
+/* 7:0  splicing countdown (Read Only)*/
+/*#define VIDEO_SPLICING_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x33)  // 0x1633*/
+/*#define VIDEO_SPLICING_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x33)  // 0x1683*/
+/*#define VIDEO_SPLICING_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x33)  // 0x16d3*/
+/*----------- bit define -----------*/
+#define VIDEO_PID_FILTER_DATA      16
+#define VIDEO_SPLICING_PID_CHANGE_ENABLE       15
+#define VIDEO_PID_FILTER_ADDRESS   10
+#define VIDEO_PES_SPLICING_ACTIVE  9
+#define VIDEO_SPLICING_ACTIVE      8
+
+
+/* 31:16 AUDIO PID filter data*/
+/*15 -- splicing AUDIO PID change enable*/
+/*14:10 -- AUDIO PID FILTER ADDRESS*/
+/* 9 -- PES splicing active (Read Only)*/
+/* 8 -- splicing active (Read Only)*/
+/* 7:0  splicing countdown (Read Only)*/
+/*#define AUDIO_SPLICING_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x34)  // 0x1634*/
+/*#define AUDIO_SPLICING_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x34)  // 0x1684*/
+/*#define AUDIO_SPLICING_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x34)  // 0x16d4*/
+/*----------- bit define -----------*/
+#define AUDIO_PID_FILTER_DATA      16
+#define AUDIO_SPLICING_PID_CHANGE_ENABLE       15
+#define AUDIO_PID_FILTER_ADDRESS   10
+#define AUDIO_PES_SPLICING_ACTIVE  9
+#define AUDIO_SPLICING_ACTIVE      8
+
+/* 23:16 M2TS_SKIP_BYTES*/
+/* 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)*/
+/* 7:0  PACKAGE BYTE COUNT (Read Only)*/
+/*#define TS_PACKAGE_BYTE_COUNT
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x35)  // 0x1635*/
+/*#define TS_PACKAGE_BYTE_COUNT_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x35)  // 0x1685*/
+/*#define TS_PACKAGE_BYTE_COUNT_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x35)  // 0x16d5*/
+/*----------- bit define -----------*/
+#define M2TS_SKIP_BYTES            16
+#define LAST_TS_PACKAGE_BYTE_COUNT 8
+
+/* 15:0 2 bytes strong sync add to PES*/
+/*#define PES_STRONG_SYNC
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x36)  // 0x1636*/
+/*#define PES_STRONG_SYNC_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x36)  // 0x1686*/
+/*#define PES_STRONG_SYNC_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x36)  // 0x16d6*/
+
+/* bit 15 -- stb_om_ren*/
+/* bit 14:11 -- reserved*/
+/* bit  10:0 -- OM_DATA_RD_ADDR*/
+/*#define OM_DATA_RD_ADDR
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x37)  // 0x1637*/
+/*#define OM_DATA_RD_ADDR_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x37)  // 0x1687*/
+/*#define OM_DATA_RD_ADDR_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x37)  // 0x16d7*/
+/*----------- bit define -----------*/
+#define STB_OM_REN                 15
+
+/* bit 15:0 -- OM_DATA_RD*/
+/*#define OM_DATA_RD
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x38)  // 0x1638*/
+/*#define OM_DATA_RD_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x38)  // 0x1688*/
+/*#define OM_DATA_RD_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x38)  // 0x16d8*/
+
+/* AUTO STOP SETTING for 32 channels*/
+/* 4-bits per channel*/
+/* when write*/
+/* bit 3 -- set section active*/
+/* bit 2:0 -- auto stop after count (0 means never stop)*/
+/* when read*/
+/* bit 3 -- current active status (1 - active, 0 - stopped )*/
+/* bit 2:0 -- count down to auto stop*/
+/* section 31:24*/
+/*#define SECTION_AUTO_STOP_3
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x39)  // 0x1639*/
+/*#define SECTION_AUTO_STOP_3_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x39)  // 0x1689*/
+/*#define SECTION_AUTO_STOP_3_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x39)  // 0x16d9*/
+/* section 23:16*/
+/*#define SECTION_AUTO_STOP_2
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3a)  // 0x163a*/
+/*#define SECTION_AUTO_STOP_2_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3a)  // 0x168a*/
+/*#define SECTION_AUTO_STOP_2_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3a)  // 0x16da*/
+/* section 15:8*/
+/*#define SECTION_AUTO_STOP_1
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3b)  // 0x163b*/
+/*#define SECTION_AUTO_STOP_1_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3b)  // 0x168b*/
+/*#define SECTION_AUTO_STOP_1_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3b)  // 0x16db*/
+/* section 7:0*/
+/*#define SECTION_AUTO_STOP_0
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3c)  // 0x163c*/
+/*#define SECTION_AUTO_STOP_0_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3c)  // 0x168c*/
+/*#define SECTION_AUTO_STOP_0_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3c)  // 0x16dc*/
+
+/* bit 31:0 reset channel status - each bit reset each channel*/
+/* read -- 32 channel status*/
+/*#define DEMUX_CHANNEL_RESET
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3d)  // 0x163d*/
+/*#define DEMUX_CHANNEL_RESET_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3d)  // 0x168d*/
+/*#define DEMUX_CHANNEL_RESET_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3d)  // 0x16dd*/
+
+/*#define DEMUX_SCRAMBLING_STATE
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3e)  // 0x163e*/
+/*#define DEMUX_SCRAMBLING_STATE_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3e)  // 0x168e*/
+/*#define DEMUX_SCRAMBLING_STATE_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3e)  // 0x16de*/
+
+/*#define DEMUX_CHANNEL_ACTIVITY
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x3f)  // 0x163f*/
+/*#define DEMUX_CHANNEL_ACTIVITY_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x3f)  // 0x168f*/
+/*#define DEMUX_CHANNEL_ACTIVITY_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x3f)  // 0x16df*/
+
+/* bit 4 -- video_stamp_use_dts*/
+/* bit 3 -- audio_stamp_sync_1_en*/
+/* bit 2 -- audio_stamp_insert_en*/
+/* bit 1 -- video_stamp_sync_1_en*/
+/* bit 0 -- video_stamp_insert_en*/
+/*#define DEMUX_STAMP_CTL
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x40)  // 0x1640*/
+/*#define DEMUX_STAMP_CTL_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x40)  // 0x1690*/
+/*#define DEMUX_STAMP_CTL_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x40)  // 0x16e0*/
+
+/*#define DEMUX_VIDEO_STAMP_SYNC_0
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x41)  // 0x1641*/
+/*#define DEMUX_VIDEO_STAMP_SYNC_0_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x41)  // 0x1691*/
+/*#define DEMUX_VIDEO_STAMP_SYNC_0_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x41)  // 0x16e1*/
+
+/*#define DEMUX_VIDEO_STAMP_SYNC_1
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x42)  // 0x1642*/
+/*#define DEMUX_VIDEO_STAMP_SYNC_1_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x42)  // 0x1692*/
+/*#define DEMUX_VIDEO_STAMP_SYNC_1_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x42)  // 0x16e2*/
+
+/*#define DEMUX_AUDIO_STAMP_SYNC_0
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x43)  // 0x1643*/
+/*#define DEMUX_AUDIO_STAMP_SYNC_0_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x43)  // 0x1693*/
+/*#define DEMUX_AUDIO_STAMP_SYNC_0_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x43)  // 0x16e3*/
+
+/*#define DEMUX_AUDIO_STAMP_SYNC_1
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x44)  // 0x1644*/
+/*#define DEMUX_AUDIO_STAMP_SYNC_1_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x44)  // 0x1694*/
+/*#define DEMUX_AUDIO_STAMP_SYNC_1_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x44)  // 0x16e4*/
+
+/* Write : Bit[4:0] secter filter number for reset*/
+/* Read  : select according to output_section_buffer_valid :*/
+/*         per bit per section buffer valid status*/
+/*         or section_buffer_ignore*/
+/*#define DEMUX_SECTION_RESET
+ * (STB_CBUS_BASE + DEMUX_1_OFFSET + 0x45)  // 0x1645*/
+/*#define DEMUX_SECTION_RESET_2
+ * (STB_CBUS_BASE + DEMUX_2_OFFSET + 0x45)  // 0x1695*/
+/*#define DEMUX_SECTION_RESET_3
+ * (STB_CBUS_BASE + DEMUX_3_OFFSET + 0x45)  // 0x16e5*/
+
+
+/* bit[31:0] - channel_reset_timeout_disable*/
+#define DEMUX_INPUT_TIMEOUT_C   \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x46)         /* 0x1646*/
+#define DEMUX_INPUT_TIMEOUT_C_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x46)         /* 0x1696*/
+#define DEMUX_INPUT_TIMEOUT_C_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x46)         /* 0x16e6*/
+/* bit[31] - no_match_reset_timeout_disable*/
+/* bit[30:0] input_time_out_int_cnt (0 -- means disable) Wr-setting, Rd-count*/
+#define DEMUX_INPUT_TIMEOUT     \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x47)         /* 0x1647*/
+#define DEMUX_INPUT_TIMEOUT_2   \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x47)         /* 0x1697*/
+#define DEMUX_INPUT_TIMEOUT_3   \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x47)         /* 0x16e7*/
+
+/* bit[31:0] - channel_packet_count_disable*/
+#define DEMUX_PACKET_COUNT_C    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x48)         /* 0x1648*/
+#define DEMUX_PACKET_COUNT_C_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x48)         /* 0x1698*/
+#define DEMUX_PACKET_COUNT_C_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x48)         /* 0x16e8*/
+/* bit[31] - no_match_packet_count_disable*/
+/* bit[30:0] input_packet_count*/
+#define DEMUX_PACKET_COUNT      \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x49)         /* 0x1649*/
+#define DEMUX_PACKET_COUNT_2    \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x49)         /* 0x1699*/
+#define DEMUX_PACKET_COUNT_3    \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x49)         /* 0x16e9*/
+
+/* bit[31:0] channel_record_enable*/
+#define DEMUX_CHAN_RECORD_EN    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4a)         /* 0x164a*/
+#define DEMUX_CHAN_RECORD_EN_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4a)         /* 0x169a*/
+#define DEMUX_CHAN_RECORD_EN_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4a)         /* 0x16ea*/
+
+/* bit[31:0] channel_process_enable*/
+#define DEMUX_CHAN_PROCESS_EN   \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4b)         /* 0x164b*/
+#define DEMUX_CHAN_PROCESS_EN_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4b)         /* 0x169b*/
+#define DEMUX_CHAN_PROCESS_EN_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4b)         /* 0x16eb*/
+
+/* bit[31:24] small_sec_size ((n+1) * 256 Bytes)*/
+/* bit[23:16] small_sec_rd_ptr */
+/* bit[15:8]  small_sec_wr_ptr */
+/* bit[7:2]   reserved*/
+/* bit[1] small_sec_wr_ptr_wr_enable*/
+/* bit[0] small_section_enable*/
+#define DEMUX_SMALL_SEC_CTL     \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4c)         /* 0x164c*/
+#define DEMUX_SMALL_SEC_CTL_2   \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4c)         /* 0x169c*/
+#define DEMUX_SMALL_SEC_CTL_3   \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4c)         /* 0x16ec*/
+/* bit[31:0] small_sec_start_addr*/
+#define DEMUX_SMALL_SEC_ADDR    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4d)         /* 0x164d*/
+#define DEMUX_SMALL_SEC_ADDR_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4d)         /* 0x169d*/
+#define DEMUX_SMALL_SEC_ADDR_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4d)         /* 0x16ed*/
+
+
+/*======================================================*/
+/*  STB Registers End*/
+/*====================================================*/
+/* ----------------------------*/
+/* ASYNC FIFO (4)*/
+/* ----------------------------*/
+/*#define ASYNC_FIFO_REG0                            0x2310*/
+/*#define ASYNC_FIFO_REG1                            0x2311*/
+#define ASYNC_FIFO_FLUSH_STATUS     31
+#define ASYNC_FIFO_ERR              30
+#define ASYNC_FIFO_FIFO_EMPTY       29
+#define ASYNC_FIFO_TO_HIU           24
+#define ASYNC_FIFO_FLUSH            23
+#define ASYNC_FIFO_RESET            22
+#define ASYNC_FIFO_WRAP_EN          21
+#define ASYNC_FIFO_FLUSH_EN         20
+#define ASYNC_FIFO_RESIDUAL_MSB     19
+#define ASYNC_FIFO_RESIDUAL_LSB     15
+#define ASYNC_FIFO_FLUSH_CNT_MSB    14
+#define ASYNC_FIFO_FLUSH_CNT_LSB    0
+/*#define ASYNC_FIFO_REG2                            0x2312*/
+#define ASYNC_FIFO_FIFO_FULL        26
+#define ASYNC_FIFO_FILL_STATUS      25
+#define ASYNC_FIFO_SOURCE_MSB       24
+#define ASYNC_FIFO_SOURCE_LSB       23
+#define ASYNC_FIFO_ENDIAN_MSB       22
+#define ASYNC_FIFO_ENDIAN_LSB       21
+#define ASYNC_FIFO_FILL_EN          20
+#define ASYNC_FIFO_FILL_CNT_MSB     19
+#define ASYNC_FIFO_FILL_CNT_LSB     0
+/*#define ASYNC_FIFO_REG3                            0x2313*/
+#define ASYNC_FLUSH_SIZE_IRQ_MSB    15
+#define ASYNC_FLUSH_SIZE_IRQ_LSB    0
+/* ----------------------------*/
+/* ASYNC FIFO (4)*/
+/* ----------------------------*/
+/*#define ASYNC_FIFO2_REG0                           0x2314*/
+/*#define ASYNC_FIFO2_REG1                           0x2315*/
+/*#define ASYNC_FIFO2_REG2                           0x2316*/
+/*#define ASYNC_FIFO2_REG3                           0x2317*/
+
+#define RESET_DEMUXSTB      (1 << 1)
+#endif /* C_STB_DEFINE_H*/
diff --git a/drivers/amlogic/wetek/wetek_stb_regs_define.h b/drivers/amlogic/wetek/wetek_stb_regs_define.h
new file mode 100644
index 0000000..2612fa6
--- /dev/null
+++ b/drivers/amlogic/wetek/wetek_stb_regs_define.h
@@ -0,0 +1,8889 @@
+/*
+ * This file is automaticly generated by genregs.awk. Please do not edit it
+ * Base files are ..
+ *   ..
+ *   ..
+ * Tue Oct 22 15:28:48 CST 2013
+ **/
+#ifndef __MACH_MESON8_REG_ADDR_H_
+#define __MACH_MESON8_REG_ADDR_H_
+#include <linux/amlogic/iomap.h>
+#define CBUS_REG_ADDR(_r) aml_read_cbus(_r)
+#define HHI_DEMOD_MEM_PD_REG         (0xc883c000 + (0x43 << 2))
+#define STB_TOP_CONFIG 0x16f0
+#define P_STB_TOP_CONFIG                CBUS_REG_ADDR(STB_TOP_CONFIG)
+#define TS_TOP_CONFIG 0x16f1
+#define P_TS_TOP_CONFIG                 CBUS_REG_ADDR(TS_TOP_CONFIG)
+#define TS_FILE_CONFIG 0x16f2
+#define P_TS_FILE_CONFIG        CBUS_REG_ADDR(TS_FILE_CONFIG)
+#define TS_PL_PID_INDEX 0x16f3
+#define P_TS_PL_PID_INDEX               CBUS_REG_ADDR(TS_PL_PID_INDEX)
+#define TS_PL_PID_DATA 0x16f4
+#define P_TS_PL_PID_DATA                CBUS_REG_ADDR(TS_PL_PID_DATA)
+#define COMM_DESC_KEY0 0x16f5
+#define P_COMM_DESC_KEY0                CBUS_REG_ADDR(COMM_DESC_KEY0)
+#define COMM_DESC_KEY1 0x16f6
+#define P_COMM_DESC_KEY1                CBUS_REG_ADDR(COMM_DESC_KEY1)
+#define COMM_DESC_KEY_RW 0x16f7
+#define P_COMM_DESC_KEY_RW              CBUS_REG_ADDR(COMM_DESC_KEY_RW)
+#define CIPLUS_KEY0 0x16f8
+#define P_CIPLUS_KEY0           CBUS_REG_ADDR(CIPLUS_KEY0)
+#define CIPLUS_KEY1 0x16f9
+#define P_CIPLUS_KEY1           CBUS_REG_ADDR(CIPLUS_KEY1)
+#define CIPLUS_KEY2 0x16fa
+#define P_CIPLUS_KEY2           CBUS_REG_ADDR(CIPLUS_KEY2)
+#define CIPLUS_KEY3 0x16fb
+#define P_CIPLUS_KEY3           CBUS_REG_ADDR(CIPLUS_KEY3)
+#define CIPLUS_KEY_WR 0x16fc
+#define P_CIPLUS_KEY_WR                 CBUS_REG_ADDR(CIPLUS_KEY_WR)
+#define CIPLUS_CONFIG 0x16fd
+#define P_CIPLUS_CONFIG                 CBUS_REG_ADDR(CIPLUS_CONFIG)
+#define CIPLUS_ENDIAN 0x16fe
+#define P_CIPLUS_ENDIAN                 CBUS_REG_ADDR(CIPLUS_ENDIAN)
+#define PREG_CTLREG0_ADDR 0x2000
+#define P_PREG_CTLREG0_ADDR             CBUS_REG_ADDR(PREG_CTLREG0_ADDR)
+#define PREG_PAD_GPIO6_EN_N 0x2008
+#define P_PREG_PAD_GPIO6_EN_N   CBUS_REG_ADDR(PREG_PAD_GPIO6_EN_N)
+#define PREG_PAD_GPIO6_O 0x2009
+#define P_PREG_PAD_GPIO6_O              CBUS_REG_ADDR(PREG_PAD_GPIO6_O)
+#define PREG_PAD_GPIO6_I 0x200a
+#define P_PREG_PAD_GPIO6_I              CBUS_REG_ADDR(PREG_PAD_GPIO6_I)
+#define PREG_JTAG_GPIO_ADDR 0x200b
+#define P_PREG_JTAG_GPIO_ADDR           CBUS_REG_ADDR(PREG_JTAG_GPIO_ADDR)
+#define PREG_PAD_GPIO0_EN_N 0x200c
+#define P_PREG_PAD_GPIO0_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO0_EN_N)
+#define PREG_PAD_GPIO0_O 0x200d
+#define P_PREG_PAD_GPIO0_O              CBUS_REG_ADDR(PREG_PAD_GPIO0_O)
+#define PREG_PAD_GPIO0_I 0x200e
+#define P_PREG_PAD_GPIO0_I              CBUS_REG_ADDR(PREG_PAD_GPIO0_I)
+#define PREG_PAD_GPIO1_EN_N 0x200f
+#define P_PREG_PAD_GPIO1_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO1_EN_N)
+#define PREG_PAD_GPIO1_O 0x2010
+#define P_PREG_PAD_GPIO1_O              CBUS_REG_ADDR(PREG_PAD_GPIO1_O)
+#define PREG_PAD_GPIO1_I 0x2011
+#define P_PREG_PAD_GPIO1_I              CBUS_REG_ADDR(PREG_PAD_GPIO1_I)
+#define PREG_PAD_GPIO2_EN_N 0x2012
+#define P_PREG_PAD_GPIO2_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO2_EN_N)
+#define PREG_PAD_GPIO2_O 0x2013
+#define P_PREG_PAD_GPIO2_O              CBUS_REG_ADDR(PREG_PAD_GPIO2_O)
+#define PREG_PAD_GPIO2_I 0x2014
+#define P_PREG_PAD_GPIO2_I              CBUS_REG_ADDR(PREG_PAD_GPIO2_I)
+#define PREG_PAD_GPIO3_EN_N 0x2015
+#define P_PREG_PAD_GPIO3_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO3_EN_N)
+#define PREG_PAD_GPIO3_O 0x2016
+#define P_PREG_PAD_GPIO3_O              CBUS_REG_ADDR(PREG_PAD_GPIO3_O)
+#define PREG_PAD_GPIO3_I 0x2017
+#define P_PREG_PAD_GPIO3_I              CBUS_REG_ADDR(PREG_PAD_GPIO3_I)
+#define PREG_PAD_GPIO4_EN_N 0x2018
+#define P_PREG_PAD_GPIO4_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO4_EN_N)
+#define PREG_PAD_GPIO4_O 0x2019
+#define P_PREG_PAD_GPIO4_O              CBUS_REG_ADDR(PREG_PAD_GPIO4_O)
+#define PREG_PAD_GPIO4_I 0x201a
+#define P_PREG_PAD_GPIO4_I              CBUS_REG_ADDR(PREG_PAD_GPIO4_I)
+#define PREG_PAD_GPIO5_EN_N 0x201b
+#define P_PREG_PAD_GPIO5_EN_N           CBUS_REG_ADDR(PREG_PAD_GPIO5_EN_N)
+#define PREG_PAD_GPIO5_O 0x201c
+#define P_PREG_PAD_GPIO5_O              CBUS_REG_ADDR(PREG_PAD_GPIO5_O)
+#define PREG_PAD_GPIO5_I 0x201d
+#define P_PREG_PAD_GPIO5_I              CBUS_REG_ADDR(PREG_PAD_GPIO5_I)
+#define A9_STATUS1 0x201f
+#define P_A9_STATUS1            CBUS_REG_ADDR(A9_STATUS1)
+#define A9_CFG0 0x2020
+#define P_A9_CFG0               CBUS_REG_ADDR(A9_CFG0)
+#define A9_CFG1 0x2021
+#define P_A9_CFG1               CBUS_REG_ADDR(A9_CFG1)
+#define A9_CFG2 0x2022
+#define P_A9_CFG2               CBUS_REG_ADDR(A9_CFG2)
+#define A9_PERIPH_BASE 0x2023
+#define P_A9_PERIPH_BASE                CBUS_REG_ADDR(A9_PERIPH_BASE)
+#define A9_L2_REG_BASE 0x2024
+#define P_A9_L2_REG_BASE                CBUS_REG_ADDR(A9_L2_REG_BASE)
+#define A9_L2_STATUS 0x2025
+#define P_A9_L2_STATUS          CBUS_REG_ADDR(A9_L2_STATUS)
+#define A9_POR_CFG 0x2026
+#define P_A9_POR_CFG            CBUS_REG_ADDR(A9_POR_CFG)
+#define A9_STATUS2 0x2027
+#define P_A9_STATUS2            CBUS_REG_ADDR(A9_STATUS2)
+#define AXI_REG_EN 0x2028
+#define P_AXI_REG_EN            CBUS_REG_ADDR(AXI_REG_EN)
+#define A9_CFG3 0x2029
+#define P_A9_CFG3               CBUS_REG_ADDR(A9_CFG3)
+#define A9_CFG4 0x202a
+#define P_A9_CFG4               CBUS_REG_ADDR(A9_CFG4)
+#define A9_STATUS3 0x202b
+#define P_A9_STATUS3            CBUS_REG_ADDR(A9_STATUS3)
+#define PERIPHS_PIN_MUX_0 0x202c
+#define P_PERIPHS_PIN_MUX_0             CBUS_REG_ADDR(PERIPHS_PIN_MUX_0)
+#define PERIPHS_PIN_MUX_1 0x202d
+#define P_PERIPHS_PIN_MUX_1             CBUS_REG_ADDR(PERIPHS_PIN_MUX_1)
+#define PERIPHS_PIN_MUX_2 0x202e
+#define P_PERIPHS_PIN_MUX_2             CBUS_REG_ADDR(PERIPHS_PIN_MUX_2)
+#define PERIPHS_PIN_MUX_3 0x202f
+#define P_PERIPHS_PIN_MUX_3             CBUS_REG_ADDR(PERIPHS_PIN_MUX_3)
+#define PERIPHS_PIN_MUX_4 0x2030
+#define P_PERIPHS_PIN_MUX_4             CBUS_REG_ADDR(PERIPHS_PIN_MUX_4)
+#define PERIPHS_PIN_MUX_5 0x2031
+#define P_PERIPHS_PIN_MUX_5             CBUS_REG_ADDR(PERIPHS_PIN_MUX_5)
+#define PERIPHS_PIN_MUX_6 0x2032
+#define P_PERIPHS_PIN_MUX_6             CBUS_REG_ADDR(PERIPHS_PIN_MUX_6)
+#define PERIPHS_PIN_MUX_7 0x2033
+#define P_PERIPHS_PIN_MUX_7             CBUS_REG_ADDR(PERIPHS_PIN_MUX_7)
+#define PERIPHS_PIN_MUX_8 0x2034
+#define P_PERIPHS_PIN_MUX_8             CBUS_REG_ADDR(PERIPHS_PIN_MUX_8)
+#define PERIPHS_PIN_MUX_9 0x2035
+#define P_PERIPHS_PIN_MUX_9             CBUS_REG_ADDR(PERIPHS_PIN_MUX_9)
+#define PERIPHS_PIN_MUX_10 0x2036
+#define P_PERIPHS_PIN_MUX_10            CBUS_REG_ADDR(PERIPHS_PIN_MUX_10)
+#define PERIPHS_PIN_MUX_11 0x2037
+#define P_PERIPHS_PIN_MUX_11            CBUS_REG_ADDR(PERIPHS_PIN_MUX_11)
+#define PERIPHS_PIN_MUX_12 0x2038
+#define P_PERIPHS_PIN_MUX_12            CBUS_REG_ADDR(PERIPHS_PIN_MUX_12)
+#define PAD_PULL_UP_REG6 0x2039
+#define P_PAD_PULL_UP_REG6              CBUS_REG_ADDR(PAD_PULL_UP_REG6)
+#define PAD_PULL_UP_REG0 0x203a
+#define P_PAD_PULL_UP_REG0              CBUS_REG_ADDR(PAD_PULL_UP_REG0)
+#define PAD_PULL_UP_REG1 0x203b
+#define P_PAD_PULL_UP_REG1              CBUS_REG_ADDR(PAD_PULL_UP_REG1)
+#define PAD_PULL_UP_REG2 0x203c
+#define P_PAD_PULL_UP_REG2              CBUS_REG_ADDR(PAD_PULL_UP_REG2)
+#define PAD_PULL_UP_REG3 0x203d
+#define P_PAD_PULL_UP_REG3              CBUS_REG_ADDR(PAD_PULL_UP_REG3)
+#define PAD_PULL_UP_REG4 0x203e
+#define P_PAD_PULL_UP_REG4              CBUS_REG_ADDR(PAD_PULL_UP_REG4)
+#define PAD_PULL_UP_REG5 0x203f
+#define P_PAD_PULL_UP_REG5              CBUS_REG_ADDR(PAD_PULL_UP_REG5)
+#define RAND64_ADDR0 0x2040
+#define P_RAND64_ADDR0          CBUS_REG_ADDR(RAND64_ADDR0)
+#define RAND64_ADDR1 0x2041
+#define P_RAND64_ADDR1          CBUS_REG_ADDR(RAND64_ADDR1)
+#define PREG_ETHERNET_ADDR0 0x2042
+#define P_PREG_ETHERNET_ADDR0           CBUS_REG_ADDR(PREG_ETHERNET_ADDR0)
+#define PREG_AM_ANALOG_ADDR 0x2043
+#define P_PREG_AM_ANALOG_ADDR           CBUS_REG_ADDR(PREG_AM_ANALOG_ADDR)
+#define PREG_MALI_BYTE_CNTL 0x2044
+#define P_PREG_MALI_BYTE_CNTL           CBUS_REG_ADDR(PREG_MALI_BYTE_CNTL)
+#define PREG_WIFI_CNTL 0x2045
+#define P_PREG_WIFI_CNTL                CBUS_REG_ADDR(PREG_WIFI_CNTL)
+#define PAD_PULL_UP_EN_REG0 0x2048
+#define P_PAD_PULL_UP_EN_REG0           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG0)
+#define PAD_PULL_UP_EN_REG1 0x2049
+#define P_PAD_PULL_UP_EN_REG1           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG1)
+#define PAD_PULL_UP_EN_REG2 0x204a
+#define P_PAD_PULL_UP_EN_REG2           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG2)
+#define PAD_PULL_UP_EN_REG3 0x204b
+#define P_PAD_PULL_UP_EN_REG3           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG3)
+#define PAD_PULL_UP_EN_REG4 0x204c
+#define P_PAD_PULL_UP_EN_REG4           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG4)
+#define PAD_PULL_UP_EN_REG5 0x204d
+#define P_PAD_PULL_UP_EN_REG5           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG5)
+#define PAD_PULL_UP_EN_REG6 0x204e
+#define P_PAD_PULL_UP_EN_REG6           CBUS_REG_ADDR(PAD_PULL_UP_EN_REG6)
+/* add from M8M2*/
+#define PREG_ETH_REG0 0x2050
+#define P_PREG_ETH_REG0                 CBUS_REG_ADDR(PREG_ETH_REG0)
+#define PREG_ETH_REG1 0x2051
+#define P_PREG_ETH_REG1                 CBUS_REG_ADDR(PREG_ETH_REG1)
+/***************/
+#define PROD_TEST_REG0 0x2068
+#define P_PROD_TEST_REG0                CBUS_REG_ADDR(PROD_TEST_REG0)
+#define PROD_TEST_REG1 0x2067
+#define P_PROD_TEST_REG1                CBUS_REG_ADDR(PROD_TEST_REG1)
+#define METAL_REVISION 0x206a
+#define P_METAL_REVISION                CBUS_REG_ADDR(METAL_REVISION)
+#define ADC_TOP_MISC 0x206b
+#define P_ADC_TOP_MISC          CBUS_REG_ADDR(ADC_TOP_MISC)
+#define DPLL_TOP_MISC 0x206c
+#define P_DPLL_TOP_MISC                 CBUS_REG_ADDR(DPLL_TOP_MISC)
+#define ANALOG_TOP_MISC 0x206d
+#define P_ANALOG_TOP_MISC               CBUS_REG_ADDR(ANALOG_TOP_MISC)
+#define AM_ANALOG_TOP_REG0 0x206e
+#define P_AM_ANALOG_TOP_REG0            CBUS_REG_ADDR(AM_ANALOG_TOP_REG0)
+#define AM_ANALOG_TOP_REG1 0x206f
+#define P_AM_ANALOG_TOP_REG1            CBUS_REG_ADDR(AM_ANALOG_TOP_REG1)
+#define PREG_STICKY_REG0 0x207c
+#define P_PREG_STICKY_REG0              CBUS_REG_ADDR(PREG_STICKY_REG0)
+#define PREG_STICKY_REG1 0x207d
+#define P_PREG_STICKY_REG1              CBUS_REG_ADDR(PREG_STICKY_REG1)
+#define PREG_WRITE_ONCE_REG 0x207e
+#define P_PREG_WRITE_ONCE_REG           CBUS_REG_ADDR(PREG_WRITE_ONCE_REG)
+#define AM_RING_OSC_REG0 0x207f
+#define P_AM_RING_OSC_REG0              CBUS_REG_ADDR(AM_RING_OSC_REG0)
+#define SMARTCARD_REG0 0x2110
+#define P_SMARTCARD_REG0                CBUS_REG_ADDR(SMARTCARD_REG0)
+#define SMARTCARD_REG1 0x2111
+#define P_SMARTCARD_REG1                CBUS_REG_ADDR(SMARTCARD_REG1)
+#define SMARTCARD_REG2 0x2112
+#define P_SMARTCARD_REG2                CBUS_REG_ADDR(SMARTCARD_REG2)
+#define SMARTCARD_STATUS 0x2113
+#define P_SMARTCARD_STATUS              CBUS_REG_ADDR(SMARTCARD_STATUS)
+#define SMARTCARD_INTR 0x2114
+#define P_SMARTCARD_INTR                CBUS_REG_ADDR(SMARTCARD_INTR)
+#define SMARTCARD_REG5 0x2115
+#define P_SMARTCARD_REG5                CBUS_REG_ADDR(SMARTCARD_REG5)
+#define SMARTCARD_REG6 0x2116
+#define P_SMARTCARD_REG6                CBUS_REG_ADDR(SMARTCARD_REG6)
+#define SMARTCARD_FIFO 0x2117
+#define P_SMARTCARD_FIFO                CBUS_REG_ADDR(SMARTCARD_FIFO)
+#define SMARTCARD_REG8 0x2118
+#define P_SMARTCARD_REG8                CBUS_REG_ADDR(SMARTCARD_REG8)
+#define IR_DEC_LDR_ACTIVE 0x2120
+#define P_IR_DEC_LDR_ACTIVE             CBUS_REG_ADDR(IR_DEC_LDR_ACTIVE)
+#define IR_DEC_LDR_IDLE 0x2121
+#define P_IR_DEC_LDR_IDLE               CBUS_REG_ADDR(IR_DEC_LDR_IDLE)
+#define IR_DEC_LDR_REPEAT 0x2122
+#define P_IR_DEC_LDR_REPEAT             CBUS_REG_ADDR(IR_DEC_LDR_REPEAT)
+#define IR_DEC_BIT_0 0x2123
+#define P_IR_DEC_BIT_0          CBUS_REG_ADDR(IR_DEC_BIT_0)
+#define IR_DEC_REG0 0x2124
+#define P_IR_DEC_REG0           CBUS_REG_ADDR(IR_DEC_REG0)
+#define IR_DEC_FRAME 0x2125
+#define P_IR_DEC_FRAME          CBUS_REG_ADDR(IR_DEC_FRAME)
+#define IR_DEC_STATUS 0x2126
+#define P_IR_DEC_STATUS                 CBUS_REG_ADDR(IR_DEC_STATUS)
+#define IR_DEC_REG1 0x2127
+#define P_IR_DEC_REG1           CBUS_REG_ADDR(IR_DEC_REG1)
+#define DEMOD_ADC_SAMPLING 0x212d
+#define P_DEMOD_ADC_SAMPLING            CBUS_REG_ADDR(DEMOD_ADC_SAMPLING)
+#define UART0_WFIFO 0x2130
+#define P_UART0_WFIFO           CBUS_REG_ADDR(UART0_WFIFO)
+#define UART0_RFIFO 0x2131
+#define P_UART0_RFIFO           CBUS_REG_ADDR(UART0_RFIFO)
+#define UART0_CONTROL 0x2132
+#define P_UART0_CONTROL                 CBUS_REG_ADDR(UART0_CONTROL)
+#define UART0_STATUS 0x2133
+#define P_UART0_STATUS          CBUS_REG_ADDR(UART0_STATUS)
+#define UART0_MISC 0x2134
+#define P_UART0_MISC            CBUS_REG_ADDR(UART0_MISC)
+#define UART0_REG5 0x2135
+#define P_UART0_REG5            CBUS_REG_ADDR(UART0_REG5)
+#define UART1_WFIFO 0x2137
+#define P_UART1_WFIFO           CBUS_REG_ADDR(UART1_WFIFO)
+#define UART1_RFIFO 0x2138
+#define P_UART1_RFIFO           CBUS_REG_ADDR(UART1_RFIFO)
+#define UART1_CONTROL 0x2139
+#define P_UART1_CONTROL                 CBUS_REG_ADDR(UART1_CONTROL)
+#define UART1_STATUS 0x213a
+#define P_UART1_STATUS          CBUS_REG_ADDR(UART1_STATUS)
+#define UART1_MISC 0x213b
+#define P_UART1_MISC            CBUS_REG_ADDR(UART1_MISC)
+#define UART1_REG5 0x213c
+#define P_UART1_REG5            CBUS_REG_ADDR(UART1_REG5)
+#define I2C_M_0_CONTROL_REG 0x2140
+#define P_I2C_M_0_CONTROL_REG           CBUS_REG_ADDR(I2C_M_0_CONTROL_REG)
+#define I2C_M_0_SLAVE_ADDR 0x2141
+#define P_I2C_M_0_SLAVE_ADDR            CBUS_REG_ADDR(I2C_M_0_SLAVE_ADDR)
+#define I2C_M_0_TOKEN_LIST0 0x2142
+#define P_I2C_M_0_TOKEN_LIST0           CBUS_REG_ADDR(I2C_M_0_TOKEN_LIST0)
+#define I2C_M_0_TOKEN_LIST1 0x2143
+#define P_I2C_M_0_TOKEN_LIST1           CBUS_REG_ADDR(I2C_M_0_TOKEN_LIST1)
+#define I2C_M_0_WDATA_REG0 0x2144
+#define P_I2C_M_0_WDATA_REG0            CBUS_REG_ADDR(I2C_M_0_WDATA_REG0)
+#define I2C_M_0_WDATA_REG1 0x2145
+#define P_I2C_M_0_WDATA_REG1            CBUS_REG_ADDR(I2C_M_0_WDATA_REG1)
+#define I2C_M_0_RDATA_REG0 0x2146
+#define P_I2C_M_0_RDATA_REG0            CBUS_REG_ADDR(I2C_M_0_RDATA_REG0)
+#define I2C_M_0_RDATA_REG1 0x2147
+#define P_I2C_M_0_RDATA_REG1            CBUS_REG_ADDR(I2C_M_0_RDATA_REG1)
+#define I2C_S_CONTROL_REG 0x2150
+#define P_I2C_S_CONTROL_REG             CBUS_REG_ADDR(I2C_S_CONTROL_REG)
+#define I2C_S_SEND_REG 0x2151
+#define P_I2C_S_SEND_REG                CBUS_REG_ADDR(I2C_S_SEND_REG)
+#define I2C_S_RECV_REG 0x2152
+#define P_I2C_S_RECV_REG                CBUS_REG_ADDR(I2C_S_RECV_REG)
+#define I2C_S_CNTL1_REG 0x2153
+#define P_I2C_S_CNTL1_REG               CBUS_REG_ADDR(I2C_S_CNTL1_REG)
+#define PWM_PWM_A 0x2154
+#define P_PWM_PWM_A             CBUS_REG_ADDR(PWM_PWM_A)
+#define PWM_PWM_B 0x2155
+#define P_PWM_PWM_B             CBUS_REG_ADDR(PWM_PWM_B)
+#define PWM_MISC_REG_AB 0x2156
+#define P_PWM_MISC_REG_AB               CBUS_REG_ADDR(PWM_MISC_REG_AB)
+#define PWM_DELTA_SIGMA_AB 0x2157
+#define P_PWM_DELTA_SIGMA_AB            CBUS_REG_ADDR(PWM_DELTA_SIGMA_AB)
+#define ATAPI_IDEREG0 0x2160
+#define P_ATAPI_IDEREG0                 CBUS_REG_ADDR(ATAPI_IDEREG0)
+#define ATAPI_IDEREG1 0x2161
+#define P_ATAPI_IDEREG1                 CBUS_REG_ADDR(ATAPI_IDEREG1)
+#define ATAPI_IDEREG2 0x2162
+#define P_ATAPI_IDEREG2                 CBUS_REG_ADDR(ATAPI_IDEREG2)
+#define ATAPI_CYCTIME 0x2163
+#define P_ATAPI_CYCTIME                 CBUS_REG_ADDR(ATAPI_CYCTIME)
+#define ATAPI_IDETIME 0x2164
+#define P_ATAPI_IDETIME                 CBUS_REG_ADDR(ATAPI_IDETIME)
+#define ATAPI_PIO_TIMING 0x2165
+#define P_ATAPI_PIO_TIMING              CBUS_REG_ADDR(ATAPI_PIO_TIMING)
+#define ATAPI_TABLE_ADD_REG 0x2166
+#define P_ATAPI_TABLE_ADD_REG           CBUS_REG_ADDR(ATAPI_TABLE_ADD_REG)
+#define ATAPI_IDEREG3 0x2167
+#define P_ATAPI_IDEREG3                 CBUS_REG_ADDR(ATAPI_IDEREG3)
+#define ATAPI_UDMA_REG0 0x2168
+#define P_ATAPI_UDMA_REG0               CBUS_REG_ADDR(ATAPI_UDMA_REG0)
+#define ATAPI_UDMA_REG1 0x2169
+#define P_ATAPI_UDMA_REG1               CBUS_REG_ADDR(ATAPI_UDMA_REG1)
+#define TRANS_PWMA_REG0 0x2170
+#define P_TRANS_PWMA_REG0               CBUS_REG_ADDR(TRANS_PWMA_REG0)
+#define TRANS_PWMA_REG1 0x2171
+#define P_TRANS_PWMA_REG1               CBUS_REG_ADDR(TRANS_PWMA_REG1)
+#define TRANS_PWMA_MUX0 0x2172
+#define P_TRANS_PWMA_MUX0               CBUS_REG_ADDR(TRANS_PWMA_MUX0)
+#define TRANS_PWMA_MUX1 0x2173
+#define P_TRANS_PWMA_MUX1               CBUS_REG_ADDR(TRANS_PWMA_MUX1)
+#define TRANS_PWMA_MUX2 0x2174
+#define P_TRANS_PWMA_MUX2               CBUS_REG_ADDR(TRANS_PWMA_MUX2)
+#define TRANS_PWMA_MUX3 0x2175
+#define P_TRANS_PWMA_MUX3               CBUS_REG_ADDR(TRANS_PWMA_MUX3)
+#define TRANS_PWMA_MUX4 0x2176
+#define P_TRANS_PWMA_MUX4               CBUS_REG_ADDR(TRANS_PWMA_MUX4)
+#define TRANS_PWMA_MUX5 0x2177
+#define P_TRANS_PWMA_MUX5               CBUS_REG_ADDR(TRANS_PWMA_MUX5)
+#define TRANS_PWMB_REG0 0x2178
+#define P_TRANS_PWMB_REG0               CBUS_REG_ADDR(TRANS_PWMB_REG0)
+#define TRANS_PWMB_REG1 0x2179
+#define P_TRANS_PWMB_REG1               CBUS_REG_ADDR(TRANS_PWMB_REG1)
+#define TRANS_PWMB_MUX0 0x217a
+#define P_TRANS_PWMB_MUX0               CBUS_REG_ADDR(TRANS_PWMB_MUX0)
+#define TRANS_PWMB_MUX1 0x217b
+#define P_TRANS_PWMB_MUX1               CBUS_REG_ADDR(TRANS_PWMB_MUX1)
+#define TRANS_PWMB_MUX2 0x217c
+#define P_TRANS_PWMB_MUX2               CBUS_REG_ADDR(TRANS_PWMB_MUX2)
+#define TRANS_PWMB_MUX3 0x217d
+#define P_TRANS_PWMB_MUX3               CBUS_REG_ADDR(TRANS_PWMB_MUX3)
+#define TRANS_PWMB_MUX4 0x217e
+#define P_TRANS_PWMB_MUX4               CBUS_REG_ADDR(TRANS_PWMB_MUX4)
+#define TRANS_PWMB_MUX5 0x217f
+#define P_TRANS_PWMB_MUX5               CBUS_REG_ADDR(TRANS_PWMB_MUX5)
+#define NAND_START 0x2180
+#define P_NAND_START            CBUS_REG_ADDR(NAND_START)
+#define NAND_ADR_CMD 0x218a
+#define P_NAND_ADR_CMD          CBUS_REG_ADDR(NAND_ADR_CMD)
+#define NAND_ADR_STS 0x218b
+#define P_NAND_ADR_STS          CBUS_REG_ADDR(NAND_ADR_STS)
+#define NAND_END 0x218f
+#define P_NAND_END              CBUS_REG_ADDR(NAND_END)
+#define PWM_PWM_C 0x2194
+#define P_PWM_PWM_C             CBUS_REG_ADDR(PWM_PWM_C)
+#define PWM_PWM_D 0x2195
+#define P_PWM_PWM_D             CBUS_REG_ADDR(PWM_PWM_D)
+#define PWM_MISC_REG_CD 0x2196
+#define P_PWM_MISC_REG_CD               CBUS_REG_ADDR(PWM_MISC_REG_CD)
+#define PWM_DELTA_SIGMA_CD 0x2197
+#define P_PWM_DELTA_SIGMA_CD            CBUS_REG_ADDR(PWM_DELTA_SIGMA_CD)
+#define ISP_LED_CTRL 0x2198
+#define P_ISP_LED_CTRL          CBUS_REG_ADDR(ISP_LED_CTRL)
+#define ISP_LED_TIMING1 0x2199
+#define P_ISP_LED_TIMING1               CBUS_REG_ADDR(ISP_LED_TIMING1)
+#define ISP_LED_TIMING2 0x219a
+#define P_ISP_LED_TIMING2               CBUS_REG_ADDR(ISP_LED_TIMING2)
+#define ISP_LED_TIMING3 0x219b
+#define P_ISP_LED_TIMING3               CBUS_REG_ADDR(ISP_LED_TIMING3)
+#define ISP_LED_TIMING4 0x219c
+#define P_ISP_LED_TIMING4               CBUS_REG_ADDR(ISP_LED_TIMING4)
+#define ISP_LED_TIMING5 0x219d
+#define P_ISP_LED_TIMING5               CBUS_REG_ADDR(ISP_LED_TIMING5)
+#define ISP_LED_TIMING6 0x219e
+#define P_ISP_LED_TIMING6               CBUS_REG_ADDR(ISP_LED_TIMING6)
+#define SAR_ADC_REG0 0x21a0
+#define P_SAR_ADC_REG0          CBUS_REG_ADDR(SAR_ADC_REG0)
+#define SAR_ADC_CHAN_LIST 0x21a1
+#define P_SAR_ADC_CHAN_LIST             CBUS_REG_ADDR(SAR_ADC_CHAN_LIST)
+#define SAR_ADC_AVG_CNTL 0x21a2
+#define P_SAR_ADC_AVG_CNTL              CBUS_REG_ADDR(SAR_ADC_AVG_CNTL)
+#define SAR_ADC_REG3 0x21a3
+#define P_SAR_ADC_REG3          CBUS_REG_ADDR(SAR_ADC_REG3)
+#define SAR_ADC_DELAY 0x21a4
+#define P_SAR_ADC_DELAY                 CBUS_REG_ADDR(SAR_ADC_DELAY)
+#define SAR_ADC_LAST_RD 0x21a5
+#define P_SAR_ADC_LAST_RD               CBUS_REG_ADDR(SAR_ADC_LAST_RD)
+#define SAR_ADC_FIFO_RD 0x21a6
+#define P_SAR_ADC_FIFO_RD               CBUS_REG_ADDR(SAR_ADC_FIFO_RD)
+#define SAR_ADC_AUX_SW 0x21a7
+#define P_SAR_ADC_AUX_SW                CBUS_REG_ADDR(SAR_ADC_AUX_SW)
+#define SAR_ADC_CHAN_10_SW 0x21a8
+#define P_SAR_ADC_CHAN_10_SW            CBUS_REG_ADDR(SAR_ADC_CHAN_10_SW)
+#define SAR_ADC_DETECT_IDLE_SW 0x21a9
+#define P_SAR_ADC_DETECT_IDLE_SW \
+	CBUS_REG_ADDR(SAR_ADC_DETECT_IDLE_SW)
+#define SAR_ADC_DELTA_10 0x21aa
+#define P_SAR_ADC_DELTA_10              CBUS_REG_ADDR(SAR_ADC_DELTA_10)
+#define PWM_PWM_E 0x21b0
+#define P_PWM_PWM_E             CBUS_REG_ADDR(PWM_PWM_E)
+#define PWM_PWM_F 0x21b1
+#define P_PWM_PWM_F             CBUS_REG_ADDR(PWM_PWM_F)
+#define PWM_MISC_REG_EF 0x21b2
+#define P_PWM_MISC_REG_EF               CBUS_REG_ADDR(PWM_MISC_REG_EF)
+#define PWM_DELTA_SIGMA_EF 0x21b3
+#define P_PWM_DELTA_SIGMA_EF            CBUS_REG_ADDR(PWM_DELTA_SIGMA_EF)
+#define UART2_WFIFO 0x21c0
+#define P_UART2_WFIFO           CBUS_REG_ADDR(UART2_WFIFO)
+#define UART2_RFIFO 0x21c1
+#define P_UART2_RFIFO           CBUS_REG_ADDR(UART2_RFIFO)
+#define UART2_CONTROL 0x21c2
+#define P_UART2_CONTROL                 CBUS_REG_ADDR(UART2_CONTROL)
+#define UART2_STATUS 0x21c3
+#define P_UART2_STATUS          CBUS_REG_ADDR(UART2_STATUS)
+#define UART2_MISC 0x21c4
+#define P_UART2_MISC            CBUS_REG_ADDR(UART2_MISC)
+#define UART2_REG5 0x21c5
+#define P_UART2_REG5            CBUS_REG_ADDR(UART2_REG5)
+#define UART3_WFIFO 0x21c8
+#define P_UART3_WFIFO           CBUS_REG_ADDR(UART3_WFIFO)
+#define UART3_RFIFO 0x21c9
+#define P_UART3_RFIFO           CBUS_REG_ADDR(UART3_RFIFO)
+#define UART3_CONTROL 0x21ca
+#define P_UART3_CONTROL                 CBUS_REG_ADDR(UART3_CONTROL)
+#define UART3_STATUS 0x21cb
+#define P_UART3_STATUS          CBUS_REG_ADDR(UART3_STATUS)
+#define UART3_MISC 0x21cc
+#define P_UART3_MISC            CBUS_REG_ADDR(UART3_MISC)
+#define UART3_REG5 0x21cd
+#define P_UART3_REG5            CBUS_REG_ADDR(UART3_REG5)
+#define RTC_ADDR0 0x21d0
+#define P_RTC_ADDR0             CBUS_REG_ADDR(RTC_ADDR0)
+#define RTC_ADDR1 0x21d1
+#define P_RTC_ADDR1             CBUS_REG_ADDR(RTC_ADDR1)
+#define RTC_ADDR2 0x21d2
+#define P_RTC_ADDR2             CBUS_REG_ADDR(RTC_ADDR2)
+#define RTC_ADDR3 0x21d3
+#define P_RTC_ADDR3             CBUS_REG_ADDR(RTC_ADDR3)
+#define RTC_ADDR4 0x21d4
+#define P_RTC_ADDR4             CBUS_REG_ADDR(RTC_ADDR4)
+#define MSR_CLK_DUTY 0x21d6
+#define P_MSR_CLK_DUTY          CBUS_REG_ADDR(MSR_CLK_DUTY)
+#define MSR_CLK_REG0 0x21d7
+#define P_MSR_CLK_REG0          CBUS_REG_ADDR(MSR_CLK_REG0)
+#define MSR_CLK_REG1 0x21d8
+#define P_MSR_CLK_REG1          CBUS_REG_ADDR(MSR_CLK_REG1)
+#define MSR_CLK_REG2 0x21d9
+#define P_MSR_CLK_REG2          CBUS_REG_ADDR(MSR_CLK_REG2)
+/*add from M8M2*/
+#define MSR_CLK_REG3 0x21da
+#define P_MSR_CLK_REG3          CBUS_REG_ADDR(MSR_CLK_REG3)
+#define MSR_CLK_REG4 0x21db
+#define P_MSR_CLK_REG4          CBUS_REG_ADDR(MSR_CLK_REG4)
+#define MSR_CLK_REG5 0x21de
+#define P_MSR_CLK_REG5          CBUS_REG_ADDR(MSR_CLK_REG5)
+/**/
+/*
+ * #define LED_PWM_REG0 0x21da
+ * #define P_LED_PWM_REG0		CBUS_REG_ADDR(LED_PWM_REG0)
+ * #define LED_PWM_REG1 0x21db
+ * #define P_LED_PWM_REG1		CBUS_REG_ADDR(LED_PWM_REG1)
+ * #define LED_PWM_REG2 0x21dc
+ * #define P_LED_PWM_REG2		CBUS_REG_ADDR(LED_PWM_REG2)
+ * #define LED_PWM_REG3 0x21dd
+ * #define P_LED_PWM_REG3		CBUS_REG_ADDR(LED_PWM_REG3)
+ * #define LED_PWM_REG4 0x21de
+ * #define P_LED_PWM_REG4		CBUS_REG_ADDR(LED_PWM_REG4)
+ * #define LED_PWM_REG5 0x21df
+ * #define P_LED_PWM_REG5		CBUS_REG_ADDR(LED_PWM_REG5)
+ * #define LED_PWM_REG6 0x21e0
+ * #define P_LED_PWM_REG6		CBUS_REG_ADDR(LED_PWM_REG6)
+ */
+#define VGHL_PWM_REG0 0x21e1
+#define P_VGHL_PWM_REG0                 CBUS_REG_ADDR(VGHL_PWM_REG0)
+#define VGHL_PWM_REG1 0x21e2
+#define P_VGHL_PWM_REG1                 CBUS_REG_ADDR(VGHL_PWM_REG1)
+#define VGHL_PWM_REG2 0x21e3
+#define P_VGHL_PWM_REG2                 CBUS_REG_ADDR(VGHL_PWM_REG2)
+#define VGHL_PWM_REG3 0x21e4
+#define P_VGHL_PWM_REG3                 CBUS_REG_ADDR(VGHL_PWM_REG3)
+#define VGHL_PWM_REG4 0x21e5
+#define P_VGHL_PWM_REG4                 CBUS_REG_ADDR(VGHL_PWM_REG4)
+#define VGHL_PWM_REG5 0x21e6
+#define P_VGHL_PWM_REG5                 CBUS_REG_ADDR(VGHL_PWM_REG5)
+#define VGHL_PWM_REG6 0x21e7
+#define P_VGHL_PWM_REG6                 CBUS_REG_ADDR(VGHL_PWM_REG6)
+#define I2C_M_1_CONTROL_REG 0x21f0
+#define P_I2C_M_1_CONTROL_REG           CBUS_REG_ADDR(I2C_M_1_CONTROL_REG)
+#define I2C_M_1_SLAVE_ADDR 0x21f1
+#define P_I2C_M_1_SLAVE_ADDR            CBUS_REG_ADDR(I2C_M_1_SLAVE_ADDR)
+#define I2C_M_1_TOKEN_LIST0 0x21f2
+#define P_I2C_M_1_TOKEN_LIST0           CBUS_REG_ADDR(I2C_M_1_TOKEN_LIST0)
+#define I2C_M_1_TOKEN_LIST1 0x21f3
+#define P_I2C_M_1_TOKEN_LIST1           CBUS_REG_ADDR(I2C_M_1_TOKEN_LIST1)
+#define I2C_M_1_WDATA_REG0 0x21f4
+#define P_I2C_M_1_WDATA_REG0            CBUS_REG_ADDR(I2C_M_1_WDATA_REG0)
+#define I2C_M_1_WDATA_REG1 0x21f5
+#define P_I2C_M_1_WDATA_REG1            CBUS_REG_ADDR(I2C_M_1_WDATA_REG1)
+#define I2C_M_1_RDATA_REG0 0x21f6
+#define P_I2C_M_1_RDATA_REG0            CBUS_REG_ADDR(I2C_M_1_RDATA_REG0)
+#define I2C_M_1_RDATA_REG1 0x21f7
+#define P_I2C_M_1_RDATA_REG1            CBUS_REG_ADDR(I2C_M_1_RDATA_REG1)
+#define I2C_M_2_CONTROL_REG 0x21f8
+#define P_I2C_M_2_CONTROL_REG           CBUS_REG_ADDR(I2C_M_2_CONTROL_REG)
+#define I2C_M_2_SLAVE_ADDR 0x21f9
+#define P_I2C_M_2_SLAVE_ADDR            CBUS_REG_ADDR(I2C_M_2_SLAVE_ADDR)
+#define I2C_M_2_TOKEN_LIST0 0x21fa
+#define P_I2C_M_2_TOKEN_LIST0           CBUS_REG_ADDR(I2C_M_2_TOKEN_LIST0)
+#define I2C_M_2_TOKEN_LIST1 0x21fb
+#define P_I2C_M_2_TOKEN_LIST1           CBUS_REG_ADDR(I2C_M_2_TOKEN_LIST1)
+#define I2C_M_2_WDATA_REG0 0x21fc
+#define P_I2C_M_2_WDATA_REG0            CBUS_REG_ADDR(I2C_M_2_WDATA_REG0)
+#define I2C_M_2_WDATA_REG1 0x21fd
+#define P_I2C_M_2_WDATA_REG1            CBUS_REG_ADDR(I2C_M_2_WDATA_REG1)
+#define I2C_M_2_RDATA_REG0 0x21fe
+#define P_I2C_M_2_RDATA_REG0            CBUS_REG_ADDR(I2C_M_2_RDATA_REG0)
+#define I2C_M_2_RDATA_REG1 0x21ff
+#define P_I2C_M_2_RDATA_REG1            CBUS_REG_ADDR(I2C_M_2_RDATA_REG1)
+#define USB_ADDR0 0x2200
+#define P_USB_ADDR0             CBUS_REG_ADDR(USB_ADDR0)
+#define USB_ADDR1 0x2201
+#define P_USB_ADDR1             CBUS_REG_ADDR(USB_ADDR1)
+#define USB_ADDR2 0x2202
+#define P_USB_ADDR2             CBUS_REG_ADDR(USB_ADDR2)
+#define USB_ADDR3 0x2203
+#define P_USB_ADDR3             CBUS_REG_ADDR(USB_ADDR3)
+#define USB_ADDR4 0x2204
+#define P_USB_ADDR4             CBUS_REG_ADDR(USB_ADDR4)
+#define USB_ADDR5 0x2205
+#define P_USB_ADDR5             CBUS_REG_ADDR(USB_ADDR5)
+#define USB_ADDR6 0x2206
+#define P_USB_ADDR6             CBUS_REG_ADDR(USB_ADDR6)
+#define USB_ADDR7 0x2207
+#define P_USB_ADDR7             CBUS_REG_ADDR(USB_ADDR7)
+#define USB_ADDR8 0x2208
+#define P_USB_ADDR8             CBUS_REG_ADDR(USB_ADDR8)
+#define USB_ADDR9 0x2209
+#define P_USB_ADDR9             CBUS_REG_ADDR(USB_ADDR9)
+#define USB_ADDR10 0x220a
+#define P_USB_ADDR10            CBUS_REG_ADDR(USB_ADDR10)
+#define USB_ADDR11 0x220b
+#define P_USB_ADDR11            CBUS_REG_ADDR(USB_ADDR11)
+#define USB_ADDR12 0x220c
+#define P_USB_ADDR12            CBUS_REG_ADDR(USB_ADDR12)
+#define USB_ADDR13 0x220d
+#define P_USB_ADDR13            CBUS_REG_ADDR(USB_ADDR13)
+#define USB_ADDR14 0x220e
+#define P_USB_ADDR14            CBUS_REG_ADDR(USB_ADDR14)
+#define USB_ADDR15 0x220f
+#define P_USB_ADDR15            CBUS_REG_ADDR(USB_ADDR15)
+#define USB_ADDR16 0x2210
+#define P_USB_ADDR16            CBUS_REG_ADDR(USB_ADDR16)
+#define USB_ADDR17 0x2211
+#define P_USB_ADDR17            CBUS_REG_ADDR(USB_ADDR17)
+#define USB_ADDR18 0x2212
+#define P_USB_ADDR18            CBUS_REG_ADDR(USB_ADDR18)
+#define USB_ADDR19 0x2213
+#define P_USB_ADDR19            CBUS_REG_ADDR(USB_ADDR19)
+#define USB_ADDR20 0x2214
+#define P_USB_ADDR20            CBUS_REG_ADDR(USB_ADDR20)
+#define USB_ADDR21 0x2215
+#define P_USB_ADDR21            CBUS_REG_ADDR(USB_ADDR21)
+#define USB_ADDR22 0x2216
+#define P_USB_ADDR22            CBUS_REG_ADDR(USB_ADDR22)
+#define USB_ADDR23 0x2217
+#define P_USB_ADDR23            CBUS_REG_ADDR(USB_ADDR23)
+#define USB_ADDR24 0x2218
+#define P_USB_ADDR24            CBUS_REG_ADDR(USB_ADDR24)
+#define USB_ADDR25 0x2219
+#define P_USB_ADDR25            CBUS_REG_ADDR(USB_ADDR25)
+#define USB_ADDR26 0x221a
+#define P_USB_ADDR26            CBUS_REG_ADDR(USB_ADDR26)
+#define USB_ADDR27 0x221b
+#define P_USB_ADDR27            CBUS_REG_ADDR(USB_ADDR27)
+#define USB_ADDR28 0x221c
+#define P_USB_ADDR28            CBUS_REG_ADDR(USB_ADDR28)
+#define USB_ADDR29 0x221d
+#define P_USB_ADDR29            CBUS_REG_ADDR(USB_ADDR29)
+#define USB_ADDR30 0x221e
+#define P_USB_ADDR30            CBUS_REG_ADDR(USB_ADDR30)
+#define USB_ADDR31 0x221f
+#define P_USB_ADDR31            CBUS_REG_ADDR(USB_ADDR31)
+/*add from M8M2*/
+#define SANA_STREAM_CONTROL 0x2220
+#define P_SANA_STREAM_CONTROL           CBUS_REG_ADDR(SANA_STREAM_CONTROL)
+#define SANA_STREAM_START_ADDR 0x2221
+#define P_SANA_STREAM_START_ADDR        \
+	CBUS_REG_ADDR(SANA_STREAM_START_ADDR)
+#define SANA_STREAM_END_ADDR 0x2222
+#define P_SANA_STREAM_END_ADDR          CBUS_REG_ADDR(SANA_STREAM_END_ADDR)
+#define SANA_STREAM_WR_PTR 0x2223
+#define P_SANA_STREAM_WR_PTR            CBUS_REG_ADDR(SANA_STREAM_WR_PTR)
+#define SANA_STREAM_RD_PTR 0x2224
+#define P_SANA_STREAM_RD_PTR            CBUS_REG_ADDR(SANA_STREAM_RD_PTR)
+#define SANA_STREAM_LEVEL 0x2225
+#define P_SANA_STREAM_LEVEL             CBUS_REG_ADDR(SANA_STREAM_LEVEL)
+#define SANA_STREAM_FIFO_CTL 0x2226
+#define P_SANA_STREAM_FIFO_CTL          CBUS_REG_ADDR(SANA_STREAM_FIFO_CTL)
+#define SANA_SHIFT_CONTROL 0x2227
+#define P_SANA_SHIFT_CONTROL            CBUS_REG_ADDR(SANA_SHIFT_CONTROL)
+#define SANA_SHIFT_STARTCODE 0x2228
+#define P_SANA_SHIFT_STARTCODE          CBUS_REG_ADDR(SANA_SHIFT_STARTCODE)
+#define SANA_SHIFT_EMULATECODE 0x2229
+#define P_SANA_SHIFT_EMULATECODE        \
+	CBUS_REG_ADDR(SANA_SHIFT_EMULATECODE)
+#define SANA_SHIFT_STATUS 0x222a
+#define P_SANA_SHIFT_STATUS             CBUS_REG_ADDR(SANA_SHIFT_STATUS)
+#define SANA_SHIFTED_DATA 0x222b
+#define P_SANA_SHIFTED_DATA             CBUS_REG_ADDR(SANA_SHIFTED_DATA)
+#define SANA_SHIFT_BYTE_COUNT 0x222c
+#define P_SANA_SHIFT_BYTE_COUNT         \
+	CBUS_REG_ADDR(SANA_SHIFT_BYTE_COUNT)
+#define SANA_SHIFT_COMMAND 0x222d
+#define P_SANA_SHIFT_COMMAND            CBUS_REG_ADDR(SANA_SHIFT_COMMAND)
+#define SANA_ELEMENT_RESULT 0x222e
+#define P_SANA_ELEMENT_RESULT           CBUS_REG_ADDR(SANA_ELEMENT_RESULT)
+#define ATOM_LOCK 0x222f
+#define P_ATOM_LOCK             CBUS_REG_ADDR(ATOM_LOCK)
+/**/
+#define NDMA_CNTL_REG0 0x2270
+#define P_NDMA_CNTL_REG0                CBUS_REG_ADDR(NDMA_CNTL_REG0)
+#define NDMA_TABLE_ADD_REG 0x2272
+#define P_NDMA_TABLE_ADD_REG            CBUS_REG_ADDR(NDMA_TABLE_ADD_REG)
+#define NDMA_TDES_KEY_LO 0x2273
+#define P_NDMA_TDES_KEY_LO              CBUS_REG_ADDR(NDMA_TDES_KEY_LO)
+#define NDMA_TDES_KEY_HI 0x2274
+#define P_NDMA_TDES_KEY_HI              CBUS_REG_ADDR(NDMA_TDES_KEY_HI)
+#define NDMA_TDES_CONTROL 0x2275
+#define P_NDMA_TDES_CONTROL             CBUS_REG_ADDR(NDMA_TDES_CONTROL)
+#define NDMA_RIJNDAEL_CONTROL 0x2276
+#define P_NDMA_RIJNDAEL_CONTROL         \
+	CBUS_REG_ADDR(NDMA_RIJNDAEL_CONTROL)
+#define NDMA_RIJNDAEL_RK_FIFO 0x2277
+#define P_NDMA_RIJNDAEL_RK_FIFO         \
+	CBUS_REG_ADDR(NDMA_RIJNDAEL_RK_FIFO)
+#define NDMA_CRC_OUT 0x2278
+#define P_NDMA_CRC_OUT          CBUS_REG_ADDR(NDMA_CRC_OUT)
+#define NDMA_THREAD_REG 0x2279
+#define P_NDMA_THREAD_REG               CBUS_REG_ADDR(NDMA_THREAD_REG)
+#define NDMA_THREAD_TABLE_START0 0x2280
+#define P_NDMA_THREAD_TABLE_START0      \
+	CBUS_REG_ADDR(NDMA_THREAD_TABLE_START0)
+#define NDMA_THREAD_TABLE_CURR0 0x2281
+
+#define NDMA_CNTL_REG1 0x228c
+#define P_NDMA_CNTL_REG1                CBUS_REG_ADDR(NDMA_CNTL_REG1)
+#define NDMA_AES_KEY_0 0x2290
+#define P_NDMA_AES_KEY_0                CBUS_REG_ADDR(NDMA_AES_KEY_0)
+#define NDMA_AES_KEY_1 0x2291
+#define P_NDMA_AES_KEY_1                CBUS_REG_ADDR(NDMA_AES_KEY_1)
+#define NDMA_AES_KEY_2 0x2292
+#define P_NDMA_AES_KEY_2                CBUS_REG_ADDR(NDMA_AES_KEY_2)
+#define NDMA_AES_KEY_3 0x2293
+#define P_NDMA_AES_KEY_3                CBUS_REG_ADDR(NDMA_AES_KEY_3)
+#define NDMA_AES_KEY_4 0x2294
+#define P_NDMA_AES_KEY_4                CBUS_REG_ADDR(NDMA_AES_KEY_4)
+#define NDMA_AES_KEY_5 0x2295
+#define P_NDMA_AES_KEY_5                CBUS_REG_ADDR(NDMA_AES_KEY_5)
+#define NDMA_AES_KEY_6 0x2296
+#define P_NDMA_AES_KEY_6                CBUS_REG_ADDR(NDMA_AES_KEY_6)
+#define NDMA_AES_KEY_7 0x2297
+#define P_NDMA_AES_KEY_7                CBUS_REG_ADDR(NDMA_AES_KEY_7)
+#define NDMA_AES_IV_0 0x2298
+#define P_NDMA_AES_IV_0                 CBUS_REG_ADDR(NDMA_AES_IV_0)
+#define NDMA_AES_IV_1 0x2299
+#define P_NDMA_AES_IV_1                 CBUS_REG_ADDR(NDMA_AES_IV_1)
+#define NDMA_AES_IV_2 0x229a
+#define P_NDMA_AES_IV_2                 CBUS_REG_ADDR(NDMA_AES_IV_2)
+#define NDMA_AES_IV_3 0x229b
+#define P_NDMA_AES_IV_3                 CBUS_REG_ADDR(NDMA_AES_IV_3)
+#define NDMA_AES_REG0 0x229c
+#define P_NDMA_AES_REG0                 CBUS_REG_ADDR(NDMA_AES_REG0)
+#define STREAM_EVENT_INFO 0x2300
+#define P_STREAM_EVENT_INFO             CBUS_REG_ADDR(STREAM_EVENT_INFO)
+#define STREAM_OUTPUT_CONFIG 0x2301
+#define P_STREAM_OUTPUT_CONFIG          CBUS_REG_ADDR(STREAM_OUTPUT_CONFIG)
+#define C_D_BUS_CONTROL 0x2302
+#define P_C_D_BUS_CONTROL               CBUS_REG_ADDR(C_D_BUS_CONTROL)
+#define C_DATA 0x2303
+#define P_C_DATA                CBUS_REG_ADDR(C_DATA)
+#define STREAM_BUS_CONFIG 0x2304
+#define P_STREAM_BUS_CONFIG             CBUS_REG_ADDR(STREAM_BUS_CONFIG)
+#define STREAM_EVENT_CTL 0x2307
+#define P_STREAM_EVENT_CTL              CBUS_REG_ADDR(STREAM_EVENT_CTL)
+#define CMD_ARGUMENT 0x2308
+#define P_CMD_ARGUMENT          CBUS_REG_ADDR(CMD_ARGUMENT)
+#define CMD_SEND 0x2309
+#define P_CMD_SEND              CBUS_REG_ADDR(CMD_SEND)
+#define SDIO_CONFIG 0x230a
+#define P_SDIO_CONFIG           CBUS_REG_ADDR(SDIO_CONFIG)
+#define SDIO_STATUS_IRQ 0x230b
+#define P_SDIO_STATUS_IRQ               CBUS_REG_ADDR(SDIO_STATUS_IRQ)
+#define SDIO_IRQ_CONFIG 0x230c
+#define P_SDIO_IRQ_CONFIG               CBUS_REG_ADDR(SDIO_IRQ_CONFIG)
+#define SDIO_MULT_CONFIG 0x230d
+#define P_SDIO_MULT_CONFIG              CBUS_REG_ADDR(SDIO_MULT_CONFIG)
+#define SDIO_M_ADDR 0x230e
+#define P_SDIO_M_ADDR           CBUS_REG_ADDR(SDIO_M_ADDR)
+#define SDIO_EXTENSION 0x230f
+#define P_SDIO_EXTENSION                CBUS_REG_ADDR(SDIO_EXTENSION)
+#define ASYNC_FIFO_REG0 0x2310
+#define P_ASYNC_FIFO_REG0               CBUS_REG_ADDR(ASYNC_FIFO_REG0)
+#define ASYNC_FIFO_REG1 0x2311
+#define P_ASYNC_FIFO_REG1               CBUS_REG_ADDR(ASYNC_FIFO_REG1)
+#define ASYNC_FIFO_REG2 0x2312
+#define P_ASYNC_FIFO_REG2               CBUS_REG_ADDR(ASYNC_FIFO_REG2)
+#define ASYNC_FIFO_REG3 0x2313
+#define P_ASYNC_FIFO_REG3               CBUS_REG_ADDR(ASYNC_FIFO_REG3)
+#define ASYNC_FIFO2_REG0 0x2314
+#define P_ASYNC_FIFO2_REG0              CBUS_REG_ADDR(ASYNC_FIFO2_REG0)
+#define ASYNC_FIFO2_REG1 0x2315
+#define P_ASYNC_FIFO2_REG1              CBUS_REG_ADDR(ASYNC_FIFO2_REG1)
+#define ASYNC_FIFO2_REG2 0x2316
+#define P_ASYNC_FIFO2_REG2              CBUS_REG_ADDR(ASYNC_FIFO2_REG2)
+#define ASYNC_FIFO2_REG3 0x2317
+#define P_ASYNC_FIFO2_REG3              CBUS_REG_ADDR(ASYNC_FIFO2_REG3)
+#define SDIO_AHB_CBUS_CTRL 0x2318
+#define P_SDIO_AHB_CBUS_CTRL            CBUS_REG_ADDR(SDIO_AHB_CBUS_CTRL)
+#define SDIO_AHB_CBUS_M_DATA 0x2319
+#define P_SDIO_AHB_CBUS_M_DATA          CBUS_REG_ADDR(SDIO_AHB_CBUS_M_DATA)
+#define SPI_FLASH_CMD 0x2320
+#define P_SPI_FLASH_CMD                 CBUS_REG_ADDR(SPI_FLASH_CMD)
+#define SPI_FLASH_ADDR 0x2321
+#define P_SPI_FLASH_ADDR                CBUS_REG_ADDR(SPI_FLASH_ADDR)
+#define SPI_FLASH_CTRL 0x2322
+#define P_SPI_FLASH_CTRL                CBUS_REG_ADDR(SPI_FLASH_CTRL)
+#define SPI_FLASH_CTRL1 0x2323
+#define P_SPI_FLASH_CTRL1               CBUS_REG_ADDR(SPI_FLASH_CTRL1)
+#define SPI_FLASH_STATUS 0x2324
+#define P_SPI_FLASH_STATUS              CBUS_REG_ADDR(SPI_FLASH_STATUS)
+#define SPI_FLASH_CTRL2 0x2325
+#define P_SPI_FLASH_CTRL2               CBUS_REG_ADDR(SPI_FLASH_CTRL2)
+#define SPI_FLASH_CLOCK 0x2326
+#define P_SPI_FLASH_CLOCK               CBUS_REG_ADDR(SPI_FLASH_CLOCK)
+#define SPI_FLASH_USER 0x2327
+#define P_SPI_FLASH_USER                CBUS_REG_ADDR(SPI_FLASH_USER)
+#define SPI_FLASH_USER1 0x2328
+#define P_SPI_FLASH_USER1               CBUS_REG_ADDR(SPI_FLASH_USER1)
+#define SPI_FLASH_USER2 0x2329
+#define P_SPI_FLASH_USER2               CBUS_REG_ADDR(SPI_FLASH_USER2)
+#define SPI_FLASH_USER3 0x232a
+#define P_SPI_FLASH_USER3               CBUS_REG_ADDR(SPI_FLASH_USER3)
+#define SPI_FLASH_USER4 0x232b
+#define P_SPI_FLASH_USER4               CBUS_REG_ADDR(SPI_FLASH_USER4)
+#define SPI_FLASH_SLAVE 0x232c
+#define P_SPI_FLASH_SLAVE               CBUS_REG_ADDR(SPI_FLASH_SLAVE)
+#define SPI_FLASH_SLAVE1 0x232d
+#define P_SPI_FLASH_SLAVE1              CBUS_REG_ADDR(SPI_FLASH_SLAVE1)
+#define SPI_FLASH_SLAVE2 0x232e
+#define P_SPI_FLASH_SLAVE2              CBUS_REG_ADDR(SPI_FLASH_SLAVE2)
+#define SPI_FLASH_SLAVE3 0x232f
+#define P_SPI_FLASH_SLAVE3              CBUS_REG_ADDR(SPI_FLASH_SLAVE3)
+#define SPI_FLASH_C0 0x2330
+#define P_SPI_FLASH_C0          CBUS_REG_ADDR(SPI_FLASH_C0)
+#define SPI_FLASH_C1 0x2331
+#define P_SPI_FLASH_C1          CBUS_REG_ADDR(SPI_FLASH_C1)
+#define SPI_FLASH_C2 0x2332
+#define P_SPI_FLASH_C2          CBUS_REG_ADDR(SPI_FLASH_C2)
+#define SPI_FLASH_C3 0x2333
+#define P_SPI_FLASH_C3          CBUS_REG_ADDR(SPI_FLASH_C3)
+#define SPI_FLASH_C4 0x2334
+#define P_SPI_FLASH_C4          CBUS_REG_ADDR(SPI_FLASH_C4)
+#define SPI_FLASH_C5 0x2335
+#define P_SPI_FLASH_C5          CBUS_REG_ADDR(SPI_FLASH_C5)
+#define SPI_FLASH_C6 0x2336
+#define P_SPI_FLASH_C6          CBUS_REG_ADDR(SPI_FLASH_C6)
+#define SPI_FLASH_C7 0x2337
+#define P_SPI_FLASH_C7          CBUS_REG_ADDR(SPI_FLASH_C7)
+#define SPI_FLASH_B8 0x2338
+#define P_SPI_FLASH_B8          CBUS_REG_ADDR(SPI_FLASH_B8)
+#define SPI_FLASH_B9 0x2339
+#define P_SPI_FLASH_B9          CBUS_REG_ADDR(SPI_FLASH_B9)
+#define SPI_FLASH_B10 0x233a
+#define P_SPI_FLASH_B10                 CBUS_REG_ADDR(SPI_FLASH_B10)
+#define SPI_FLASH_B11 0x233b
+#define P_SPI_FLASH_B11                 CBUS_REG_ADDR(SPI_FLASH_B11)
+#define SPI_FLASH_B12 0x233c
+#define P_SPI_FLASH_B12                 CBUS_REG_ADDR(SPI_FLASH_B12)
+#define SPI_FLASH_B13 0x233d
+#define P_SPI_FLASH_B13                 CBUS_REG_ADDR(SPI_FLASH_B13)
+#define SPI_FLASH_B14 0x233e
+#define P_SPI_FLASH_B14                 CBUS_REG_ADDR(SPI_FLASH_B14)
+#define SPI_FLASH_B15 0x233f
+#define P_SPI_FLASH_B15                 CBUS_REG_ADDR(SPI_FLASH_B15)
+#define I2C_M_3_CONTROL_REG 0x2348
+#define P_I2C_M_3_CONTROL_REG           CBUS_REG_ADDR(I2C_M_3_CONTROL_REG)
+#define I2C_M_3_SLAVE_ADDR 0x2349
+#define P_I2C_M_3_SLAVE_ADDR            CBUS_REG_ADDR(I2C_M_3_SLAVE_ADDR)
+#define I2C_M_3_TOKEN_LIST0 0x234a
+#define P_I2C_M_3_TOKEN_LIST0           CBUS_REG_ADDR(I2C_M_3_TOKEN_LIST0)
+#define I2C_M_3_TOKEN_LIST1 0x234b
+#define P_I2C_M_3_TOKEN_LIST1           CBUS_REG_ADDR(I2C_M_3_TOKEN_LIST1)
+#define I2C_M_3_WDATA_REG0 0x234c
+#define P_I2C_M_3_WDATA_REG0            CBUS_REG_ADDR(I2C_M_3_WDATA_REG0)
+#define I2C_M_3_WDATA_REG1 0x234d
+#define P_I2C_M_3_WDATA_REG1            CBUS_REG_ADDR(I2C_M_3_WDATA_REG1)
+#define I2C_M_3_RDATA_REG0 0x234e
+#define P_I2C_M_3_RDATA_REG0            CBUS_REG_ADDR(I2C_M_3_RDATA_REG0)
+#define I2C_M_3_RDATA_REG1 0x234f
+#define P_I2C_M_3_RDATA_REG1            CBUS_REG_ADDR(I2C_M_3_RDATA_REG1)
+#define SPICC_RXDATA 0x2360
+#define P_SPICC_RXDATA          CBUS_REG_ADDR(SPICC_RXDATA)
+#define SPICC_TXDATA 0x2361
+#define P_SPICC_TXDATA          CBUS_REG_ADDR(SPICC_TXDATA)
+#define SPICC_CONREG 0x2362
+#define P_SPICC_CONREG          CBUS_REG_ADDR(SPICC_CONREG)
+#define SPICC_INTREG 0x2363
+#define P_SPICC_INTREG          CBUS_REG_ADDR(SPICC_INTREG)
+#define SPICC_DMAREG 0x2364
+#define P_SPICC_DMAREG          CBUS_REG_ADDR(SPICC_DMAREG)
+#define SPICC_STATREG 0x2365
+#define P_SPICC_STATREG                 CBUS_REG_ADDR(SPICC_STATREG)
+#define SPICC_PERIODREG 0x2366
+#define P_SPICC_PERIODREG               CBUS_REG_ADDR(SPICC_PERIODREG)
+#define SPICC_TESTREG 0x2367
+#define P_SPICC_TESTREG                 CBUS_REG_ADDR(SPICC_TESTREG)
+#define SPICC_DRADDR 0x2368
+#define P_SPICC_DRADDR          CBUS_REG_ADDR(SPICC_DRADDR)
+#define SPICC_DWADDR 0x2369
+#define P_SPICC_DWADDR          CBUS_REG_ADDR(SPICC_DWADDR)
+#define SD_REG0_ARGU 0x2380
+#define P_SD_REG0_ARGU          CBUS_REG_ADDR(SD_REG0_ARGU)
+#define SD_REG1_SEND 0x2381
+#define P_SD_REG1_SEND          CBUS_REG_ADDR(SD_REG1_SEND)
+#define SD_REG2_CNTL 0x2382
+#define P_SD_REG2_CNTL          CBUS_REG_ADDR(SD_REG2_CNTL)
+#define SD_REG3_STAT 0x2383
+#define P_SD_REG3_STAT          CBUS_REG_ADDR(SD_REG3_STAT)
+#define SD_REG4_CLKC 0x2384
+#define P_SD_REG4_CLKC          CBUS_REG_ADDR(SD_REG4_CLKC)
+#define SD_REG5_ADDR 0x2385
+#define P_SD_REG5_ADDR          CBUS_REG_ADDR(SD_REG5_ADDR)
+#define SD_REG6_PDMA 0x2386
+#define P_SD_REG6_PDMA          CBUS_REG_ADDR(SD_REG6_PDMA)
+#define SD_REG7_MISC 0x2387
+#define P_SD_REG7_MISC          CBUS_REG_ADDR(SD_REG7_MISC)
+#define SD_REG8_DATA 0x2388
+#define P_SD_REG8_DATA          CBUS_REG_ADDR(SD_REG8_DATA)
+#define SD_REG9_ICTL 0x2389
+#define P_SD_REG9_ICTL          CBUS_REG_ADDR(SD_REG9_ICTL)
+#define SD_REGA_ISTA 0x238a
+#define P_SD_REGA_ISTA          CBUS_REG_ADDR(SD_REGA_ISTA)
+#define SD_REGB_SRST 0x238b
+#define P_SD_REGB_SRST          CBUS_REG_ADDR(SD_REGB_SRST)
+#define SD_REGC_ESTA 0x238c
+#define P_SD_REGC_ESTA          CBUS_REG_ADDR(SD_REGC_ESTA)
+#define SD_REGD_ENHC 0x238d
+#define P_SD_REGD_ENHC          CBUS_REG_ADDR(SD_REGD_ENHC)
+#define SD_REGE_CLK2 0x238e
+#define P_SD_REGE_CLK2          CBUS_REG_ADDR(SD_REGE_CLK2)
+#define ISA_DEBUG_REG0 0x2600
+#define P_ISA_DEBUG_REG0                CBUS_REG_ADDR(ISA_DEBUG_REG0)
+#define ISA_DEBUG_REG1 0x2601
+#define P_ISA_DEBUG_REG1                CBUS_REG_ADDR(ISA_DEBUG_REG1)
+#define ISA_DEBUG_REG2 0x2602
+#define P_ISA_DEBUG_REG2                CBUS_REG_ADDR(ISA_DEBUG_REG2)
+#define ISA_DEBUG_REG3 0x2603
+#define P_ISA_DEBUG_REG3                CBUS_REG_ADDR(ISA_DEBUG_REG3)
+#define ISA_PLL_CLK_SIM0 0x2608
+#define P_ISA_PLL_CLK_SIM0              CBUS_REG_ADDR(ISA_PLL_CLK_SIM0)
+#define ISA_CNTL_REG0 0x2609
+#define P_ISA_CNTL_REG0                 CBUS_REG_ADDR(ISA_CNTL_REG0)
+#define AO_CPU_IRQ_IN0_INTR_STAT 0x2610
+#define P_AO_CPU_IRQ_IN0_INTR_STAT      \
+	CBUS_REG_ADDR(AO_CPU_IRQ_IN0_INTR_STAT)
+#define AO_CPU_IRQ_IN0_INTR_STAT_CLR 0x2611
+#define P_AO_CPU_IRQ_IN0_INTR_STAT_CLR  \
+	CBUS_REG_ADDR(AO_CPU_IRQ_IN0_INTR_STAT_CLR)
+#define AO_CPU_IRQ_IN0_INTR_MASK 0x2612
+#define P_AO_CPU_IRQ_IN0_INTR_MASK      \
+	CBUS_REG_ADDR(AO_CPU_IRQ_IN0_INTR_MASK)
+#define AO_CPU_IRQ_IN0_INTR_FIRQ_SEL 0x2613
+#define P_AO_CPU_IRQ_IN0_INTR_FIRQ_SEL  \
+	CBUS_REG_ADDR(AO_CPU_IRQ_IN0_INTR_FIRQ_SEL)
+#define GPIO_INTR_EDGE_POL 0x2620
+#define P_GPIO_INTR_EDGE_POL            CBUS_REG_ADDR(GPIO_INTR_EDGE_POL)
+#define GPIO_INTR_GPIO_SEL0 0x2621
+#define P_GPIO_INTR_GPIO_SEL0           CBUS_REG_ADDR(GPIO_INTR_GPIO_SEL0)
+#define GPIO_INTR_GPIO_SEL1 0x2622
+#define P_GPIO_INTR_GPIO_SEL1           CBUS_REG_ADDR(GPIO_INTR_GPIO_SEL1)
+#define GPIO_INTR_FILTER_SEL0 0x2623
+#define P_GPIO_INTR_FILTER_SEL0         \
+	CBUS_REG_ADDR(GPIO_INTR_FILTER_SEL0)
+#define MEDIA_CPU_INTR_STAT 0x2628
+#define P_MEDIA_CPU_INTR_STAT           CBUS_REG_ADDR(MEDIA_CPU_INTR_STAT)
+#define ISA_BIST_REG1 0x2631
+#define P_ISA_BIST_REG1                 CBUS_REG_ADDR(ISA_BIST_REG1)
+#define WATCHDOG_TC 0x2640
+#define P_WATCHDOG_TC           CBUS_REG_ADDR(WATCHDOG_TC)
+#define WATCHDOG_RESET 0x2641
+#define P_WATCHDOG_RESET                CBUS_REG_ADDR(WATCHDOG_RESET)
+#define AHB_ARBITER_REG 0x2642
+#define P_AHB_ARBITER_REG               CBUS_REG_ADDR(AHB_ARBITER_REG)
+#define AHB_ARBDEC_REG 0x2643
+#define P_AHB_ARBDEC_REG                CBUS_REG_ADDR(AHB_ARBDEC_REG)
+#define AHB_ARBITER2_REG 0x264a
+#define P_AHB_ARBITER2_REG              CBUS_REG_ADDR(AHB_ARBITER2_REG)
+#define DEVICE_MMCP_CNTL 0x264b
+#define P_DEVICE_MMCP_CNTL              CBUS_REG_ADDR(DEVICE_MMCP_CNTL)
+#define AUDIO_MMCP_CNTL 0x264c
+#define P_AUDIO_MMCP_CNTL               CBUS_REG_ADDR(AUDIO_MMCP_CNTL)
+#define ISA_TIMER_MUX 0x2650
+#define P_ISA_TIMER_MUX                 CBUS_REG_ADDR(ISA_TIMER_MUX)
+#define ISA_TIMERA 0x2651
+#define P_ISA_TIMERA            CBUS_REG_ADDR(ISA_TIMERA)
+#define ISA_TIMERB 0x2652
+#define P_ISA_TIMERB            CBUS_REG_ADDR(ISA_TIMERB)
+#define ISA_TIMERC 0x2653
+#define P_ISA_TIMERC            CBUS_REG_ADDR(ISA_TIMERC)
+#define ISA_TIMERD 0x2654
+#define P_ISA_TIMERD            CBUS_REG_ADDR(ISA_TIMERD)
+#define ISA_TIMERE 0x2655
+#define P_ISA_TIMERE            CBUS_REG_ADDR(ISA_TIMERE)
+#define FBUF_ADDR 0x2656
+#define P_FBUF_ADDR             CBUS_REG_ADDR(FBUF_ADDR)
+#define SDRAM_CTL0 0x2657
+#define P_SDRAM_CTL0            CBUS_REG_ADDR(SDRAM_CTL0)
+#define SDRAM_CTL2 0x2658
+#define P_SDRAM_CTL2            CBUS_REG_ADDR(SDRAM_CTL2)
+#define SDRAM_CTL4 0x265a
+#define P_SDRAM_CTL4            CBUS_REG_ADDR(SDRAM_CTL4)
+#define SDRAM_CTL5 0x265b
+#define P_SDRAM_CTL5            CBUS_REG_ADDR(SDRAM_CTL5)
+#define SDRAM_CTL6 0x265c
+#define P_SDRAM_CTL6            CBUS_REG_ADDR(SDRAM_CTL6)
+#define SDRAM_CTL7 0x265d
+#define P_SDRAM_CTL7            CBUS_REG_ADDR(SDRAM_CTL7)
+#define SDRAM_CTL8 0x265e
+#define P_SDRAM_CTL8            CBUS_REG_ADDR(SDRAM_CTL8)
+#define AHB_MP4_MC_CTL 0x265f
+#define P_AHB_MP4_MC_CTL                CBUS_REG_ADDR(AHB_MP4_MC_CTL)
+#define MEDIA_CPU_PCR 0x2660
+#define P_MEDIA_CPU_PCR                 CBUS_REG_ADDR(MEDIA_CPU_PCR)
+#define MEDIA_CPU_CTL 0x2661
+#define P_MEDIA_CPU_CTL                 CBUS_REG_ADDR(MEDIA_CPU_CTL)
+#define ISA_TIMER_MUX1 0x2664
+#define P_ISA_TIMER_MUX1                CBUS_REG_ADDR(ISA_TIMER_MUX1)
+#define ISA_TIMERF 0x2665
+#define P_ISA_TIMERF            CBUS_REG_ADDR(ISA_TIMERF)
+#define ISA_TIMERG 0x2666
+#define P_ISA_TIMERG            CBUS_REG_ADDR(ISA_TIMERG)
+#define ISA_TIMERH 0x2667
+#define P_ISA_TIMERH            CBUS_REG_ADDR(ISA_TIMERH)
+#define ISA_TIMERI 0x2668
+#define P_ISA_TIMERI            CBUS_REG_ADDR(ISA_TIMERI)
+#define ABUF_WR_CTL0 0x2670
+#define P_ABUF_WR_CTL0          CBUS_REG_ADDR(ABUF_WR_CTL0)
+#define ABUF_WR_CTL1 0x2671
+#define P_ABUF_WR_CTL1          CBUS_REG_ADDR(ABUF_WR_CTL1)
+#define ABUF_WR_CTL2 0x2672
+#define P_ABUF_WR_CTL2          CBUS_REG_ADDR(ABUF_WR_CTL2)
+#define ABUF_WR_CTL3 0x2673
+#define P_ABUF_WR_CTL3          CBUS_REG_ADDR(ABUF_WR_CTL3)
+#define ABUF_RD_CTL0 0x2674
+#define P_ABUF_RD_CTL0          CBUS_REG_ADDR(ABUF_RD_CTL0)
+#define ABUF_RD_CTL1 0x2675
+#define P_ABUF_RD_CTL1          CBUS_REG_ADDR(ABUF_RD_CTL1)
+#define ABUF_RD_CTL2 0x2676
+#define P_ABUF_RD_CTL2          CBUS_REG_ADDR(ABUF_RD_CTL2)
+#define ABUF_RD_CTL3 0x2677
+#define P_ABUF_RD_CTL3          CBUS_REG_ADDR(ABUF_RD_CTL3)
+#define ABUF_ARB_CTL0 0x2678
+#define P_ABUF_ARB_CTL0                 CBUS_REG_ADDR(ABUF_ARB_CTL0)
+#define ABUF_FIFO_CTL0 0x2679
+#define P_ABUF_FIFO_CTL0                CBUS_REG_ADDR(ABUF_FIFO_CTL0)
+#define AHB_BRIDGE_CNTL_WR 0x2680
+#define P_AHB_BRIDGE_CNTL_WR            CBUS_REG_ADDR(AHB_BRIDGE_CNTL_WR)
+#define AHB_BRIDGE_REMAP0 0x2681
+#define P_AHB_BRIDGE_REMAP0             CBUS_REG_ADDR(AHB_BRIDGE_REMAP0)
+#define AHB_BRIDGE_REMAP1 0x2682
+#define P_AHB_BRIDGE_REMAP1             CBUS_REG_ADDR(AHB_BRIDGE_REMAP1)
+#define AHB_BRIDGE_REMAP2 0x2683
+#define P_AHB_BRIDGE_REMAP2             CBUS_REG_ADDR(AHB_BRIDGE_REMAP2)
+#define AHB_BRIDGE_REMAP3 0x2684
+#define P_AHB_BRIDGE_REMAP3             CBUS_REG_ADDR(AHB_BRIDGE_REMAP3)
+#define AHB_BRIDGE_CNTL_REG1 0x2685
+#define P_AHB_BRIDGE_CNTL_REG1          CBUS_REG_ADDR(AHB_BRIDGE_CNTL_REG1)
+#define AHB_BRIDGE_CNTL_REG2 0x2686
+#define P_AHB_BRIDGE_CNTL_REG2          CBUS_REG_ADDR(AHB_BRIDGE_CNTL_REG2)
+#define IQ_OM_WIDTH 0x2510
+#define P_IQ_OM_WIDTH           CBUS_REG_ADDR(IQ_OM_WIDTH)
+#define DBG_ADDR_START 0x2ff0
+#define P_DBG_ADDR_START                CBUS_REG_ADDR(DBG_ADDR_START)
+#define DBG_ADDR_END 0x2fff
+#define P_DBG_ADDR_END          CBUS_REG_ADDR(DBG_ADDR_END)
+#define DBG_CTRL 0x2ff1
+#define P_DBG_CTRL              CBUS_REG_ADDR(DBG_CTRL)
+#define DBG_LED 0x2ff2
+#define P_DBG_LED               CBUS_REG_ADDR(DBG_LED)
+#define DBG_SWITCH 0x2ff3
+#define P_DBG_SWITCH            CBUS_REG_ADDR(DBG_SWITCH)
+#define DBG_VERSION 0x2ff4
+#define P_DBG_VERSION           CBUS_REG_ADDR(DBG_VERSION)
+#define VERSION_CTRL 0x1100
+#define P_VERSION_CTRL          CBUS_REG_ADDR(VERSION_CTRL)
+#define RESET0_REGISTER 0x1101
+#define P_RESET0_REGISTER               CBUS_REG_ADDR(RESET0_REGISTER)
+#define RESET1_REGISTER 0x1102
+#define P_RESET1_REGISTER               CBUS_REG_ADDR(RESET1_REGISTER)
+#define RESET2_REGISTER 0x1103
+#define P_RESET2_REGISTER               CBUS_REG_ADDR(RESET2_REGISTER)
+#define RESET3_REGISTER 0x1104
+#define P_RESET3_REGISTER               CBUS_REG_ADDR(RESET3_REGISTER)
+#define RESET4_REGISTER 0x1105
+#define P_RESET4_REGISTER               CBUS_REG_ADDR(RESET4_REGISTER)
+#define RESET5_REGISTER 0x1106
+#define P_RESET5_REGISTER               CBUS_REG_ADDR(RESET5_REGISTER)
+#define RESET6_REGISTER 0x1107
+#define P_RESET6_REGISTER               CBUS_REG_ADDR(RESET6_REGISTER)
+#define RESET7_REGISTER 0x1108
+#define P_RESET7_REGISTER               CBUS_REG_ADDR(RESET7_REGISTER)
+#define RESET0_MASK 0x1110
+#define P_RESET0_MASK           CBUS_REG_ADDR(RESET0_MASK)
+#define RESET1_MASK 0x1111
+#define P_RESET1_MASK           CBUS_REG_ADDR(RESET1_MASK)
+#define RESET2_MASK 0x1112
+#define P_RESET2_MASK           CBUS_REG_ADDR(RESET2_MASK)
+#define RESET3_MASK 0x1113
+#define P_RESET3_MASK           CBUS_REG_ADDR(RESET3_MASK)
+#define RESET4_MASK 0x1114
+#define P_RESET4_MASK           CBUS_REG_ADDR(RESET4_MASK)
+#define RESET5_MASK 0x1115
+#define P_RESET5_MASK           CBUS_REG_ADDR(RESET5_MASK)
+#define RESET6_MASK 0x1116
+#define P_RESET6_MASK           CBUS_REG_ADDR(RESET6_MASK)
+#define CRT_MASK 0x1117
+#define P_CRT_MASK              CBUS_REG_ADDR(CRT_MASK)
+#define RESET7_MASK 0x1118
+#define P_RESET7_MASK           CBUS_REG_ADDR(RESET7_MASK)
+/*add from M8M2*/
+#define RESET0_LEVEL 0xc1104480
+#define RESET1_LEVEL 0x1121
+#define P_RESET1_LEVEL          CBUS_REG_ADDR(RESET1_LEVEL)
+#define RESET2_LEVEL 0x1122
+#define P_RESET2_LEVEL          CBUS_REG_ADDR(RESET2_LEVEL)
+#define RESET3_LEVEL 0x1123
+#define P_RESET3_LEVEL          CBUS_REG_ADDR(RESET3_LEVEL)
+#define RESET4_LEVEL 0x1124
+#define P_RESET4_LEVEL          CBUS_REG_ADDR(RESET4_LEVEL)
+#define RESET5_LEVEL 0x1125
+#define P_RESET5_LEVEL          CBUS_REG_ADDR(RESET5_LEVEL)
+#define RESET6_LEVEL 0x1126
+#define P_RESET6_LEVEL          CBUS_REG_ADDR(RESET6_LEVEL)
+#define RESET7_LEVEL 0x1127
+#define P_RESET7_LEVEL          CBUS_REG_ADDR(RESET7_LEVEL)
+/**/
+#define SCR_HIU 0x100b
+#define P_SCR_HIU               CBUS_REG_ADDR(SCR_HIU)
+#define HPG_TIMER 0x100f
+#define P_HPG_TIMER             CBUS_REG_ADDR(HPG_TIMER)
+/*add from M8M2*/
+#define HHI_GP_PLL_CNTL 0x1010
+#define P_HHI_GP_PLL_CNTL               CBUS_REG_ADDR(HHI_GP_PLL_CNTL)
+#define HHI_GP_PLL_CNTL2 0x1011
+#define P_HHI_GP_PLL_CNTL2              CBUS_REG_ADDR(HHI_GP_PLL_CNTL2)
+#define HHI_GP_PLL_CNTL3 0x1012
+#define P_HHI_GP_PLL_CNTL3              CBUS_REG_ADDR(HHI_GP_PLL_CNTL3)
+#define HHI_GP_PLL_CNTL4 0x1013
+#define P_HHI_GP_PLL_CNTL4              CBUS_REG_ADDR(HHI_GP_PLL_CNTL4)
+#define HHI_GP_PLL_CNTL5 0x1014
+#define P_HHI_GP_PLL_CNTL5              CBUS_REG_ADDR(HHI_GP_PLL_CNTL5)
+/**/
+
+#define HHI_DADC_CNTL				0x1027
+#define P_HHI_DADC_CNTL             CBUS_REG_ADDR(HHI_DADC_CNTL)
+#define HHI_DADC_CNTL2				0x1028
+#define P_HHI_DADC_CNTL2             CBUS_REG_ADDR(HHI_DADC_CNTL2)
+#define HHI_DADC_RDBK0_I			0x1029
+#define P_HHI_DADC_RDBK0_I             CBUS_REG_ADDR(HHI_DADC_RDBK0_I)
+#define HHI_DADC_CNTL3				0x102a
+#define P_HHI_DADC_CNTL3             CBUS_REG_ADDR(HHI_DADC_CNTL3)
+#define HHI_DADC_CNTL4				0x102b
+#define P_HHI_DADC_CNTL4             CBUS_REG_ADDR(HHI_DADC_CNTL4)
+
+
+#define HARM_ASB_MB0 0x1030
+#define P_HARM_ASB_MB0          CBUS_REG_ADDR(HARM_ASB_MB0)
+#define HARM_ASB_MB1 0x1031
+#define P_HARM_ASB_MB1          CBUS_REG_ADDR(HARM_ASB_MB1)
+#define HARM_ASB_MB2 0x1032
+#define P_HARM_ASB_MB2          CBUS_REG_ADDR(HARM_ASB_MB2)
+#define HARM_ASB_MB3 0x1033
+#define P_HARM_ASB_MB3          CBUS_REG_ADDR(HARM_ASB_MB3)
+#define HASB_ARM_MB0 0x1034
+#define P_HASB_ARM_MB0          CBUS_REG_ADDR(HASB_ARM_MB0)
+#define HASB_ARM_MB1 0x1035
+#define P_HASB_ARM_MB1          CBUS_REG_ADDR(HASB_ARM_MB1)
+#define HASB_ARM_MB2 0x1036
+#define P_HASB_ARM_MB2          CBUS_REG_ADDR(HASB_ARM_MB2)
+#define HASB_ARM_MB3 0x1037
+#define P_HASB_ARM_MB3          CBUS_REG_ADDR(HASB_ARM_MB3)
+#define HHI_TIMER90K 0x103b
+#define P_HHI_TIMER90K          CBUS_REG_ADDR(HHI_TIMER90K)
+#define HHI_MEM_PD_REG0 0x1040
+#define P_HHI_MEM_PD_REG0               CBUS_REG_ADDR(HHI_MEM_PD_REG0)
+#define HHI_VPU_MEM_PD_REG0 0x1041
+#define P_HHI_VPU_MEM_PD_REG0           CBUS_REG_ADDR(HHI_VPU_MEM_PD_REG0)
+#define HHI_VPU_MEM_PD_REG1 0x1042
+#define P_HHI_VPU_MEM_PD_REG1           CBUS_REG_ADDR(HHI_VPU_MEM_PD_REG1)
+#define HHI_AUD_DAC_CTRL 0x1044
+#define P_HHI_AUD_DAC_CTRL              CBUS_REG_ADDR(HHI_AUD_DAC_CTRL)
+#define HHI_VIID_CLK_DIV 0x104a
+#define P_HHI_VIID_CLK_DIV              CBUS_REG_ADDR(HHI_VIID_CLK_DIV)
+#define HHI_VIID_CLK_CNTL 0x104b
+#define P_HHI_VIID_CLK_CNTL             CBUS_REG_ADDR(HHI_VIID_CLK_CNTL)
+#define HHI_VIID_DIVIDER_CNTL 0x104c
+#define P_HHI_VIID_DIVIDER_CNTL         \
+	CBUS_REG_ADDR(HHI_VIID_DIVIDER_CNTL)
+#define HHI_GCLK_MPEG0 0x1050
+#define P_HHI_GCLK_MPEG0                CBUS_REG_ADDR(HHI_GCLK_MPEG0)
+#define HHI_GCLK_MPEG1 0x1051
+#define P_HHI_GCLK_MPEG1                CBUS_REG_ADDR(HHI_GCLK_MPEG1)
+#define HHI_GCLK_MPEG2 0x1052
+#define P_HHI_GCLK_MPEG2                CBUS_REG_ADDR(HHI_GCLK_MPEG2)
+#define HHI_GCLK_OTHER 0x1054
+#define P_HHI_GCLK_OTHER                CBUS_REG_ADDR(HHI_GCLK_OTHER)
+#define HHI_GCLK_AO 0x1055
+#define P_HHI_GCLK_AO           CBUS_REG_ADDR(HHI_GCLK_AO)
+#define HHI_SYS_CPU_CLK_CNTL1 0x1057
+#define P_HHI_SYS_CPU_CLK_CNTL1         \
+	CBUS_REG_ADDR(HHI_SYS_CPU_CLK_CNTL1)
+#define HHI_VID_CLK_DIV 0x1059
+#define P_HHI_VID_CLK_DIV               CBUS_REG_ADDR(HHI_VID_CLK_DIV)
+#define HHI_MPEG_CLK_CNTL 0x105d
+#define P_HHI_MPEG_CLK_CNTL             CBUS_REG_ADDR(HHI_MPEG_CLK_CNTL)
+#define HHI_AUD_CLK_CNTL 0x105e
+#define P_HHI_AUD_CLK_CNTL              CBUS_REG_ADDR(HHI_AUD_CLK_CNTL)
+#define HHI_VID_CLK_CNTL 0x105f
+#define P_HHI_VID_CLK_CNTL              CBUS_REG_ADDR(HHI_VID_CLK_CNTL)
+#define HHI_WIFI_CLK_CNTL 0x1060
+#define P_HHI_WIFI_CLK_CNTL             CBUS_REG_ADDR(HHI_WIFI_CLK_CNTL)
+#define HHI_WIFI_PLL_CNTL 0x1061
+#define P_HHI_WIFI_PLL_CNTL             CBUS_REG_ADDR(HHI_WIFI_PLL_CNTL)
+#define HHI_WIFI_PLL_CNTL2 0x1062
+#define P_HHI_WIFI_PLL_CNTL2            CBUS_REG_ADDR(HHI_WIFI_PLL_CNTL2)
+#define HHI_WIFI_PLL_CNTL3 0x1063
+#define P_HHI_WIFI_PLL_CNTL3            CBUS_REG_ADDR(HHI_WIFI_PLL_CNTL3)
+#define HHI_AUD_CLK_CNTL2 0x1064
+#define P_HHI_AUD_CLK_CNTL2             CBUS_REG_ADDR(HHI_AUD_CLK_CNTL2)
+/*add from M8m2*/
+#define HHI_VID_CLK_CNTL2 0x1065
+#define P_HHI_VID_CLK_CNTL2             CBUS_REG_ADDR(HHI_VID_CLK_CNTL2)
+/**/
+#define HHI_VID_DIVIDER_CNTL 0x1066
+#define P_HHI_VID_DIVIDER_CNTL          CBUS_REG_ADDR(HHI_VID_DIVIDER_CNTL)
+#define HHI_SYS_CPU_CLK_CNTL 0x1067
+#define P_HHI_SYS_CPU_CLK_CNTL          CBUS_REG_ADDR(HHI_SYS_CPU_CLK_CNTL)
+#define HHI_MALI_CLK_CNTL 0x106c
+#define P_HHI_MALI_CLK_CNTL             CBUS_REG_ADDR(HHI_MALI_CLK_CNTL)
+#define HHI_MIPI_PHY_CLK_CNTL 0x106e
+#define P_HHI_MIPI_PHY_CLK_CNTL         \
+	CBUS_REG_ADDR(HHI_MIPI_PHY_CLK_CNTL)
+#define HHI_VPU_CLK_CNTL 0x106f
+#define P_HHI_VPU_CLK_CNTL              CBUS_REG_ADDR(HHI_VPU_CLK_CNTL)
+#define HHI_OTHER_PLL_CNTL 0x1070
+#define P_HHI_OTHER_PLL_CNTL            CBUS_REG_ADDR(HHI_OTHER_PLL_CNTL)
+#define HHI_OTHER_PLL_CNTL2 0x1071
+#define P_HHI_OTHER_PLL_CNTL2           CBUS_REG_ADDR(HHI_OTHER_PLL_CNTL2)
+#define HHI_OTHER_PLL_CNTL3 0x1072
+#define P_HHI_OTHER_PLL_CNTL3           CBUS_REG_ADDR(HHI_OTHER_PLL_CNTL3)
+#define HHI_HDMI_CLK_CNTL 0x1073
+#define P_HHI_HDMI_CLK_CNTL             CBUS_REG_ADDR(HHI_HDMI_CLK_CNTL)
+#define HHI_DEMOD_CLK_CNTL 0x1074
+#define P_HHI_DEMOD_CLK_CNTL            CBUS_REG_ADDR(HHI_DEMOD_CLK_CNTL)
+#define HHI_SATA_CLK_CNTL 0x1075
+#define P_HHI_SATA_CLK_CNTL             CBUS_REG_ADDR(HHI_SATA_CLK_CNTL)
+#define HHI_ETH_CLK_CNTL 0x1076
+#define P_HHI_ETH_CLK_CNTL              CBUS_REG_ADDR(HHI_ETH_CLK_CNTL)
+#define HHI_CLK_DOUBLE_CNTL 0x1077
+#define P_HHI_CLK_DOUBLE_CNTL           CBUS_REG_ADDR(HHI_CLK_DOUBLE_CNTL)
+#define HHI_VDEC_CLK_CNTL 0x1078
+#define P_HHI_VDEC_CLK_CNTL             CBUS_REG_ADDR(HHI_VDEC_CLK_CNTL)
+#define HHI_VDEC2_CLK_CNTL 0x1079
+#define P_HHI_VDEC2_CLK_CNTL            CBUS_REG_ADDR(HHI_VDEC2_CLK_CNTL)
+/*add from M8M2*/
+#define HHI_VDEC3_CLK_CNTL 0x107a
+#define P_HHI_VDEC3_CLK_CNTL            CBUS_REG_ADDR(HHI_VDEC3_CLK_CNTL)
+#define HHI_VDEC4_CLK_CNTL 0x107b
+#define P_HHI_VDEC4_CLK_CNTL            CBUS_REG_ADDR(HHI_VDEC4_CLK_CNTL)
+/**/
+#define HHI_HDMI_PLL_CNTL 0x107c
+#define P_HHI_HDMI_PLL_CNTL             CBUS_REG_ADDR(HHI_HDMI_PLL_CNTL)
+#define HHI_HDMI_PLL_CNTL1 0x107d
+#define P_HHI_HDMI_PLL_CNTL1            CBUS_REG_ADDR(HHI_HDMI_PLL_CNTL1)
+#define HHI_HDMI_PLL_CNTL2 0x107e
+#define P_HHI_HDMI_PLL_CNTL2            CBUS_REG_ADDR(HHI_HDMI_PLL_CNTL2)
+#define HHI_HDMI_AFC_CNTL 0x107f
+#define P_HHI_HDMI_AFC_CNTL             CBUS_REG_ADDR(HHI_HDMI_AFC_CNTL)
+#define HHI_HDMIRX_CLK_CNTL 0x1080
+#define P_HHI_HDMIRX_CLK_CNTL           CBUS_REG_ADDR(HHI_HDMIRX_CLK_CNTL)
+#define HHI_HDMIRX_AUD_CLK_CNTL 0x1081
+#define P_HHI_HDMIRX_AUD_CLK_CNTL       \
+	CBUS_REG_ADDR(HHI_HDMIRX_AUD_CLK_CNTL)
+/*M8 M8M2 diff*/
+#define HHI_EDP_APB_CLK_CNTL_M8M2 0x1082
+#define HHI_EDP_APB_CLK_CNTL 0x107b
+#define P_HHI_EDP_APB_CLK_CNTL          CBUS_REG_ADDR(HHI_EDP_APB_CLK_CNTL)
+#define P_HHI_EDP_APB_CLK_CNTL_M8M2     \
+	CBUS_REG_ADDR(HHI_EDP_APB_CLK_CNTL_M8M2)
+/**/
+#define HHI_VID_PLL_MOD_CNTL0 0x1084
+#define P_HHI_VID_PLL_MOD_CNTL0         \
+	CBUS_REG_ADDR(HHI_VID_PLL_MOD_CNTL0)
+#define HHI_VID_PLL_MOD_LOW_TCNT 0x1085
+#define P_HHI_VID_PLL_MOD_LOW_TCNT      \
+	CBUS_REG_ADDR(HHI_VID_PLL_MOD_LOW_TCNT)
+#define HHI_VID_PLL_MOD_HIGH_TCNT 0x1086
+#define P_HHI_VID_PLL_MOD_HIGH_TCNT     \
+	CBUS_REG_ADDR(HHI_VID_PLL_MOD_HIGH_TCNT)
+#define HHI_VID_PLL_MOD_NOM_TCNT 0x1087
+#define P_HHI_VID_PLL_MOD_NOM_TCNT      \
+	CBUS_REG_ADDR(HHI_VID_PLL_MOD_NOM_TCNT)
+#define HHI_USB_CLK_CNTL 0x1089
+#define P_HHI_USB_CLK_CNTL              CBUS_REG_ADDR(HHI_USB_CLK_CNTL)
+#define HHI_GEN_CLK_CNTL 0x108a
+#define P_HHI_GEN_CLK_CNTL              CBUS_REG_ADDR(HHI_GEN_CLK_CNTL)
+#define HHI_GEN_CLK_CNTL2 0x108b
+#define P_HHI_GEN_CLK_CNTL2             CBUS_REG_ADDR(HHI_GEN_CLK_CNTL2)
+#define HHI_JTAG_CONFIG 0x108e
+#define P_HHI_JTAG_CONFIG               CBUS_REG_ADDR(HHI_JTAG_CONFIG)
+#define HHI_VAFE_CLKXTALIN_CNTL 0x108f
+#define P_HHI_VAFE_CLKXTALIN_CNTL       \
+	CBUS_REG_ADDR(HHI_VAFE_CLKXTALIN_CNTL)
+#define HHI_VAFE_CLKOSCIN_CNTL 0x1090
+#define P_HHI_VAFE_CLKOSCIN_CNTL        \
+	CBUS_REG_ADDR(HHI_VAFE_CLKOSCIN_CNTL)
+#define HHI_VAFE_CLKIN_CNTL 0x1091
+#define P_HHI_VAFE_CLKIN_CNTL           CBUS_REG_ADDR(HHI_VAFE_CLKIN_CNTL)
+#define HHI_TVFE_AUTOMODE_CLK_CNTL 0x1092
+#define P_HHI_TVFE_AUTOMODE_CLK_CNTL            \
+	CBUS_REG_ADDR(HHI_TVFE_AUTOMODE_CLK_CNTL)
+#define HHI_VAFE_CLKPI_CNTL 0x1093
+#define P_HHI_VAFE_CLKPI_CNTL           CBUS_REG_ADDR(HHI_VAFE_CLKPI_CNTL)
+#define HHI_VDIN_MEAS_CLK_CNTL 0x1094
+#define HHI_PCM2_CLK_CNTL 0x1095
+#define P_HHI_PCM2_CLK_CNTL             CBUS_REG_ADDR(HHI_PCM2_CLK_CNTL)
+#define HHI_PCM_CLK_CNTL 0x1096
+#define P_HHI_PCM_CLK_CNTL              CBUS_REG_ADDR(HHI_PCM_CLK_CNTL)
+#define HHI_NAND_CLK_CNTL 0x1097
+#define P_HHI_NAND_CLK_CNTL             CBUS_REG_ADDR(HHI_NAND_CLK_CNTL)
+#define HHI_ISP_LED_CLK_CNTL 0x1098
+#define P_HHI_ISP_LED_CLK_CNTL          CBUS_REG_ADDR(HHI_ISP_LED_CLK_CNTL)
+#define HHI_EDP_TX_PHY_CNTL0 0x109c
+#define P_HHI_EDP_TX_PHY_CNTL0          CBUS_REG_ADDR(HHI_EDP_TX_PHY_CNTL0)
+#define HHI_EDP_TX_PHY_CNTL1 0x109d
+#define P_HHI_EDP_TX_PHY_CNTL1          CBUS_REG_ADDR(HHI_EDP_TX_PHY_CNTL1)
+#define HHI_MPLL_CNTL 0x10a0
+#define P_HHI_MPLL_CNTL                 CBUS_REG_ADDR(HHI_MPLL_CNTL)
+#define HHI_MPLL_CNTL2 0x10a1
+#define P_HHI_MPLL_CNTL2                CBUS_REG_ADDR(HHI_MPLL_CNTL2)
+#define HHI_MPLL_CNTL3 0x10a2
+#define P_HHI_MPLL_CNTL3                CBUS_REG_ADDR(HHI_MPLL_CNTL3)
+#define HHI_MPLL_CNTL4 0x10a3
+#define P_HHI_MPLL_CNTL4                CBUS_REG_ADDR(HHI_MPLL_CNTL4)
+#define HHI_MPLL_CNTL5 0x10a4
+#define P_HHI_MPLL_CNTL5                CBUS_REG_ADDR(HHI_MPLL_CNTL5)
+#define HHI_MPLL_CNTL6 0x10a5
+#define P_HHI_MPLL_CNTL6                CBUS_REG_ADDR(HHI_MPLL_CNTL6)
+#define HHI_MPLL_CNTL7 0x10a6
+#define P_HHI_MPLL_CNTL7                CBUS_REG_ADDR(HHI_MPLL_CNTL7)
+#define HHI_MPLL_CNTL8 0x10a7
+#define P_HHI_MPLL_CNTL8                CBUS_REG_ADDR(HHI_MPLL_CNTL8)
+#define HHI_MPLL_CNTL9 0x10a8
+#define P_HHI_MPLL_CNTL9                CBUS_REG_ADDR(HHI_MPLL_CNTL9)
+#define HHI_MPLL_CNTL10 0x10a9
+#define P_HHI_MPLL_CNTL10               CBUS_REG_ADDR(HHI_MPLL_CNTL10)
+
+
+#define HHI_ADC_PLL_CNTL			0x10aa
+#define P_HHI_ADC_PLL_CNTL			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL)
+#define HHI_ADC_PLL_CNTL2			0x10ab
+#define P_HHI_ADC_PLL_CNTL2			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL2)
+#define HHI_ADC_PLL_CNTL3			0x10ac
+#define P_HHI_ADC_PLL_CNTL3			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL3)
+#define HHI_ADC_PLL_CNTL4			0x10ad
+#define P_HHI_ADC_PLL_CNTL4			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL4)
+#define HHI_ADC_PLL_CNTL5			0x109e
+#define P_HHI_ADC_PLL_CNTL5			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL5)
+#define HHI_ADC_PLL_CNTL6			0x109f
+#define P_HHI_ADC_PLL_CNTL6			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL6)
+#define HHI_ADC_PLL_CNTL1			0x10af
+#define P_HHI_ADC_PLL_CNTL1			CBUS_REG_ADDR(HHI_ADC_PLL_CNTL1)
+
+
+#define HHI_AUDCLK_PLL_CNTL 0x10b0
+#define P_HHI_AUDCLK_PLL_CNTL           CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL)
+#define HHI_AUDCLK_PLL_CNTL2 0x10b1
+#define P_HHI_AUDCLK_PLL_CNTL2          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL2)
+#define HHI_AUDCLK_PLL_CNTL3 0x10b2
+#define P_HHI_AUDCLK_PLL_CNTL3          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL3)
+#define HHI_AUDCLK_PLL_CNTL4 0x10b3
+#define P_HHI_AUDCLK_PLL_CNTL4          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL4)
+#define HHI_AUDCLK_PLL_CNTL5 0x10b4
+#define P_HHI_AUDCLK_PLL_CNTL5          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL5)
+#define HHI_AUDCLK_PLL_CNTL6 0x10b5
+#define P_HHI_AUDCLK_PLL_CNTL6          CBUS_REG_ADDR(HHI_AUDCLK_PLL_CNTL6)
+#define HHI_L2_DDR_CLK_CNTL 0x10b6
+#define P_HHI_L2_DDR_CLK_CNTL           CBUS_REG_ADDR(HHI_L2_DDR_CLK_CNTL)
+#define HHI_VDAC_CNTL0 0x10bd
+#define P_HHI_VDAC_CNTL0                CBUS_REG_ADDR(HHI_VDAC_CNTL0)
+#define HHI_VDAC_CNTL1 0x10be
+#define P_HHI_VDAC_CNTL1                CBUS_REG_ADDR(HHI_VDAC_CNTL1)
+#define HHI_SYS_PLL_CNTL 0x10c0
+#define P_HHI_SYS_PLL_CNTL              CBUS_REG_ADDR(HHI_SYS_PLL_CNTL)
+#define HHI_SYS_PLL_CNTL2 0x10c1
+#define P_HHI_SYS_PLL_CNTL2             CBUS_REG_ADDR(HHI_SYS_PLL_CNTL2)
+#define HHI_SYS_PLL_CNTL3 0x10c2
+#define P_HHI_SYS_PLL_CNTL3             CBUS_REG_ADDR(HHI_SYS_PLL_CNTL3)
+#define HHI_SYS_PLL_CNTL4 0x10c3
+#define P_HHI_SYS_PLL_CNTL4             CBUS_REG_ADDR(HHI_SYS_PLL_CNTL4)
+#define HHI_SYS_PLL_CNTL5 0x10c4
+#define P_HHI_SYS_PLL_CNTL5             CBUS_REG_ADDR(HHI_SYS_PLL_CNTL5)
+#define HHI_DPLL_TOP_0 0x10c6
+#define P_HHI_DPLL_TOP_0                CBUS_REG_ADDR(HHI_DPLL_TOP_0)
+#define HHI_DPLL_TOP_1 0x10c7
+#define P_HHI_DPLL_TOP_1                CBUS_REG_ADDR(HHI_DPLL_TOP_1)
+#define HHI_VID_PLL_CNTL 0x10c8
+#define P_HHI_VID_PLL_CNTL              CBUS_REG_ADDR(HHI_VID_PLL_CNTL)
+#define HHI_VID_PLL_CNTL2 0x10c9
+#define P_HHI_VID_PLL_CNTL2             CBUS_REG_ADDR(HHI_VID_PLL_CNTL2)
+#define HHI_VID_PLL_CNTL3 0x10ca
+#define P_HHI_VID_PLL_CNTL3             CBUS_REG_ADDR(HHI_VID_PLL_CNTL3)
+#define HHI_VID_PLL_CNTL4 0x10cb
+#define P_HHI_VID_PLL_CNTL4             CBUS_REG_ADDR(HHI_VID_PLL_CNTL4)
+#define HHI_VID_PLL_CNTL5 0x10cc
+#define P_HHI_VID_PLL_CNTL5             CBUS_REG_ADDR(HHI_VID_PLL_CNTL5)
+#define HHI_VID_PLL_CNTL6 0x10cd
+#define P_HHI_VID_PLL_CNTL6             CBUS_REG_ADDR(HHI_VID_PLL_CNTL6)
+#define HHI_CSI_PHY_CNTL0 0x10d3
+#define P_HHI_CSI_PHY_CNTL0             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL0)
+#define HHI_CSI_PHY_CNTL1 0x10d4
+#define P_HHI_CSI_PHY_CNTL1             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL1)
+#define HHI_CSI_PHY_CNTL2 0x10d5
+#define P_HHI_CSI_PHY_CNTL2             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL2)
+#define HHI_CSI_PHY_CNTL3 0x10d6
+#define P_HHI_CSI_PHY_CNTL3             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL3)
+#define HHI_CSI_PHY_CNTL4 0x10d7
+#define P_HHI_CSI_PHY_CNTL4             CBUS_REG_ADDR(HHI_CSI_PHY_CNTL4)
+#define HHI_DIF_CSI_PHY_CNTL0 0x10d8
+#define P_HHI_DIF_CSI_PHY_CNTL0         \
+	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL0)
+#define HHI_DIF_CSI_PHY_CNTL1 0x10d9
+#define P_HHI_DIF_CSI_PHY_CNTL1         \
+	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL1)
+#define HHI_DIF_CSI_PHY_CNTL2 0x10da
+#define P_HHI_DIF_CSI_PHY_CNTL2         \
+	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL2)
+#define HHI_DIF_CSI_PHY_CNTL3 0x10db
+#define P_HHI_DIF_CSI_PHY_CNTL3         \
+	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL3)
+#define HHI_DIF_CSI_PHY_CNTL4 0x10dc
+#define P_HHI_DIF_CSI_PHY_CNTL4         \
+	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL4)
+#define HHI_DIF_CSI_PHY_CNTL5 0x10dd
+#define P_HHI_DIF_CSI_PHY_CNTL5         \
+	CBUS_REG_ADDR(HHI_DIF_CSI_PHY_CNTL5)
+#define HHI_LVDS_TX_PHY_CNTL0 0x10de
+#define P_HHI_LVDS_TX_PHY_CNTL0         \
+	CBUS_REG_ADDR(HHI_LVDS_TX_PHY_CNTL0)
+#define HHI_LVDS_TX_PHY_CNTL1 0x10df
+#define P_HHI_LVDS_TX_PHY_CNTL1         \
+	CBUS_REG_ADDR(HHI_LVDS_TX_PHY_CNTL1)
+#define HHI_VID2_PLL_CNTL 0x10e0
+#define P_HHI_VID2_PLL_CNTL             CBUS_REG_ADDR(HHI_VID2_PLL_CNTL)
+#define HHI_VID2_PLL_CNTL2 0x10e1
+#define P_HHI_VID2_PLL_CNTL2            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL2)
+#define HHI_VID2_PLL_CNTL3 0x10e2
+#define P_HHI_VID2_PLL_CNTL3            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL3)
+#define HHI_VID2_PLL_CNTL4 0x10e3
+#define P_HHI_VID2_PLL_CNTL4            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL4)
+#define HHI_VID2_PLL_CNTL5 0x10e4
+#define P_HHI_VID2_PLL_CNTL5            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL5)
+#define HHI_VID2_PLL_CNTL6 0x10e5
+#define P_HHI_VID2_PLL_CNTL6            CBUS_REG_ADDR(HHI_VID2_PLL_CNTL6)
+#define HHI_HDMI_PHY_CNTL0 0x10e8
+#define P_HHI_HDMI_PHY_CNTL0            CBUS_REG_ADDR(HHI_HDMI_PHY_CNTL0)
+#define HHI_HDMI_PHY_CNTL1 0x10e9
+#define P_HHI_HDMI_PHY_CNTL1            CBUS_REG_ADDR(HHI_HDMI_PHY_CNTL1)
+#define HHI_HDMI_PHY_CNTL2 0x10ea
+#define P_HHI_HDMI_PHY_CNTL2            CBUS_REG_ADDR(HHI_HDMI_PHY_CNTL2)
+#define PARSER_CONTROL 0x2960
+#define P_PARSER_CONTROL                CBUS_REG_ADDR(PARSER_CONTROL)
+#define PARSER_FETCH_ADDR 0x2961
+#define P_PARSER_FETCH_ADDR             CBUS_REG_ADDR(PARSER_FETCH_ADDR)
+#define PARSER_FETCH_CMD 0x2962
+#define P_PARSER_FETCH_CMD              CBUS_REG_ADDR(PARSER_FETCH_CMD)
+#define PARSER_FETCH_LEVEL 0x2964
+#define P_PARSER_FETCH_LEVEL            CBUS_REG_ADDR(PARSER_FETCH_LEVEL)
+#define PARSER_CONFIG 0x2965
+#define P_PARSER_CONFIG                 CBUS_REG_ADDR(PARSER_CONFIG)
+#define PFIFO_WR_PTR 0x2966
+#define P_PFIFO_WR_PTR          CBUS_REG_ADDR(PFIFO_WR_PTR)
+#define PFIFO_RD_PTR 0x2967
+#define P_PFIFO_RD_PTR          CBUS_REG_ADDR(PFIFO_RD_PTR)
+#define PFIFO_DATA 0x2968
+#define P_PFIFO_DATA            CBUS_REG_ADDR(PFIFO_DATA)
+#define PARSER_SEARCH_PATTERN 0x2969
+#define P_PARSER_SEARCH_PATTERN         \
+	CBUS_REG_ADDR(PARSER_SEARCH_PATTERN)
+#define PARSER_SEARCH_MASK 0x296a
+#define P_PARSER_SEARCH_MASK            CBUS_REG_ADDR(PARSER_SEARCH_MASK)
+#define PARSER_INT_ENABLE 0x296b
+#define P_PARSER_INT_ENABLE             CBUS_REG_ADDR(PARSER_INT_ENABLE)
+#define PARSER_INT_STATUS 0x296c
+#define P_PARSER_INT_STATUS             CBUS_REG_ADDR(PARSER_INT_STATUS)
+#define PARSER_SCR_CTL 0x296d
+#define P_PARSER_SCR_CTL                CBUS_REG_ADDR(PARSER_SCR_CTL)
+#define PARSER_SCR 0x296e
+#define P_PARSER_SCR            CBUS_REG_ADDR(PARSER_SCR)
+#define PARSER_PARAMETER 0x296f
+#define P_PARSER_PARAMETER              CBUS_REG_ADDR(PARSER_PARAMETER)
+#define PARSER_INSERT_DATA 0x2970
+#define P_PARSER_INSERT_DATA            CBUS_REG_ADDR(PARSER_INSERT_DATA)
+#define VAS_STREAM_ID 0x2971
+#define P_VAS_STREAM_ID                 CBUS_REG_ADDR(VAS_STREAM_ID)
+#define VIDEO_DTS 0x2972
+#define P_VIDEO_DTS             CBUS_REG_ADDR(VIDEO_DTS)
+#define VIDEO_PTS 0x2973
+#define P_VIDEO_PTS             CBUS_REG_ADDR(VIDEO_PTS)
+#define VIDEO_PTS_DTS_WR_PTR 0x2974
+#define P_VIDEO_PTS_DTS_WR_PTR          CBUS_REG_ADDR(VIDEO_PTS_DTS_WR_PTR)
+#define AUDIO_PTS 0x2975
+#define P_AUDIO_PTS             CBUS_REG_ADDR(AUDIO_PTS)
+#define AUDIO_PTS_WR_PTR 0x2976
+#define P_AUDIO_PTS_WR_PTR              CBUS_REG_ADDR(AUDIO_PTS_WR_PTR)
+#define PARSER_ES_CONTROL 0x2977
+#define P_PARSER_ES_CONTROL             CBUS_REG_ADDR(PARSER_ES_CONTROL)
+#define PFIFO_MONITOR 0x2978
+#define P_PFIFO_MONITOR                 CBUS_REG_ADDR(PFIFO_MONITOR)
+#define PARSER_VIDEO_START_PTR 0x2980
+#define P_PARSER_VIDEO_START_PTR        \
+	CBUS_REG_ADDR(PARSER_VIDEO_START_PTR)
+#define PARSER_VIDEO_END_PTR 0x2981
+#define P_PARSER_VIDEO_END_PTR          CBUS_REG_ADDR(PARSER_VIDEO_END_PTR)
+#define PARSER_VIDEO_WP 0x2982
+#define P_PARSER_VIDEO_WP               CBUS_REG_ADDR(PARSER_VIDEO_WP)
+#define PARSER_VIDEO_RP 0x2983
+#define P_PARSER_VIDEO_RP               CBUS_REG_ADDR(PARSER_VIDEO_RP)
+#define PARSER_VIDEO_HOLE 0x2984
+#define P_PARSER_VIDEO_HOLE             CBUS_REG_ADDR(PARSER_VIDEO_HOLE)
+#define PARSER_AUDIO_START_PTR 0x2985
+#define P_PARSER_AUDIO_START_PTR        \
+	CBUS_REG_ADDR(PARSER_AUDIO_START_PTR)
+#define PARSER_AUDIO_END_PTR 0x2986
+#define P_PARSER_AUDIO_END_PTR          CBUS_REG_ADDR(PARSER_AUDIO_END_PTR)
+#define PARSER_AUDIO_WP 0x2987
+#define P_PARSER_AUDIO_WP               CBUS_REG_ADDR(PARSER_AUDIO_WP)
+#define PARSER_AUDIO_RP 0x2988
+#define P_PARSER_AUDIO_RP               CBUS_REG_ADDR(PARSER_AUDIO_RP)
+#define PARSER_AUDIO_HOLE 0x2989
+#define P_PARSER_AUDIO_HOLE             CBUS_REG_ADDR(PARSER_AUDIO_HOLE)
+#define PARSER_SUB_START_PTR 0x298a
+#define P_PARSER_SUB_START_PTR          CBUS_REG_ADDR(PARSER_SUB_START_PTR)
+#define PARSER_SUB_END_PTR 0x298b
+#define P_PARSER_SUB_END_PTR            CBUS_REG_ADDR(PARSER_SUB_END_PTR)
+#define PARSER_SUB_WP 0x298c
+#define P_PARSER_SUB_WP                 CBUS_REG_ADDR(PARSER_SUB_WP)
+#define PARSER_SUB_RP 0x298d
+#define P_PARSER_SUB_RP                 CBUS_REG_ADDR(PARSER_SUB_RP)
+#define PARSER_SUB_HOLE 0x298e
+#define P_PARSER_SUB_HOLE               CBUS_REG_ADDR(PARSER_SUB_HOLE)
+#define PARSER_FETCH_INFO 0x298f
+#define P_PARSER_FETCH_INFO             CBUS_REG_ADDR(PARSER_FETCH_INFO)
+#define PARSER_STATUS 0x2990
+#define P_PARSER_STATUS                 CBUS_REG_ADDR(PARSER_STATUS)
+#define PARSER_AV_WRAP_COUNT 0x2991
+#define P_PARSER_AV_WRAP_COUNT          CBUS_REG_ADDR(PARSER_AV_WRAP_COUNT)
+#define WRRSP_PARSER 0x2992
+#define P_WRRSP_PARSER          CBUS_REG_ADDR(WRRSP_PARSER)
+#define PARSER_VIDEO2_START_PTR 0x2993
+#define P_PARSER_VIDEO2_START_PTR       \
+	CBUS_REG_ADDR(PARSER_VIDEO2_START_PTR)
+#define PARSER_VIDEO2_END_PTR 0x2994
+#define P_PARSER_VIDEO2_END_PTR         \
+	CBUS_REG_ADDR(PARSER_VIDEO2_END_PTR)
+#define PARSER_VIDEO2_WP 0x2995
+#define P_PARSER_VIDEO2_WP              CBUS_REG_ADDR(PARSER_VIDEO2_WP)
+#define PARSER_VIDEO2_RP 0x2996
+#define P_PARSER_VIDEO2_RP              CBUS_REG_ADDR(PARSER_VIDEO2_RP)
+#define PARSER_VIDEO2_HOLE 0x2997
+#define P_PARSER_VIDEO2_HOLE            CBUS_REG_ADDR(PARSER_VIDEO2_HOLE)
+#define PARSER_AV2_WRAP_COUNT 0x2998
+#define P_PARSER_AV2_WRAP_COUNT         \
+	CBUS_REG_ADDR(PARSER_AV2_WRAP_COUNT)
+#define DVIN_FRONT_END_CTRL 0x12e0
+#define P_DVIN_FRONT_END_CTRL           CBUS_REG_ADDR(DVIN_FRONT_END_CTRL)
+#define DVIN_HS_LEAD_VS_ODD 0x12e1
+#define P_DVIN_HS_LEAD_VS_ODD           CBUS_REG_ADDR(DVIN_HS_LEAD_VS_ODD)
+#define DVIN_ACTIVE_START_PIX 0x12e2
+#define P_DVIN_ACTIVE_START_PIX         \
+	CBUS_REG_ADDR(DVIN_ACTIVE_START_PIX)
+#define DVIN_ACTIVE_START_LINE 0x12e3
+#define P_DVIN_ACTIVE_START_LINE        \
+	CBUS_REG_ADDR(DVIN_ACTIVE_START_LINE)
+#define DVIN_DISPLAY_SIZE 0x12e4
+#define P_DVIN_DISPLAY_SIZE             CBUS_REG_ADDR(DVIN_DISPLAY_SIZE)
+#define DVIN_CTRL_STAT 0x12e5
+#define P_DVIN_CTRL_STAT                CBUS_REG_ADDR(DVIN_CTRL_STAT)
+#define AIU_958_BPF 0x1500
+#define P_AIU_958_BPF           CBUS_REG_ADDR(AIU_958_BPF)
+#define AIU_958_BRST 0x1501
+#define P_AIU_958_BRST          CBUS_REG_ADDR(AIU_958_BRST)
+#define AIU_958_LENGTH 0x1502
+#define P_AIU_958_LENGTH                CBUS_REG_ADDR(AIU_958_LENGTH)
+#define AIU_958_PADDSIZE 0x1503
+#define P_AIU_958_PADDSIZE              CBUS_REG_ADDR(AIU_958_PADDSIZE)
+#define AIU_958_MISC 0x1504
+#define P_AIU_958_MISC          CBUS_REG_ADDR(AIU_958_MISC)
+#define AIU_958_FORCE_LEFT 0x1505
+#define P_AIU_958_FORCE_LEFT            CBUS_REG_ADDR(AIU_958_FORCE_LEFT)
+#define AIU_958_DISCARD_NUM 0x1506
+#define P_AIU_958_DISCARD_NUM           CBUS_REG_ADDR(AIU_958_DISCARD_NUM)
+#define AIU_958_DCU_FF_CTRL 0x1507
+#define P_AIU_958_DCU_FF_CTRL           CBUS_REG_ADDR(AIU_958_DCU_FF_CTRL)
+#define AIU_958_CHSTAT_L0 0x1508
+#define P_AIU_958_CHSTAT_L0             CBUS_REG_ADDR(AIU_958_CHSTAT_L0)
+#define AIU_958_CHSTAT_L1 0x1509
+#define P_AIU_958_CHSTAT_L1             CBUS_REG_ADDR(AIU_958_CHSTAT_L1)
+#define AIU_958_CTRL 0x150a
+#define P_AIU_958_CTRL          CBUS_REG_ADDR(AIU_958_CTRL)
+#define AIU_958_RPT 0x150b
+#define P_AIU_958_RPT           CBUS_REG_ADDR(AIU_958_RPT)
+#define AIU_I2S_MUTE_SWAP 0x150c
+#define P_AIU_I2S_MUTE_SWAP             CBUS_REG_ADDR(AIU_I2S_MUTE_SWAP)
+#define AIU_I2S_SOURCE_DESC 0x150d
+#define P_AIU_I2S_SOURCE_DESC           CBUS_REG_ADDR(AIU_I2S_SOURCE_DESC)
+#define AIU_I2S_MED_CTRL 0x150e
+#define P_AIU_I2S_MED_CTRL              CBUS_REG_ADDR(AIU_I2S_MED_CTRL)
+#define AIU_I2S_MED_THRESH 0x150f
+#define P_AIU_I2S_MED_THRESH            CBUS_REG_ADDR(AIU_I2S_MED_THRESH)
+#define AIU_I2S_DAC_CFG 0x1510
+#define P_AIU_I2S_DAC_CFG               CBUS_REG_ADDR(AIU_I2S_DAC_CFG)
+#define AIU_I2S_SYNC 0x1511
+#define P_AIU_I2S_SYNC          CBUS_REG_ADDR(AIU_I2S_SYNC)
+#define AIU_I2S_MISC 0x1512
+#define P_AIU_I2S_MISC          CBUS_REG_ADDR(AIU_I2S_MISC)
+#define AIU_I2S_OUT_CFG 0x1513
+#define P_AIU_I2S_OUT_CFG               CBUS_REG_ADDR(AIU_I2S_OUT_CFG)
+#define AIU_I2S_FF_CTRL 0x1514
+#define P_AIU_I2S_FF_CTRL               CBUS_REG_ADDR(AIU_I2S_FF_CTRL)
+#define AIU_RST_SOFT 0x1515
+#define P_AIU_RST_SOFT          CBUS_REG_ADDR(AIU_RST_SOFT)
+#define AIU_CLK_CTRL 0x1516
+#define P_AIU_CLK_CTRL          CBUS_REG_ADDR(AIU_CLK_CTRL)
+#define AIU_MIX_ADCCFG 0x1517
+#define P_AIU_MIX_ADCCFG                CBUS_REG_ADDR(AIU_MIX_ADCCFG)
+#define AIU_MIX_CTRL 0x1518
+#define P_AIU_MIX_CTRL          CBUS_REG_ADDR(AIU_MIX_CTRL)
+#define AIU_CLK_CTRL_MORE 0x1519
+#define P_AIU_CLK_CTRL_MORE             CBUS_REG_ADDR(AIU_CLK_CTRL_MORE)
+#define AIU_958_POP 0x151a
+#define P_AIU_958_POP           CBUS_REG_ADDR(AIU_958_POP)
+#define AIU_MIX_GAIN 0x151b
+#define P_AIU_MIX_GAIN          CBUS_REG_ADDR(AIU_MIX_GAIN)
+#define AIU_958_SYNWORD1 0x151c
+#define P_AIU_958_SYNWORD1              CBUS_REG_ADDR(AIU_958_SYNWORD1)
+#define AIU_958_SYNWORD2 0x151d
+#define P_AIU_958_SYNWORD2              CBUS_REG_ADDR(AIU_958_SYNWORD2)
+#define AIU_958_SYNWORD3 0x151e
+#define P_AIU_958_SYNWORD3              CBUS_REG_ADDR(AIU_958_SYNWORD3)
+#define AIU_958_SYNWORD1_MASK 0x151f
+#define P_AIU_958_SYNWORD1_MASK         \
+	CBUS_REG_ADDR(AIU_958_SYNWORD1_MASK)
+#define AIU_958_SYNWORD2_MASK 0x1520
+#define P_AIU_958_SYNWORD2_MASK         \
+	CBUS_REG_ADDR(AIU_958_SYNWORD2_MASK)
+#define AIU_958_SYNWORD3_MASK 0x1521
+#define P_AIU_958_SYNWORD3_MASK         \
+	CBUS_REG_ADDR(AIU_958_SYNWORD3_MASK)
+#define AIU_958_FFRDOUT_THD 0x1522
+#define P_AIU_958_FFRDOUT_THD           CBUS_REG_ADDR(AIU_958_FFRDOUT_THD)
+#define AIU_958_LENGTH_PER_PAUSE 0x1523
+#define P_AIU_958_LENGTH_PER_PAUSE      \
+	CBUS_REG_ADDR(AIU_958_LENGTH_PER_PAUSE)
+#define AIU_958_PAUSE_NUM 0x1524
+#define P_AIU_958_PAUSE_NUM             CBUS_REG_ADDR(AIU_958_PAUSE_NUM)
+#define AIU_958_PAUSE_PAYLOAD 0x1525
+#define P_AIU_958_PAUSE_PAYLOAD         \
+	CBUS_REG_ADDR(AIU_958_PAUSE_PAYLOAD)
+#define AIU_958_AUTO_PAUSE 0x1526
+#define P_AIU_958_AUTO_PAUSE            CBUS_REG_ADDR(AIU_958_AUTO_PAUSE)
+#define AIU_958_PAUSE_PD_LENGTH 0x1527
+#define P_AIU_958_PAUSE_PD_LENGTH       \
+	CBUS_REG_ADDR(AIU_958_PAUSE_PD_LENGTH)
+#define AIU_CODEC_DAC_LRCLK_CTRL 0x1528
+#define P_AIU_CODEC_DAC_LRCLK_CTRL      \
+	CBUS_REG_ADDR(AIU_CODEC_DAC_LRCLK_CTRL)
+#define AIU_CODEC_ADC_LRCLK_CTRL 0x1529
+#define P_AIU_CODEC_ADC_LRCLK_CTRL      \
+	CBUS_REG_ADDR(AIU_CODEC_ADC_LRCLK_CTRL)
+#define AIU_CODEC_CLK_DATA_CTRL 0x152b
+#define P_AIU_CODEC_CLK_DATA_CTRL       \
+	CBUS_REG_ADDR(AIU_CODEC_CLK_DATA_CTRL)
+#define AIU_958_CHSTAT_R0 0x1530
+#define P_AIU_958_CHSTAT_R0             CBUS_REG_ADDR(AIU_958_CHSTAT_R0)
+#define AIU_958_CHSTAT_R1 0x1531
+#define P_AIU_958_CHSTAT_R1             CBUS_REG_ADDR(AIU_958_CHSTAT_R1)
+#define AIU_958_VALID_CTRL 0x1532
+#define P_AIU_958_VALID_CTRL            CBUS_REG_ADDR(AIU_958_VALID_CTRL)
+#define AIU_AUDIO_AMP_REG0 0x153c
+#define P_AIU_AUDIO_AMP_REG0            CBUS_REG_ADDR(AIU_AUDIO_AMP_REG0)
+#define AIU_AUDIO_AMP_REG1 0x153d
+#define P_AIU_AUDIO_AMP_REG1            CBUS_REG_ADDR(AIU_AUDIO_AMP_REG1)
+#define AIU_AUDIO_AMP_REG2 0x153e
+#define P_AIU_AUDIO_AMP_REG2            CBUS_REG_ADDR(AIU_AUDIO_AMP_REG2)
+#define AIU_AUDIO_AMP_REG3 0x153f
+#define P_AIU_AUDIO_AMP_REG3            CBUS_REG_ADDR(AIU_AUDIO_AMP_REG3)
+#define AIU_AIFIFO2_CTRL 0x1540
+#define P_AIU_AIFIFO2_CTRL              CBUS_REG_ADDR(AIU_AIFIFO2_CTRL)
+#define AIU_AIFIFO2_STATUS 0x1541
+#define P_AIU_AIFIFO2_STATUS            CBUS_REG_ADDR(AIU_AIFIFO2_STATUS)
+#define AIU_AIFIFO2_GBIT 0x1542
+#define P_AIU_AIFIFO2_GBIT              CBUS_REG_ADDR(AIU_AIFIFO2_GBIT)
+#define AIU_AIFIFO2_CLB 0x1543
+#define P_AIU_AIFIFO2_CLB               CBUS_REG_ADDR(AIU_AIFIFO2_CLB)
+#define AIU_CRC_CTRL 0x1544
+#define P_AIU_CRC_CTRL          CBUS_REG_ADDR(AIU_CRC_CTRL)
+#define AIU_CRC_STATUS 0x1545
+#define P_AIU_CRC_STATUS                CBUS_REG_ADDR(AIU_CRC_STATUS)
+#define AIU_CRC_SHIFT_REG 0x1546
+#define P_AIU_CRC_SHIFT_REG             CBUS_REG_ADDR(AIU_CRC_SHIFT_REG)
+#define AIU_CRC_IREG 0x1547
+#define P_AIU_CRC_IREG          CBUS_REG_ADDR(AIU_CRC_IREG)
+#define AIU_CRC_CAL_REG1 0x1548
+#define P_AIU_CRC_CAL_REG1              CBUS_REG_ADDR(AIU_CRC_CAL_REG1)
+#define AIU_CRC_CAL_REG0 0x1549
+#define P_AIU_CRC_CAL_REG0              CBUS_REG_ADDR(AIU_CRC_CAL_REG0)
+#define AIU_CRC_POLY_COEF1 0x154a
+#define P_AIU_CRC_POLY_COEF1            CBUS_REG_ADDR(AIU_CRC_POLY_COEF1)
+#define AIU_CRC_POLY_COEF0 0x154b
+#define P_AIU_CRC_POLY_COEF0            CBUS_REG_ADDR(AIU_CRC_POLY_COEF0)
+#define AIU_CRC_BIT_SIZE1 0x154c
+#define P_AIU_CRC_BIT_SIZE1             CBUS_REG_ADDR(AIU_CRC_BIT_SIZE1)
+#define AIU_CRC_BIT_SIZE0 0x154d
+#define P_AIU_CRC_BIT_SIZE0             CBUS_REG_ADDR(AIU_CRC_BIT_SIZE0)
+#define AIU_CRC_BIT_CNT1 0x154e
+#define P_AIU_CRC_BIT_CNT1              CBUS_REG_ADDR(AIU_CRC_BIT_CNT1)
+#define AIU_CRC_BIT_CNT0 0x154f
+#define P_AIU_CRC_BIT_CNT0              CBUS_REG_ADDR(AIU_CRC_BIT_CNT0)
+#define AIU_AMCLK_GATE_HI 0x1550
+#define P_AIU_AMCLK_GATE_HI             CBUS_REG_ADDR(AIU_AMCLK_GATE_HI)
+#define AIU_AMCLK_GATE_LO 0x1551
+#define P_AIU_AMCLK_GATE_LO             CBUS_REG_ADDR(AIU_AMCLK_GATE_LO)
+#define AIU_AMCLK_MSR 0x1552
+#define P_AIU_AMCLK_MSR                 CBUS_REG_ADDR(AIU_AMCLK_MSR)
+#define AIU_AUDAC_CTRL0 0x1553
+#define P_AIU_AUDAC_CTRL0               CBUS_REG_ADDR(AIU_AUDAC_CTRL0)
+#define AIU_DELTA_SIGMA0 0x1555
+#define P_AIU_DELTA_SIGMA0              CBUS_REG_ADDR(AIU_DELTA_SIGMA0)
+#define AIU_DELTA_SIGMA1 0x1556
+#define P_AIU_DELTA_SIGMA1              CBUS_REG_ADDR(AIU_DELTA_SIGMA1)
+#define AIU_DELTA_SIGMA2 0x1557
+#define P_AIU_DELTA_SIGMA2              CBUS_REG_ADDR(AIU_DELTA_SIGMA2)
+#define AIU_DELTA_SIGMA3 0x1558
+#define P_AIU_DELTA_SIGMA3              CBUS_REG_ADDR(AIU_DELTA_SIGMA3)
+#define AIU_DELTA_SIGMA4 0x1559
+#define P_AIU_DELTA_SIGMA4              CBUS_REG_ADDR(AIU_DELTA_SIGMA4)
+#define AIU_DELTA_SIGMA5 0x155a
+#define P_AIU_DELTA_SIGMA5              CBUS_REG_ADDR(AIU_DELTA_SIGMA5)
+#define AIU_DELTA_SIGMA6 0x155b
+#define P_AIU_DELTA_SIGMA6              CBUS_REG_ADDR(AIU_DELTA_SIGMA6)
+#define AIU_DELTA_SIGMA7 0x155c
+#define P_AIU_DELTA_SIGMA7              CBUS_REG_ADDR(AIU_DELTA_SIGMA7)
+#define AIU_DELTA_SIGMA_LCNTS 0x155d
+#define P_AIU_DELTA_SIGMA_LCNTS         \
+	CBUS_REG_ADDR(AIU_DELTA_SIGMA_LCNTS)
+#define AIU_DELTA_SIGMA_RCNTS 0x155e
+#define P_AIU_DELTA_SIGMA_RCNTS         \
+	CBUS_REG_ADDR(AIU_DELTA_SIGMA_RCNTS)
+#define AIU_MEM_I2S_START_PTR 0x1560
+#define P_AIU_MEM_I2S_START_PTR         \
+	CBUS_REG_ADDR(AIU_MEM_I2S_START_PTR)
+#define AIU_MEM_I2S_RD_PTR 0x1561
+#define P_AIU_MEM_I2S_RD_PTR            CBUS_REG_ADDR(AIU_MEM_I2S_RD_PTR)
+#define AIU_MEM_I2S_END_PTR 0x1562
+#define P_AIU_MEM_I2S_END_PTR           CBUS_REG_ADDR(AIU_MEM_I2S_END_PTR)
+#define AIU_MEM_I2S_MASKS 0x1563
+#define P_AIU_MEM_I2S_MASKS             CBUS_REG_ADDR(AIU_MEM_I2S_MASKS)
+#define AIU_MEM_I2S_CONTROL 0x1564
+#define P_AIU_MEM_I2S_CONTROL           CBUS_REG_ADDR(AIU_MEM_I2S_CONTROL)
+#define AIU_MEM_IEC958_START_PTR 0x1565
+#define P_AIU_MEM_IEC958_START_PTR      \
+	CBUS_REG_ADDR(AIU_MEM_IEC958_START_PTR)
+#define AIU_MEM_IEC958_RD_PTR 0x1566
+#define P_AIU_MEM_IEC958_RD_PTR         \
+	CBUS_REG_ADDR(AIU_MEM_IEC958_RD_PTR)
+#define AIU_MEM_IEC958_END_PTR 0x1567
+#define AIU_MEM_AIFIFO2_START_PTR 0x156a
+#define P_AIU_MEM_AIFIFO2_START_PTR     \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_START_PTR)
+#define AIU_MEM_AIFIFO2_CURR_PTR 0x156b
+#define P_AIU_MEM_AIFIFO2_CURR_PTR      \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_CURR_PTR)
+#define AIU_MEM_AIFIFO2_BYTES_AVAIL 0x156d
+#define P_AIU_MEM_AIFIFO2_BYTES_AVAIL           \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_BYTES_AVAIL)
+#define AIU_MEM_AIFIFO2_CONTROL 0x156e
+#define P_AIU_MEM_AIFIFO2_CONTROL               \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_CONTROL)
+#define AIU_MEM_AIFIFO2_LEVEL 0x1571
+#define P_AIU_MEM_AIFIFO2_LEVEL                 \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_LEVEL)
+#define AIU_MEM_AIFIFO2_BUF_CNTL 0x1572
+#define P_AIU_MEM_AIFIFO2_BUF_CNTL              \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_BUF_CNTL)
+#define AIU_MEM_I2S_MAN_WP 0x1573
+#define P_AIU_MEM_I2S_MAN_WP            CBUS_REG_ADDR(AIU_MEM_I2S_MAN_WP)
+#define AIU_MEM_I2S_MAN_RP 0x1574
+#define P_AIU_MEM_I2S_MAN_RP            CBUS_REG_ADDR(AIU_MEM_I2S_MAN_RP)
+#define AIU_MEM_I2S_LEVEL 0x1575
+#define P_AIU_MEM_I2S_LEVEL             CBUS_REG_ADDR(AIU_MEM_I2S_LEVEL)
+#define AIU_MEM_I2S_BUF_CNTL 0x1576
+#define P_AIU_MEM_I2S_BUF_CNTL          CBUS_REG_ADDR(AIU_MEM_I2S_BUF_CNTL)
+#define AIU_MEM_I2S_BUF_WRAP_COUNT 0x1577
+#define P_AIU_MEM_I2S_BUF_WRAP_COUNT            \
+	CBUS_REG_ADDR(AIU_MEM_I2S_BUF_WRAP_COUNT)
+#define AIU_MEM_I2S_MEM_CTL 0x1578
+#define P_AIU_MEM_I2S_MEM_CTL           CBUS_REG_ADDR(AIU_MEM_I2S_MEM_CTL)
+#define AIU_MEM_IEC958_WRAP_COUNT 0x157a
+#define P_AIU_MEM_IEC958_WRAP_COUNT             \
+	CBUS_REG_ADDR(AIU_MEM_IEC958_WRAP_COUNT)
+#define AIU_MEM_IEC958_IRQ_LEVEL 0x157b
+#define P_AIU_MEM_IEC958_IRQ_LEVEL              \
+	CBUS_REG_ADDR(AIU_MEM_IEC958_IRQ_LEVEL)
+#define AIU_MEM_IEC958_MAN_WP 0x157c
+#define P_AIU_MEM_IEC958_MAN_WP                 \
+	CBUS_REG_ADDR(AIU_MEM_IEC958_MAN_WP)
+#define AIU_MEM_IEC958_MAN_RP 0x157d
+#define P_AIU_MEM_IEC958_MAN_RP                 \
+	CBUS_REG_ADDR(AIU_MEM_IEC958_MAN_RP)
+#define AIU_MEM_IEC958_LEVEL 0x157e
+#define P_AIU_MEM_IEC958_LEVEL          \
+	CBUS_REG_ADDR(AIU_MEM_IEC958_LEVEL)
+#define AIU_AIFIFO_CTRL 0x1580
+#define P_AIU_AIFIFO_CTRL               CBUS_REG_ADDR(AIU_AIFIFO_CTRL)
+#define AIU_AIFIFO_STATUS 0x1581
+#define P_AIU_AIFIFO_STATUS             CBUS_REG_ADDR(AIU_AIFIFO_STATUS)
+#define AIU_AIFIFO_GBIT 0x1582
+#define P_AIU_AIFIFO_GBIT               CBUS_REG_ADDR(AIU_AIFIFO_GBIT)
+#define AIU_AIFIFO_CLB 0x1583
+#define P_AIU_AIFIFO_CLB                CBUS_REG_ADDR(AIU_AIFIFO_CLB)
+#define AIU_MEM_AIFIFO_START_PTR 0x1584
+#define P_AIU_MEM_AIFIFO_START_PTR              \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO_START_PTR)
+#define AIU_MEM_AIFIFO_BYTES_AVAIL 0x1587
+#define P_AIU_MEM_AIFIFO_BYTES_AVAIL            \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO_BYTES_AVAIL)
+#define AIU_MEM_AIFIFO_MAN_WP 0x1589
+#define P_AIU_MEM_AIFIFO_MAN_WP                 \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO_MAN_WP)
+#define AIU_MEM_AIFIFO_MAN_RP 0x158a
+#define P_AIU_MEM_AIFIFO_MAN_RP                 \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO_MAN_RP)
+#define AIU_MEM_AIFIFO_BUF_WRAP_COUNT 0x158d
+#define P_AIU_MEM_AIFIFO_BUF_WRAP_COUNT                 \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO_BUF_WRAP_COUNT)
+#define AIU_MEM_AIFIFO2_BUF_WRAP_COUNT 0x158e
+#define P_AIU_MEM_AIFIFO2_BUF_WRAP_COUNT                \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_BUF_WRAP_COUNT)
+#define AIFIFO_TIME_STAMP_SYNC_0 0x1591
+#define P_AIFIFO_TIME_STAMP_SYNC_0              \
+	CBUS_REG_ADDR(AIFIFO_TIME_STAMP_SYNC_0)
+#define AIFIFO_TIME_STAMP_SYNC_1 0x1592
+#define P_AIFIFO_TIME_STAMP_SYNC_1              \
+	CBUS_REG_ADDR(AIFIFO_TIME_STAMP_SYNC_1)
+#define AIFIFO_TIME_STAMP_0 0x1593
+#define P_AIFIFO_TIME_STAMP_0           CBUS_REG_ADDR(AIFIFO_TIME_STAMP_0)
+#define AIFIFO_TIME_STAMP_1 0x1594
+#define P_AIFIFO_TIME_STAMP_1           CBUS_REG_ADDR(AIFIFO_TIME_STAMP_1)
+#define AIFIFO_TIME_STAMP_2 0x1595
+#define P_AIFIFO_TIME_STAMP_2           CBUS_REG_ADDR(AIFIFO_TIME_STAMP_2)
+#define AIFIFO_TIME_STAMP_3 0x1596
+#define P_AIFIFO_TIME_STAMP_3           CBUS_REG_ADDR(AIFIFO_TIME_STAMP_3)
+#define AIFIFO_TIME_STAMP_LENGTH 0x1597
+#define P_AIFIFO_TIME_STAMP_LENGTH              \
+	CBUS_REG_ADDR(AIFIFO_TIME_STAMP_LENGTH)
+#define AIFIFO2_TIME_STAMP_CNTL 0x1598
+#define P_AIFIFO2_TIME_STAMP_CNTL       \
+	CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_CNTL)
+#define AIFIFO2_TIME_STAMP_SYNC_0 0x1599
+#define P_AIFIFO2_TIME_STAMP_SYNC_0             \
+	CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_SYNC_0)
+#define AIFIFO2_TIME_STAMP_SYNC_1 0x159a
+#define P_AIFIFO2_TIME_STAMP_SYNC_1             \
+	CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_SYNC_1)
+#define AIFIFO2_TIME_STAMP_0 0x159b
+#define P_AIFIFO2_TIME_STAMP_0          CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_0)
+#define AIFIFO2_TIME_STAMP_1 0x159c
+#define P_AIFIFO2_TIME_STAMP_1          CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_1)
+#define AIFIFO2_TIME_STAMP_2 0x159d
+#define P_AIFIFO2_TIME_STAMP_2          CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_2)
+#define AIFIFO2_TIME_STAMP_3 0x159e
+#define P_AIFIFO2_TIME_STAMP_3          CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_3)
+#define AIFIFO2_TIME_STAMP_LENGTH 0x159f
+#define P_AIFIFO2_TIME_STAMP_LENGTH             \
+	CBUS_REG_ADDR(AIFIFO2_TIME_STAMP_LENGTH)
+#define IEC958_TIME_STAMP_SYNC_0 0x15a1
+#define P_IEC958_TIME_STAMP_SYNC_0              \
+	CBUS_REG_ADDR(IEC958_TIME_STAMP_SYNC_0)
+#define IEC958_TIME_STAMP_SYNC_1 0x15a2
+#define P_IEC958_TIME_STAMP_SYNC_1              \
+	CBUS_REG_ADDR(IEC958_TIME_STAMP_SYNC_1)
+#define IEC958_TIME_STAMP_0 0x15a3
+#define P_IEC958_TIME_STAMP_0           CBUS_REG_ADDR(IEC958_TIME_STAMP_0)
+#define IEC958_TIME_STAMP_1 0x15a4
+#define P_IEC958_TIME_STAMP_1           CBUS_REG_ADDR(IEC958_TIME_STAMP_1)
+#define IEC958_TIME_STAMP_2 0x15a5
+#define P_IEC958_TIME_STAMP_2           CBUS_REG_ADDR(IEC958_TIME_STAMP_2)
+#define IEC958_TIME_STAMP_3 0x15a6
+#define P_IEC958_TIME_STAMP_3           CBUS_REG_ADDR(IEC958_TIME_STAMP_3)
+#define IEC958_TIME_STAMP_LENGTH 0x15a7
+#define P_IEC958_TIME_STAMP_LENGTH              \
+	CBUS_REG_ADDR(IEC958_TIME_STAMP_LENGTH)
+#define AIU_MEM_AIFIFO2_MEM_CTL 0x15a8
+#define P_AIU_MEM_AIFIFO2_MEM_CTL               \
+	CBUS_REG_ADDR(AIU_MEM_AIFIFO2_MEM_CTL)
+#define AIU_I2S_CBUS_DDR_CNTL 0x15a9
+#define P_AIU_I2S_CBUS_DDR_CNTL                 \
+	CBUS_REG_ADDR(AIU_I2S_CBUS_DDR_CNTL)
+#define AIU_I2S_CBUS_DDR_WDATA 0x15aa
+#define P_AIU_I2S_CBUS_DDR_WDATA                \
+	CBUS_REG_ADDR(AIU_I2S_CBUS_DDR_WDATA)
+#define AIU_I2S_CBUS_DDR_ADDR 0x15ab
+#define P_AIU_I2S_CBUS_DDR_ADDR                 \
+	CBUS_REG_ADDR(AIU_I2S_CBUS_DDR_ADDR)
+#define GE2D_GEN_CTRL0 0x18a0
+#define P_GE2D_GEN_CTRL0                CBUS_REG_ADDR(GE2D_GEN_CTRL0)
+#define GE2D_GEN_CTRL1 0x18a1
+#define P_GE2D_GEN_CTRL1                CBUS_REG_ADDR(GE2D_GEN_CTRL1)
+#define GE2D_GEN_CTRL2 0x18a2
+#define P_GE2D_GEN_CTRL2                CBUS_REG_ADDR(GE2D_GEN_CTRL2)
+#define GE2D_CMD_CTRL 0x18a3
+#define P_GE2D_CMD_CTRL                 CBUS_REG_ADDR(GE2D_CMD_CTRL)
+#define GE2D_STATUS0 0x18a4
+#define P_GE2D_STATUS0          CBUS_REG_ADDR(GE2D_STATUS0)
+#define GE2D_STATUS1 0x18a5
+#define P_GE2D_STATUS1          CBUS_REG_ADDR(GE2D_STATUS1)
+#define GE2D_SRC1_DEF_COLOR 0x18a6
+#define P_GE2D_SRC1_DEF_COLOR           CBUS_REG_ADDR(GE2D_SRC1_DEF_COLOR)
+#define GE2D_SRC1_CLIPX_START_END 0x18a7
+#define P_GE2D_SRC1_CLIPX_START_END             \
+	CBUS_REG_ADDR(GE2D_SRC1_CLIPX_START_END)
+#define GE2D_SRC1_CLIPY_START_END 0x18a8
+#define P_GE2D_SRC1_CLIPY_START_END             \
+	CBUS_REG_ADDR(GE2D_SRC1_CLIPY_START_END)
+#define GE2D_SRC1_CANVAS 0x18a9
+#define P_GE2D_SRC1_CANVAS              CBUS_REG_ADDR(GE2D_SRC1_CANVAS)
+#define GE2D_SRC1_X_START_END 0x18aa
+#define P_GE2D_SRC1_X_START_END                 \
+	CBUS_REG_ADDR(GE2D_SRC1_X_START_END)
+#define GE2D_SRC1_Y_START_END 0x18ab
+#define P_GE2D_SRC1_Y_START_END                 \
+	CBUS_REG_ADDR(GE2D_SRC1_Y_START_END)
+#define GE2D_SRC1_LUT_ADDR 0x18ac
+#define P_GE2D_SRC1_LUT_ADDR            \
+	CBUS_REG_ADDR(GE2D_SRC1_LUT_ADDR)
+#define GE2D_SRC1_LUT_DAT 0x18ad
+#define P_GE2D_SRC1_LUT_DAT             \
+	CBUS_REG_ADDR(GE2D_SRC1_LUT_DAT)
+#define GE2D_SRC1_FMT_CTRL 0x18ae
+#define P_GE2D_SRC1_FMT_CTRL            \
+	CBUS_REG_ADDR(GE2D_SRC1_FMT_CTRL)
+#define GE2D_SRC2_DEF_COLOR 0x18af
+#define P_GE2D_SRC2_DEF_COLOR           CBUS_REG_ADDR(GE2D_SRC2_DEF_COLOR)
+#define GE2D_SRC2_CLIPX_START_END 0x18b0
+#define P_GE2D_SRC2_CLIPX_START_END             \
+	CBUS_REG_ADDR(GE2D_SRC2_CLIPX_START_END)
+#define GE2D_SRC2_CLIPY_START_END 0x18b1
+#define P_GE2D_SRC2_CLIPY_START_END             \
+	CBUS_REG_ADDR(GE2D_SRC2_CLIPY_START_END)
+#define GE2D_SRC2_X_START_END 0x18b2
+#define P_GE2D_SRC2_X_START_END                 \
+	CBUS_REG_ADDR(GE2D_SRC2_X_START_END)
+#define GE2D_SRC2_Y_START_END 0x18b3
+#define P_GE2D_SRC2_Y_START_END                 \
+	CBUS_REG_ADDR(GE2D_SRC2_Y_START_END)
+#define GE2D_DST_CLIPX_START_END 0x18b4
+#define P_GE2D_DST_CLIPX_START_END              \
+	CBUS_REG_ADDR(GE2D_DST_CLIPX_START_END)
+#define GE2D_DST_CLIPY_START_END 0x18b5
+#define P_GE2D_DST_CLIPY_START_END              \
+	CBUS_REG_ADDR(GE2D_DST_CLIPY_START_END)
+#define GE2D_DST_X_START_END 0x18b6
+#define P_GE2D_DST_X_START_END          CBUS_REG_ADDR(GE2D_DST_X_START_END)
+#define GE2D_DST_Y_START_END 0x18b7
+#define P_GE2D_DST_Y_START_END          CBUS_REG_ADDR(GE2D_DST_Y_START_END)
+#define GE2D_SRC2_DST_CANVAS 0x18b8
+#define P_GE2D_SRC2_DST_CANVAS          CBUS_REG_ADDR(GE2D_SRC2_DST_CANVAS)
+#define GE2D_VSC_PHASE_SLOPE 0x18ba
+#define P_GE2D_VSC_PHASE_SLOPE          CBUS_REG_ADDR(GE2D_VSC_PHASE_SLOPE)
+#define GE2D_VSC_INI_CTRL 0x18bb
+#define P_GE2D_VSC_INI_CTRL             CBUS_REG_ADDR(GE2D_VSC_INI_CTRL)
+#define GE2D_HSC_PHASE_SLOPE 0x18bd
+#define P_GE2D_HSC_PHASE_SLOPE          CBUS_REG_ADDR(GE2D_HSC_PHASE_SLOPE)
+#define GE2D_HSC_INI_CTRL 0x18be
+#define P_GE2D_HSC_INI_CTRL             CBUS_REG_ADDR(GE2D_HSC_INI_CTRL)
+#define GE2D_HSC_ADV_CTRL 0x18bf
+#define P_GE2D_HSC_ADV_CTRL             CBUS_REG_ADDR(GE2D_HSC_ADV_CTRL)
+#define GE2D_SC_MISC_CTRL 0x18c0
+#define P_GE2D_SC_MISC_CTRL             CBUS_REG_ADDR(GE2D_SC_MISC_CTRL)
+#define GE2D_VSC_NRND_POINT 0x18c1
+#define P_GE2D_VSC_NRND_POINT           CBUS_REG_ADDR(GE2D_VSC_NRND_POINT)
+#define GE2D_VSC_NRND_PHASE 0x18c2
+#define P_GE2D_VSC_NRND_PHASE           CBUS_REG_ADDR(GE2D_VSC_NRND_PHASE)
+#define GE2D_HSC_NRND_POINT 0x18c3
+#define P_GE2D_HSC_NRND_POINT           CBUS_REG_ADDR(GE2D_HSC_NRND_POINT)
+#define GE2D_HSC_NRND_PHASE 0x18c4
+#define P_GE2D_HSC_NRND_PHASE           CBUS_REG_ADDR(GE2D_HSC_NRND_PHASE)
+#define GE2D_MATRIX_COEF00_01 0x18c6
+#define P_GE2D_MATRIX_COEF00_01                 \
+	CBUS_REG_ADDR(GE2D_MATRIX_COEF00_01)
+#define GE2D_MATRIX_COEF02_10 0x18c7
+#define P_GE2D_MATRIX_COEF02_10                 \
+	CBUS_REG_ADDR(GE2D_MATRIX_COEF02_10)
+#define GE2D_MATRIX_COEF11_12 0x18c8
+#define P_GE2D_MATRIX_COEF11_12                 \
+	CBUS_REG_ADDR(GE2D_MATRIX_COEF11_12)
+#define GE2D_MATRIX_COEF20_21 0x18c9
+#define P_GE2D_MATRIX_COEF20_21                 \
+	CBUS_REG_ADDR(GE2D_MATRIX_COEF20_21)
+#define GE2D_MATRIX_COEF22_CTRL 0x18ca
+#define P_GE2D_MATRIX_COEF22_CTRL               \
+	CBUS_REG_ADDR(GE2D_MATRIX_COEF22_CTRL)
+#define GE2D_MATRIX_OFFSET 0x18cb
+#define P_GE2D_MATRIX_OFFSET            CBUS_REG_ADDR(GE2D_MATRIX_OFFSET)
+#define GE2D_ALU_OP_CTRL 0x18cc
+#define P_GE2D_ALU_OP_CTRL              CBUS_REG_ADDR(GE2D_ALU_OP_CTRL)
+#define GE2D_ALU_CONST_COLOR 0x18cd
+#define P_GE2D_ALU_CONST_COLOR          CBUS_REG_ADDR(GE2D_ALU_CONST_COLOR)
+#define GE2D_SRC1_KEY 0x18ce
+#define P_GE2D_SRC1_KEY                 CBUS_REG_ADDR(GE2D_SRC1_KEY)
+#define GE2D_SRC1_KEY_MASK 0x18cf
+#define P_GE2D_SRC1_KEY_MASK            CBUS_REG_ADDR(GE2D_SRC1_KEY_MASK)
+#define GE2D_SRC2_KEY 0x18d0
+#define P_GE2D_SRC2_KEY                 CBUS_REG_ADDR(GE2D_SRC2_KEY)
+#define GE2D_SRC2_KEY_MASK 0x18d1
+#define P_GE2D_SRC2_KEY_MASK            CBUS_REG_ADDR(GE2D_SRC2_KEY_MASK)
+#define GE2D_DST_BITMASK 0x18d2
+#define P_GE2D_DST_BITMASK              CBUS_REG_ADDR(GE2D_DST_BITMASK)
+#define GE2D_DP_ONOFF_CTRL 0x18d3
+#define P_GE2D_DP_ONOFF_CTRL            CBUS_REG_ADDR(GE2D_DP_ONOFF_CTRL)
+#define GE2D_SCALE_COEF_IDX 0x18d4
+#define P_GE2D_SCALE_COEF_IDX           CBUS_REG_ADDR(GE2D_SCALE_COEF_IDX)
+#define GE2D_SCALE_COEF 0x18d5
+#define P_GE2D_SCALE_COEF               CBUS_REG_ADDR(GE2D_SCALE_COEF)
+#define GE2D_ANTIFLICK_CTRL0 0x18d8
+#define P_GE2D_ANTIFLICK_CTRL0          CBUS_REG_ADDR(GE2D_ANTIFLICK_CTRL0)
+#define GE2D_ANTIFLICK_CTRL1 0x18d9
+#define P_GE2D_ANTIFLICK_CTRL1          CBUS_REG_ADDR(GE2D_ANTIFLICK_CTRL1)
+#define GE2D_ANTIFLICK_COLOR_FILT0 0x18da
+#define P_GE2D_ANTIFLICK_COLOR_FILT0            \
+	CBUS_REG_ADDR(GE2D_ANTIFLICK_COLOR_FILT0)
+#define GE2D_ANTIFLICK_COLOR_FILT1 0x18db
+#define P_GE2D_ANTIFLICK_COLOR_FILT1            \
+	CBUS_REG_ADDR(GE2D_ANTIFLICK_COLOR_FILT1)
+#define GE2D_ANTIFLICK_COLOR_FILT2 0x18dc
+#define P_GE2D_ANTIFLICK_COLOR_FILT2            \
+	CBUS_REG_ADDR(GE2D_ANTIFLICK_COLOR_FILT2)
+#define GE2D_ANTIFLICK_COLOR_FILT3 0x18dd
+#define P_GE2D_ANTIFLICK_COLOR_FILT3            \
+	CBUS_REG_ADDR(GE2D_ANTIFLICK_COLOR_FILT3)
+#define GE2D_ANTIFLICK_ALPHA_FILT0 0x18de
+#define P_GE2D_ANTIFLICK_ALPHA_FILT0            \
+	CBUS_REG_ADDR(GE2D_ANTIFLICK_ALPHA_FILT0)
+#define GE2D_ANTIFLICK_ALPHA_FILT1 0x18df
+#define P_GE2D_ANTIFLICK_ALPHA_FILT1            \
+	CBUS_REG_ADDR(GE2D_ANTIFLICK_ALPHA_FILT1)
+#define GE2D_ANTIFLICK_ALPHA_FILT2 0x18e0
+#define P_GE2D_ANTIFLICK_ALPHA_FILT2            \
+	CBUS_REG_ADDR(GE2D_ANTIFLICK_ALPHA_FILT2)
+#define GE2D_ANTIFLICK_ALPHA_FILT3 0x18e1
+#define P_GE2D_ANTIFLICK_ALPHA_FILT3            \
+	CBUS_REG_ADDR(GE2D_ANTIFLICK_ALPHA_FILT3)
+#define GE2D_SRC1_RANGE_MAP_Y_CTRL 0x18e3
+#define P_GE2D_SRC1_RANGE_MAP_Y_CTRL            \
+	CBUS_REG_ADDR(GE2D_SRC1_RANGE_MAP_Y_CTRL)
+#define GE2D_SRC1_RANGE_MAP_CB_CTRL 0x18e4
+#define P_GE2D_SRC1_RANGE_MAP_CB_CTRL           \
+	CBUS_REG_ADDR(GE2D_SRC1_RANGE_MAP_CB_CTRL)
+#define GE2D_SRC1_RANGE_MAP_CR_CTRL 0x18e5
+#define P_GE2D_SRC1_RANGE_MAP_CR_CTRL           \
+	CBUS_REG_ADDR(GE2D_SRC1_RANGE_MAP_CR_CTRL)
+#define GE2D_ARB_BURST_NUM 0x18e6
+#define P_GE2D_ARB_BURST_NUM            CBUS_REG_ADDR(GE2D_ARB_BURST_NUM)
+#define GE2D_TID_TOKEN 0x18e7
+#define P_GE2D_TID_TOKEN                CBUS_REG_ADDR(GE2D_TID_TOKEN)
+#define GE2D_GEN_CTRL3 0x18e8
+#define P_GE2D_GEN_CTRL3                CBUS_REG_ADDR(GE2D_GEN_CTRL3)
+#define GE2D_STATUS2 0x18e9
+#define P_GE2D_STATUS2          CBUS_REG_ADDR(GE2D_STATUS2)
+#define GE2D_GEN_CTRL4 0x18ea
+#define P_GE2D_GEN_CTRL4                CBUS_REG_ADDR(GE2D_GEN_CTRL4)
+#define AUDIO_COP_CTL2 0x1f01
+#define P_AUDIO_COP_CTL2                CBUS_REG_ADDR(AUDIO_COP_CTL2)
+#define OPERAND_M_CTL 0x1f02
+#define P_OPERAND_M_CTL                 CBUS_REG_ADDR(OPERAND_M_CTL)
+#define OPERAND1_ADDR 0x1f03
+#define P_OPERAND1_ADDR                 CBUS_REG_ADDR(OPERAND1_ADDR)
+#define OPERAND2_ADDR 0x1f04
+#define P_OPERAND2_ADDR                 CBUS_REG_ADDR(OPERAND2_ADDR)
+#define RESULT_M_CTL 0x1f05
+#define P_RESULT_M_CTL          CBUS_REG_ADDR(RESULT_M_CTL)
+#define RESULT1_ADDR 0x1f06
+#define P_RESULT1_ADDR          CBUS_REG_ADDR(RESULT1_ADDR)
+#define RESULT2_ADDR 0x1f07
+#define P_RESULT2_ADDR          CBUS_REG_ADDR(RESULT2_ADDR)
+#define ADD_SHFT_CTL 0x1f08
+#define P_ADD_SHFT_CTL          CBUS_REG_ADDR(ADD_SHFT_CTL)
+#define OPERAND_ONE_H 0x1f09
+#define P_OPERAND_ONE_H                 CBUS_REG_ADDR(OPERAND_ONE_H)
+#define OPERAND_ONE_L 0x1f0a
+#define P_OPERAND_ONE_L                 CBUS_REG_ADDR(OPERAND_ONE_L)
+#define OPERAND_TWO_H 0x1f0b
+#define P_OPERAND_TWO_H                 CBUS_REG_ADDR(OPERAND_TWO_H)
+#define OPERAND_TWO_L 0x1f0c
+#define P_OPERAND_TWO_L                 CBUS_REG_ADDR(OPERAND_TWO_L)
+#define RESULT_H 0x1f0d
+#define P_RESULT_H              CBUS_REG_ADDR(RESULT_H)
+#define RESULT_M 0x1f0e
+#define P_RESULT_M              CBUS_REG_ADDR(RESULT_M)
+#define RESULT_L 0x1f0f
+#define P_RESULT_L              CBUS_REG_ADDR(RESULT_L)
+#define WMEM_R_PTR 0x1f10
+#define P_WMEM_R_PTR            CBUS_REG_ADDR(WMEM_R_PTR)
+#define WMEM_W_PTR 0x1f11
+#define P_WMEM_W_PTR            CBUS_REG_ADDR(WMEM_W_PTR)
+#define AUDIO_LAYER 0x1f20
+#define P_AUDIO_LAYER           CBUS_REG_ADDR(AUDIO_LAYER)
+#define AC3_DECODING 0x1f21
+#define P_AC3_DECODING          CBUS_REG_ADDR(AC3_DECODING)
+#define AC3_DYNAMIC 0x1f22
+#define P_AC3_DYNAMIC           CBUS_REG_ADDR(AC3_DYNAMIC)
+#define AC3_MELODY 0x1f23
+#define P_AC3_MELODY            CBUS_REG_ADDR(AC3_MELODY)
+#define AC3_VOCAL 0x1f24
+#define P_AC3_VOCAL             CBUS_REG_ADDR(AC3_VOCAL)
+#define ASSIST_AMR_SCRATCH0 0x1f4f
+#define P_ASSIST_AMR_SCRATCH0           CBUS_REG_ADDR(ASSIST_AMR_SCRATCH0)
+#define ASSIST_AMR_SCRATCH1 0x1f50
+#define P_ASSIST_AMR_SCRATCH1           CBUS_REG_ADDR(ASSIST_AMR_SCRATCH1)
+#define ASSIST_AMR_SCRATCH2 0x1f51
+#define P_ASSIST_AMR_SCRATCH2           CBUS_REG_ADDR(ASSIST_AMR_SCRATCH2)
+#define ASSIST_AMR_SCRATCH3 0x1f52
+#define P_ASSIST_AMR_SCRATCH3           CBUS_REG_ADDR(ASSIST_AMR_SCRATCH3)
+#define ASSIST_HW_REV 0x1f53
+#define P_ASSIST_HW_REV                 CBUS_REG_ADDR(ASSIST_HW_REV)
+#define ASSIST_POR_CONFIG 0x1f55
+#define P_ASSIST_POR_CONFIG             CBUS_REG_ADDR(ASSIST_POR_CONFIG)
+#define ASSIST_SPARE16_REG1 0x1f56
+#define P_ASSIST_SPARE16_REG1           CBUS_REG_ADDR(ASSIST_SPARE16_REG1)
+#define ASSIST_SPARE16_REG2 0x1f57
+#define P_ASSIST_SPARE16_REG2           CBUS_REG_ADDR(ASSIST_SPARE16_REG2)
+#define ASSIST_SPARE8_REG1 0x1f58
+#define P_ASSIST_SPARE8_REG1            CBUS_REG_ADDR(ASSIST_SPARE8_REG1)
+#define ASSIST_SPARE8_REG2 0x1f59
+#define P_ASSIST_SPARE8_REG2            CBUS_REG_ADDR(ASSIST_SPARE8_REG2)
+#define ASSIST_SPARE8_REG3 0x1f5a
+#define P_ASSIST_SPARE8_REG3            CBUS_REG_ADDR(ASSIST_SPARE8_REG3)
+#define AC3_CTRL_REG1 0x1f5b
+#define P_AC3_CTRL_REG1                 CBUS_REG_ADDR(AC3_CTRL_REG1)
+#define AC3_CTRL_REG2 0x1f5c
+#define P_AC3_CTRL_REG2                 CBUS_REG_ADDR(AC3_CTRL_REG2)
+#define AC3_CTRL_REG3 0x1f5d
+#define P_AC3_CTRL_REG3                 CBUS_REG_ADDR(AC3_CTRL_REG3)
+#define AC3_CTRL_REG4 0x1f5e
+#define P_AC3_CTRL_REG4                 CBUS_REG_ADDR(AC3_CTRL_REG4)
+#define ASSIST_GEN_CNTL 0x1f68
+#define P_ASSIST_GEN_CNTL               CBUS_REG_ADDR(ASSIST_GEN_CNTL)
+#define EE_ASSIST_MBOX0_IRQ_REG 0x1f70
+
+#define EE_ASSIST_MBOX3_MASK 0x1f7e
+#define P_EE_ASSIST_MBOX3_MASK          CBUS_REG_ADDR(EE_ASSIST_MBOX3_MASK)
+#define AUDIN_SPDIF_MODE 0x2800
+#define P_AUDIN_SPDIF_MODE              CBUS_REG_ADDR(AUDIN_SPDIF_MODE)
+#define AUDIN_SPDIF_MISC 0x2804
+#define P_AUDIN_SPDIF_MISC              CBUS_REG_ADDR(AUDIN_SPDIF_MISC)
+#define AUDIN_SPDIF_END 0x280f
+#define P_AUDIN_SPDIF_END               CBUS_REG_ADDR(AUDIN_SPDIF_END)
+#define AUDIN_I2SIN_CTRL 0x2810
+#define P_AUDIN_I2SIN_CTRL              CBUS_REG_ADDR(AUDIN_I2SIN_CTRL)
+#define AUDIN_SOURCE_SEL 0x2811
+#define P_AUDIN_SOURCE_SEL              CBUS_REG_ADDR(AUDIN_SOURCE_SEL)
+#define AUDIN_DECODE_FORMAT 0x2812
+#define P_AUDIN_DECODE_FORMAT           CBUS_REG_ADDR(AUDIN_DECODE_FORMAT)
+#define AUDIN_DECODE_CONTROL_STATUS 0x2813
+#define P_AUDIN_DECODE_CONTROL_STATUS           \
+	CBUS_REG_ADDR(AUDIN_DECODE_CONTROL_STATUS)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_0 0x2814
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_0               \
+	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_0)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_1 0x2815
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_1               \
+	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_1)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_2 0x2816
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_2               \
+	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_2)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_3 0x2817
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_3               \
+	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_3)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_4 0x2818
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_4               \
+	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_4)
+#define AUDIN_DECODE_CHANNEL_STATUS_A_5 0x2819
+#define P_AUDIN_DECODE_CHANNEL_STATUS_A_5               \
+	CBUS_REG_ADDR(AUDIN_DECODE_CHANNEL_STATUS_A_5)
+#define AUDIN_FIFO0_START 0x2820
+#define P_AUDIN_FIFO0_START             CBUS_REG_ADDR(AUDIN_FIFO0_START)
+#define AUDIN_FIFO0_END 0x2821
+#define P_AUDIN_FIFO0_END               CBUS_REG_ADDR(AUDIN_FIFO0_END)
+#define AUDIN_FIFO0_PTR 0x2822
+#define P_AUDIN_FIFO0_PTR               CBUS_REG_ADDR(AUDIN_FIFO0_PTR)
+#define AUDIN_FIFO0_INTR 0x2823
+#define P_AUDIN_FIFO0_INTR              CBUS_REG_ADDR(AUDIN_FIFO0_INTR)
+#define AUDIN_FIFO0_RDPTR 0x2824
+#define P_AUDIN_FIFO0_RDPTR             CBUS_REG_ADDR(AUDIN_FIFO0_RDPTR)
+#define AUDIN_FIFO0_CTRL 0x2825
+#define P_AUDIN_FIFO0_CTRL              CBUS_REG_ADDR(AUDIN_FIFO0_CTRL)
+#define AUDIN_FIFO0_CTRL1 0x2826
+#define P_AUDIN_FIFO0_CTRL1             CBUS_REG_ADDR(AUDIN_FIFO0_CTRL1)
+#define AUDIN_FIFO0_LVL0 0x2827
+#define P_AUDIN_FIFO0_LVL0              CBUS_REG_ADDR(AUDIN_FIFO0_LVL0)
+#define AUDIN_FIFO0_LVL1 0x2828
+#define P_AUDIN_FIFO0_LVL1              CBUS_REG_ADDR(AUDIN_FIFO0_LVL1)
+#define AUDIN_FIFO0_LVL2 0x2829
+#define P_AUDIN_FIFO0_LVL2              CBUS_REG_ADDR(AUDIN_FIFO0_LVL2)
+#define AUDIN_FIFO0_REQID 0x2830
+#define P_AUDIN_FIFO0_REQID             CBUS_REG_ADDR(AUDIN_FIFO0_REQID)
+#define AUDIN_FIFO0_WRAP 0x2831
+#define P_AUDIN_FIFO0_WRAP              CBUS_REG_ADDR(AUDIN_FIFO0_WRAP)
+#define AUDIN_FIFO1_START 0x2833
+#define P_AUDIN_FIFO1_START             CBUS_REG_ADDR(AUDIN_FIFO1_START)
+#define AUDIN_FIFO1_END 0x2834
+#define P_AUDIN_FIFO1_END               CBUS_REG_ADDR(AUDIN_FIFO1_END)
+#define AUDIN_FIFO1_PTR 0x2835
+#define P_AUDIN_FIFO1_PTR               CBUS_REG_ADDR(AUDIN_FIFO1_PTR)
+#define AUDIN_FIFO1_INTR 0x2836
+#define P_AUDIN_FIFO1_INTR              CBUS_REG_ADDR(AUDIN_FIFO1_INTR)
+#define AUDIN_FIFO1_RDPTR 0x2837
+#define P_AUDIN_FIFO1_RDPTR             CBUS_REG_ADDR(AUDIN_FIFO1_RDPTR)
+#define AUDIN_FIFO1_CTRL 0x2838
+#define P_AUDIN_FIFO1_CTRL              CBUS_REG_ADDR(AUDIN_FIFO1_CTRL)
+#define AUDIN_FIFO1_CTRL1 0x2839
+#define P_AUDIN_FIFO1_CTRL1             CBUS_REG_ADDR(AUDIN_FIFO1_CTRL1)
+#define AUDIN_FIFO1_LVL0 0x2840
+#define P_AUDIN_FIFO1_LVL0              CBUS_REG_ADDR(AUDIN_FIFO1_LVL0)
+#define AUDIN_FIFO1_LVL1 0x2841
+#define P_AUDIN_FIFO1_LVL1              CBUS_REG_ADDR(AUDIN_FIFO1_LVL1)
+#define AUDIN_FIFO1_LVL2 0x2842
+#define P_AUDIN_FIFO1_LVL2              CBUS_REG_ADDR(AUDIN_FIFO1_LVL2)
+#define AUDIN_FIFO1_REQID 0x2843
+#define P_AUDIN_FIFO1_REQID             CBUS_REG_ADDR(AUDIN_FIFO1_REQID)
+#define AUDIN_FIFO1_WRAP 0x2844
+#define P_AUDIN_FIFO1_WRAP              CBUS_REG_ADDR(AUDIN_FIFO1_WRAP)
+#define AUDIN_FIFO2_START 0x2845
+#define P_AUDIN_FIFO2_START             CBUS_REG_ADDR(AUDIN_FIFO2_START)
+#define AUDIN_FIFO2_END 0x2846
+#define P_AUDIN_FIFO2_END               CBUS_REG_ADDR(AUDIN_FIFO2_END)
+#define AUDIN_FIFO2_PTR 0x2847
+#define P_AUDIN_FIFO2_PTR               CBUS_REG_ADDR(AUDIN_FIFO2_PTR)
+#define AUDIN_FIFO2_INTR 0x2848
+#define P_AUDIN_FIFO2_INTR              CBUS_REG_ADDR(AUDIN_FIFO2_INTR)
+#define AUDIN_FIFO2_RDPTR 0x2849
+#define P_AUDIN_FIFO2_RDPTR             CBUS_REG_ADDR(AUDIN_FIFO2_RDPTR)
+#define AUDIN_FIFO2_CTRL 0x284a
+#define P_AUDIN_FIFO2_CTRL              CBUS_REG_ADDR(AUDIN_FIFO2_CTRL)
+#define AUDIN_FIFO2_CTRL1 0x284b
+#define P_AUDIN_FIFO2_CTRL1             CBUS_REG_ADDR(AUDIN_FIFO2_CTRL1)
+#define AUDIN_FIFO2_LVL0 0x284c
+#define P_AUDIN_FIFO2_LVL0              CBUS_REG_ADDR(AUDIN_FIFO2_LVL0)
+#define AUDIN_FIFO2_LVL1 0x284d
+#define P_AUDIN_FIFO2_LVL1              CBUS_REG_ADDR(AUDIN_FIFO2_LVL1)
+#define AUDIN_FIFO2_LVL2 0x284e
+#define P_AUDIN_FIFO2_LVL2              CBUS_REG_ADDR(AUDIN_FIFO2_LVL2)
+#define AUDIN_FIFO2_REQID 0x284f
+#define P_AUDIN_FIFO2_REQID             CBUS_REG_ADDR(AUDIN_FIFO2_REQID)
+#define AUDIN_FIFO2_WRAP 0x2850
+#define P_AUDIN_FIFO2_WRAP              CBUS_REG_ADDR(AUDIN_FIFO2_WRAP)
+#define AUDIN_INT_CTRL 0x2851
+#define P_AUDIN_INT_CTRL                CBUS_REG_ADDR(AUDIN_INT_CTRL)
+#define AUDIN_FIFO_INT 0x2852
+#define P_AUDIN_FIFO_INT                CBUS_REG_ADDR(AUDIN_FIFO_INT)
+#define PCMIN_CTRL0 0x2860
+#define P_PCMIN_CTRL0           CBUS_REG_ADDR(PCMIN_CTRL0)
+#define PCMIN_CTRL1 0x2861
+#define P_PCMIN_CTRL1           CBUS_REG_ADDR(PCMIN_CTRL1)
+#define PCMIN1_CTRL0 0x2862
+#define P_PCMIN1_CTRL0          CBUS_REG_ADDR(PCMIN1_CTRL0)
+#define PCMIN1_CTRL1 0x2863
+#define P_PCMIN1_CTRL1          CBUS_REG_ADDR(PCMIN1_CTRL1)
+#define PCMOUT_CTRL0 0x2870
+#define P_PCMOUT_CTRL0          CBUS_REG_ADDR(PCMOUT_CTRL0)
+#define PCMOUT_CTRL1 0x2871
+#define P_PCMOUT_CTRL1          CBUS_REG_ADDR(PCMOUT_CTRL1)
+#define PCMOUT_CTRL2 0x2872
+#define P_PCMOUT_CTRL2          CBUS_REG_ADDR(PCMOUT_CTRL2)
+#define PCMOUT_CTRL3 0x2873
+#define P_PCMOUT_CTRL3          CBUS_REG_ADDR(PCMOUT_CTRL3)
+#define PCMOUT1_CTRL0 0x2874
+#define P_PCMOUT1_CTRL0                 CBUS_REG_ADDR(PCMOUT1_CTRL0)
+#define PCMOUT1_CTRL1 0x2875
+#define P_PCMOUT1_CTRL1                 CBUS_REG_ADDR(PCMOUT1_CTRL1)
+#define PCMOUT1_CTRL2 0x2876
+#define P_PCMOUT1_CTRL2                 CBUS_REG_ADDR(PCMOUT1_CTRL2)
+#define PCMOUT1_CTRL3 0x2877
+#define P_PCMOUT1_CTRL3                 CBUS_REG_ADDR(PCMOUT1_CTRL3)
+#define AUDOUT_CTRL 0x2880
+#define P_AUDOUT_CTRL           CBUS_REG_ADDR(AUDOUT_CTRL)
+#define AUDOUT_CTRL1 0x2881
+#define P_AUDOUT_CTRL1          CBUS_REG_ADDR(AUDOUT_CTRL1)
+#define AUDOUT_BUF0_STA 0x2882
+#define P_AUDOUT_BUF0_STA               CBUS_REG_ADDR(AUDOUT_BUF0_STA)
+#define AUDOUT_BUF0_EDA 0x2883
+#define P_AUDOUT_BUF0_EDA               CBUS_REG_ADDR(AUDOUT_BUF0_EDA)
+#define AUDOUT_BUF0_WPTR 0x2884
+#define P_AUDOUT_BUF0_WPTR              CBUS_REG_ADDR(AUDOUT_BUF0_WPTR)
+#define AUDOUT_BUF1_STA 0x2885
+#define P_AUDOUT_BUF1_STA               CBUS_REG_ADDR(AUDOUT_BUF1_STA)
+#define AUDOUT_BUF1_EDA 0x2886
+#define P_AUDOUT_BUF1_EDA               CBUS_REG_ADDR(AUDOUT_BUF1_EDA)
+#define AUDOUT_BUF1_WPTR 0x2887
+#define P_AUDOUT_BUF1_WPTR              CBUS_REG_ADDR(AUDOUT_BUF1_WPTR)
+#define AUDOUT_FIFO_RPTR 0x2888
+#define P_AUDOUT_FIFO_RPTR              CBUS_REG_ADDR(AUDOUT_FIFO_RPTR)
+#define AUDOUT_INTR_PTR 0x2889
+#define P_AUDOUT_INTR_PTR               CBUS_REG_ADDR(AUDOUT_INTR_PTR)
+#define AUDOUT_FIFO_STS 0x288a
+#define P_AUDOUT_FIFO_STS               CBUS_REG_ADDR(AUDOUT_FIFO_STS)
+#define AUDOUT1_CTRL 0x2890
+#define P_AUDOUT1_CTRL          CBUS_REG_ADDR(AUDOUT1_CTRL)
+#define AUDOUT1_CTRL1 0x2891
+#define P_AUDOUT1_CTRL1                 CBUS_REG_ADDR(AUDOUT1_CTRL1)
+#define AUDOUT1_BUF0_STA 0x2892
+#define P_AUDOUT1_BUF0_STA              CBUS_REG_ADDR(AUDOUT1_BUF0_STA)
+#define AUDOUT1_BUF0_EDA 0x2893
+#define P_AUDOUT1_BUF0_EDA              CBUS_REG_ADDR(AUDOUT1_BUF0_EDA)
+#define AUDOUT1_BUF0_WPTR 0x2894
+#define P_AUDOUT1_BUF0_WPTR             CBUS_REG_ADDR(AUDOUT1_BUF0_WPTR)
+#define AUDOUT1_BUF1_STA 0x2895
+#define P_AUDOUT1_BUF1_STA              CBUS_REG_ADDR(AUDOUT1_BUF1_STA)
+#define AUDOUT1_BUF1_EDA 0x2896
+#define P_AUDOUT1_BUF1_EDA              CBUS_REG_ADDR(AUDOUT1_BUF1_EDA)
+#define AUDOUT1_BUF1_WPTR 0x2897
+#define P_AUDOUT1_BUF1_WPTR             CBUS_REG_ADDR(AUDOUT1_BUF1_WPTR)
+#define AUDOUT1_FIFO_RPTR 0x2898
+#define P_AUDOUT1_FIFO_RPTR             CBUS_REG_ADDR(AUDOUT1_FIFO_RPTR)
+#define AUDOUT1_INTR_PTR 0x2899
+#define P_AUDOUT1_INTR_PTR              CBUS_REG_ADDR(AUDOUT1_INTR_PTR)
+#define AUDOUT1_FIFO_STS 0x289a
+#define P_AUDOUT1_FIFO_STS              CBUS_REG_ADDR(AUDOUT1_FIFO_STS)
+#define AUDIN_HDMI_MEAS_CTRL 0x28a0
+#define P_AUDIN_HDMI_MEAS_CTRL          CBUS_REG_ADDR(AUDIN_HDMI_MEAS_CTRL)
+#define AUDIN_HDMI_MEAS_CYCLES_M1 0x28a1
+#define AUDIN_FIFO0_PIO_STS 0x28b0
+#define P_AUDIN_FIFO0_PIO_STS           CBUS_REG_ADDR(AUDIN_FIFO0_PIO_STS)
+#define AUDIN_FIFO0_PIO_RDL 0x28b1
+#define P_AUDIN_FIFO0_PIO_RDL           CBUS_REG_ADDR(AUDIN_FIFO0_PIO_RDL)
+#define AUDIN_FIFO0_PIO_RDH 0x28b2
+#define P_AUDIN_FIFO0_PIO_RDH           CBUS_REG_ADDR(AUDIN_FIFO0_PIO_RDH)
+#define AUDIN_FIFO1_PIO_STS 0x28b3
+#define P_AUDIN_FIFO1_PIO_STS           CBUS_REG_ADDR(AUDIN_FIFO1_PIO_STS)
+#define AUDIN_FIFO1_PIO_RDL 0x28b4
+#define P_AUDIN_FIFO1_PIO_RDL           CBUS_REG_ADDR(AUDIN_FIFO1_PIO_RDL)
+#define AUDIN_FIFO1_PIO_RDH 0x28b5
+#define P_AUDIN_FIFO1_PIO_RDH           CBUS_REG_ADDR(AUDIN_FIFO1_PIO_RDH)
+#define AUDIN_FIFO2_PIO_STS 0x28b6
+#define P_AUDIN_FIFO2_PIO_STS           CBUS_REG_ADDR(AUDIN_FIFO2_PIO_STS)
+#define AUDIN_FIFO2_PIO_RDL 0x28b7
+#define P_AUDIN_FIFO2_PIO_RDL           CBUS_REG_ADDR(AUDIN_FIFO2_PIO_RDL)
+#define AUDIN_FIFO2_PIO_RDH 0x28b8
+#define P_AUDIN_FIFO2_PIO_RDH           CBUS_REG_ADDR(AUDIN_FIFO2_PIO_RDH)
+#define AUDOUT_FIFO_PIO_STS 0x28b9
+#define P_AUDOUT_FIFO_PIO_STS           CBUS_REG_ADDR(AUDOUT_FIFO_PIO_STS)
+#define AUDOUT_FIFO_PIO_WRL 0x28ba
+#define P_AUDOUT_FIFO_PIO_WRL           CBUS_REG_ADDR(AUDOUT_FIFO_PIO_WRL)
+#define AUDOUT_FIFO_PIO_WRH 0x28bb
+#define P_AUDOUT_FIFO_PIO_WRH           CBUS_REG_ADDR(AUDOUT_FIFO_PIO_WRH)
+#define AUDOUT1_FIFO_PIO_STS 0x28bc
+#define P_AUDOUT1_FIFO_PIO_STS          CBUS_REG_ADDR(AUDOUT1_FIFO_PIO_STS)
+#define AUDOUT1_FIFO_PIO_WRL 0x28bd
+#define P_AUDOUT1_FIFO_PIO_WRL          CBUS_REG_ADDR(AUDOUT1_FIFO_PIO_WRL)
+#define AUDOUT1_FIFO_PIO_WRH 0x28be
+#define P_AUDOUT1_FIFO_PIO_WRH          CBUS_REG_ADDR(AUDOUT1_FIFO_PIO_WRH)
+#define AUDIN_ADDR_END 0x28bf
+#define P_AUDIN_ADDR_END                CBUS_REG_ADDR(AUDIN_ADDR_END)
+#define VDIN_SCALE_COEF_IDX 0x1200
+#define P_VDIN_SCALE_COEF_IDX           VCBUS_REG_ADDR(VDIN_SCALE_COEF_IDX)
+#define VDIN_SCALE_COEF 0x1201
+#define P_VDIN_SCALE_COEF               VCBUS_REG_ADDR(VDIN_SCALE_COEF)
+#define VDIN_COM_CTRL0 0x1202
+#define P_VDIN_COM_CTRL0                VCBUS_REG_ADDR(VDIN_COM_CTRL0)
+#define VDIN_ACTIVE_MAX_PIX_CNT_STATUS 0x1203
+#define VDIN_LCNT_STATUS 0x1204
+#define P_VDIN_LCNT_STATUS              VCBUS_REG_ADDR(VDIN_LCNT_STATUS)
+#define VDIN_COM_STATUS0 0x1205
+#define P_VDIN_COM_STATUS0              VCBUS_REG_ADDR(VDIN_COM_STATUS0)
+#define VDIN_COM_STATUS1 0x1206
+#define P_VDIN_COM_STATUS1              VCBUS_REG_ADDR(VDIN_COM_STATUS1)
+#define VDIN_LCNT_SHADOW_STATUS 0x1207
+#define VDIN_ASFIFO_CTRL0 0x1208
+#define P_VDIN_ASFIFO_CTRL0             VCBUS_REG_ADDR(VDIN_ASFIFO_CTRL0)
+#define VDIN_ASFIFO_CTRL1 0x1209
+#define P_VDIN_ASFIFO_CTRL1             VCBUS_REG_ADDR(VDIN_ASFIFO_CTRL1)
+#define VDIN_WIDTHM1I_WIDTHM1O 0x120a
+#define VDIN_SC_MISC_CTRL 0x120b
+#define P_VDIN_SC_MISC_CTRL             VCBUS_REG_ADDR(VDIN_SC_MISC_CTRL)
+#define VDIN_HSC_PHASE_STEP 0x120c
+#define P_VDIN_HSC_PHASE_STEP           VCBUS_REG_ADDR(VDIN_HSC_PHASE_STEP)
+#define VDIN_HSC_INI_CTRL 0x120d
+#define P_VDIN_HSC_INI_CTRL             VCBUS_REG_ADDR(VDIN_HSC_INI_CTRL)
+#define VDIN_COM_STATUS2 0x120e
+#define P_VDIN_COM_STATUS2              VCBUS_REG_ADDR(VDIN_COM_STATUS2)
+#define VDIN_ASFIFO_CTRL2 0x120f
+#define P_VDIN_ASFIFO_CTRL2             VCBUS_REG_ADDR(VDIN_ASFIFO_CTRL2)
+#define VDIN_MATRIX_CTRL 0x1210
+#define P_VDIN_MATRIX_CTRL              VCBUS_REG_ADDR(VDIN_MATRIX_CTRL)
+#define VDIN_LFIFO_CTRL 0x121a
+#define P_VDIN_LFIFO_CTRL               VCBUS_REG_ADDR(VDIN_LFIFO_CTRL)
+#define VDIN_COM_GCLK_CTRL 0x121b
+#define P_VDIN_COM_GCLK_CTRL            VCBUS_REG_ADDR(VDIN_COM_GCLK_CTRL)
+#define VDIN_INTF_WIDTHM1 0x121c
+#define P_VDIN_INTF_WIDTHM1             VCBUS_REG_ADDR(VDIN_INTF_WIDTHM1)
+#define VDIN_WR_CTRL2 0x121f
+#define P_VDIN_WR_CTRL2                 VCBUS_REG_ADDR(VDIN_WR_CTRL2)
+#define VDIN_WR_CTRL 0x1220
+#define P_VDIN_WR_CTRL          VCBUS_REG_ADDR(VDIN_WR_CTRL)
+#define VDIN_WR_H_START_END 0x1221
+#define P_VDIN_WR_H_START_END           VCBUS_REG_ADDR(VDIN_WR_H_START_END)
+#define VDIN_WR_V_START_END 0x1222
+#define P_VDIN_WR_V_START_END           VCBUS_REG_ADDR(VDIN_WR_V_START_END)
+#define VDIN_VSC_PHASE_STEP 0x1223
+#define P_VDIN_VSC_PHASE_STEP           VCBUS_REG_ADDR(VDIN_VSC_PHASE_STEP)
+#define VDIN_VSC_INI_CTRL 0x1224
+#define P_VDIN_VSC_INI_CTRL             VCBUS_REG_ADDR(VDIN_VSC_INI_CTRL)
+#define VDIN_SCIN_HEIGHTM1 0x1225
+#define P_VDIN_SCIN_HEIGHTM1            VCBUS_REG_ADDR(VDIN_SCIN_HEIGHTM1)
+#define VDIN_DUMMY_DATA 0x1226
+#define P_VDIN_DUMMY_DATA               VCBUS_REG_ADDR(VDIN_DUMMY_DATA)
+#define VDIN_HIST_MAX_MIN 0x1233
+#define P_VDIN_HIST_MAX_MIN             VCBUS_REG_ADDR(VDIN_HIST_MAX_MIN)
+#define VDIN_HIST_SPL_VAL 0x1234
+#define P_VDIN_HIST_SPL_VAL             VCBUS_REG_ADDR(VDIN_HIST_SPL_VAL)
+#define VDIN_HIST_SPL_PIX_CNT 0x1235
+#define P_VDIN_HIST_CHROMA_SUM          VCBUS_REG_ADDR(VDIN_HIST_CHROMA_SUM)
+#define VDIN_DNLP_HIST00 0x1237
+#define P_VDIN_DNLP_HIST00              VCBUS_REG_ADDR(VDIN_DNLP_HIST00)
+#define VDIN_DNLP_HIST01 0x1238
+#define P_VDIN_DNLP_HIST01              VCBUS_REG_ADDR(VDIN_DNLP_HIST01)
+#define VDIN_DNLP_HIST02 0x1239
+#define P_VDIN_DNLP_HIST02              VCBUS_REG_ADDR(VDIN_DNLP_HIST02)
+#define VDIN_DNLP_HIST03 0x123a
+#define P_VDIN_DNLP_HIST03              VCBUS_REG_ADDR(VDIN_DNLP_HIST03)
+#define VDIN_DNLP_HIST04 0x123b
+#define P_VDIN_DNLP_HIST04              VCBUS_REG_ADDR(VDIN_DNLP_HIST04)
+#define VDIN_DNLP_HIST05 0x123c
+#define P_VDIN_DNLP_HIST05              VCBUS_REG_ADDR(VDIN_DNLP_HIST05)
+#define VDIN_DNLP_HIST06 0x123d
+#define P_VDIN_DNLP_HIST06              VCBUS_REG_ADDR(VDIN_DNLP_HIST06)
+#define VDIN_DNLP_HIST07 0x123e
+#define P_VDIN_DNLP_HIST07              VCBUS_REG_ADDR(VDIN_DNLP_HIST07)
+#define VDIN_DNLP_HIST08 0x123f
+#define P_VDIN_DNLP_HIST08              VCBUS_REG_ADDR(VDIN_DNLP_HIST08)
+#define VDIN_DNLP_HIST09 0x1240
+#define P_VDIN_DNLP_HIST09              VCBUS_REG_ADDR(VDIN_DNLP_HIST09)
+#define VDIN_DNLP_HIST10 0x1241
+#define P_VDIN_DNLP_HIST10              VCBUS_REG_ADDR(VDIN_DNLP_HIST10)
+#define VDIN_DNLP_HIST11 0x1242
+#define P_VDIN_DNLP_HIST11              VCBUS_REG_ADDR(VDIN_DNLP_HIST11)
+#define VDIN_DNLP_HIST12 0x1243
+#define P_VDIN_DNLP_HIST12              VCBUS_REG_ADDR(VDIN_DNLP_HIST12)
+#define VDIN_DNLP_HIST13 0x1244
+#define P_VDIN_DNLP_HIST13              VCBUS_REG_ADDR(VDIN_DNLP_HIST13)
+#define VDIN_DNLP_HIST14 0x1245
+#define P_VDIN_DNLP_HIST14              VCBUS_REG_ADDR(VDIN_DNLP_HIST14)
+#define VDIN_DNLP_HIST15 0x1246
+#define P_VDIN_DNLP_HIST15              VCBUS_REG_ADDR(VDIN_DNLP_HIST15)
+#define VDIN_DNLP_HIST16 0x1247
+#define P_VDIN_DNLP_HIST16              VCBUS_REG_ADDR(VDIN_DNLP_HIST16)
+#define VDIN_DNLP_HIST17 0x1248
+#define P_VDIN_DNLP_HIST17              VCBUS_REG_ADDR(VDIN_DNLP_HIST17)
+#define VDIN_DNLP_HIST18 0x1249
+#define P_VDIN_DNLP_HIST18              VCBUS_REG_ADDR(VDIN_DNLP_HIST18)
+#define VDIN_DNLP_HIST19 0x124a
+#define P_VDIN_DNLP_HIST19              VCBUS_REG_ADDR(VDIN_DNLP_HIST19)
+#define VDIN_DNLP_HIST20 0x124b
+#define P_VDIN_DNLP_HIST20              VCBUS_REG_ADDR(VDIN_DNLP_HIST20)
+#define VDIN_DNLP_HIST21 0x124c
+#define P_VDIN_DNLP_HIST21              VCBUS_REG_ADDR(VDIN_DNLP_HIST21)
+#define VDIN_DNLP_HIST22 0x124d
+#define P_VDIN_DNLP_HIST22              VCBUS_REG_ADDR(VDIN_DNLP_HIST22)
+#define VDIN_DNLP_HIST23 0x124e
+#define P_VDIN_DNLP_HIST23              VCBUS_REG_ADDR(VDIN_DNLP_HIST23)
+#define VDIN_DNLP_HIST24 0x124f
+#define P_VDIN_DNLP_HIST24              VCBUS_REG_ADDR(VDIN_DNLP_HIST24)
+#define VDIN_DNLP_HIST25 0x1250
+#define P_VDIN_DNLP_HIST25              VCBUS_REG_ADDR(VDIN_DNLP_HIST25)
+#define VDIN_DNLP_HIST26 0x1251
+#define P_VDIN_DNLP_HIST26              VCBUS_REG_ADDR(VDIN_DNLP_HIST26)
+#define VDIN_DNLP_HIST27 0x1252
+#define P_VDIN_DNLP_HIST27              VCBUS_REG_ADDR(VDIN_DNLP_HIST27)
+#define VDIN_DNLP_HIST28 0x1253
+#define P_VDIN_DNLP_HIST28              VCBUS_REG_ADDR(VDIN_DNLP_HIST28)
+#define VDIN_DNLP_HIST29 0x1254
+#define P_VDIN_DNLP_HIST29              VCBUS_REG_ADDR(VDIN_DNLP_HIST29)
+#define VDIN_DNLP_HIST30 0x1255
+#define P_VDIN_DNLP_HIST30              VCBUS_REG_ADDR(VDIN_DNLP_HIST30)
+#define VDIN_DNLP_HIST31 0x1256
+#define P_VDIN_DNLP_HIST31              VCBUS_REG_ADDR(VDIN_DNLP_HIST31)
+
+#define P_VDIN1_ASFIFO_CTRL3            VCBUS_REG_ADDR(VDIN1_ASFIFO_CTRL3)
+#define VPP_DUMMY_DATA 0x1d00
+#define P_VPP_DUMMY_DATA                VCBUS_REG_ADDR(VPP_DUMMY_DATA)
+#define VPP_LINE_IN_LENGTH 0x1d01
+#define P_VPP_LINE_IN_LENGTH            VCBUS_REG_ADDR(VPP_LINE_IN_LENGTH)
+#define VPP_PIC_IN_HEIGHT 0x1d02
+#define P_VPP_PIC_IN_HEIGHT             VCBUS_REG_ADDR(VPP_PIC_IN_HEIGHT)
+#define VPP_SCALE_COEF_IDX 0x1d03
+#define P_VPP_SCALE_COEF_IDX            VCBUS_REG_ADDR(VPP_SCALE_COEF_IDX)
+#define VPP_SCALE_COEF 0x1d04
+#define P_VPP_SCALE_COEF                VCBUS_REG_ADDR(VPP_SCALE_COEF)
+
+#define VPP_VSC_PHASE_CTRL 0x1d0d
+#define P_VPP_VSC_PHASE_CTRL            VCBUS_REG_ADDR(VPP_VSC_PHASE_CTRL)
+#define VPP_VSC_INI_PHASE 0x1d0e
+#define P_VPP_VSC_INI_PHASE             VCBUS_REG_ADDR(VPP_VSC_INI_PHASE)
+#define VPP_HSC_REGION12_STARTP 0x1d10
+
+#define VPP_DUMMY_DATA1 0x1d69
+#define P_VPP_DUMMY_DATA1               VCBUS_REG_ADDR(VPP_DUMMY_DATA1)
+#define VPP_GAINOFF_CTRL0 0x1d6a
+#define P_VPP_GAINOFF_CTRL0             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL0)
+#define VPP_GAINOFF_CTRL1 0x1d6b
+#define P_VPP_GAINOFF_CTRL1             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL1)
+#define VPP_GAINOFF_CTRL2 0x1d6c
+#define P_VPP_GAINOFF_CTRL2             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL2)
+#define VPP_GAINOFF_CTRL3 0x1d6d
+#define P_VPP_GAINOFF_CTRL3             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL3)
+#define VPP_GAINOFF_CTRL4 0x1d6e
+#define P_VPP_GAINOFF_CTRL4             VCBUS_REG_ADDR(VPP_GAINOFF_CTRL4)
+#define VPP_CHROMA_ADDR_PORT 0x1d70
+#define P_VPP_CHROMA_ADDR_PORT          VCBUS_REG_ADDR(VPP_CHROMA_ADDR_PORT)
+#define VPP_CHROMA_DATA_PORT 0x1d71
+#define P_VPP_CHROMA_DATA_PORT          VCBUS_REG_ADDR(VPP_CHROMA_DATA_PORT)
+#define VPP_GCLK_CTRL0 0x1d72
+#define P_VPP_GCLK_CTRL0                VCBUS_REG_ADDR(VPP_GCLK_CTRL0)
+#define VPP_GCLK_CTRL1 0x1d73
+#define P_VPP_GCLK_CTRL1                VCBUS_REG_ADDR(VPP_GCLK_CTRL1)
+#define VPP_SC_GCLK_CTRL 0x1d74
+#define P_VPP_SC_GCLK_CTRL              VCBUS_REG_ADDR(VPP_SC_GCLK_CTRL)
+#define VPP_MISC1 0x1d76
+#define P_VPP_MISC1             VCBUS_REG_ADDR(VPP_MISC1)
+#define VPP_BLACKEXT_CTRL 0x1d80
+#define P_VPP_BLACKEXT_CTRL             VCBUS_REG_ADDR(VPP_BLACKEXT_CTRL)
+#define VPP_DNLP_CTRL_00 0x1d81
+#define P_VPP_DNLP_CTRL_00              VCBUS_REG_ADDR(VPP_DNLP_CTRL_00)
+#define VPP_DNLP_CTRL_01 0x1d82
+#define P_VPP_DNLP_CTRL_01              VCBUS_REG_ADDR(VPP_DNLP_CTRL_01)
+#define VPP_DNLP_CTRL_02 0x1d83
+#define P_VPP_DNLP_CTRL_02              VCBUS_REG_ADDR(VPP_DNLP_CTRL_02)
+#define VPP_DNLP_CTRL_03 0x1d84
+#define P_VPP_DNLP_CTRL_03              VCBUS_REG_ADDR(VPP_DNLP_CTRL_03)
+#define VPP_DNLP_CTRL_04 0x1d85
+#define P_VPP_DNLP_CTRL_04              VCBUS_REG_ADDR(VPP_DNLP_CTRL_04)
+#define VPP_DNLP_CTRL_05 0x1d86
+#define P_VPP_DNLP_CTRL_05              VCBUS_REG_ADDR(VPP_DNLP_CTRL_05)
+#define VPP_DNLP_CTRL_06 0x1d87
+#define P_VPP_DNLP_CTRL_06              VCBUS_REG_ADDR(VPP_DNLP_CTRL_06)
+#define VPP_DNLP_CTRL_07 0x1d88
+#define P_VPP_DNLP_CTRL_07              VCBUS_REG_ADDR(VPP_DNLP_CTRL_07)
+#define VPP_DNLP_CTRL_08 0x1d89
+#define P_VPP_DNLP_CTRL_08              VCBUS_REG_ADDR(VPP_DNLP_CTRL_08)
+#define VPP_DNLP_CTRL_09 0x1d8a
+#define P_VPP_DNLP_CTRL_09              VCBUS_REG_ADDR(VPP_DNLP_CTRL_09)
+#define VPP_DNLP_CTRL_10 0x1d8b
+#define P_VPP_DNLP_CTRL_10              VCBUS_REG_ADDR(VPP_DNLP_CTRL_10)
+#define VPP_DNLP_CTRL_11 0x1d8c
+#define P_VPP_DNLP_CTRL_11              VCBUS_REG_ADDR(VPP_DNLP_CTRL_11)
+#define VPP_DNLP_CTRL_12 0x1d8d
+#define P_VPP_DNLP_CTRL_12              VCBUS_REG_ADDR(VPP_DNLP_CTRL_12)
+#define VPP_DNLP_CTRL_13 0x1d8e
+#define P_VPP_DNLP_CTRL_13              VCBUS_REG_ADDR(VPP_DNLP_CTRL_13)
+#define VPP_DNLP_CTRL_14 0x1d8f
+#define P_VPP_DNLP_CTRL_14              VCBUS_REG_ADDR(VPP_DNLP_CTRL_14)
+#define VPP_DNLP_CTRL_15 0x1d90
+#define P_VPP_DNLP_CTRL_15              VCBUS_REG_ADDR(VPP_DNLP_CTRL_15)
+#define VPP_PEAKING_HGAIN 0x1d91
+#define P_VPP_PEAKING_HGAIN             VCBUS_REG_ADDR(VPP_PEAKING_HGAIN)
+#define VPP_PEAKING_VGAIN 0x1d92
+#define P_VPP_PEAKING_VGAIN             VCBUS_REG_ADDR(VPP_PEAKING_VGAIN)
+#define VPP_PEAKING_NLP_1 0x1d93
+#define P_VPP_PEAKING_NLP_1             VCBUS_REG_ADDR(VPP_PEAKING_NLP_1)
+#define VPP_PEAKING_NLP_2 0x1d94
+#define P_VPP_PEAKING_NLP_2             VCBUS_REG_ADDR(VPP_PEAKING_NLP_2)
+#define VPP_PEAKING_NLP_3 0x1d95
+#define P_VPP_PEAKING_NLP_3             VCBUS_REG_ADDR(VPP_PEAKING_NLP_3)
+#define VPP_PEAKING_NLP_4 0x1d96
+#define P_VPP_PEAKING_NLP_4             VCBUS_REG_ADDR(VPP_PEAKING_NLP_4)
+#define VPP_PEAKING_NLP_5 0x1d97
+#define P_VPP_PEAKING_NLP_5             VCBUS_REG_ADDR(VPP_PEAKING_NLP_5)
+#define VPP_SHARP_LIMIT 0x1d98
+#define P_VPP_SHARP_LIMIT               VCBUS_REG_ADDR(VPP_SHARP_LIMIT)
+#define VPP_VLTI_CTRL 0x1d99
+#define P_VPP_VLTI_CTRL                 VCBUS_REG_ADDR(VPP_VLTI_CTRL)
+#define VPP_HLTI_CTRL 0x1d9a
+#define P_VPP_HLTI_CTRL                 VCBUS_REG_ADDR(VPP_HLTI_CTRL)
+#define VPP_CTI_CTRL 0x1d9b
+#define P_VPP_CTI_CTRL          VCBUS_REG_ADDR(VPP_CTI_CTRL)
+#define VPP_BLUE_STRETCH_1 0x1d9c
+#define P_VPP_BLUE_STRETCH_1            VCBUS_REG_ADDR(VPP_BLUE_STRETCH_1)
+#define VPP_BLUE_STRETCH_2 0x1d9d
+#define P_VPP_BLUE_STRETCH_2            VCBUS_REG_ADDR(VPP_BLUE_STRETCH_2)
+#define VPP_BLUE_STRETCH_3 0x1d9e
+#define P_VPP_BLUE_STRETCH_3            VCBUS_REG_ADDR(VPP_BLUE_STRETCH_3)
+#define VPP_CCORING_CTRL 0x1da0
+#define P_VPP_CCORING_CTRL              VCBUS_REG_ADDR(VPP_CCORING_CTRL)
+#define VPP_VE_ENABLE_CTRL 0x1da1
+#define P_VPP_VE_ENABLE_CTRL            VCBUS_REG_ADDR(VPP_VE_ENABLE_CTRL)
+#define VPP_INPUT_CTRL 0x1dab
+#define P_VPP_INPUT_CTRL                VCBUS_REG_ADDR(VPP_INPUT_CTRL)
+#define VPP_CTI_CTRL2 0x1dac
+#define P_VPP_CTI_CTRL2                 VCBUS_REG_ADDR(VPP_CTI_CTRL2)
+#define VPP_PEAKING_SAT_THD1 0x1dad
+#define P_VPP_PEAKING_SAT_THD1          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD1)
+#define VPP_PEAKING_SAT_THD2 0x1dae
+#define P_VPP_PEAKING_SAT_THD2          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD2)
+#define VPP_PEAKING_SAT_THD3 0x1daf
+#define P_VPP_PEAKING_SAT_THD3          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD3)
+#define VPP_PEAKING_SAT_THD4 0x1db0
+#define P_VPP_PEAKING_SAT_THD4          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD4)
+#define VPP_PEAKING_SAT_THD5 0x1db1
+#define P_VPP_PEAKING_SAT_THD5          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD5)
+#define VPP_PEAKING_SAT_THD6 0x1db2
+#define P_VPP_PEAKING_SAT_THD6          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD6)
+#define VPP_PEAKING_SAT_THD7 0x1db3
+#define P_VPP_PEAKING_SAT_THD7          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD7)
+#define VPP_PEAKING_SAT_THD8 0x1db4
+#define P_VPP_PEAKING_SAT_THD8          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD8)
+#define VPP_PEAKING_SAT_THD9 0x1db5
+#define P_VPP_PEAKING_SAT_THD9          VCBUS_REG_ADDR(VPP_PEAKING_SAT_THD9)
+#define VPP_PEAKING_GAIN_ADD1 0x1db6
+#define VPP2_GCLK_CTRL0 0x1972
+#define P_VPP2_GCLK_CTRL0               VCBUS_REG_ADDR(VPP2_GCLK_CTRL0)
+#define VPP2_GCLK_CTRL1 0x1973
+#define P_VPP2_GCLK_CTRL1               VCBUS_REG_ADDR(VPP2_GCLK_CTRL1)
+#define VPP2_SC_GCLK_CTRL 0x1974
+#define P_VPP2_SC_GCLK_CTRL             VCBUS_REG_ADDR(VPP2_SC_GCLK_CTRL)
+#define VPP2_MISC1 0x1976
+#define P_VPP2_MISC1            VCBUS_REG_ADDR(VPP2_MISC1)
+#define VPP2_DNLP_CTRL_00 0x1981
+#define P_VPP2_DNLP_CTRL_00             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_00)
+#define VPP2_DNLP_CTRL_01 0x1982
+#define P_VPP2_DNLP_CTRL_01             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_01)
+#define VPP2_DNLP_CTRL_02 0x1983
+#define P_VPP2_DNLP_CTRL_02             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_02)
+#define VPP2_DNLP_CTRL_03 0x1984
+#define P_VPP2_DNLP_CTRL_03             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_03)
+#define VPP2_DNLP_CTRL_04 0x1985
+#define P_VPP2_DNLP_CTRL_04             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_04)
+#define VPP2_DNLP_CTRL_05 0x1986
+#define P_VPP2_DNLP_CTRL_05             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_05)
+#define VPP2_DNLP_CTRL_06 0x1987
+#define P_VPP2_DNLP_CTRL_06             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_06)
+#define VPP2_DNLP_CTRL_07 0x1988
+#define P_VPP2_DNLP_CTRL_07             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_07)
+#define VPP2_DNLP_CTRL_08 0x1989
+#define P_VPP2_DNLP_CTRL_08             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_08)
+#define VPP2_DNLP_CTRL_09 0x198a
+#define P_VPP2_DNLP_CTRL_09             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_09)
+#define VPP2_DNLP_CTRL_10 0x198b
+#define P_VPP2_DNLP_CTRL_10             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_10)
+#define VPP2_DNLP_CTRL_11 0x198c
+#define P_VPP2_DNLP_CTRL_11             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_11)
+#define VPP2_DNLP_CTRL_12 0x198d
+#define P_VPP2_DNLP_CTRL_12             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_12)
+#define VPP2_DNLP_CTRL_13 0x198e
+#define P_VPP2_DNLP_CTRL_13             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_13)
+#define VPP2_DNLP_CTRL_14 0x198f
+#define P_VPP2_DNLP_CTRL_14             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_14)
+#define VPP2_DNLP_CTRL_15 0x1990
+#define P_VPP2_DNLP_CTRL_15             VCBUS_REG_ADDR(VPP2_DNLP_CTRL_15)
+#define VPP2_VE_ENABLE_CTRL 0x19a1
+#define P_VPP2_VE_ENABLE_CTRL           VCBUS_REG_ADDR(VPP2_VE_ENABLE_CTRL)
+#define VPP2_VE_DEMO_LEFT_TOP_SCREEN_WIDTH 0x19a2
+#define VPP2_OSD_SCALE_COEF 0x19cd
+#define P_VPP2_OSD_SCALE_COEF           VCBUS_REG_ADDR(VPP2_OSD_SCALE_COEF)
+#define VPP2_INT_LINE_NUM 0x19ce
+#define P_VPP2_INT_LINE_NUM             VCBUS_REG_ADDR(VPP2_INT_LINE_NUM)
+#define VIU_ADDR_START 0x1a00
+#define P_VIU_ADDR_START                VCBUS_REG_ADDR(VIU_ADDR_START)
+#define VIU_ADDR_END 0x1aff
+#define P_VIU_ADDR_END          VCBUS_REG_ADDR(VIU_ADDR_END)
+#define VIU_SW_RESET 0x1a01
+#define P_VIU_SW_RESET          VCBUS_REG_ADDR(VIU_SW_RESET)
+#define VIU_MISC_CTRL0 0x1a06
+#define P_VIU_MISC_CTRL0                VCBUS_REG_ADDR(VIU_MISC_CTRL0)
+#define D2D3_INTF_LENGTH 0x1a08
+#define P_D2D3_INTF_LENGTH              VCBUS_REG_ADDR(D2D3_INTF_LENGTH)
+#define D2D3_INTF_CTRL0 0x1a09
+#define P_D2D3_INTF_CTRL0               VCBUS_REG_ADDR(D2D3_INTF_CTRL0)
+#define VIU_OSD1_CTRL_STAT 0x1a10
+#define P_VIU_OSD1_CTRL_STAT            VCBUS_REG_ADDR(VIU_OSD1_CTRL_STAT)
+#define VIU_OSD1_CTRL_STAT2 0x1a2d
+#define P_VIU_OSD1_CTRL_STAT2           VCBUS_REG_ADDR(VIU_OSD1_CTRL_STAT2)
+#define VIU_OSD1_COLOR_ADDR 0x1a11
+#define P_VIU_OSD1_COLOR_ADDR           VCBUS_REG_ADDR(VIU_OSD1_COLOR_ADDR)
+#define VIU_OSD1_COLOR 0x1a12
+#define P_VIU_OSD1_COLOR                VCBUS_REG_ADDR(VIU_OSD1_COLOR)
+#define VIU_OSD1_TCOLOR_AG0 0x1a17
+#define P_VIU_OSD1_TCOLOR_AG0           VCBUS_REG_ADDR(VIU_OSD1_TCOLOR_AG0)
+#define VIU_OSD1_TCOLOR_AG1 0x1a18
+#define P_VIU_OSD1_TCOLOR_AG1           VCBUS_REG_ADDR(VIU_OSD1_TCOLOR_AG1)
+#define VIU_OSD1_TCOLOR_AG2 0x1a19
+#define P_VIU_OSD1_TCOLOR_AG2           VCBUS_REG_ADDR(VIU_OSD1_TCOLOR_AG2)
+#define VIU_OSD1_TCOLOR_AG3 0x1a1a
+#define P_VIU_OSD1_TCOLOR_AG3           VCBUS_REG_ADDR(VIU_OSD1_TCOLOR_AG3)
+#define VIU_OSD1_BLK0_CFG_W0 0x1a1b
+#define P_VIU_OSD1_BLK0_CFG_W0          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W0)
+#define VIU_OSD1_BLK1_CFG_W0 0x1a1f
+#define P_VIU_OSD1_BLK1_CFG_W0          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W0)
+#define VIU_OSD1_BLK2_CFG_W0 0x1a23
+#define P_VIU_OSD1_BLK2_CFG_W0          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W0)
+#define VIU_OSD1_BLK3_CFG_W0 0x1a27
+#define P_VIU_OSD1_BLK3_CFG_W0          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W0)
+#define VIU_OSD1_BLK0_CFG_W1 0x1a1c
+#define P_VIU_OSD1_BLK0_CFG_W1          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W1)
+#define VIU_OSD1_BLK1_CFG_W1 0x1a20
+#define P_VIU_OSD1_BLK1_CFG_W1          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W1)
+#define VIU_OSD1_BLK2_CFG_W1 0x1a24
+#define P_VIU_OSD1_BLK2_CFG_W1          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W1)
+#define VIU_OSD1_BLK3_CFG_W1 0x1a28
+#define P_VIU_OSD1_BLK3_CFG_W1          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W1)
+#define VIU_OSD1_BLK0_CFG_W2 0x1a1d
+#define P_VIU_OSD1_BLK0_CFG_W2          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W2)
+#define VIU_OSD1_BLK1_CFG_W2 0x1a21
+#define P_VIU_OSD1_BLK1_CFG_W2          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W2)
+#define VIU_OSD1_BLK2_CFG_W2 0x1a25
+#define P_VIU_OSD1_BLK2_CFG_W2          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W2)
+#define VIU_OSD1_BLK3_CFG_W2 0x1a29
+#define P_VIU_OSD1_BLK3_CFG_W2          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W2)
+#define VIU_OSD1_BLK0_CFG_W3 0x1a1e
+#define P_VIU_OSD1_BLK0_CFG_W3          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W3)
+#define VIU_OSD1_BLK1_CFG_W3 0x1a22
+#define P_VIU_OSD1_BLK1_CFG_W3          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W3)
+#define VIU_OSD1_BLK2_CFG_W3 0x1a26
+#define P_VIU_OSD1_BLK2_CFG_W3          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W3)
+#define VIU_OSD1_BLK3_CFG_W3 0x1a2a
+#define P_VIU_OSD1_BLK3_CFG_W3          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W3)
+#define VIU_OSD1_BLK0_CFG_W4 0x1a13
+#define P_VIU_OSD1_BLK0_CFG_W4          VCBUS_REG_ADDR(VIU_OSD1_BLK0_CFG_W4)
+#define VIU_OSD1_BLK1_CFG_W4 0x1a14
+#define P_VIU_OSD1_BLK1_CFG_W4          VCBUS_REG_ADDR(VIU_OSD1_BLK1_CFG_W4)
+#define VIU_OSD1_BLK2_CFG_W4 0x1a15
+#define P_VIU_OSD1_BLK2_CFG_W4          VCBUS_REG_ADDR(VIU_OSD1_BLK2_CFG_W4)
+#define VIU_OSD1_BLK3_CFG_W4 0x1a16
+#define P_VIU_OSD1_BLK3_CFG_W4          VCBUS_REG_ADDR(VIU_OSD1_BLK3_CFG_W4)
+#define VIU_OSD1_TEST_RDDATA 0x1a2c
+#define P_VIU_OSD1_TEST_RDDATA          VCBUS_REG_ADDR(VIU_OSD1_TEST_RDDATA)
+#define VIU_OSD1_PROT_CTRL 0x1a2e
+#define P_VIU_OSD1_PROT_CTRL            VCBUS_REG_ADDR(VIU_OSD1_PROT_CTRL)
+#define VIU_OSD2_CTRL_STAT 0x1a30
+#define P_VIU_OSD2_CTRL_STAT            VCBUS_REG_ADDR(VIU_OSD2_CTRL_STAT)
+#define VIU_OSD2_CTRL_STAT2 0x1a4d
+#define P_VIU_OSD2_CTRL_STAT2           VCBUS_REG_ADDR(VIU_OSD2_CTRL_STAT2)
+#define VIU_OSD2_COLOR_ADDR 0x1a31
+#define P_VIU_OSD2_COLOR_ADDR           VCBUS_REG_ADDR(VIU_OSD2_COLOR_ADDR)
+#define VIU_OSD2_COLOR 0x1a32
+#define P_VIU_OSD2_COLOR                VCBUS_REG_ADDR(VIU_OSD2_COLOR)
+#define VIU_OSD2_HL1_H_START_END 0x1a33
+#define VIU_OSD2_TCOLOR_AG0 0x1a37
+#define P_VIU_OSD2_TCOLOR_AG0           VCBUS_REG_ADDR(VIU_OSD2_TCOLOR_AG0)
+#define VIU_OSD2_TCOLOR_AG1 0x1a38
+#define P_VIU_OSD2_TCOLOR_AG1           VCBUS_REG_ADDR(VIU_OSD2_TCOLOR_AG1)
+#define VIU_OSD2_TCOLOR_AG2 0x1a39
+#define P_VIU_OSD2_TCOLOR_AG2           VCBUS_REG_ADDR(VIU_OSD2_TCOLOR_AG2)
+#define VIU_OSD2_TCOLOR_AG3 0x1a3a
+#define P_VIU_OSD2_TCOLOR_AG3           VCBUS_REG_ADDR(VIU_OSD2_TCOLOR_AG3)
+#define VIU_OSD2_BLK0_CFG_W0 0x1a3b
+#define P_VIU_OSD2_BLK0_CFG_W0          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W0)
+#define VIU_OSD2_BLK1_CFG_W0 0x1a3f
+#define P_VIU_OSD2_BLK1_CFG_W0          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W0)
+#define VIU_OSD2_BLK2_CFG_W0 0x1a43
+#define P_VIU_OSD2_BLK2_CFG_W0          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W0)
+#define VIU_OSD2_BLK3_CFG_W0 0x1a47
+#define P_VIU_OSD2_BLK3_CFG_W0          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W0)
+#define VIU_OSD2_BLK0_CFG_W1 0x1a3c
+#define P_VIU_OSD2_BLK0_CFG_W1          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W1)
+#define VIU_OSD2_BLK1_CFG_W1 0x1a40
+#define P_VIU_OSD2_BLK1_CFG_W1          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W1)
+#define VIU_OSD2_BLK2_CFG_W1 0x1a44
+#define P_VIU_OSD2_BLK2_CFG_W1          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W1)
+#define VIU_OSD2_BLK3_CFG_W1 0x1a48
+#define P_VIU_OSD2_BLK3_CFG_W1          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W1)
+#define VIU_OSD2_BLK0_CFG_W2 0x1a3d
+#define P_VIU_OSD2_BLK0_CFG_W2          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W2)
+#define VIU_OSD2_BLK1_CFG_W2 0x1a41
+#define P_VIU_OSD2_BLK1_CFG_W2          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W2)
+#define VIU_OSD2_BLK2_CFG_W2 0x1a45
+#define P_VIU_OSD2_BLK2_CFG_W2          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W2)
+#define VIU_OSD2_BLK3_CFG_W2 0x1a49
+#define P_VIU_OSD2_BLK3_CFG_W2          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W2)
+#define VIU_OSD2_BLK0_CFG_W3 0x1a3e
+#define P_VIU_OSD2_BLK0_CFG_W3          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W3)
+#define VIU_OSD2_BLK1_CFG_W3 0x1a42
+#define P_VIU_OSD2_BLK1_CFG_W3          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W3)
+#define VIU_OSD2_BLK2_CFG_W3 0x1a46
+#define P_VIU_OSD2_BLK2_CFG_W3          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W3)
+#define VIU_OSD2_BLK3_CFG_W3 0x1a4a
+#define P_VIU_OSD2_BLK3_CFG_W3          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W3)
+#define VIU_OSD2_BLK0_CFG_W4 0x1a64
+#define P_VIU_OSD2_BLK0_CFG_W4          VCBUS_REG_ADDR(VIU_OSD2_BLK0_CFG_W4)
+#define VIU_OSD2_BLK1_CFG_W4 0x1a65
+#define P_VIU_OSD2_BLK1_CFG_W4          VCBUS_REG_ADDR(VIU_OSD2_BLK1_CFG_W4)
+#define VIU_OSD2_BLK2_CFG_W4 0x1a66
+#define P_VIU_OSD2_BLK2_CFG_W4          VCBUS_REG_ADDR(VIU_OSD2_BLK2_CFG_W4)
+#define VIU_OSD2_BLK3_CFG_W4 0x1a67
+#define P_VIU_OSD2_BLK3_CFG_W4          VCBUS_REG_ADDR(VIU_OSD2_BLK3_CFG_W4)
+#define VIU_OSD2_TEST_RDDATA 0x1a4c
+#define P_VIU_OSD2_TEST_RDDATA          VCBUS_REG_ADDR(VIU_OSD2_TEST_RDDATA)
+#define VIU_OSD2_PROT_CTRL 0x1a4e
+#define P_VIU_OSD2_PROT_CTRL            VCBUS_REG_ADDR(VIU_OSD2_PROT_CTRL)
+#define VD1_IF0_GEN_REG 0x1a50
+#define P_VD1_IF0_GEN_REG               VCBUS_REG_ADDR(VD1_IF0_GEN_REG)
+#define VD1_IF0_CANVAS0 0x1a51
+#define P_VD1_IF0_CANVAS0               VCBUS_REG_ADDR(VD1_IF0_CANVAS0)
+#define VD1_IF0_CANVAS1 0x1a52
+#define P_VD1_IF0_CANVAS1               VCBUS_REG_ADDR(VD1_IF0_CANVAS1)
+#define VD1_IF0_LUMA_X0 0x1a53
+#define P_VD1_IF0_LUMA_X0               VCBUS_REG_ADDR(VD1_IF0_LUMA_X0)
+#define VD1_IF0_LUMA_Y0 0x1a54
+#define P_VD1_IF0_LUMA_Y0               VCBUS_REG_ADDR(VD1_IF0_LUMA_Y0)
+#define VD1_IF0_CHROMA_X0 0x1a55
+#define P_VD1_IF0_CHROMA_X0             VCBUS_REG_ADDR(VD1_IF0_CHROMA_X0)
+#define VD1_IF0_CHROMA_Y0 0x1a56
+#define P_VD1_IF0_CHROMA_Y0             VCBUS_REG_ADDR(VD1_IF0_CHROMA_Y0)
+#define VD1_IF0_LUMA_X1 0x1a57
+#define P_VD1_IF0_LUMA_X1               VCBUS_REG_ADDR(VD1_IF0_LUMA_X1)
+#define VD1_IF0_LUMA_Y1 0x1a58
+#define P_VD1_IF0_LUMA_Y1               VCBUS_REG_ADDR(VD1_IF0_LUMA_Y1)
+#define VD1_IF0_CHROMA_X1 0x1a59
+#define P_VD1_IF0_CHROMA_X1             VCBUS_REG_ADDR(VD1_IF0_CHROMA_X1)
+#define VD1_IF0_CHROMA_Y1 0x1a5a
+#define P_VD1_IF0_CHROMA_Y1             VCBUS_REG_ADDR(VD1_IF0_CHROMA_Y1)
+#define VD1_IF0_RPT_LOOP 0x1a5b
+#define P_VD1_IF0_RPT_LOOP              VCBUS_REG_ADDR(VD1_IF0_RPT_LOOP)
+
+#define VD1_IF0_LUMA_PSEL 0x1a60
+#define P_VD1_IF0_LUMA_PSEL             VCBUS_REG_ADDR(VD1_IF0_LUMA_PSEL)
+#define VD1_IF0_CHROMA_PSEL 0x1a61
+#define P_VD1_IF0_CHROMA_PSEL           VCBUS_REG_ADDR(VD1_IF0_CHROMA_PSEL)
+#define VD1_IF0_DUMMY_PIXEL 0x1a62
+#define P_VD1_IF0_DUMMY_PIXEL           VCBUS_REG_ADDR(VD1_IF0_DUMMY_PIXEL)
+#define VD1_IF0_RANGE_MAP_Y 0x1a6a
+#define P_VD1_IF0_RANGE_MAP_Y           VCBUS_REG_ADDR(VD1_IF0_RANGE_MAP_Y)
+#define VD1_IF0_RANGE_MAP_CB 0x1a6b
+#define P_VD1_IF0_RANGE_MAP_CB          VCBUS_REG_ADDR(VD1_IF0_RANGE_MAP_CB)
+#define VD1_IF0_RANGE_MAP_CR 0x1a6c
+#define P_VD1_IF0_RANGE_MAP_CR          VCBUS_REG_ADDR(VD1_IF0_RANGE_MAP_CR)
+#define VD1_IF0_GEN_REG2 0x1a6d
+#define P_VD1_IF0_GEN_REG2              VCBUS_REG_ADDR(VD1_IF0_GEN_REG2)
+#define VD1_IF0_PROT_CNTL 0x1a6e
+#define P_VD1_IF0_PROT_CNTL             VCBUS_REG_ADDR(VD1_IF0_PROT_CNTL)
+#define VIU_VD1_FMT_CTRL 0x1a68
+#define P_VIU_VD1_FMT_CTRL              VCBUS_REG_ADDR(VIU_VD1_FMT_CTRL)
+#define VIU_VD1_FMT_W 0x1a69
+#define P_VIU_VD1_FMT_W                 VCBUS_REG_ADDR(VIU_VD1_FMT_W)
+#define VD2_IF0_GEN_REG 0x1a70
+#define P_VD2_IF0_GEN_REG               VCBUS_REG_ADDR(VD2_IF0_GEN_REG)
+#define VD2_IF0_CANVAS0 0x1a71
+#define P_VD2_IF0_CANVAS0               VCBUS_REG_ADDR(VD2_IF0_CANVAS0)
+#define VD2_IF0_CANVAS1 0x1a72
+#define P_VD2_IF0_CANVAS1               VCBUS_REG_ADDR(VD2_IF0_CANVAS1)
+#define VD2_IF0_LUMA_X0 0x1a73
+#define P_VD2_IF0_LUMA_X0               VCBUS_REG_ADDR(VD2_IF0_LUMA_X0)
+#define VD2_IF0_LUMA_Y0 0x1a74
+#define P_VD2_IF0_LUMA_Y0               VCBUS_REG_ADDR(VD2_IF0_LUMA_Y0)
+#define VD2_IF0_CHROMA_X0 0x1a75
+#define P_VD2_IF0_CHROMA_X0             VCBUS_REG_ADDR(VD2_IF0_CHROMA_X0)
+#define VD2_IF0_CHROMA_Y0 0x1a76
+#define P_VD2_IF0_CHROMA_Y0             VCBUS_REG_ADDR(VD2_IF0_CHROMA_Y0)
+#define VD2_IF0_LUMA_X1 0x1a77
+#define P_VD2_IF0_LUMA_X1               VCBUS_REG_ADDR(VD2_IF0_LUMA_X1)
+#define VD2_IF0_LUMA_Y1 0x1a78
+#define P_VD2_IF0_LUMA_Y1               VCBUS_REG_ADDR(VD2_IF0_LUMA_Y1)
+#define VD2_IF0_CHROMA_X1 0x1a79
+#define P_VD2_IF0_CHROMA_X1             VCBUS_REG_ADDR(VD2_IF0_CHROMA_X1)
+#define VD2_IF0_CHROMA_Y1 0x1a7a
+#define P_VD2_IF0_CHROMA_Y1             VCBUS_REG_ADDR(VD2_IF0_CHROMA_Y1)
+
+#define VD2_IF0_LUMA_PSEL 0x1a80
+#define P_VD2_IF0_LUMA_PSEL             VCBUS_REG_ADDR(VD2_IF0_LUMA_PSEL)
+#define VD2_IF0_CHROMA_PSEL 0x1a81
+#define P_VD2_IF0_CHROMA_PSEL           VCBUS_REG_ADDR(VD2_IF0_CHROMA_PSEL)
+#define VD2_IF0_DUMMY_PIXEL 0x1a82
+#define P_VD2_IF0_DUMMY_PIXEL           VCBUS_REG_ADDR(VD2_IF0_DUMMY_PIXEL)
+#define VD2_IF0_LUMA_FIFO_SIZE 0x1a83
+#define P_VD2_IF0_RANGE_MAP_Y           VCBUS_REG_ADDR(VD2_IF0_RANGE_MAP_Y)
+#define VD2_IF0_RANGE_MAP_CB 0x1a8b
+#define P_VD2_IF0_RANGE_MAP_CB          VCBUS_REG_ADDR(VD2_IF0_RANGE_MAP_CB)
+#define VD2_IF0_RANGE_MAP_CR 0x1a8c
+#define P_VD2_IF0_RANGE_MAP_CR          VCBUS_REG_ADDR(VD2_IF0_RANGE_MAP_CR)
+#define VD2_IF0_GEN_REG2 0x1a8d
+#define P_VD2_IF0_GEN_REG2              VCBUS_REG_ADDR(VD2_IF0_GEN_REG2)
+#define VD2_IF0_PROT_CNTL 0x1a8e
+#define P_VD2_IF0_PROT_CNTL             VCBUS_REG_ADDR(VD2_IF0_PROT_CNTL)
+#define VIU_VD2_FMT_CTRL 0x1a88
+#define P_VIU_VD2_FMT_CTRL              VCBUS_REG_ADDR(VIU_VD2_FMT_CTRL)
+#define VIU_VD2_FMT_W 0x1a89
+#define P_VIU_VD2_FMT_W                 VCBUS_REG_ADDR(VIU_VD2_FMT_W)
+#define LDIM_STTS_GCLK_CTRL0 0x1a90
+#define P_LDIM_STTS_GCLK_CTRL0          VCBUS_REG_ADDR(LDIM_STTS_GCLK_CTRL0)
+#define LDIM_STTS_CTRL0 0x1a91
+#define P_LDIM_STTS_CTRL0               VCBUS_REG_ADDR(LDIM_STTS_CTRL0)
+
+#define DI_PRE_CTRL 0x1700
+#define P_DI_PRE_CTRL           VCBUS_REG_ADDR(DI_PRE_CTRL)
+#define DI_POST_CTRL 0x1701
+#define P_DI_POST_CTRL          VCBUS_REG_ADDR(DI_POST_CTRL)
+#define DI_POST_SIZE 0x1702
+#define P_DI_POST_SIZE          VCBUS_REG_ADDR(DI_POST_SIZE)
+#define DI_PRE_SIZE 0x1703
+#define P_DI_PRE_SIZE           VCBUS_REG_ADDR(DI_PRE_SIZE)
+#define DI_EI_CTRL0 0x1704
+#define P_DI_EI_CTRL0           VCBUS_REG_ADDR(DI_EI_CTRL0)
+#define DI_EI_CTRL1 0x1705
+#define P_DI_EI_CTRL1           VCBUS_REG_ADDR(DI_EI_CTRL1)
+#define DI_EI_CTRL2 0x1706
+#define P_DI_EI_CTRL2           VCBUS_REG_ADDR(DI_EI_CTRL2)
+#define DI_NR_CTRL0 0x1707
+#define P_DI_NR_CTRL0           VCBUS_REG_ADDR(DI_NR_CTRL0)
+#define DI_NR_CTRL1 0x1708
+#define P_DI_NR_CTRL1           VCBUS_REG_ADDR(DI_NR_CTRL1)
+#define DI_NR_CTRL2 0x1709
+#define P_DI_NR_CTRL2           VCBUS_REG_ADDR(DI_NR_CTRL2)
+#define DI_NR_CTRL3 0x170a
+#define P_DI_NR_CTRL3           VCBUS_REG_ADDR(DI_NR_CTRL3)
+#define DI_MTN_CTRL 0x170b
+#define P_DI_MTN_CTRL           VCBUS_REG_ADDR(DI_MTN_CTRL)
+#define DI_MTN_CTRL1 0x170c
+#define P_DI_MTN_CTRL1          VCBUS_REG_ADDR(DI_MTN_CTRL1)
+#define DI_BLEND_CTRL 0x170d
+#define P_DI_BLEND_CTRL                 VCBUS_REG_ADDR(DI_BLEND_CTRL)
+#define DI_BLEND_CTRL1 0x170e
+#define P_DI_BLEND_CTRL1                VCBUS_REG_ADDR(DI_BLEND_CTRL1)
+#define DI_BLEND_CTRL2 0x170f
+#define P_DI_BLEND_CTRL2                VCBUS_REG_ADDR(DI_BLEND_CTRL2)
+#define DI_BLEND_REG0_X 0x1710
+#define P_DI_BLEND_REG0_X               VCBUS_REG_ADDR(DI_BLEND_REG0_X)
+#define DI_BLEND_REG0_Y 0x1711
+#define P_DI_BLEND_REG0_Y               VCBUS_REG_ADDR(DI_BLEND_REG0_Y)
+#define DI_BLEND_REG1_X 0x1712
+#define P_DI_BLEND_REG1_X               VCBUS_REG_ADDR(DI_BLEND_REG1_X)
+#define DI_BLEND_REG1_Y 0x1713
+#define P_DI_BLEND_REG1_Y               VCBUS_REG_ADDR(DI_BLEND_REG1_Y)
+#define DI_BLEND_REG2_X 0x1714
+#define P_DI_BLEND_REG2_X               VCBUS_REG_ADDR(DI_BLEND_REG2_X)
+#define DI_BLEND_REG2_Y 0x1715
+#define P_DI_BLEND_REG2_Y               VCBUS_REG_ADDR(DI_BLEND_REG2_Y)
+#define DI_BLEND_REG3_X 0x1716
+#define P_DI_BLEND_REG3_X               VCBUS_REG_ADDR(DI_BLEND_REG3_X)
+#define DI_BLEND_REG3_Y 0x1717
+#define P_DI_BLEND_REG3_Y               VCBUS_REG_ADDR(DI_BLEND_REG3_Y)
+#define DI_CLKG_CTRL 0x1718
+#define P_DI_CLKG_CTRL          VCBUS_REG_ADDR(DI_CLKG_CTRL)
+#define DI_EI_CTRL3 0x1719
+#define P_DI_EI_CTRL3           VCBUS_REG_ADDR(DI_EI_CTRL3)
+#define DI_EI_CTRL4 0x171a
+#define P_DI_EI_CTRL4           VCBUS_REG_ADDR(DI_EI_CTRL4)
+#define DI_EI_CTRL5 0x171b
+#define P_DI_EI_CTRL5           VCBUS_REG_ADDR(DI_EI_CTRL5)
+#define DI_EI_CTRL6 0x171c
+#define P_DI_EI_CTRL6           VCBUS_REG_ADDR(DI_EI_CTRL6)
+#define DI_EI_CTRL7 0x171d
+#define P_DI_EI_CTRL7           VCBUS_REG_ADDR(DI_EI_CTRL7)
+#define DI_EI_CTRL8 0x171e
+#define P_DI_EI_CTRL8           VCBUS_REG_ADDR(DI_EI_CTRL8)
+#define DI_EI_CTRL9 0x171f
+#define P_DI_EI_CTRL9           VCBUS_REG_ADDR(DI_EI_CTRL9)
+#define DI_EI_CTRL10 0x1793
+#define P_DI_EI_CTRL10          VCBUS_REG_ADDR(DI_EI_CTRL10)
+#define DI_EI_CTRL11 0x179e
+#define P_DI_EI_CTRL11          VCBUS_REG_ADDR(DI_EI_CTRL11)
+#define DI_EI_CTRL12 0x179f
+#define P_DI_EI_CTRL12          VCBUS_REG_ADDR(DI_EI_CTRL12)
+#define DI_EI_CTRL13 0x17a8
+#define P_DI_EI_CTRL13          VCBUS_REG_ADDR(DI_EI_CTRL13)
+#define DI_EI_XWIN0 0x1798
+#define P_DI_EI_XWIN0           VCBUS_REG_ADDR(DI_EI_XWIN0)
+#define DI_EI_XWIN1 0x1799
+#define P_DI_EI_XWIN1           VCBUS_REG_ADDR(DI_EI_XWIN1)
+#define DI_MC_REG0_X 0x1720
+#define P_DI_MC_REG0_X          VCBUS_REG_ADDR(DI_MC_REG0_X)
+#define DI_MC_REG0_Y 0x1721
+#define P_DI_MC_REG0_Y          VCBUS_REG_ADDR(DI_MC_REG0_Y)
+#define DI_MC_REG1_X 0x1722
+#define P_DI_MC_REG1_X          VCBUS_REG_ADDR(DI_MC_REG1_X)
+#define DI_MC_REG1_Y 0x1723
+#define P_DI_MC_REG1_Y          VCBUS_REG_ADDR(DI_MC_REG1_Y)
+#define DI_MC_REG2_X 0x1724
+#define P_DI_MC_REG2_X          VCBUS_REG_ADDR(DI_MC_REG2_X)
+#define DI_MC_REG2_Y 0x1725
+#define P_DI_MC_REG2_Y          VCBUS_REG_ADDR(DI_MC_REG2_Y)
+#define DI_MC_REG3_X 0x1726
+#define P_DI_MC_REG3_X          VCBUS_REG_ADDR(DI_MC_REG3_X)
+#define DI_MC_REG3_Y 0x1727
+#define P_DI_MC_REG3_Y          VCBUS_REG_ADDR(DI_MC_REG3_Y)
+#define DI_MC_REG4_X 0x1728
+#define P_DI_MC_REG4_X          VCBUS_REG_ADDR(DI_MC_REG4_X)
+#define DI_MC_REG4_Y 0x1729
+#define P_DI_MC_REG4_Y          VCBUS_REG_ADDR(DI_MC_REG4_Y)
+#define DI_MC_32LVL0 0x172a
+#define P_DI_MC_32LVL0          VCBUS_REG_ADDR(DI_MC_32LVL0)
+#define DI_MC_32LVL1 0x172b
+#define P_DI_MC_32LVL1          VCBUS_REG_ADDR(DI_MC_32LVL1)
+#define DI_MC_22LVL0 0x172c
+#define P_DI_MC_22LVL0          VCBUS_REG_ADDR(DI_MC_22LVL0)
+#define DI_MC_22LVL1 0x172d
+#define P_DI_MC_22LVL1          VCBUS_REG_ADDR(DI_MC_22LVL1)
+#define DI_MC_22LVL2 0x172e
+#define P_DI_MC_22LVL2          VCBUS_REG_ADDR(DI_MC_22LVL2)
+#define DI_MC_CTRL 0x172f
+#define P_DI_MC_CTRL            VCBUS_REG_ADDR(DI_MC_CTRL)
+#define DI_INTR_CTRL 0x1730
+#define P_DI_INTR_CTRL          VCBUS_REG_ADDR(DI_INTR_CTRL)
+#define DI_INFO_ADDR 0x1731
+#define P_DI_INFO_ADDR          VCBUS_REG_ADDR(DI_INFO_ADDR)
+#define DI_INFO_DATA 0x1732
+#define P_DI_INFO_DATA          VCBUS_REG_ADDR(DI_INFO_DATA)
+#define DI_PRE_HOLD 0x1733
+#define P_DI_PRE_HOLD           VCBUS_REG_ADDR(DI_PRE_HOLD)
+#define DI_MTN_1_CTRL1 0x1740
+#define P_DI_MTN_1_CTRL1                VCBUS_REG_ADDR(DI_MTN_1_CTRL1)
+#define DI_MTN_1_CTRL2 0x1741
+#define P_DI_MTN_1_CTRL2                VCBUS_REG_ADDR(DI_MTN_1_CTRL2)
+#define DI_MTN_1_CTRL3 0x1742
+#define P_DI_MTN_1_CTRL3                VCBUS_REG_ADDR(DI_MTN_1_CTRL3)
+#define DI_MTN_1_CTRL4 0x1743
+#define P_DI_MTN_1_CTRL4                VCBUS_REG_ADDR(DI_MTN_1_CTRL4)
+#define DI_MTN_1_CTRL5 0x1744
+#define P_DI_MTN_1_CTRL5                VCBUS_REG_ADDR(DI_MTN_1_CTRL5)
+#define DI_MTN_1_CTRL6 0x17a9
+#define P_DI_MTN_1_CTRL6                VCBUS_REG_ADDR(DI_MTN_1_CTRL6)
+#define DI_MTN_1_CTRL7 0x17aa
+#define P_DI_MTN_1_CTRL7                VCBUS_REG_ADDR(DI_MTN_1_CTRL7)
+#define DI_MTN_1_CTRL8 0x17ab
+#define P_DI_MTN_1_CTRL8                VCBUS_REG_ADDR(DI_MTN_1_CTRL8)
+#define DI_MTN_1_CTRL9 0x17ac
+#define P_DI_MTN_1_CTRL9                VCBUS_REG_ADDR(DI_MTN_1_CTRL9)
+#define DI_MTN_1_CTRL10 0x17ad
+#define P_DI_MTN_1_CTRL10               VCBUS_REG_ADDR(DI_MTN_1_CTRL10)
+#define DI_MTN_1_CTRL11 0x17ae
+#define P_DI_MTN_1_CTRL11               VCBUS_REG_ADDR(DI_MTN_1_CTRL11)
+#define DI_MTN_1_CTRL12 0x17af
+#define P_DI_MTN_1_CTRL12               VCBUS_REG_ADDR(DI_MTN_1_CTRL12)
+#define DET3D_MOTN_CFG 0x1734
+#define P_DET3D_MOTN_CFG                VCBUS_REG_ADDR(DET3D_MOTN_CFG)
+#define DET3D_CB_CFG 0x1735
+#define P_DET3D_CB_CFG          VCBUS_REG_ADDR(DET3D_CB_CFG)
+#define DET3D_SPLT_CFG 0x1736
+#define P_DET3D_SPLT_CFG                VCBUS_REG_ADDR(DET3D_SPLT_CFG)
+#define DET3D_HV_MUTE 0x1737
+#define P_DET3D_HV_MUTE                 VCBUS_REG_ADDR(DET3D_HV_MUTE)
+#define DET3D_MAT_STA_P1M1 0x1738
+#define P_DET3D_MAT_STA_P1M1            VCBUS_REG_ADDR(DET3D_MAT_STA_P1M1)
+#define DET3D_MAT_STA_P1TH 0x1739
+#define P_DET3D_MAT_STA_P1TH            VCBUS_REG_ADDR(DET3D_MAT_STA_P1TH)
+#define DET3D_MAT_STA_M1TH 0x173a
+#define P_DET3D_MAT_STA_M1TH            VCBUS_REG_ADDR(DET3D_MAT_STA_M1TH)
+#define DET3D_MAT_STA_RSFT 0x173b
+#define P_DET3D_MAT_STA_RSFT            VCBUS_REG_ADDR(DET3D_MAT_STA_RSFT)
+#define DET3D_MAT_SYMTC_TH 0x173c
+#define P_DET3D_MAT_SYMTC_TH            VCBUS_REG_ADDR(DET3D_MAT_SYMTC_TH)
+#define DET3D_RO_DET_CB_HOR 0x173d
+#define P_DET3D_RO_DET_CB_HOR           VCBUS_REG_ADDR(DET3D_RO_DET_CB_HOR)
+#define DET3D_RO_DET_CB_VER 0x173e
+#define P_DET3D_RO_DET_CB_VER           VCBUS_REG_ADDR(DET3D_RO_DET_CB_VER)
+#define DET3D_RO_SPLT_HT 0x173f
+#define P_DET3D_RO_SPLT_HT              VCBUS_REG_ADDR(DET3D_RO_SPLT_HT)
+#define NR2_MET_NM_CTRL 0x1745
+#define P_NR2_MET_NM_CTRL               VCBUS_REG_ADDR(NR2_MET_NM_CTRL)
+#define NR2_MET_NM_YCTRL 0x1746
+#define P_NR2_MET_NM_YCTRL              VCBUS_REG_ADDR(NR2_MET_NM_YCTRL)
+#define NR2_MET_NM_CCTRL 0x1747
+#define P_NR2_MET_NM_CCTRL              VCBUS_REG_ADDR(NR2_MET_NM_CCTRL)
+
+#define NR2_MATNR_SNR_EDGE2B 0x1757
+#define P_NR2_MATNR_SNR_EDGE2B          VCBUS_REG_ADDR(NR2_MATNR_SNR_EDGE2B)
+#define NR2_MATNR_BETA_EGAIN 0x1758
+#define P_NR2_MATNR_BETA_EGAIN          VCBUS_REG_ADDR(NR2_MATNR_BETA_EGAIN)
+#define NR2_MATNR_BETA_BRT 0x1759
+#define P_NR2_MATNR_BETA_BRT            VCBUS_REG_ADDR(NR2_MATNR_BETA_BRT)
+#define NR2_MATNR_XBETA_CFG 0x175a
+#define P_NR2_MATNR_XBETA_CFG           VCBUS_REG_ADDR(NR2_MATNR_XBETA_CFG)
+#define NR2_MATNR_YBETA_SCL 0x175b
+#define P_NR2_MATNR_YBETA_SCL           VCBUS_REG_ADDR(NR2_MATNR_YBETA_SCL)
+#define NR2_MATNR_CBETA_SCL 0x175c
+#define P_NR2_MATNR_CBETA_SCL           VCBUS_REG_ADDR(NR2_MATNR_CBETA_SCL)
+#define NR2_SNR_MASK 0x175d
+#define P_NR2_SNR_MASK          VCBUS_REG_ADDR(NR2_SNR_MASK)
+#define NR2_SAD2NORM_LUT0 0x175e
+#define P_NR2_SAD2NORM_LUT0             VCBUS_REG_ADDR(NR2_SAD2NORM_LUT0)
+#define NR2_SAD2NORM_LUT1 0x175f
+#define P_NR2_SAD2NORM_LUT1             VCBUS_REG_ADDR(NR2_SAD2NORM_LUT1)
+#define NR2_SAD2NORM_LUT2 0x1760
+#define P_NR2_SAD2NORM_LUT2             VCBUS_REG_ADDR(NR2_SAD2NORM_LUT2)
+#define NR2_SAD2NORM_LUT3 0x1761
+#define P_NR2_SAD2NORM_LUT3             VCBUS_REG_ADDR(NR2_SAD2NORM_LUT3)
+#define NR2_EDGE2BETA_LUT0 0x1762
+#define P_NR2_EDGE2BETA_LUT0            VCBUS_REG_ADDR(NR2_EDGE2BETA_LUT0)
+#define NR2_EDGE2BETA_LUT1 0x1763
+#define P_NR2_EDGE2BETA_LUT1            VCBUS_REG_ADDR(NR2_EDGE2BETA_LUT1)
+#define NR2_EDGE2BETA_LUT2 0x1764
+#define P_NR2_EDGE2BETA_LUT2            VCBUS_REG_ADDR(NR2_EDGE2BETA_LUT2)
+#define NR2_EDGE2BETA_LUT3 0x1765
+#define P_NR2_EDGE2BETA_LUT3            VCBUS_REG_ADDR(NR2_EDGE2BETA_LUT3)
+#define NR2_MOTION2BETA_LUT0 0x1766
+#define P_NR2_MOTION2BETA_LUT0          VCBUS_REG_ADDR(NR2_MOTION2BETA_LUT0)
+#define NR2_MOTION2BETA_LUT1 0x1767
+#define P_NR2_MOTION2BETA_LUT1          VCBUS_REG_ADDR(NR2_MOTION2BETA_LUT1)
+#define NR2_MOTION2BETA_LUT2 0x1768
+#define P_NR2_MOTION2BETA_LUT2          VCBUS_REG_ADDR(NR2_MOTION2BETA_LUT2)
+#define NR2_MOTION2BETA_LUT3 0x1769
+#define P_NR2_MOTION2BETA_LUT3          VCBUS_REG_ADDR(NR2_MOTION2BETA_LUT3)
+#define NR2_MATNR_MTN_CRTL 0x176a
+#define P_NR2_MATNR_MTN_CRTL            VCBUS_REG_ADDR(NR2_MATNR_MTN_CRTL)
+#define NR2_MATNR_MTN_CRTL2 0x176b
+#define P_NR2_MATNR_MTN_CRTL2           VCBUS_REG_ADDR(NR2_MATNR_MTN_CRTL2)
+#define NR2_MATNR_MTN_COR 0x176c
+#define P_NR2_MATNR_MTN_COR             VCBUS_REG_ADDR(NR2_MATNR_MTN_COR)
+#define NR2_MATNR_MTN_GAIN 0x176d
+#define P_NR2_MATNR_MTN_GAIN            VCBUS_REG_ADDR(NR2_MATNR_MTN_GAIN)
+#define NR2_MATNR_DEGHOST 0x176e
+#define P_NR2_MATNR_DEGHOST             VCBUS_REG_ADDR(NR2_MATNR_DEGHOST)
+#define NR2_MATNR_MTNB_BRT 0x1777
+#define P_NR2_MATNR_MTNB_BRT            VCBUS_REG_ADDR(NR2_MATNR_MTNB_BRT)
+#define NR2_CUE_MODE 0x1778
+#define P_NR2_CUE_MODE          VCBUS_REG_ADDR(NR2_CUE_MODE)
+#define NR2_CUE_CON_MOT_TH 0x1779
+#define P_NR2_CUE_CON_MOT_TH            VCBUS_REG_ADDR(NR2_CUE_CON_MOT_TH)
+#define NR2_CUE_CON_DIF0 0x177a
+#define P_NR2_CUE_CON_DIF0              VCBUS_REG_ADDR(NR2_CUE_CON_DIF0)
+#define NR2_CUE_CON_DIF1 0x177b
+#define P_NR2_CUE_CON_DIF1              VCBUS_REG_ADDR(NR2_CUE_CON_DIF1)
+#define NR2_CUE_CON_DIF2 0x177c
+#define P_NR2_CUE_CON_DIF2              VCBUS_REG_ADDR(NR2_CUE_CON_DIF2)
+#define NR2_CUE_CON_DIF3 0x177d
+#define P_NR2_CUE_CON_DIF3              VCBUS_REG_ADDR(NR2_CUE_CON_DIF3)
+#define NR2_CUE_PRG_DIF 0x177e
+#define P_NR2_CUE_PRG_DIF               VCBUS_REG_ADDR(NR2_CUE_PRG_DIF)
+#define NR2_CONV_MODE 0x177f
+#define P_NR2_CONV_MODE                 VCBUS_REG_ADDR(NR2_CONV_MODE)
+#define DET3D_RO_SPLT_HB 0x1780
+#define P_DET3D_RO_SPLT_HB              VCBUS_REG_ADDR(DET3D_RO_SPLT_HB)
+#define DET3D_RO_SPLT_VL 0x1781
+#define P_DET3D_RO_SPLT_VL              VCBUS_REG_ADDR(DET3D_RO_SPLT_VL)
+#define DET3D_RO_SPLT_VR 0x1782
+#define P_DET3D_RO_SPLT_VR              VCBUS_REG_ADDR(DET3D_RO_SPLT_VR)
+#define DET3D_RO_MAT_LUMA_LR 0x1783
+#define P_DET3D_RO_MAT_LUMA_LR          VCBUS_REG_ADDR(DET3D_RO_MAT_LUMA_LR)
+#define DET3D_RO_MAT_LUMA_TB 0x1784
+#define P_DET3D_RO_MAT_LUMA_TB          VCBUS_REG_ADDR(DET3D_RO_MAT_LUMA_TB)
+#define DET3D_RO_MAT_CHRU_LR 0x1785
+#define P_DET3D_RO_MAT_CHRU_LR          VCBUS_REG_ADDR(DET3D_RO_MAT_CHRU_LR)
+#define DET3D_RO_MAT_CHRU_TB 0x1786
+#define P_DET3D_RO_MAT_CHRU_TB          VCBUS_REG_ADDR(DET3D_RO_MAT_CHRU_TB)
+#define DET3D_RO_MAT_CHRV_LR 0x1787
+#define P_DET3D_RO_MAT_CHRV_LR          VCBUS_REG_ADDR(DET3D_RO_MAT_CHRV_LR)
+#define NR2_CFR_PARA_CFG0 0x179c
+#define P_NR2_CFR_PARA_CFG0             VCBUS_REG_ADDR(NR2_CFR_PARA_CFG0)
+#define NR2_CFR_PARA_CFG1 0x179d
+#define P_NR2_CFR_PARA_CFG1             VCBUS_REG_ADDR(NR2_CFR_PARA_CFG1)
+#define DI_NR_1_CTRL0 0x1794
+#define P_DI_NR_1_CTRL0                 VCBUS_REG_ADDR(DI_NR_1_CTRL0)
+#define DI_NR_1_CTRL1 0x1795
+#define P_DI_NR_1_CTRL1                 VCBUS_REG_ADDR(DI_NR_1_CTRL1)
+#define DI_NR_1_CTRL2 0x1796
+#define P_DI_NR_1_CTRL2                 VCBUS_REG_ADDR(DI_NR_1_CTRL2)
+#define DI_NR_1_CTRL3 0x1797
+#define P_DI_NR_1_CTRL3                 VCBUS_REG_ADDR(DI_NR_1_CTRL3)
+#define DI_CONTWR_X 0x17a0
+#define P_DI_CONTWR_X           VCBUS_REG_ADDR(DI_CONTWR_X)
+#define DI_CONTWR_Y 0x17a1
+#define P_DI_CONTWR_Y           VCBUS_REG_ADDR(DI_CONTWR_Y)
+#define DI_CONTWR_CTRL 0x17a2
+#define P_DI_CONTWR_CTRL                VCBUS_REG_ADDR(DI_CONTWR_CTRL)
+#define DI_CONTPRD_X 0x17a3
+#define P_DI_CONTPRD_X          VCBUS_REG_ADDR(DI_CONTPRD_X)
+#define DI_CONTPRD_Y 0x17a4
+#define P_DI_CONTPRD_Y          VCBUS_REG_ADDR(DI_CONTPRD_Y)
+#define DI_CONTP2RD_X 0x17a5
+#define P_DI_CONTP2RD_X                 VCBUS_REG_ADDR(DI_CONTP2RD_X)
+#define DI_CONTP2RD_Y 0x17a6
+#define P_DI_CONTP2RD_Y                 VCBUS_REG_ADDR(DI_CONTP2RD_Y)
+#define DI_CONTRD_CTRL 0x17a7
+#define P_DI_CONTRD_CTRL                VCBUS_REG_ADDR(DI_CONTRD_CTRL)
+#define DI_NRWR_X 0x17c0
+#define P_DI_NRWR_X             VCBUS_REG_ADDR(DI_NRWR_X)
+#define DI_NRWR_Y 0x17c1
+#define P_DI_NRWR_Y             VCBUS_REG_ADDR(DI_NRWR_Y)
+#define DI_NRWR_CTRL 0x17c2
+#define P_DI_NRWR_CTRL          VCBUS_REG_ADDR(DI_NRWR_CTRL)
+#define DI_MTNWR_X 0x17c3
+#define P_DI_MTNWR_X            VCBUS_REG_ADDR(DI_MTNWR_X)
+#define DI_MTNWR_Y 0x17c4
+#define P_DI_MTNWR_Y            VCBUS_REG_ADDR(DI_MTNWR_Y)
+#define DI_MTNWR_CTRL 0x17c5
+#define P_DI_MTNWR_CTRL                 VCBUS_REG_ADDR(DI_MTNWR_CTRL)
+#define DI_DIWR_X 0x17c6
+#define P_DI_DIWR_X             VCBUS_REG_ADDR(DI_DIWR_X)
+#define DI_DIWR_Y 0x17c7
+#define P_DI_DIWR_Y             VCBUS_REG_ADDR(DI_DIWR_Y)
+#define DI_DIWR_CTRL 0x17c8
+#define P_DI_DIWR_CTRL          VCBUS_REG_ADDR(DI_DIWR_CTRL)
+#define DI_MTNCRD_X 0x17c9
+#define P_DI_MTNCRD_X           VCBUS_REG_ADDR(DI_MTNCRD_X)
+#define DI_MTNCRD_Y 0x17ca
+#define P_DI_MTNCRD_Y           VCBUS_REG_ADDR(DI_MTNCRD_Y)
+#define DI_MTNPRD_X 0x17cb
+#define P_DI_MTNPRD_X           VCBUS_REG_ADDR(DI_MTNPRD_X)
+#define DI_MTNPRD_Y 0x17cc
+#define P_DI_MTNPRD_Y           VCBUS_REG_ADDR(DI_MTNPRD_Y)
+#define DI_MTNRD_CTRL 0x17cd
+#define P_DI_MTNRD_CTRL                 VCBUS_REG_ADDR(DI_MTNRD_CTRL)
+#define DI_INP_GEN_REG 0x17ce
+#define P_DI_INP_GEN_REG                VCBUS_REG_ADDR(DI_INP_GEN_REG)
+#define DI_INP_CANVAS0 0x17cf
+#define P_DI_INP_CANVAS0                VCBUS_REG_ADDR(DI_INP_CANVAS0)
+#define DI_INP_LUMA_X0 0x17d0
+#define P_DI_INP_LUMA_X0                VCBUS_REG_ADDR(DI_INP_LUMA_X0)
+#define DI_INP_LUMA_Y0 0x17d1
+#define P_DI_INP_LUMA_Y0                VCBUS_REG_ADDR(DI_INP_LUMA_Y0)
+#define DI_INP_CHROMA_X0 0x17d2
+#define P_DI_INP_CHROMA_X0              VCBUS_REG_ADDR(DI_INP_CHROMA_X0)
+#define DI_INP_CHROMA_Y0 0x17d3
+#define P_DI_INP_CHROMA_Y0              VCBUS_REG_ADDR(DI_INP_CHROMA_Y0)
+#define DI_INP_RPT_LOOP 0x17d4
+#define P_DI_INP_RPT_LOOP               VCBUS_REG_ADDR(DI_INP_RPT_LOOP)
+#define DI_INP_LUMA0_RPT_PAT 0x17d5
+#define P_DI_INP_LUMA0_RPT_PAT          VCBUS_REG_ADDR(DI_INP_LUMA0_RPT_PAT)
+#define DI_INP_CHROMA0_RPT_PAT 0x17d6
+
+#define DI_INP_RANGE_MAP_Y 0x17ba
+#define P_DI_INP_RANGE_MAP_Y            VCBUS_REG_ADDR(DI_INP_RANGE_MAP_Y)
+#define DI_INP_RANGE_MAP_CB 0x17bb
+#define P_DI_INP_RANGE_MAP_CB           VCBUS_REG_ADDR(DI_INP_RANGE_MAP_CB)
+#define DI_INP_RANGE_MAP_CR 0x17bc
+#define P_DI_INP_RANGE_MAP_CR           VCBUS_REG_ADDR(DI_INP_RANGE_MAP_CR)
+#define DI_INP_GEN_REG2 0x1791
+#define P_DI_INP_GEN_REG2               VCBUS_REG_ADDR(DI_INP_GEN_REG2)
+#define DI_INP_FMT_CTRL 0x17d9
+#define P_DI_INP_FMT_CTRL               VCBUS_REG_ADDR(DI_INP_FMT_CTRL)
+#define DI_INP_FMT_W 0x17da
+#define P_DI_INP_FMT_W          VCBUS_REG_ADDR(DI_INP_FMT_W)
+#define DI_MEM_GEN_REG 0x17db
+#define P_DI_MEM_GEN_REG                VCBUS_REG_ADDR(DI_MEM_GEN_REG)
+#define DI_MEM_CANVAS0 0x17dc
+#define P_DI_MEM_CANVAS0                VCBUS_REG_ADDR(DI_MEM_CANVAS0)
+#define DI_MEM_LUMA_X0 0x17dd
+#define P_DI_MEM_LUMA_X0                VCBUS_REG_ADDR(DI_MEM_LUMA_X0)
+#define DI_MEM_LUMA_Y0 0x17de
+#define P_DI_MEM_LUMA_Y0                VCBUS_REG_ADDR(DI_MEM_LUMA_Y0)
+#define DI_MEM_CHROMA_X0 0x17df
+#define P_DI_MEM_CHROMA_X0              VCBUS_REG_ADDR(DI_MEM_CHROMA_X0)
+#define DI_MEM_CHROMA_Y0 0x17e0
+#define P_DI_MEM_CHROMA_Y0              VCBUS_REG_ADDR(DI_MEM_CHROMA_Y0)
+#define DI_MEM_RPT_LOOP 0x17e1
+#define P_DI_MEM_RPT_LOOP               VCBUS_REG_ADDR(DI_MEM_RPT_LOOP)
+
+#define DI_MEM_RANGE_MAP_Y 0x17bd
+#define P_DI_MEM_RANGE_MAP_Y            VCBUS_REG_ADDR(DI_MEM_RANGE_MAP_Y)
+#define DI_MEM_RANGE_MAP_CB 0x17be
+#define P_DI_MEM_RANGE_MAP_CB           VCBUS_REG_ADDR(DI_MEM_RANGE_MAP_CB)
+#define DI_MEM_RANGE_MAP_CR 0x17bf
+#define P_DI_MEM_RANGE_MAP_CR           VCBUS_REG_ADDR(DI_MEM_RANGE_MAP_CR)
+#define DI_MEM_GEN_REG2 0x1792
+#define P_DI_MEM_GEN_REG2               VCBUS_REG_ADDR(DI_MEM_GEN_REG2)
+#define DI_MEM_FMT_CTRL 0x17e6
+#define P_DI_MEM_FMT_CTRL               VCBUS_REG_ADDR(DI_MEM_FMT_CTRL)
+#define DI_MEM_FMT_W 0x17e7
+#define P_DI_MEM_FMT_W          VCBUS_REG_ADDR(DI_MEM_FMT_W)
+#define DI_IF1_GEN_REG 0x17e8
+#define P_DI_IF1_GEN_REG                VCBUS_REG_ADDR(DI_IF1_GEN_REG)
+#define DI_IF1_CANVAS0 0x17e9
+#define P_DI_IF1_CANVAS0                VCBUS_REG_ADDR(DI_IF1_CANVAS0)
+#define DI_IF1_LUMA_X0 0x17ea
+#define P_DI_IF1_LUMA_X0                VCBUS_REG_ADDR(DI_IF1_LUMA_X0)
+#define DI_IF1_LUMA_Y0 0x17eb
+#define P_DI_IF1_LUMA_Y0                VCBUS_REG_ADDR(DI_IF1_LUMA_Y0)
+#define DI_IF1_CHROMA_X0 0x17ec
+#define P_DI_IF1_CHROMA_X0              VCBUS_REG_ADDR(DI_IF1_CHROMA_X0)
+#define DI_IF1_CHROMA_Y0 0x17ed
+#define P_DI_IF1_CHROMA_Y0              VCBUS_REG_ADDR(DI_IF1_CHROMA_Y0)
+#define DI_IF1_RPT_LOOP 0x17ee
+#define P_DI_IF1_RPT_LOOP               VCBUS_REG_ADDR(DI_IF1_RPT_LOOP)
+#define DI_IF1_LUMA0_RPT_PAT 0x17ef
+#define P_DI_IF1_LUMA0_RPT_PAT          VCBUS_REG_ADDR(DI_IF1_LUMA0_RPT_PAT)
+#define DI_IF1_CHROMA0_RPT_PAT 0x17f0
+#define P_DI_IF1_DUMMY_PIXEL            VCBUS_REG_ADDR(DI_IF1_DUMMY_PIXEL)
+#define DI_IF1_LUMA_FIFO_SIZE 0x17f2
+
+#define DI_CHAN2_GEN_REG2 0x17b7
+#define P_DI_CHAN2_GEN_REG2             VCBUS_REG_ADDR(DI_CHAN2_GEN_REG2)
+#define DI_CHAN2_FMT_CTRL 0x17b8
+#define P_DI_CHAN2_FMT_CTRL             VCBUS_REG_ADDR(DI_CHAN2_FMT_CTRL)
+#define DI_CHAN2_FMT_W 0x17b9
+#define P_DI_CHAN2_FMT_W                VCBUS_REG_ADDR(DI_CHAN2_FMT_W)
+#define VIU2_ADDR_START 0x1e00
+#define P_VIU2_ADDR_START               VCBUS_REG_ADDR(VIU2_ADDR_START)
+#define VIU2_ADDR_END 0x1eff
+#define P_VIU2_ADDR_END                 VCBUS_REG_ADDR(VIU2_ADDR_END)
+#define VIU2_SW_RESET 0x1e01
+#define P_VIU2_SW_RESET                 VCBUS_REG_ADDR(VIU2_SW_RESET)
+#define VIU2_OSD1_CTRL_STAT 0x1e10
+#define P_VIU2_OSD1_CTRL_STAT           VCBUS_REG_ADDR(VIU2_OSD1_CTRL_STAT)
+#define VIU2_OSD1_CTRL_STAT2 0x1e2d
+#define P_VIU2_OSD1_CTRL_STAT2          VCBUS_REG_ADDR(VIU2_OSD1_CTRL_STAT2)
+#define VIU2_OSD1_COLOR_ADDR 0x1e11
+#define P_VIU2_OSD1_COLOR_ADDR          VCBUS_REG_ADDR(VIU2_OSD1_COLOR_ADDR)
+#define VIU2_OSD1_COLOR 0x1e12
+#define P_VIU2_OSD1_COLOR               VCBUS_REG_ADDR(VIU2_OSD1_COLOR)
+#define VIU2_OSD1_TCOLOR_AG0 0x1e17
+#define P_VIU2_OSD1_TCOLOR_AG0          VCBUS_REG_ADDR(VIU2_OSD1_TCOLOR_AG0)
+#define VIU2_OSD1_TCOLOR_AG1 0x1e18
+#define P_VIU2_OSD1_TCOLOR_AG1          VCBUS_REG_ADDR(VIU2_OSD1_TCOLOR_AG1)
+#define VIU2_OSD1_TCOLOR_AG2 0x1e19
+#define P_VIU2_OSD1_TCOLOR_AG2          VCBUS_REG_ADDR(VIU2_OSD1_TCOLOR_AG2)
+#define VIU2_OSD1_TCOLOR_AG3 0x1e1a
+#define P_VIU2_OSD1_TCOLOR_AG3          VCBUS_REG_ADDR(VIU2_OSD1_TCOLOR_AG3)
+
+
+#define VENC_SYNC_ROUTE 0x1b60
+#define P_VENC_SYNC_ROUTE               VCBUS_REG_ADDR(VENC_SYNC_ROUTE)
+#define VENC_VIDEO_EXSRC 0x1b61
+#define P_VENC_VIDEO_EXSRC              VCBUS_REG_ADDR(VENC_VIDEO_EXSRC)
+#define VENC_DVI_SETTING 0x1b62
+#define P_VENC_DVI_SETTING              VCBUS_REG_ADDR(VENC_DVI_SETTING)
+#define VENC_C656_CTRL 0x1b63
+#define P_VENC_C656_CTRL                VCBUS_REG_ADDR(VENC_C656_CTRL)
+#define VENC_UPSAMPLE_CTRL0 0x1b64
+#define P_VENC_UPSAMPLE_CTRL0           VCBUS_REG_ADDR(VENC_UPSAMPLE_CTRL0)
+#define VENC_UPSAMPLE_CTRL1 0x1b65
+#define P_VENC_UPSAMPLE_CTRL1           VCBUS_REG_ADDR(VENC_UPSAMPLE_CTRL1)
+#define VENC_UPSAMPLE_CTRL2 0x1b66
+#define P_VENC_UPSAMPLE_CTRL2           VCBUS_REG_ADDR(VENC_UPSAMPLE_CTRL2)
+#define TCON_INVERT_CTL 0x1b67
+#define P_TCON_INVERT_CTL               VCBUS_REG_ADDR(TCON_INVERT_CTL)
+#define VENC_VIDEO_PROG_MODE 0x1b68
+#define P_VENC_VIDEO_PROG_MODE          VCBUS_REG_ADDR(VENC_VIDEO_PROG_MODE)
+#define VENC_ENCI_LINE 0x1b69
+#define P_VENC_ENCI_LINE                VCBUS_REG_ADDR(VENC_ENCI_LINE)
+#define VENC_ENCI_PIXEL 0x1b6a
+#define P_VENC_ENCI_PIXEL               VCBUS_REG_ADDR(VENC_ENCI_PIXEL)
+#define VENC_ENCP_LINE 0x1b6b
+#define P_VENC_ENCP_LINE                VCBUS_REG_ADDR(VENC_ENCP_LINE)
+#define VENC_ENCP_PIXEL 0x1b6c
+#define P_VENC_ENCP_PIXEL               VCBUS_REG_ADDR(VENC_ENCP_PIXEL)
+#define VENC_STATA 0x1b6d
+#define P_VENC_STATA            VCBUS_REG_ADDR(VENC_STATA)
+#define VENC_INTCTRL 0x1b6e
+#define P_VENC_INTCTRL          VCBUS_REG_ADDR(VENC_INTCTRL)
+#define VENC_INTFLAG 0x1b6f
+#define P_VENC_INTFLAG          VCBUS_REG_ADDR(VENC_INTFLAG)
+#define VENC_VIDEO_TST_EN 0x1b70
+#define P_VENC_VIDEO_TST_EN             VCBUS_REG_ADDR(VENC_VIDEO_TST_EN)
+#define VENC_VIDEO_TST_MDSEL 0x1b71
+#define P_VENC_VIDEO_TST_MDSEL          VCBUS_REG_ADDR(VENC_VIDEO_TST_MDSEL)
+#define VENC_VIDEO_TST_Y 0x1b72
+#define P_VENC_VIDEO_TST_Y              VCBUS_REG_ADDR(VENC_VIDEO_TST_Y)
+#define VENC_VIDEO_TST_CB 0x1b73
+#define P_VENC_VIDEO_TST_CB             VCBUS_REG_ADDR(VENC_VIDEO_TST_CB)
+#define VENC_VIDEO_TST_CR 0x1b74
+#define P_VENC_VIDEO_TST_CR             VCBUS_REG_ADDR(VENC_VIDEO_TST_CR)
+#define VENC_VIDEO_TST_CLRBAR_STRT 0x1b75
+#define VENC_VDAC_FIFO_CTRL 0x1bfc
+#define P_VENC_VDAC_FIFO_CTRL           VCBUS_REG_ADDR(VENC_VDAC_FIFO_CTRL)
+#define ENCL_TCON_INVERT_CTL 0x1bfd
+#define P_ENCL_TCON_INVERT_CTL          VCBUS_REG_ADDR(ENCL_TCON_INVERT_CTL)
+#define ENCP_VIDEO_EN 0x1b80
+#define P_ENCP_VIDEO_EN                 VCBUS_REG_ADDR(ENCP_VIDEO_EN)
+#define ENCP_VIDEO_SYNC_MODE 0x1b81
+#define P_ENCP_VIDEO_SYNC_MODE          VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_MODE)
+#define ENCP_MACV_EN 0x1b82
+#define P_ENCP_MACV_EN          VCBUS_REG_ADDR(ENCP_MACV_EN)
+#define ENCP_VIDEO_Y_SCL 0x1b83
+#define P_ENCP_VIDEO_Y_SCL              VCBUS_REG_ADDR(ENCP_VIDEO_Y_SCL)
+#define ENCP_VIDEO_PB_SCL 0x1b84
+#define P_ENCP_VIDEO_PB_SCL             VCBUS_REG_ADDR(ENCP_VIDEO_PB_SCL)
+#define ENCP_VIDEO_PR_SCL 0x1b85
+#define P_ENCP_VIDEO_PR_SCL             VCBUS_REG_ADDR(ENCP_VIDEO_PR_SCL)
+#define ENCP_VIDEO_SYNC_SCL 0x1b86
+#define P_ENCP_VIDEO_SYNC_SCL           VCBUS_REG_ADDR(ENCP_VIDEO_SYNC_SCL)
+#define ENCP_VIDEO_MACV_SCL 0x1b87
+#define P_ENCP_VIDEO_MACV_SCL           VCBUS_REG_ADDR(ENCP_VIDEO_MACV_SCL)
+#define ENCP_VIDEO_Y_OFFST 0x1b88
+#define P_ENCP_VIDEO_Y_OFFST            VCBUS_REG_ADDR(ENCP_VIDEO_Y_OFFST)
+#define ENCP_VIDEO_PB_OFFST 0x1b89
+#define P_ENCP_VIDEO_PB_OFFST           VCBUS_REG_ADDR(ENCP_VIDEO_PB_OFFST)
+#define ENCP_VIDEO_PR_OFFST 0x1b8a
+#define P_ENCP_VIDEO_PR_OFFST           VCBUS_REG_ADDR(ENCP_VIDEO_PR_OFFST)
+#define ENCP_VIDEO_MACV_OFFST 0x1b8c
+#define ENCP_VIDEO_MODE 0x1b8d
+#define P_ENCP_VIDEO_MODE               VCBUS_REG_ADDR(ENCP_VIDEO_MODE)
+#define ENCP_VIDEO_MODE_ADV 0x1b8e
+#define P_ENCP_VIDEO_MODE_ADV           VCBUS_REG_ADDR(ENCP_VIDEO_MODE_ADV)
+#define ENCP_DBG_PX_RST 0x1b90
+#define P_ENCP_DBG_PX_RST               VCBUS_REG_ADDR(ENCP_DBG_PX_RST)
+#define ENCP_DBG_LN_RST 0x1b91
+#define P_ENCP_DBG_LN_RST               VCBUS_REG_ADDR(ENCP_DBG_LN_RST)
+#define ENCP_DBG_PX_INT 0x1b92
+#define P_ENCP_DBG_PX_INT               VCBUS_REG_ADDR(ENCP_DBG_PX_INT)
+#define ENCP_DBG_LN_INT 0x1b93
+#define P_ENCP_DBG_LN_INT               VCBUS_REG_ADDR(ENCP_DBG_LN_INT)
+#define ENCP_VIDEO_YFP1_HTIME 0x1b94
+#define ENCP_VIDEO_YFP2_HTIME 0x1b95
+#define ENCP_VIDEO_YC_DLY 0x1b96
+#define P_ENCP_VIDEO_YC_DLY             VCBUS_REG_ADDR(ENCP_VIDEO_YC_DLY)
+#define ENCP_VIDEO_MAX_PXCNT 0x1b97
+#define P_ENCP_VIDEO_MAX_PXCNT          VCBUS_REG_ADDR(ENCP_VIDEO_MAX_PXCNT)
+#define ENCP_VIDEO_HSO_END 0x1ba8
+#define P_ENCP_VIDEO_HSO_END            VCBUS_REG_ADDR(ENCP_VIDEO_HSO_END)
+#define ENCP_VIDEO_VSO_BEGIN 0x1ba9
+#define P_ENCP_VIDEO_VSO_BEGIN          VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BEGIN)
+#define ENCP_VIDEO_VSO_END 0x1baa
+#define P_ENCP_VIDEO_VSO_END            VCBUS_REG_ADDR(ENCP_VIDEO_VSO_END)
+#define ENCP_VIDEO_VSO_BLINE 0x1bab
+#define P_ENCP_VIDEO_VSO_BLINE          VCBUS_REG_ADDR(ENCP_VIDEO_VSO_BLINE)
+#define ENCP_VIDEO_VSO_ELINE 0x1bac
+#define P_ENCP_VIDEO_VSO_ELINE          VCBUS_REG_ADDR(ENCP_VIDEO_VSO_ELINE)
+#define ENCP_VIDEO_SYNC_WAVE_CURVE 0x1bad
+#define ENCP_VIDEO_MAX_LNCNT 0x1bae
+#define P_ENCP_VIDEO_MAX_LNCNT          VCBUS_REG_ADDR(ENCP_VIDEO_MAX_LNCNT)
+#define ENCP_VIDEO_SY_VAL 0x1bb0
+#define P_ENCP_VIDEO_SY_VAL             VCBUS_REG_ADDR(ENCP_VIDEO_SY_VAL)
+#define ENCP_VIDEO_SY2_VAL 0x1bb1
+#define P_ENCP_VIDEO_SY2_VAL            VCBUS_REG_ADDR(ENCP_VIDEO_SY2_VAL)
+#define ENCP_VIDEO_BLANKY_VAL 0x1bb2
+#define ENCP_VIDEO_HOFFST 0x1bb5
+#define P_ENCP_VIDEO_HOFFST             VCBUS_REG_ADDR(ENCP_VIDEO_HOFFST)
+#define ENCP_VIDEO_VOFFST 0x1bb6
+#define P_ENCP_VIDEO_VOFFST             VCBUS_REG_ADDR(ENCP_VIDEO_VOFFST)
+#define ENCP_VIDEO_RGB_CTRL 0x1bb7
+#define P_ENCP_VIDEO_RGB_CTRL           VCBUS_REG_ADDR(ENCP_VIDEO_RGB_CTRL)
+#define ENCP_VIDEO_FILT_CTRL 0x1bb8
+#define P_ENCP_VIDEO_FILT_CTRL          VCBUS_REG_ADDR(ENCP_VIDEO_FILT_CTRL)
+#define ENCP_VIDEO_OFLD_VPEQ_OFST 0x1bb9
+#define ENCP_MACV_TIME_DOWN 0x1bcb
+#define P_ENCP_MACV_TIME_DOWN           VCBUS_REG_ADDR(ENCP_MACV_TIME_DOWN)
+#define ENCP_MACV_TIME_LO 0x1bcc
+#define P_ENCP_MACV_TIME_LO             VCBUS_REG_ADDR(ENCP_MACV_TIME_LO)
+#define ENCP_MACV_TIME_UP 0x1bcd
+#define P_ENCP_MACV_TIME_UP             VCBUS_REG_ADDR(ENCP_MACV_TIME_UP)
+#define ENCP_MACV_TIME_RST 0x1bce
+#define P_ENCP_MACV_TIME_RST            VCBUS_REG_ADDR(ENCP_MACV_TIME_RST)
+#define ENCP_VBI_CTRL 0x1bd0
+#define P_ENCP_VBI_CTRL                 VCBUS_REG_ADDR(ENCP_VBI_CTRL)
+#define ENCP_VBI_SETTING 0x1bd1
+#define P_ENCP_VBI_SETTING              VCBUS_REG_ADDR(ENCP_VBI_SETTING)
+#define ENCP_VBI_BEGIN 0x1bd2
+#define P_ENCP_VBI_BEGIN                VCBUS_REG_ADDR(ENCP_VBI_BEGIN)
+#define ENCP_VBI_WIDTH 0x1bd3
+#define P_ENCP_VBI_WIDTH                VCBUS_REG_ADDR(ENCP_VBI_WIDTH)
+#define ENCP_VBI_HVAL 0x1bd4
+#define P_ENCP_VBI_HVAL                 VCBUS_REG_ADDR(ENCP_VBI_HVAL)
+#define ENCP_VBI_DATA0 0x1bd5
+#define P_ENCP_VBI_DATA0                VCBUS_REG_ADDR(ENCP_VBI_DATA0)
+#define ENCP_VBI_DATA1 0x1bd6
+#define P_ENCP_VBI_DATA1                VCBUS_REG_ADDR(ENCP_VBI_DATA1)
+#define C656_HS_ST 0x1be0
+#define P_C656_HS_ST            VCBUS_REG_ADDR(C656_HS_ST)
+#define C656_HS_ED 0x1be1
+#define P_C656_HS_ED            VCBUS_REG_ADDR(C656_HS_ED)
+#define C656_VS_LNST_E 0x1be2
+#define P_C656_VS_LNST_E                VCBUS_REG_ADDR(C656_VS_LNST_E)
+#define C656_VS_LNST_O 0x1be3
+#define P_C656_VS_LNST_O                VCBUS_REG_ADDR(C656_VS_LNST_O)
+#define C656_VS_LNED_E 0x1be4
+#define P_C656_VS_LNED_E                VCBUS_REG_ADDR(C656_VS_LNED_E)
+#define C656_VS_LNED_O 0x1be5
+#define P_C656_VS_LNED_O                VCBUS_REG_ADDR(C656_VS_LNED_O)
+#define C656_FS_LNST 0x1be6
+#define P_C656_FS_LNST          VCBUS_REG_ADDR(C656_FS_LNST)
+#define C656_FS_LNED 0x1be7
+#define P_C656_FS_LNED          VCBUS_REG_ADDR(C656_FS_LNED)
+#define ENCI_VIDEO_MODE 0x1b00
+#define P_ENCI_VIDEO_MODE               VCBUS_REG_ADDR(ENCI_VIDEO_MODE)
+#define ENCI_VIDEO_MODE_ADV 0x1b01
+#define P_ENCI_VIDEO_MODE_ADV           VCBUS_REG_ADDR(ENCI_VIDEO_MODE_ADV)
+#define ENCI_VIDEO_FSC_ADJ 0x1b02
+#define P_ENCI_VIDEO_FSC_ADJ            VCBUS_REG_ADDR(ENCI_VIDEO_FSC_ADJ)
+#define ENCI_VIDEO_BRIGHT 0x1b03
+#define P_ENCI_VIDEO_BRIGHT             VCBUS_REG_ADDR(ENCI_VIDEO_BRIGHT)
+#define ENCI_VIDEO_CONT 0x1b04
+#define P_ENCI_VIDEO_CONT               VCBUS_REG_ADDR(ENCI_VIDEO_CONT)
+#define ENCI_VIDEO_SAT 0x1b05
+#define P_ENCI_VIDEO_SAT                VCBUS_REG_ADDR(ENCI_VIDEO_SAT)
+#define ENCI_VIDEO_HUE 0x1b06
+#define P_ENCI_VIDEO_HUE                VCBUS_REG_ADDR(ENCI_VIDEO_HUE)
+#define ENCI_VIDEO_SCH 0x1b07
+#define P_ENCI_VIDEO_SCH                VCBUS_REG_ADDR(ENCI_VIDEO_SCH)
+#define ENCI_SYNC_MODE 0x1b08
+#define P_ENCI_SYNC_MODE                VCBUS_REG_ADDR(ENCI_SYNC_MODE)
+#define ENCI_SYNC_CTRL 0x1b09
+#define P_ENCI_SYNC_CTRL                VCBUS_REG_ADDR(ENCI_SYNC_CTRL)
+#define ENCI_SYNC_HSO_BEGIN 0x1b0a
+#define P_ENCI_SYNC_HSO_BEGIN           VCBUS_REG_ADDR(ENCI_SYNC_HSO_BEGIN)
+#define ENCI_SYNC_HSO_END 0x1b0b
+#define P_ENCI_SYNC_HSO_END             VCBUS_REG_ADDR(ENCI_SYNC_HSO_END)
+#define ENCI_SYNC_VSO_EVN 0x1b0c
+#define P_ENCI_SYNC_VSO_EVN             VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVN)
+#define ENCI_SYNC_VSO_ODD 0x1b0d
+#define P_ENCI_SYNC_VSO_ODD             VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODD)
+#define ENCI_SYNC_VSO_EVNLN 0x1b0e
+#define P_ENCI_SYNC_VSO_EVNLN           VCBUS_REG_ADDR(ENCI_SYNC_VSO_EVNLN)
+#define ENCI_SYNC_VSO_ODDLN 0x1b0f
+#define P_ENCI_SYNC_VSO_ODDLN           VCBUS_REG_ADDR(ENCI_SYNC_VSO_ODDLN)
+#define ENCI_SYNC_HOFFST 0x1b10
+#define P_ENCI_SYNC_HOFFST              VCBUS_REG_ADDR(ENCI_SYNC_HOFFST)
+#define ENCI_SYNC_VOFFST 0x1b11
+#define P_ENCI_SYNC_VOFFST              VCBUS_REG_ADDR(ENCI_SYNC_VOFFST)
+#define ENCI_SYNC_ADJ 0x1b12
+#define P_ENCI_SYNC_ADJ                 VCBUS_REG_ADDR(ENCI_SYNC_ADJ)
+#define ENCI_RGB_SETTING 0x1b13
+#define P_ENCI_RGB_SETTING              VCBUS_REG_ADDR(ENCI_RGB_SETTING)
+#define ENCI_DE_H_BEGIN 0x1b16
+#define P_ENCI_DE_H_BEGIN               VCBUS_REG_ADDR(ENCI_DE_H_BEGIN)
+#define ENCI_DE_H_END 0x1b17
+#define P_ENCI_DE_H_END                 VCBUS_REG_ADDR(ENCI_DE_H_END)
+#define ENCI_DE_V_BEGIN_EVEN 0x1b18
+#define P_ENCI_DE_V_BEGIN_EVEN          VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_EVEN)
+#define ENCI_DE_V_END_EVEN 0x1b19
+#define P_ENCI_DE_V_END_EVEN            VCBUS_REG_ADDR(ENCI_DE_V_END_EVEN)
+#define ENCI_DE_V_BEGIN_ODD 0x1b1a
+#define P_ENCI_DE_V_BEGIN_ODD           VCBUS_REG_ADDR(ENCI_DE_V_BEGIN_ODD)
+#define ENCI_DE_V_END_ODD 0x1b1b
+#define P_ENCI_DE_V_END_ODD             VCBUS_REG_ADDR(ENCI_DE_V_END_ODD)
+#define ENCI_VBI_SETTING 0x1b20
+#define P_ENCI_VBI_SETTING              VCBUS_REG_ADDR(ENCI_VBI_SETTING)
+#define ENCI_VBI_CCDT_EVN 0x1b21
+#define P_ENCI_VBI_CCDT_EVN             VCBUS_REG_ADDR(ENCI_VBI_CCDT_EVN)
+#define ENCI_VBI_CCDT_ODD 0x1b22
+#define P_ENCI_VBI_CCDT_ODD             VCBUS_REG_ADDR(ENCI_VBI_CCDT_ODD)
+#define ENCI_VBI_CC525_LN 0x1b23
+#define P_ENCI_VBI_CC525_LN             VCBUS_REG_ADDR(ENCI_VBI_CC525_LN)
+#define ENCI_VBI_CC625_LN 0x1b24
+#define P_ENCI_VBI_CC625_LN             VCBUS_REG_ADDR(ENCI_VBI_CC625_LN)
+#define ENCI_VBI_WSSDT 0x1b25
+#define P_ENCI_VBI_WSSDT                VCBUS_REG_ADDR(ENCI_VBI_WSSDT)
+#define ENCI_VBI_WSS_LN 0x1b26
+#define P_ENCI_VBI_WSS_LN               VCBUS_REG_ADDR(ENCI_VBI_WSS_LN)
+#define ENCI_VBI_CGMSDT_L 0x1b27
+#define P_ENCI_VBI_CGMSDT_L             VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_L)
+#define ENCI_VBI_CGMSDT_H 0x1b28
+#define P_ENCI_VBI_CGMSDT_H             VCBUS_REG_ADDR(ENCI_VBI_CGMSDT_H)
+#define ENCI_VBI_CGMS_LN 0x1b29
+#define P_ENCI_VBI_CGMS_LN              VCBUS_REG_ADDR(ENCI_VBI_CGMS_LN)
+#define ENCI_VBI_TTX_HTIME 0x1b2a
+#define P_ENCI_VBI_TTX_HTIME            VCBUS_REG_ADDR(ENCI_VBI_TTX_HTIME)
+#define ENCI_VBI_TTX_LN 0x1b2b
+#define P_ENCI_VBI_TTX_LN               VCBUS_REG_ADDR(ENCI_VBI_TTX_LN)
+#define ENCI_VBI_TTXDT0 0x1b2c
+#define P_ENCI_VBI_TTXDT0               VCBUS_REG_ADDR(ENCI_VBI_TTXDT0)
+#define ENCI_VBI_TTXDT1 0x1b2d
+#define P_ENCI_VBI_TTXDT1               VCBUS_REG_ADDR(ENCI_VBI_TTXDT1)
+#define ENCI_VBI_TTXDT2 0x1b2e
+#define P_ENCI_VBI_TTXDT2               VCBUS_REG_ADDR(ENCI_VBI_TTXDT2)
+#define ENCI_VBI_TTXDT3 0x1b2f
+#define P_ENCI_VBI_TTXDT3               VCBUS_REG_ADDR(ENCI_VBI_TTXDT3)
+#define ENCI_MACV_N0 0x1b30
+#define P_ENCI_MACV_N0          VCBUS_REG_ADDR(ENCI_MACV_N0)
+#define ENCI_MACV_N1 0x1b31
+#define P_ENCI_MACV_N1          VCBUS_REG_ADDR(ENCI_MACV_N1)
+#define ENCI_MACV_N2 0x1b32
+#define P_ENCI_MACV_N2          VCBUS_REG_ADDR(ENCI_MACV_N2)
+#define ENCI_MACV_N3 0x1b33
+#define P_ENCI_MACV_N3          VCBUS_REG_ADDR(ENCI_MACV_N3)
+#define ENCI_MACV_N4 0x1b34
+#define P_ENCI_MACV_N4          VCBUS_REG_ADDR(ENCI_MACV_N4)
+#define ENCI_MACV_N5 0x1b35
+#define P_ENCI_MACV_N5          VCBUS_REG_ADDR(ENCI_MACV_N5)
+#define ENCI_MACV_N6 0x1b36
+#define P_ENCI_MACV_N6          VCBUS_REG_ADDR(ENCI_MACV_N6)
+#define ENCI_MACV_N7 0x1b37
+#define P_ENCI_MACV_N7          VCBUS_REG_ADDR(ENCI_MACV_N7)
+#define ENCI_MACV_N8 0x1b38
+#define P_ENCI_MACV_N8          VCBUS_REG_ADDR(ENCI_MACV_N8)
+#define ENCI_MACV_N9 0x1b39
+#define P_ENCI_MACV_N9          VCBUS_REG_ADDR(ENCI_MACV_N9)
+#define ENCI_MACV_N10 0x1b3a
+#define P_ENCI_MACV_N10                 VCBUS_REG_ADDR(ENCI_MACV_N10)
+#define ENCI_MACV_N11 0x1b3b
+#define P_ENCI_MACV_N11                 VCBUS_REG_ADDR(ENCI_MACV_N11)
+#define ENCI_MACV_N12 0x1b3c
+#define P_ENCI_MACV_N12                 VCBUS_REG_ADDR(ENCI_MACV_N12)
+#define ENCI_MACV_N13 0x1b3d
+#define P_ENCI_MACV_N13                 VCBUS_REG_ADDR(ENCI_MACV_N13)
+#define ENCI_MACV_N14 0x1b3e
+#define P_ENCI_MACV_N14                 VCBUS_REG_ADDR(ENCI_MACV_N14)
+#define ENCI_MACV_N15 0x1b3f
+#define P_ENCI_MACV_N15                 VCBUS_REG_ADDR(ENCI_MACV_N15)
+#define ENCI_MACV_N16 0x1b40
+#define P_ENCI_MACV_N16                 VCBUS_REG_ADDR(ENCI_MACV_N16)
+#define ENCI_MACV_N17 0x1b41
+#define P_ENCI_MACV_N17                 VCBUS_REG_ADDR(ENCI_MACV_N17)
+#define ENCI_MACV_N18 0x1b42
+#define P_ENCI_MACV_N18                 VCBUS_REG_ADDR(ENCI_MACV_N18)
+#define ENCI_MACV_N19 0x1b43
+#define P_ENCI_MACV_N19                 VCBUS_REG_ADDR(ENCI_MACV_N19)
+#define ENCI_MACV_N20 0x1b44
+#define P_ENCI_MACV_N20                 VCBUS_REG_ADDR(ENCI_MACV_N20)
+#define ENCI_MACV_N21 0x1b45
+#define P_ENCI_MACV_N21                 VCBUS_REG_ADDR(ENCI_MACV_N21)
+#define ENCI_MACV_N22 0x1b46
+#define P_ENCI_MACV_N22                 VCBUS_REG_ADDR(ENCI_MACV_N22)
+#define ENCI_DBG_PX_RST 0x1b48
+#define P_ENCI_DBG_PX_RST               VCBUS_REG_ADDR(ENCI_DBG_PX_RST)
+#define ENCI_DBG_FLDLN_RST 0x1b49
+#define P_ENCI_DBG_FLDLN_RST            VCBUS_REG_ADDR(ENCI_DBG_FLDLN_RST)
+#define ENCI_DBG_PX_INT 0x1b4a
+#define P_ENCI_DBG_PX_INT               VCBUS_REG_ADDR(ENCI_DBG_PX_INT)
+#define ENCI_DBG_FLDLN_INT 0x1b4b
+#define P_ENCI_DBG_FLDLN_INT            VCBUS_REG_ADDR(ENCI_DBG_FLDLN_INT)
+#define ENCI_DBG_MAXPX 0x1b4c
+#define P_ENCI_DBG_MAXPX                VCBUS_REG_ADDR(ENCI_DBG_MAXPX)
+#define ENCI_DBG_MAXLN 0x1b4d
+#define P_ENCI_DBG_MAXLN                VCBUS_REG_ADDR(ENCI_DBG_MAXLN)
+#define ENCI_MACV_MAX_AMP 0x1b50
+#define P_ENCI_MACV_MAX_AMP             VCBUS_REG_ADDR(ENCI_MACV_MAX_AMP)
+#define ENCI_MACV_PULSE_LO 0x1b51
+#define P_ENCI_MACV_PULSE_LO            VCBUS_REG_ADDR(ENCI_MACV_PULSE_LO)
+#define ENCI_MACV_PULSE_HI 0x1b52
+#define P_ENCI_MACV_PULSE_HI            VCBUS_REG_ADDR(ENCI_MACV_PULSE_HI)
+#define ENCI_MACV_BKP_MAX 0x1b53
+#define P_ENCI_MACV_BKP_MAX             VCBUS_REG_ADDR(ENCI_MACV_BKP_MAX)
+#define ENCI_CFILT_CTRL 0x1b54
+#define P_ENCI_CFILT_CTRL               VCBUS_REG_ADDR(ENCI_CFILT_CTRL)
+#define ENCI_CFILT7 0x1b55
+#define P_ENCI_CFILT7           VCBUS_REG_ADDR(ENCI_CFILT7)
+#define ENCI_YC_DELAY 0x1b56
+#define P_ENCI_YC_DELAY                 VCBUS_REG_ADDR(ENCI_YC_DELAY)
+#define ENCI_VIDEO_EN 0x1b57
+#define P_ENCI_VIDEO_EN                 VCBUS_REG_ADDR(ENCI_VIDEO_EN)
+#define ENCI_DVI_HSO_BEGIN 0x1c00
+#define P_ENCI_DVI_HSO_BEGIN            VCBUS_REG_ADDR(ENCI_DVI_HSO_BEGIN)
+#define ENCI_DVI_HSO_END 0x1c01
+#define P_ENCI_DVI_HSO_END              VCBUS_REG_ADDR(ENCI_DVI_HSO_END)
+#define ENCI_DVI_VSO_END_ODD 0x1c09
+#define P_ENCI_DVI_VSO_END_ODD          VCBUS_REG_ADDR(ENCI_DVI_VSO_END_ODD)
+#define ENCI_CFILT_CTRL2 0x1c0a
+#define P_ENCI_CFILT_CTRL2              VCBUS_REG_ADDR(ENCI_CFILT_CTRL2)
+#define ENCI_DACSEL_0 0x1c0b
+#define P_ENCI_DACSEL_0                 VCBUS_REG_ADDR(ENCI_DACSEL_0)
+#define ENCI_DACSEL_1 0x1c0c
+#define P_ENCI_DACSEL_1                 VCBUS_REG_ADDR(ENCI_DACSEL_1)
+#define ENCP_DACSEL_0 0x1c0d
+#define P_ENCP_DACSEL_0                 VCBUS_REG_ADDR(ENCP_DACSEL_0)
+#define ENCP_DACSEL_1 0x1c0e
+#define P_ENCP_DACSEL_1                 VCBUS_REG_ADDR(ENCP_DACSEL_1)
+#define ENCI_TST_EN 0x1c10
+#define P_ENCI_TST_EN           VCBUS_REG_ADDR(ENCI_TST_EN)
+#define ENCI_TST_MDSEL 0x1c11
+#define P_ENCI_TST_MDSEL                VCBUS_REG_ADDR(ENCI_TST_MDSEL)
+#define ENCI_TST_Y 0x1c12
+#define P_ENCI_TST_Y            VCBUS_REG_ADDR(ENCI_TST_Y)
+#define ENCI_TST_CB 0x1c13
+#define P_ENCI_TST_CB           VCBUS_REG_ADDR(ENCI_TST_CB)
+#define ENCI_TST_CR 0x1c14
+#define P_ENCI_TST_CR           VCBUS_REG_ADDR(ENCI_TST_CR)
+#define ENCI_TST_CLRBAR_STRT 0x1c15
+#define ENCT_VFIFO2VD_CTL2 0x1c27
+#define P_ENCT_VFIFO2VD_CTL2            VCBUS_REG_ADDR(ENCT_VFIFO2VD_CTL2)
+#define ENCT_TST_EN 0x1c28
+#define P_ENCT_TST_EN           VCBUS_REG_ADDR(ENCT_TST_EN)
+#define ENCT_TST_MDSEL 0x1c29
+#define P_ENCT_TST_MDSEL                VCBUS_REG_ADDR(ENCT_TST_MDSEL)
+#define ENCT_TST_Y 0x1c2a
+#define P_ENCT_TST_Y            VCBUS_REG_ADDR(ENCT_TST_Y)
+#define ENCT_TST_CB 0x1c2b
+#define P_ENCT_TST_CB           VCBUS_REG_ADDR(ENCT_TST_CB)
+#define ENCT_TST_CR 0x1c2c
+#define P_ENCT_TST_CR           VCBUS_REG_ADDR(ENCT_TST_CR)
+#define ENCT_TST_CLRBAR_STRT 0x1c2d
+#define P_ENCT_TST_CLRBAR_STRT          VCBUS_REG_ADDR(ENCT_TST_CLRBAR_STRT)
+#define ENCT_TST_CLRBAR_WIDTH 0x1c2e
+#define ENCT_TST_VDCNT_STSET 0x1c2f
+#define P_ENCT_TST_VDCNT_STSET          VCBUS_REG_ADDR(ENCT_TST_VDCNT_STSET)
+#define ENCP_DVI_HSO_BEGIN 0x1c30
+#define P_ENCP_DVI_HSO_BEGIN            VCBUS_REG_ADDR(ENCP_DVI_HSO_BEGIN)
+#define ENCP_DVI_HSO_END 0x1c31
+#define P_ENCP_DVI_HSO_END              VCBUS_REG_ADDR(ENCP_DVI_HSO_END)
+#define ENCP_DVI_VSO_END_EVN 0x1c38
+#define P_ENCP_DVI_VSO_END_EVN          VCBUS_REG_ADDR(ENCP_DVI_VSO_END_EVN)
+#define ENCP_DVI_VSO_END_ODD 0x1c39
+#define P_ENCP_DVI_VSO_END_ODD          VCBUS_REG_ADDR(ENCP_DVI_VSO_END_ODD)
+#define ENCP_DE_H_BEGIN 0x1c3a
+#define P_ENCP_DE_H_BEGIN               VCBUS_REG_ADDR(ENCP_DE_H_BEGIN)
+#define ENCP_DE_H_END 0x1c3b
+#define P_ENCP_DE_H_END                 VCBUS_REG_ADDR(ENCP_DE_H_END)
+#define ENCP_DE_V_BEGIN_EVEN 0x1c3c
+#define P_ENCP_DE_V_BEGIN_EVEN          VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_EVEN)
+#define ENCP_DE_V_END_EVEN 0x1c3d
+#define P_ENCP_DE_V_END_EVEN            VCBUS_REG_ADDR(ENCP_DE_V_END_EVEN)
+#define ENCP_DE_V_BEGIN_ODD 0x1c3e
+#define P_ENCP_DE_V_BEGIN_ODD           VCBUS_REG_ADDR(ENCP_DE_V_BEGIN_ODD)
+#define ENCP_DE_V_END_ODD 0x1c3f
+#define P_ENCP_DE_V_END_ODD             VCBUS_REG_ADDR(ENCP_DE_V_END_ODD)
+
+#define ENCI_SYNC_PIXEL_EN 0x1c41
+#define P_ENCI_SYNC_PIXEL_EN            VCBUS_REG_ADDR(ENCI_SYNC_PIXEL_EN)
+#define ENCI_SYNC_TO_LINE_EN 0x1c42
+#define P_ENCI_SYNC_TO_LINE_EN          VCBUS_REG_ADDR(ENCI_SYNC_TO_LINE_EN)
+#define ENCI_SYNC_TO_PIXEL 0x1c43
+#define P_ENCI_SYNC_TO_PIXEL            VCBUS_REG_ADDR(ENCI_SYNC_TO_PIXEL)
+
+#define ENCT_VIDEO_EN 0x1c60
+#define P_ENCT_VIDEO_EN                 VCBUS_REG_ADDR(ENCT_VIDEO_EN)
+#define ENCT_VIDEO_Y_SCL 0x1c61
+#define P_ENCT_VIDEO_Y_SCL              VCBUS_REG_ADDR(ENCT_VIDEO_Y_SCL)
+#define ENCT_VIDEO_PB_SCL 0x1c62
+#define P_ENCT_VIDEO_PB_SCL             VCBUS_REG_ADDR(ENCT_VIDEO_PB_SCL)
+#define ENCT_VIDEO_PR_SCL 0x1c63
+#define P_ENCT_VIDEO_PR_SCL             VCBUS_REG_ADDR(ENCT_VIDEO_PR_SCL)
+#define ENCT_VIDEO_Y_OFFST 0x1c64
+#define P_ENCT_VIDEO_Y_OFFST            VCBUS_REG_ADDR(ENCT_VIDEO_Y_OFFST)
+#define ENCT_VIDEO_PB_OFFST 0x1c65
+#define P_ENCT_VIDEO_PB_OFFST           VCBUS_REG_ADDR(ENCT_VIDEO_PB_OFFST)
+#define ENCT_VIDEO_PR_OFFST 0x1c66
+#define P_ENCT_VIDEO_PR_OFFST           VCBUS_REG_ADDR(ENCT_VIDEO_PR_OFFST)
+#define ENCT_VIDEO_MODE 0x1c67
+#define P_ENCT_VIDEO_MODE               VCBUS_REG_ADDR(ENCT_VIDEO_MODE)
+#define ENCT_VIDEO_MODE_ADV 0x1c68
+#define P_ENCT_VIDEO_MODE_ADV           VCBUS_REG_ADDR(ENCT_VIDEO_MODE_ADV)
+#define ENCT_DBG_PX_RST 0x1c69
+#define P_ENCT_DBG_PX_RST               VCBUS_REG_ADDR(ENCT_DBG_PX_RST)
+#define ENCT_DBG_LN_RST 0x1c6a
+#define P_ENCT_DBG_LN_RST               VCBUS_REG_ADDR(ENCT_DBG_LN_RST)
+#define ENCT_DBG_PX_INT 0x1c6b
+#define P_ENCT_DBG_PX_INT               VCBUS_REG_ADDR(ENCT_DBG_PX_INT)
+#define ENCT_DBG_LN_INT 0x1c6c
+#define P_ENCT_DBG_LN_INT               VCBUS_REG_ADDR(ENCT_DBG_LN_INT)
+#define ENCL_TST_VDCNT_STSET 0x1c9f
+#define P_ENCL_TST_VDCNT_STSET          VCBUS_REG_ADDR(ENCL_TST_VDCNT_STSET)
+#define ENCL_VIDEO_EN 0x1ca0
+#define P_ENCL_VIDEO_EN                 VCBUS_REG_ADDR(ENCL_VIDEO_EN)
+#define ENCL_VIDEO_Y_SCL 0x1ca1
+#define P_ENCL_VIDEO_Y_SCL              VCBUS_REG_ADDR(ENCL_VIDEO_Y_SCL)
+#define ENCL_VIDEO_PB_SCL 0x1ca2
+#define P_ENCL_VIDEO_PB_SCL             VCBUS_REG_ADDR(ENCL_VIDEO_PB_SCL)
+#define ENCL_VIDEO_PR_SCL 0x1ca3
+#define P_ENCL_VIDEO_PR_SCL             VCBUS_REG_ADDR(ENCL_VIDEO_PR_SCL)
+#define ENCL_VIDEO_Y_OFFST 0x1ca4
+#define P_ENCL_VIDEO_Y_OFFST            VCBUS_REG_ADDR(ENCL_VIDEO_Y_OFFST)
+#define ENCL_VIDEO_PB_OFFST 0x1ca5
+#define P_ENCL_VIDEO_PB_OFFST           VCBUS_REG_ADDR(ENCL_VIDEO_PB_OFFST)
+#define ENCL_VIDEO_PR_OFFST 0x1ca6
+#define P_ENCL_VIDEO_PR_OFFST           VCBUS_REG_ADDR(ENCL_VIDEO_PR_OFFST)
+#define ENCL_VIDEO_MODE 0x1ca7
+#define P_ENCL_VIDEO_MODE               VCBUS_REG_ADDR(ENCL_VIDEO_MODE)
+#define ENCL_VIDEO_MODE_ADV 0x1ca8
+#define P_ENCL_VIDEO_MODE_ADV           VCBUS_REG_ADDR(ENCL_VIDEO_MODE_ADV)
+#define ENCL_DBG_PX_RST 0x1ca9
+#define P_ENCL_DBG_PX_RST               VCBUS_REG_ADDR(ENCL_DBG_PX_RST)
+#define ENCL_DBG_LN_RST 0x1caa
+#define P_ENCL_DBG_LN_RST               VCBUS_REG_ADDR(ENCL_DBG_LN_RST)
+#define ENCL_DBG_PX_INT 0x1cab
+#define P_ENCL_DBG_PX_INT               VCBUS_REG_ADDR(ENCL_DBG_PX_INT)
+#define ENCL_DBG_LN_INT 0x1cac
+#define P_ENCL_DBG_LN_INT               VCBUS_REG_ADDR(ENCL_DBG_LN_INT)
+#define ENCL_VIDEO_YC_DLY 0x1caf
+#define P_ENCL_VIDEO_YC_DLY             VCBUS_REG_ADDR(ENCL_VIDEO_YC_DLY)
+#define ENCL_VIDEO_MAX_PXCNT 0x1cb0
+#define P_ENCL_VIDEO_MAX_PXCNT          VCBUS_REG_ADDR(ENCL_VIDEO_MAX_PXCNT)
+#define ENCL_VIDEO_HAVON_END 0x1cb1
+#define P_ENCL_VIDEO_HAVON_END          VCBUS_REG_ADDR(ENCL_VIDEO_HAVON_END)
+#define ENCL_VIDEO_HSO_BEGIN 0x1cb5
+#define P_ENCL_VIDEO_HSO_BEGIN          VCBUS_REG_ADDR(ENCL_VIDEO_HSO_BEGIN)
+#define ENCL_VIDEO_HSO_END 0x1cb6
+#define P_ENCL_VIDEO_HSO_END            VCBUS_REG_ADDR(ENCL_VIDEO_HSO_END)
+#define ENCL_VIDEO_VSO_BEGIN 0x1cb7
+#define P_ENCL_VIDEO_VSO_BEGIN          VCBUS_REG_ADDR(ENCL_VIDEO_VSO_BEGIN)
+#define ENCL_VIDEO_VSO_END 0x1cb8
+#define P_ENCL_VIDEO_VSO_END            VCBUS_REG_ADDR(ENCL_VIDEO_VSO_END)
+#define ENCL_VIDEO_VSO_BLINE 0x1cb9
+#define P_ENCL_VIDEO_VSO_BLINE          VCBUS_REG_ADDR(ENCL_VIDEO_VSO_BLINE)
+#define ENCL_VIDEO_VSO_ELINE 0x1cba
+#define P_ENCL_VIDEO_VSO_ELINE          VCBUS_REG_ADDR(ENCL_VIDEO_VSO_ELINE)
+#define ENCL_VIDEO_MAX_LNCNT 0x1cbb
+#define P_ENCL_VIDEO_MAX_LNCNT          VCBUS_REG_ADDR(ENCL_VIDEO_MAX_LNCNT)
+#define ENCL_VIDEO_BLANKY_VAL 0x1cbc
+#define RDMA_AHB_END_ADDR_3 0x1cf7
+#define P_RDMA_AHB_END_ADDR_3           VCBUS_REG_ADDR(RDMA_AHB_END_ADDR_3)
+#define RDMA_ACCESS_AUTO 0x1cf8
+#define P_RDMA_ACCESS_AUTO              VCBUS_REG_ADDR(RDMA_ACCESS_AUTO)
+#define RDMA_ACCESS_MAN 0x1cf9
+#define P_RDMA_ACCESS_MAN               VCBUS_REG_ADDR(RDMA_ACCESS_MAN)
+#define RDMA_CTRL 0x1cfa
+#define P_RDMA_CTRL             VCBUS_REG_ADDR(RDMA_CTRL)
+#define RDMA_STATUS 0x1cfb
+#define P_RDMA_STATUS           VCBUS_REG_ADDR(RDMA_STATUS)
+#define L_GAMMA_CNTL_PORT 0x1400
+#define P_L_GAMMA_CNTL_PORT             VCBUS_REG_ADDR(L_GAMMA_CNTL_PORT)
+#define L_GAMMA_DATA_PORT 0x1401
+#define P_L_GAMMA_DATA_PORT             VCBUS_REG_ADDR(L_GAMMA_DATA_PORT)
+#define L_GAMMA_ADDR_PORT 0x1402
+#define P_L_GAMMA_ADDR_PORT             VCBUS_REG_ADDR(L_GAMMA_ADDR_PORT)
+#define L_GAMMA_VCOM_HSWITCH_ADDR 0x1403
+#define L_GAMMA_PROBE_POS_X 0x140d
+#define P_L_GAMMA_PROBE_POS_X           VCBUS_REG_ADDR(L_GAMMA_PROBE_POS_X)
+#define L_GAMMA_PROBE_POS_Y 0x140e
+#define P_L_GAMMA_PROBE_POS_Y           VCBUS_REG_ADDR(L_GAMMA_PROBE_POS_Y)
+#define L_STH1_HS_ADDR 0x1410
+#define P_L_STH1_HS_ADDR                VCBUS_REG_ADDR(L_STH1_HS_ADDR)
+#define L_STH1_HE_ADDR 0x1411
+#define P_L_STH1_HE_ADDR                VCBUS_REG_ADDR(L_STH1_HE_ADDR)
+#define L_STH1_VS_ADDR 0x1412
+#define P_L_STH1_VS_ADDR                VCBUS_REG_ADDR(L_STH1_VS_ADDR)
+#define L_STH1_VE_ADDR 0x1413
+#define P_L_STH1_VE_ADDR                VCBUS_REG_ADDR(L_STH1_VE_ADDR)
+#define L_STH2_HS_ADDR 0x1414
+#define P_L_STH2_HS_ADDR                VCBUS_REG_ADDR(L_STH2_HS_ADDR)
+#define L_STH2_HE_ADDR 0x1415
+#define P_L_STH2_HE_ADDR                VCBUS_REG_ADDR(L_STH2_HE_ADDR)
+#define L_STH2_VS_ADDR 0x1416
+#define P_L_STH2_VS_ADDR                VCBUS_REG_ADDR(L_STH2_VS_ADDR)
+#define L_STH2_VE_ADDR 0x1417
+#define P_L_STH2_VE_ADDR                VCBUS_REG_ADDR(L_STH2_VE_ADDR)
+#define L_OEH_HS_ADDR 0x1418
+#define P_L_OEH_HS_ADDR                 VCBUS_REG_ADDR(L_OEH_HS_ADDR)
+#define L_OEH_HE_ADDR 0x1419
+#define P_L_OEH_HE_ADDR                 VCBUS_REG_ADDR(L_OEH_HE_ADDR)
+#define L_OEH_VS_ADDR 0x141a
+#define P_L_OEH_VS_ADDR                 VCBUS_REG_ADDR(L_OEH_VS_ADDR)
+#define L_OEH_VE_ADDR 0x141b
+#define P_L_OEH_VE_ADDR                 VCBUS_REG_ADDR(L_OEH_VE_ADDR)
+#define L_VCOM_HSWITCH_ADDR 0x141c
+#define P_L_VCOM_HSWITCH_ADDR           VCBUS_REG_ADDR(L_VCOM_HSWITCH_ADDR)
+#define L_VCOM_VS_ADDR 0x141d
+#define P_L_VCOM_VS_ADDR                VCBUS_REG_ADDR(L_VCOM_VS_ADDR)
+#define L_VCOM_VE_ADDR 0x141e
+#define P_L_VCOM_VE_ADDR                VCBUS_REG_ADDR(L_VCOM_VE_ADDR)
+#define L_CPV1_HS_ADDR 0x141f
+#define P_L_CPV1_HS_ADDR                VCBUS_REG_ADDR(L_CPV1_HS_ADDR)
+#define L_CPV1_HE_ADDR 0x1420
+#define P_L_CPV1_HE_ADDR                VCBUS_REG_ADDR(L_CPV1_HE_ADDR)
+#define L_CPV1_VS_ADDR 0x1421
+#define P_L_CPV1_VS_ADDR                VCBUS_REG_ADDR(L_CPV1_VS_ADDR)
+#define L_CPV1_VE_ADDR 0x1422
+#define P_L_CPV1_VE_ADDR                VCBUS_REG_ADDR(L_CPV1_VE_ADDR)
+#define L_CPV2_HS_ADDR 0x1423
+#define P_L_CPV2_HS_ADDR                VCBUS_REG_ADDR(L_CPV2_HS_ADDR)
+#define L_CPV2_HE_ADDR 0x1424
+#define P_L_CPV2_HE_ADDR                VCBUS_REG_ADDR(L_CPV2_HE_ADDR)
+#define L_CPV2_VS_ADDR 0x1425
+#define P_L_CPV2_VS_ADDR                VCBUS_REG_ADDR(L_CPV2_VS_ADDR)
+#define L_CPV2_VE_ADDR 0x1426
+#define P_L_CPV2_VE_ADDR                VCBUS_REG_ADDR(L_CPV2_VE_ADDR)
+#define L_STV1_HS_ADDR 0x1427
+#define P_L_STV1_HS_ADDR                VCBUS_REG_ADDR(L_STV1_HS_ADDR)
+#define L_STV1_HE_ADDR 0x1428
+#define P_L_STV1_HE_ADDR                VCBUS_REG_ADDR(L_STV1_HE_ADDR)
+#define L_STV1_VS_ADDR 0x1429
+#define P_L_STV1_VS_ADDR                VCBUS_REG_ADDR(L_STV1_VS_ADDR)
+#define L_STV1_VE_ADDR 0x142a
+#define P_L_STV1_VE_ADDR                VCBUS_REG_ADDR(L_STV1_VE_ADDR)
+#define L_STV2_HS_ADDR 0x142b
+#define P_L_STV2_HS_ADDR                VCBUS_REG_ADDR(L_STV2_HS_ADDR)
+#define L_STV2_HE_ADDR 0x142c
+#define P_L_STV2_HE_ADDR                VCBUS_REG_ADDR(L_STV2_HE_ADDR)
+#define L_STV2_VS_ADDR 0x142d
+#define P_L_STV2_VS_ADDR                VCBUS_REG_ADDR(L_STV2_VS_ADDR)
+#define L_STV2_VE_ADDR 0x142e
+#define P_L_STV2_VE_ADDR                VCBUS_REG_ADDR(L_STV2_VE_ADDR)
+#define L_OEV1_HS_ADDR 0x142f
+#define P_L_OEV1_HS_ADDR                VCBUS_REG_ADDR(L_OEV1_HS_ADDR)
+#define L_OEV1_HE_ADDR 0x1430
+#define P_L_OEV1_HE_ADDR                VCBUS_REG_ADDR(L_OEV1_HE_ADDR)
+#define L_OEV1_VS_ADDR 0x1431
+#define P_L_OEV1_VS_ADDR                VCBUS_REG_ADDR(L_OEV1_VS_ADDR)
+#define L_OEV1_VE_ADDR 0x1432
+#define P_L_OEV1_VE_ADDR                VCBUS_REG_ADDR(L_OEV1_VE_ADDR)
+#define L_OEV2_HS_ADDR 0x1433
+#define P_L_OEV2_HS_ADDR                VCBUS_REG_ADDR(L_OEV2_HS_ADDR)
+#define L_OEV2_HE_ADDR 0x1434
+#define P_L_OEV2_HE_ADDR                VCBUS_REG_ADDR(L_OEV2_HE_ADDR)
+#define L_OEV2_VS_ADDR 0x1435
+#define P_L_OEV2_VS_ADDR                VCBUS_REG_ADDR(L_OEV2_VS_ADDR)
+#define L_OEV2_VE_ADDR 0x1436
+#define P_L_OEV2_VE_ADDR                VCBUS_REG_ADDR(L_OEV2_VE_ADDR)
+#define L_OEV3_HS_ADDR 0x1437
+#define P_L_OEV3_HS_ADDR                VCBUS_REG_ADDR(L_OEV3_HS_ADDR)
+#define L_OEV3_HE_ADDR 0x1438
+#define P_L_OEV3_HE_ADDR                VCBUS_REG_ADDR(L_OEV3_HE_ADDR)
+#define L_OEV3_VS_ADDR 0x1439
+#define P_L_OEV3_VS_ADDR                VCBUS_REG_ADDR(L_OEV3_VS_ADDR)
+#define L_OEV3_VE_ADDR 0x143a
+#define P_L_OEV3_VE_ADDR                VCBUS_REG_ADDR(L_OEV3_VE_ADDR)
+#define L_LCD_PWR_ADDR 0x143b
+#define P_L_LCD_PWR_ADDR                VCBUS_REG_ADDR(L_LCD_PWR_ADDR)
+#define L_LCD_PWM0_LO_ADDR 0x143c
+#define P_L_LCD_PWM0_LO_ADDR            VCBUS_REG_ADDR(L_LCD_PWM0_LO_ADDR)
+#define L_LCD_PWM0_HI_ADDR 0x143d
+#define P_L_LCD_PWM0_HI_ADDR            VCBUS_REG_ADDR(L_LCD_PWM0_HI_ADDR)
+#define L_LCD_PWM1_LO_ADDR 0x143e
+#define P_L_LCD_PWM1_LO_ADDR            VCBUS_REG_ADDR(L_LCD_PWM1_LO_ADDR)
+#define L_LCD_PWM1_HI_ADDR 0x143f
+#define P_L_LCD_PWM1_HI_ADDR            VCBUS_REG_ADDR(L_LCD_PWM1_HI_ADDR)
+#define L_INV_CNT_ADDR 0x1440
+#define P_L_INV_CNT_ADDR                VCBUS_REG_ADDR(L_INV_CNT_ADDR)
+#define L_TCON_MISC_SEL_ADDR 0x1441
+#define P_L_TCON_MISC_SEL_ADDR          VCBUS_REG_ADDR(L_TCON_MISC_SEL_ADDR)
+#define MLVDS_CLK_CTL1_HI 0x1443
+#define P_MLVDS_CLK_CTL1_HI             VCBUS_REG_ADDR(MLVDS_CLK_CTL1_HI)
+#define MLVDS_CLK_CTL1_LO 0x1444
+#define P_MLVDS_CLK_CTL1_LO             VCBUS_REG_ADDR(MLVDS_CLK_CTL1_LO)
+#define L_TCON_DOUBLE_CTL 0x1449
+#define P_L_TCON_DOUBLE_CTL             VCBUS_REG_ADDR(L_TCON_DOUBLE_CTL)
+#define L_TCON_PATTERN_HI 0x144a
+#define P_L_TCON_PATTERN_HI             VCBUS_REG_ADDR(L_TCON_PATTERN_HI)
+#define L_TCON_PATTERN_LO 0x144b
+#define P_L_TCON_PATTERN_LO             VCBUS_REG_ADDR(L_TCON_PATTERN_LO)
+#define LDIM_BL_ADDR_PORT 0x144e
+#define P_LDIM_BL_ADDR_PORT             VCBUS_REG_ADDR(LDIM_BL_ADDR_PORT)
+#define LDIM_BL_DATA_PORT 0x144f
+#define P_LDIM_BL_DATA_PORT             VCBUS_REG_ADDR(LDIM_BL_DATA_PORT)
+#define L_DE_HS_ADDR 0x1451
+#define P_L_DE_HS_ADDR          VCBUS_REG_ADDR(L_DE_HS_ADDR)
+#define L_DE_HE_ADDR 0x1452
+#define P_L_DE_HE_ADDR          VCBUS_REG_ADDR(L_DE_HE_ADDR)
+#define L_DE_VS_ADDR 0x1453
+#define P_L_DE_VS_ADDR          VCBUS_REG_ADDR(L_DE_VS_ADDR)
+#define L_DE_VE_ADDR 0x1454
+#define P_L_DE_VE_ADDR          VCBUS_REG_ADDR(L_DE_VE_ADDR)
+#define L_HSYNC_HS_ADDR 0x1455
+#define P_L_HSYNC_HS_ADDR               VCBUS_REG_ADDR(L_HSYNC_HS_ADDR)
+#define L_HSYNC_HE_ADDR 0x1456
+#define P_L_HSYNC_HE_ADDR               VCBUS_REG_ADDR(L_HSYNC_HE_ADDR)
+#define L_HSYNC_VS_ADDR 0x1457
+#define P_L_HSYNC_VS_ADDR               VCBUS_REG_ADDR(L_HSYNC_VS_ADDR)
+#define L_HSYNC_VE_ADDR 0x1458
+#define P_L_HSYNC_VE_ADDR               VCBUS_REG_ADDR(L_HSYNC_VE_ADDR)
+#define L_VSYNC_HS_ADDR 0x1459
+#define P_L_VSYNC_HS_ADDR               VCBUS_REG_ADDR(L_VSYNC_HS_ADDR)
+#define L_VSYNC_HE_ADDR 0x145a
+#define P_L_VSYNC_HE_ADDR               VCBUS_REG_ADDR(L_VSYNC_HE_ADDR)
+#define L_VSYNC_VS_ADDR 0x145b
+#define P_L_VSYNC_VS_ADDR               VCBUS_REG_ADDR(L_VSYNC_VS_ADDR)
+#define L_VSYNC_VE_ADDR 0x145c
+#define P_L_VSYNC_VE_ADDR               VCBUS_REG_ADDR(L_VSYNC_VE_ADDR)
+#define L_LCD_MCU_CTL 0x145d
+#define P_L_LCD_MCU_CTL                 VCBUS_REG_ADDR(L_LCD_MCU_CTL)
+#define DUAL_MLVDS_CTL 0x1460
+#define P_DUAL_MLVDS_CTL                VCBUS_REG_ADDR(DUAL_MLVDS_CTL)
+
+#define V_INVERSION_PIXEL 0x1470
+#define P_V_INVERSION_PIXEL             VCBUS_REG_ADDR(V_INVERSION_PIXEL)
+#define V_INVERSION_LINE 0x1471
+#define P_V_INVERSION_LINE              VCBUS_REG_ADDR(V_INVERSION_LINE)
+#define V_INVERSION_CONTROL 0x1472
+#define P_V_INVERSION_CONTROL           VCBUS_REG_ADDR(V_INVERSION_CONTROL)
+#define MLVDS2_CONTROL 0x1474
+#define P_MLVDS2_CONTROL                VCBUS_REG_ADDR(MLVDS2_CONTROL)
+#define MLVDS2_CONFIG_HI 0x1475
+#define P_MLVDS2_CONFIG_HI              VCBUS_REG_ADDR(MLVDS2_CONFIG_HI)
+#define MLVDS2_CONFIG_LO 0x1476
+#define P_MLVDS2_CONFIG_LO              VCBUS_REG_ADDR(MLVDS2_CONFIG_LO)
+#define MLVDS2_DUAL_GATE_WR_START 0x1477
+#define RGB_BASE_ADDR 0x1485
+#define P_RGB_BASE_ADDR                 VCBUS_REG_ADDR(RGB_BASE_ADDR)
+#define RGB_COEFF_ADDR 0x1486
+#define P_RGB_COEFF_ADDR                VCBUS_REG_ADDR(RGB_COEFF_ADDR)
+#define POL_CNTL_ADDR 0x1487
+#define P_POL_CNTL_ADDR                 VCBUS_REG_ADDR(POL_CNTL_ADDR)
+#define DITH_CNTL_ADDR 0x1488
+#define P_DITH_CNTL_ADDR                VCBUS_REG_ADDR(DITH_CNTL_ADDR)
+#define GAMMA_PROBE_CTRL 0x1489
+#define P_GAMMA_PROBE_CTRL              VCBUS_REG_ADDR(GAMMA_PROBE_CTRL)
+#define GAMMA_PROBE_COLOR_L 0x148a
+#define P_GAMMA_PROBE_COLOR_L           VCBUS_REG_ADDR(GAMMA_PROBE_COLOR_L)
+#define GAMMA_PROBE_COLOR_H 0x148b
+#define P_GAMMA_PROBE_COLOR_H           VCBUS_REG_ADDR(GAMMA_PROBE_COLOR_H)
+#define GAMMA_PROBE_HL_COLOR 0x148c
+#define P_GAMMA_PROBE_HL_COLOR          VCBUS_REG_ADDR(GAMMA_PROBE_HL_COLOR)
+#define GAMMA_PROBE_POS_X 0x148d
+#define P_GAMMA_PROBE_POS_X             VCBUS_REG_ADDR(GAMMA_PROBE_POS_X)
+#define GAMMA_PROBE_POS_Y 0x148e
+#define P_GAMMA_PROBE_POS_Y             VCBUS_REG_ADDR(GAMMA_PROBE_POS_Y)
+#define STH1_HS_ADDR 0x1490
+#define P_STH1_HS_ADDR          VCBUS_REG_ADDR(STH1_HS_ADDR)
+#define STH1_HE_ADDR 0x1491
+#define P_STH1_HE_ADDR          VCBUS_REG_ADDR(STH1_HE_ADDR)
+#define STH1_VS_ADDR 0x1492
+#define P_STH1_VS_ADDR          VCBUS_REG_ADDR(STH1_VS_ADDR)
+#define STH1_VE_ADDR 0x1493
+#define P_STH1_VE_ADDR          VCBUS_REG_ADDR(STH1_VE_ADDR)
+#define STH2_HS_ADDR 0x1494
+#define P_STH2_HS_ADDR          VCBUS_REG_ADDR(STH2_HS_ADDR)
+#define STH2_HE_ADDR 0x1495
+#define P_STH2_HE_ADDR          VCBUS_REG_ADDR(STH2_HE_ADDR)
+#define STH2_VS_ADDR 0x1496
+#define P_STH2_VS_ADDR          VCBUS_REG_ADDR(STH2_VS_ADDR)
+#define STH2_VE_ADDR 0x1497
+#define P_STH2_VE_ADDR          VCBUS_REG_ADDR(STH2_VE_ADDR)
+#define OEH_HS_ADDR 0x1498
+#define P_OEH_HS_ADDR           VCBUS_REG_ADDR(OEH_HS_ADDR)
+#define OEH_HE_ADDR 0x1499
+#define P_OEH_HE_ADDR           VCBUS_REG_ADDR(OEH_HE_ADDR)
+#define OEH_VS_ADDR 0x149a
+#define P_OEH_VS_ADDR           VCBUS_REG_ADDR(OEH_VS_ADDR)
+#define OEH_VE_ADDR 0x149b
+#define P_OEH_VE_ADDR           VCBUS_REG_ADDR(OEH_VE_ADDR)
+#define VCOM_HSWITCH_ADDR 0x149c
+#define P_VCOM_HSWITCH_ADDR             VCBUS_REG_ADDR(VCOM_HSWITCH_ADDR)
+#define VCOM_VS_ADDR 0x149d
+#define P_VCOM_VS_ADDR          VCBUS_REG_ADDR(VCOM_VS_ADDR)
+#define VCOM_VE_ADDR 0x149e
+#define P_VCOM_VE_ADDR          VCBUS_REG_ADDR(VCOM_VE_ADDR)
+#define CPV1_HS_ADDR 0x149f
+#define P_CPV1_HS_ADDR          VCBUS_REG_ADDR(CPV1_HS_ADDR)
+#define CPV1_HE_ADDR 0x14a0
+#define P_CPV1_HE_ADDR          VCBUS_REG_ADDR(CPV1_HE_ADDR)
+#define CPV1_VS_ADDR 0x14a1
+#define P_CPV1_VS_ADDR          VCBUS_REG_ADDR(CPV1_VS_ADDR)
+#define CPV1_VE_ADDR 0x14a2
+#define P_CPV1_VE_ADDR          VCBUS_REG_ADDR(CPV1_VE_ADDR)
+#define CPV2_HS_ADDR 0x14a3
+#define P_CPV2_HS_ADDR          VCBUS_REG_ADDR(CPV2_HS_ADDR)
+#define CPV2_HE_ADDR 0x14a4
+#define P_CPV2_HE_ADDR          VCBUS_REG_ADDR(CPV2_HE_ADDR)
+#define CPV2_VS_ADDR 0x14a5
+#define P_CPV2_VS_ADDR          VCBUS_REG_ADDR(CPV2_VS_ADDR)
+#define CPV2_VE_ADDR 0x14a6
+#define P_CPV2_VE_ADDR          VCBUS_REG_ADDR(CPV2_VE_ADDR)
+#define STV1_HS_ADDR 0x14a7
+#define P_STV1_HS_ADDR          VCBUS_REG_ADDR(STV1_HS_ADDR)
+#define STV1_HE_ADDR 0x14a8
+#define P_STV1_HE_ADDR          VCBUS_REG_ADDR(STV1_HE_ADDR)
+#define STV1_VS_ADDR 0x14a9
+#define P_STV1_VS_ADDR          VCBUS_REG_ADDR(STV1_VS_ADDR)
+#define STV1_VE_ADDR 0x14aa
+#define P_STV1_VE_ADDR          VCBUS_REG_ADDR(STV1_VE_ADDR)
+#define STV2_HS_ADDR 0x14ab
+#define P_STV2_HS_ADDR          VCBUS_REG_ADDR(STV2_HS_ADDR)
+#define STV2_HE_ADDR 0x14ac
+#define P_STV2_HE_ADDR          VCBUS_REG_ADDR(STV2_HE_ADDR)
+#define STV2_VS_ADDR 0x14ad
+#define P_STV2_VS_ADDR          VCBUS_REG_ADDR(STV2_VS_ADDR)
+#define STV2_VE_ADDR 0x14ae
+#define P_STV2_VE_ADDR          VCBUS_REG_ADDR(STV2_VE_ADDR)
+#define OEV1_HS_ADDR 0x14af
+#define P_OEV1_HS_ADDR          VCBUS_REG_ADDR(OEV1_HS_ADDR)
+#define OEV1_HE_ADDR 0x14b0
+#define P_OEV1_HE_ADDR          VCBUS_REG_ADDR(OEV1_HE_ADDR)
+#define OEV1_VS_ADDR 0x14b1
+#define P_OEV1_VS_ADDR          VCBUS_REG_ADDR(OEV1_VS_ADDR)
+#define OEV1_VE_ADDR 0x14b2
+#define P_OEV1_VE_ADDR          VCBUS_REG_ADDR(OEV1_VE_ADDR)
+#define OEV2_HS_ADDR 0x14b3
+#define P_OEV2_HS_ADDR          VCBUS_REG_ADDR(OEV2_HS_ADDR)
+#define OEV2_HE_ADDR 0x14b4
+#define P_OEV2_HE_ADDR          VCBUS_REG_ADDR(OEV2_HE_ADDR)
+#define OEV2_VS_ADDR 0x14b5
+#define P_OEV2_VS_ADDR          VCBUS_REG_ADDR(OEV2_VS_ADDR)
+#define OEV2_VE_ADDR 0x14b6
+#define P_OEV2_VE_ADDR          VCBUS_REG_ADDR(OEV2_VE_ADDR)
+#define OEV3_HS_ADDR 0x14b7
+#define P_OEV3_HS_ADDR          VCBUS_REG_ADDR(OEV3_HS_ADDR)
+#define OEV3_HE_ADDR 0x14b8
+#define P_OEV3_HE_ADDR          VCBUS_REG_ADDR(OEV3_HE_ADDR)
+#define OEV3_VS_ADDR 0x14b9
+#define P_OEV3_VS_ADDR          VCBUS_REG_ADDR(OEV3_VS_ADDR)
+#define OEV3_VE_ADDR 0x14ba
+#define P_OEV3_VE_ADDR          VCBUS_REG_ADDR(OEV3_VE_ADDR)
+#define LCD_PWR_ADDR 0x14bb
+#define P_LCD_PWR_ADDR          VCBUS_REG_ADDR(LCD_PWR_ADDR)
+#define LCD_PWM0_LO_ADDR 0x14bc
+#define P_LCD_PWM0_LO_ADDR              VCBUS_REG_ADDR(LCD_PWM0_LO_ADDR)
+#define LCD_PWM0_HI_ADDR 0x14bd
+#define P_LCD_PWM0_HI_ADDR              VCBUS_REG_ADDR(LCD_PWM0_HI_ADDR)
+#define LCD_PWM1_LO_ADDR 0x14be
+#define P_LCD_PWM1_LO_ADDR              VCBUS_REG_ADDR(LCD_PWM1_LO_ADDR)
+#define LCD_PWM1_HI_ADDR 0x14bf
+#define P_LCD_PWM1_HI_ADDR              VCBUS_REG_ADDR(LCD_PWM1_HI_ADDR)
+#define INV_CNT_ADDR 0x14c0
+#define P_INV_CNT_ADDR          VCBUS_REG_ADDR(INV_CNT_ADDR)
+#define TCON_MISC_SEL_ADDR 0x14c1
+#define P_TCON_MISC_SEL_ADDR            VCBUS_REG_ADDR(TCON_MISC_SEL_ADDR)
+#define DUAL_PORT_CNTL_ADDR 0x14c2
+#define P_DUAL_PORT_CNTL_ADDR           VCBUS_REG_ADDR(DUAL_PORT_CNTL_ADDR)
+#define MLVDS_CONTROL 0x14c3
+#define P_MLVDS_CONTROL                 VCBUS_REG_ADDR(MLVDS_CONTROL)
+#define MLVDS_CONFIG_HI 0x14c7
+#define P_MLVDS_CONFIG_HI               VCBUS_REG_ADDR(MLVDS_CONFIG_HI)
+#define MLVDS_CONFIG_LO 0x14c8
+#define P_MLVDS_CONFIG_LO               VCBUS_REG_ADDR(MLVDS_CONFIG_LO)
+#define TCON_DOUBLE_CTL 0x14c9
+#define P_TCON_DOUBLE_CTL               VCBUS_REG_ADDR(TCON_DOUBLE_CTL)
+#define TCON_PATTERN_HI 0x14ca
+#define P_TCON_PATTERN_HI               VCBUS_REG_ADDR(TCON_PATTERN_HI)
+#define TCON_PATTERN_LO 0x14cb
+#define P_TCON_PATTERN_LO               VCBUS_REG_ADDR(TCON_PATTERN_LO)
+#define TCON_CONTROL_HI 0x14cc
+#define P_TCON_CONTROL_HI               VCBUS_REG_ADDR(TCON_CONTROL_HI)
+#define TCON_CONTROL_LO 0x14cd
+#define P_TCON_CONTROL_LO               VCBUS_REG_ADDR(TCON_CONTROL_LO)
+#define LVDS_BLANK_DATA_HI 0x14ce
+#define P_LVDS_BLANK_DATA_HI            VCBUS_REG_ADDR(LVDS_BLANK_DATA_HI)
+#define LVDS_BLANK_DATA_LO 0x14cf
+#define P_LVDS_BLANK_DATA_LO            VCBUS_REG_ADDR(LVDS_BLANK_DATA_LO)
+#define LVDS_PACK_CNTL_ADDR 0x14d0
+#define P_LVDS_PACK_CNTL_ADDR           VCBUS_REG_ADDR(LVDS_PACK_CNTL_ADDR)
+#define DE_HS_ADDR 0x14d1
+#define P_DE_HS_ADDR            VCBUS_REG_ADDR(DE_HS_ADDR)
+#define DE_HE_ADDR 0x14d2
+#define P_DE_HE_ADDR            VCBUS_REG_ADDR(DE_HE_ADDR)
+#define DE_VS_ADDR 0x14d3
+#define P_DE_VS_ADDR            VCBUS_REG_ADDR(DE_VS_ADDR)
+#define DE_VE_ADDR 0x14d4
+#define P_DE_VE_ADDR            VCBUS_REG_ADDR(DE_VE_ADDR)
+#define HSYNC_HS_ADDR 0x14d5
+#define P_HSYNC_HS_ADDR                 VCBUS_REG_ADDR(HSYNC_HS_ADDR)
+#define HSYNC_HE_ADDR 0x14d6
+#define P_HSYNC_HE_ADDR                 VCBUS_REG_ADDR(HSYNC_HE_ADDR)
+#define HSYNC_VS_ADDR 0x14d7
+#define P_HSYNC_VS_ADDR                 VCBUS_REG_ADDR(HSYNC_VS_ADDR)
+#define HSYNC_VE_ADDR 0x14d8
+#define P_HSYNC_VE_ADDR                 VCBUS_REG_ADDR(HSYNC_VE_ADDR)
+#define VSYNC_HS_ADDR 0x14d9
+#define P_VSYNC_HS_ADDR                 VCBUS_REG_ADDR(VSYNC_HS_ADDR)
+#define VSYNC_HE_ADDR 0x14da
+#define P_VSYNC_HE_ADDR                 VCBUS_REG_ADDR(VSYNC_HE_ADDR)
+#define VSYNC_VS_ADDR 0x14db
+#define P_VSYNC_VS_ADDR                 VCBUS_REG_ADDR(VSYNC_VS_ADDR)
+#define VSYNC_VE_ADDR 0x14dc
+#define P_VSYNC_VE_ADDR                 VCBUS_REG_ADDR(VSYNC_VE_ADDR)
+#define LCD_MCU_CTL 0x14dd
+#define P_LCD_MCU_CTL           VCBUS_REG_ADDR(LCD_MCU_CTL)
+#define LCD_MCU_DATA_0 0x14de
+#define P_LCD_MCU_DATA_0                VCBUS_REG_ADDR(LCD_MCU_DATA_0)
+#define LCD_MCU_DATA_1 0x14df
+#define P_LCD_MCU_DATA_1                VCBUS_REG_ADDR(LCD_MCU_DATA_1)
+#define LVDS_GEN_CNTL 0x14e0
+#define P_LVDS_GEN_CNTL                 VCBUS_REG_ADDR(LVDS_GEN_CNTL)
+#define LVDS_PHY_CNTL0 0x14e1
+#define P_LVDS_PHY_CNTL0                VCBUS_REG_ADDR(LVDS_PHY_CNTL0)
+#define LVDS_PHY_CNTL1 0x14e2
+#define P_LVDS_PHY_CNTL1                VCBUS_REG_ADDR(LVDS_PHY_CNTL1)
+#define LVDS_PHY_CNTL2 0x14e3
+#define P_LVDS_PHY_CNTL2                VCBUS_REG_ADDR(LVDS_PHY_CNTL2)
+#define LVDS_PHY_CNTL3 0x14e4
+#define P_LVDS_PHY_CNTL3                VCBUS_REG_ADDR(LVDS_PHY_CNTL3)
+#define LVDS_PHY_CNTL4 0x14e5
+#define P_LVDS_PHY_CNTL4                VCBUS_REG_ADDR(LVDS_PHY_CNTL4)
+#define LVDS_PHY_CNTL5 0x14e6
+#define P_LVDS_PHY_CNTL5                VCBUS_REG_ADDR(LVDS_PHY_CNTL5)
+#define LVDS_SRG_TEST 0x14e8
+#define P_LVDS_SRG_TEST                 VCBUS_REG_ADDR(LVDS_SRG_TEST)
+#define LVDS_BIST_MUX0 0x14e9
+#define P_LVDS_BIST_MUX0                VCBUS_REG_ADDR(LVDS_BIST_MUX0)
+#define LVDS_BIST_MUX1 0x14ea
+#define P_LVDS_BIST_MUX1                VCBUS_REG_ADDR(LVDS_BIST_MUX1)
+#define LVDS_BIST_FIXED0 0x14eb
+#define P_LVDS_BIST_FIXED0              VCBUS_REG_ADDR(LVDS_BIST_FIXED0)
+#define LVDS_BIST_FIXED1 0x14ec
+#define P_LVDS_BIST_FIXED1              VCBUS_REG_ADDR(LVDS_BIST_FIXED1)
+#define P_VPU_OSD1_MMC_CTRL             VCBUS_REG_ADDR(VPU_OSD1_MMC_CTRL)
+#define VPU_OSD2_MMC_CTRL 0x2702
+#define P_VPU_OSD2_MMC_CTRL             VCBUS_REG_ADDR(VPU_OSD2_MMC_CTRL)
+#define VPU_VD1_MMC_CTRL 0x2703
+#define P_VPU_VD1_MMC_CTRL              VCBUS_REG_ADDR(VPU_VD1_MMC_CTRL)
+#define VPU_VD2_MMC_CTRL 0x2704
+#define P_VPU_VD2_MMC_CTRL              VCBUS_REG_ADDR(VPU_VD2_MMC_CTRL)
+#define VPU_DI_IF1_MMC_CTRL 0x2705
+#define P_VPU_DI_IF1_MMC_CTRL           VCBUS_REG_ADDR(VPU_DI_IF1_MMC_CTRL)
+#define VPU_DI_MEM_MMC_CTRL 0x2706
+#define P_VPU_DI_MEM_MMC_CTRL           VCBUS_REG_ADDR(VPU_DI_MEM_MMC_CTRL)
+#define VPU_DI_INP_MMC_CTRL 0x2707
+#define P_VPU_DI_INP_MMC_CTRL           VCBUS_REG_ADDR(VPU_DI_INP_MMC_CTRL)
+#define VPU_DI_NRWR_MMC_CTRL 0x270b
+#define P_VPU_DI_NRWR_MMC_CTRL          VCBUS_REG_ADDR(VPU_DI_NRWR_MMC_CTRL)
+#define VPU_DI_DIWR_MMC_CTRL 0x270c
+#define P_VPU_DI_DIWR_MMC_CTRL          VCBUS_REG_ADDR(VPU_DI_DIWR_MMC_CTRL)
+#define VPU_VDIN0_MMC_CTRL 0x270d
+#define P_VPU_VDIN0_MMC_CTRL            VCBUS_REG_ADDR(VPU_VDIN0_MMC_CTRL)
+#define VPU_VDIN1_MMC_CTRL 0x270e
+#define P_VPU_VDIN1_MMC_CTRL            VCBUS_REG_ADDR(VPU_VDIN1_MMC_CTRL)
+#define VPU_BT656_MMC_CTRL 0x270f
+#define P_VPU_BT656_MMC_CTRL            VCBUS_REG_ADDR(VPU_BT656_MMC_CTRL)
+#define VPU_TVD3D_MMC_CTRL 0x2710
+#define P_VPU_TVD3D_MMC_CTRL            VCBUS_REG_ADDR(VPU_TVD3D_MMC_CTRL)
+#define VPU_TVDVBI_MMC_CTRL 0x2711
+#define P_VPU_TVDVBI_MMC_CTRL           VCBUS_REG_ADDR(VPU_TVDVBI_MMC_CTRL)
+#define VPU_TVDVBI_VSLATCH_ADDR 0x2712
+#define VPU_HDMI_SETTING 0x271b
+#define P_VPU_HDMI_SETTING              VCBUS_REG_ADDR(VPU_HDMI_SETTING)
+#define ENCI_INFO_READ 0x271c
+#define P_ENCI_INFO_READ                VCBUS_REG_ADDR(ENCI_INFO_READ)
+#define ENCP_INFO_READ 0x271d
+#define P_ENCP_INFO_READ                VCBUS_REG_ADDR(ENCP_INFO_READ)
+#define ENCT_INFO_READ 0x271e
+#define P_ENCT_INFO_READ                VCBUS_REG_ADDR(ENCT_INFO_READ)
+#define ENCL_INFO_READ 0x271f
+#define P_ENCL_INFO_READ                VCBUS_REG_ADDR(ENCL_INFO_READ)
+#define VPU_SW_RESET 0x2720
+#define P_VPU_SW_RESET          VCBUS_REG_ADDR(VPU_SW_RESET)
+#define VPU_D2D3_MMC_CTRL 0x2721
+#define P_VPU_D2D3_MMC_CTRL             VCBUS_REG_ADDR(VPU_D2D3_MMC_CTRL)
+#define VPU_CONT_MMC_CTRL 0x2722
+#define P_VPU_CONT_MMC_CTRL             VCBUS_REG_ADDR(VPU_CONT_MMC_CTRL)
+#define VPU_CLK_GATE 0x2723
+#define P_VPU_CLK_GATE          VCBUS_REG_ADDR(VPU_CLK_GATE)
+#define VPU_RDMA_MMC_CTRL 0x2724
+#define P_VPU_RDMA_MMC_CTRL             VCBUS_REG_ADDR(VPU_RDMA_MMC_CTRL)
+#define VPU_MEM_PD_REG0 0x2725
+#define P_VPU_MEM_PD_REG0               VCBUS_REG_ADDR(VPU_MEM_PD_REG0)
+#define VPU_MEM_PD_REG1 0x2726
+#define P_VPU_MEM_PD_REG1               VCBUS_REG_ADDR(VPU_MEM_PD_REG1)
+#define VPU_HDMI_DATA_OVR 0x2727
+#define P_VPU_HDMI_DATA_OVR             VCBUS_REG_ADDR(VPU_HDMI_DATA_OVR)
+#define VPU_PROT1_MMC_CTRL 0x2728
+#define P_VPU_PROT1_MMC_CTRL            VCBUS_REG_ADDR(VPU_PROT1_MMC_CTRL)
+#define VPU_PROT2_MMC_CTRL 0x2729
+#define P_VPU_PROT2_MMC_CTRL            VCBUS_REG_ADDR(VPU_PROT2_MMC_CTRL)
+#define VPU_PROT3_MMC_CTRL 0x272a
+#define P_VPU_PROT3_MMC_CTRL            VCBUS_REG_ADDR(VPU_PROT3_MMC_CTRL)
+#define VPU_ARB4_V1_MMC_CTRL 0x272b
+#define P_VPU_ARB4_V1_MMC_CTRL          VCBUS_REG_ADDR(VPU_ARB4_V1_MMC_CTRL)
+#define VPU_ARB4_V2_MMC_CTRL 0x272c
+#define P_VPU_ARB4_V2_MMC_CTRL          VCBUS_REG_ADDR(VPU_ARB4_V2_MMC_CTRL)
+#define VPU_VPU_PWM_V0 0x2730
+#define P_VPU_VPU_PWM_V0                VCBUS_REG_ADDR(VPU_VPU_PWM_V0)
+#define VPU_VPU_PWM_V1 0x2731
+#define P_VPU_VPU_PWM_V1                VCBUS_REG_ADDR(VPU_VPU_PWM_V1)
+#define VPU_VPU_PWM_V2 0x2732
+#define P_VPU_VPU_PWM_V2                VCBUS_REG_ADDR(VPU_VPU_PWM_V2)
+#define VPU_VPU_PWM_V3 0x2733
+#define P_VPU_VPU_PWM_V3                VCBUS_REG_ADDR(VPU_VPU_PWM_V3)
+#define VPU_VPU_PWM_H0 0x2734
+#define P_VPU_VPU_PWM_H0                VCBUS_REG_ADDR(VPU_VPU_PWM_H0)
+#define VPU_VPU_PWM_H1 0x2735
+#define P_VPU_VPU_PWM_H1                VCBUS_REG_ADDR(VPU_VPU_PWM_H1)
+#define VPU_VPU_PWM_H2 0x2736
+#define VPU_PROT2_Y_LEN_STEP 0x2764
+#define P_VPU_PROT2_Y_LEN_STEP          VCBUS_REG_ADDR(VPU_PROT2_Y_LEN_STEP)
+#define VPU_PROT2_RPT_LOOP 0x2765
+#define P_VPU_PROT2_RPT_LOOP            VCBUS_REG_ADDR(VPU_PROT2_RPT_LOOP)
+#define VPU_PROT2_RPT_PAT 0x2766
+#define P_VPU_PROT2_RPT_PAT             VCBUS_REG_ADDR(VPU_PROT2_RPT_PAT)
+#define VPU_PROT2_DDR 0x2767
+#define P_VPU_PROT2_DDR                 VCBUS_REG_ADDR(VPU_PROT2_DDR)
+#define VPU_PROT2_RBUF_ROOM 0x2768
+#define P_VPU_PROT2_RBUF_ROOM           VCBUS_REG_ADDR(VPU_PROT2_RBUF_ROOM)
+#define VPU_PROT2_STAT_0 0x2769
+#define P_VPU_PROT2_STAT_0              VCBUS_REG_ADDR(VPU_PROT2_STAT_0)
+#define VPU_PROT2_STAT_1 0x276a
+#define P_VPU_PROT2_STAT_1              VCBUS_REG_ADDR(VPU_PROT2_STAT_1)
+#define VPU_PROT2_STAT_2 0x276b
+#define MC_CTRL_REG 0x0900
+#define P_MC_CTRL_REG           DOS_REG_ADDR(MC_CTRL_REG)
+#define MC_MB_INFO 0x0901
+#define P_MC_MB_INFO            DOS_REG_ADDR(MC_MB_INFO)
+#define MC_PIC_INFO 0x0902
+#define P_MC_PIC_INFO           DOS_REG_ADDR(MC_PIC_INFO)
+#define MC_HALF_PEL_ONE 0x0903
+#define P_MC_HALF_PEL_ONE               DOS_REG_ADDR(MC_HALF_PEL_ONE)
+#define MC_HALF_PEL_TWO 0x0904
+#define P_MC_HALF_PEL_TWO               DOS_REG_ADDR(MC_HALF_PEL_TWO)
+#define POWER_CTL_MC 0x0905
+#define P_POWER_CTL_MC          DOS_REG_ADDR(POWER_CTL_MC)
+#define MC_CMD 0x0906
+#define P_MC_CMD                DOS_REG_ADDR(MC_CMD)
+#define MC_CTRL0 0x0907
+#define P_MC_CTRL0              DOS_REG_ADDR(MC_CTRL0)
+#define MC_PIC_W_H 0x0908
+#define P_MC_PIC_W_H            DOS_REG_ADDR(MC_PIC_W_H)
+#define MC_STATUS0 0x0909
+#define P_MC_STATUS0            DOS_REG_ADDR(MC_STATUS0)
+#define MC_STATUS1 0x090a
+#define P_MC_STATUS1            DOS_REG_ADDR(MC_STATUS1)
+#define MC_CTRL1 0x090b
+#define P_MC_CTRL1              DOS_REG_ADDR(MC_CTRL1)
+#define MC_MIX_RATIO0 0x090c
+#define P_MC_MIX_RATIO0                 DOS_REG_ADDR(MC_MIX_RATIO0)
+#define MC_MIX_RATIO1 0x090d
+#define P_MC_MIX_RATIO1                 DOS_REG_ADDR(MC_MIX_RATIO1)
+#define MC_DP_MB_XY 0x090e
+#define P_MC_DP_MB_XY           DOS_REG_ADDR(MC_DP_MB_XY)
+#define MC_OM_MB_XY 0x090f
+#define P_MC_OM_MB_XY           DOS_REG_ADDR(MC_OM_MB_XY)
+#define PSCALE_RST 0x0910
+#define P_PSCALE_RST            DOS_REG_ADDR(PSCALE_RST)
+#define PSCALE_CTRL 0x0911
+#define P_PSCALE_CTRL           DOS_REG_ADDR(PSCALE_CTRL)
+#define PSCALE_PICI_W 0x0912
+#define P_PSCALE_PICI_W                 DOS_REG_ADDR(PSCALE_PICI_W)
+#define PSCALE_PICI_H 0x0913
+#define P_PSCALE_PICI_H                 DOS_REG_ADDR(PSCALE_PICI_H)
+#define PSCALE_PICO_W 0x0914
+#define P_PSCALE_PICO_W                 DOS_REG_ADDR(PSCALE_PICO_W)
+#define PSCALE_PICO_H 0x0915
+#define P_PSCALE_PICO_H                 DOS_REG_ADDR(PSCALE_PICO_H)
+#define PSCALE_PICO_START_X 0x0916
+#define P_PSCALE_PICO_START_X           DOS_REG_ADDR(PSCALE_PICO_START_X)
+#define PSCALE_PICO_START_Y 0x0917
+#define P_PSCALE_PICO_START_Y           DOS_REG_ADDR(PSCALE_PICO_START_Y)
+#define PSCALE_DUMMY 0x0918
+#define P_PSCALE_DUMMY          DOS_REG_ADDR(PSCALE_DUMMY)
+#define PSCALE_FILT0_COEF0 0x0919
+#define P_PSCALE_FILT0_COEF0            DOS_REG_ADDR(PSCALE_FILT0_COEF0)
+#define PSCALE_FILT0_COEF1 0x091a
+#define P_PSCALE_FILT0_COEF1            DOS_REG_ADDR(PSCALE_FILT0_COEF1)
+#define PSCALE_CMD_CTRL 0x091b
+#define P_PSCALE_CMD_CTRL               DOS_REG_ADDR(PSCALE_CMD_CTRL)
+#define PSCALE_CMD_BLK_X 0x091c
+#define P_PSCALE_CMD_BLK_X              DOS_REG_ADDR(PSCALE_CMD_BLK_X)
+#define PSCALE_CMD_BLK_Y 0x091d
+#define P_PSCALE_CMD_BLK_Y              DOS_REG_ADDR(PSCALE_CMD_BLK_Y)
+#define PSCALE_STATUS 0x091e
+#define P_PSCALE_STATUS                 DOS_REG_ADDR(PSCALE_STATUS)
+#define PSCALE_BMEM_ADDR 0x091f
+#define P_PSCALE_BMEM_ADDR              DOS_REG_ADDR(PSCALE_BMEM_ADDR)
+#define PSCALE_BMEM_DAT 0x0920
+#define P_PSCALE_BMEM_DAT               DOS_REG_ADDR(PSCALE_BMEM_DAT)
+#define PSCALE_DRAM_BUF_CTRL 0x0921
+#define P_PSCALE_DRAM_BUF_CTRL          DOS_REG_ADDR(PSCALE_DRAM_BUF_CTRL)
+#define PSCALE_MCMD_CTRL 0x0922
+#define P_PSCALE_MCMD_CTRL              DOS_REG_ADDR(PSCALE_MCMD_CTRL)
+#define PSCALE_MCMD_XSIZE 0x0923
+#define P_PSCALE_MCMD_XSIZE             DOS_REG_ADDR(PSCALE_MCMD_XSIZE)
+#define PSCALE_MCMD_YSIZE 0x0924
+#define P_PSCALE_MCMD_YSIZE             DOS_REG_ADDR(PSCALE_MCMD_YSIZE)
+#define PSCALE_PICO_SHIFT_XY 0x0928
+#define P_PSCALE_PICO_SHIFT_XY          DOS_REG_ADDR(PSCALE_PICO_SHIFT_XY)
+#define PSCALE_CTRL1 0x0929
+#define P_PSCALE_CTRL1          DOS_REG_ADDR(PSCALE_CTRL1)
+#define PSCALE_SRCKEY_CTRL0 0x092a
+#define PSCALE_CTRL2 0x092e
+#define P_PSCALE_CTRL2          DOS_REG_ADDR(PSCALE_CTRL2)
+/*add from M8m2*/
+#define HDEC_MC_OMEM_AUTO 0x0930
+#define P_HDEC_MC_OMEM_AUTO             DOS_REG_ADDR(HDEC_MC_OMEM_AUTO)
+#define HDEC_MC_MBRIGHT_IDX 0x0931
+#define P_HDEC_MC_MBRIGHT_IDX           DOS_REG_ADDR(HDEC_MC_MBRIGHT_IDX)
+#define HDEC_MC_MBRIGHT_RD 0x0932
+#define P_HDEC_MC_MBRIGHT_RD            DOS_REG_ADDR(HDEC_MC_MBRIGHT_RD)
+/**/
+#define MC_MPORT_CTRL 0x0940
+#define P_MC_MPORT_CTRL                 DOS_REG_ADDR(MC_MPORT_CTRL)
+#define MC_MPORT_DAT 0x0941
+#define P_MC_MPORT_DAT          DOS_REG_ADDR(MC_MPORT_DAT)
+#define MC_WT_PRED_CTRL 0x0942
+#define P_MC_WT_PRED_CTRL               DOS_REG_ADDR(MC_WT_PRED_CTRL)
+#define MC_MBBOT_ST_ODD_ADDR 0x0945
+#define P_MC_MBBOT_ST_ODD_ADDR          DOS_REG_ADDR(MC_MBBOT_ST_ODD_ADDR)
+#define MC_DPDN_MB_XY 0x0946
+#define P_MC_DPDN_MB_XY                 DOS_REG_ADDR(MC_DPDN_MB_XY)
+#define MC_OMDN_MB_XY 0x0947
+#define P_MC_OMDN_MB_XY                 DOS_REG_ADDR(MC_OMDN_MB_XY)
+#define MC_HCMDBUF_H 0x0948
+#define P_MC_HCMDBUF_H          DOS_REG_ADDR(MC_HCMDBUF_H)
+#define MC_HCMDBUF_L 0x0949
+#define P_MC_HCMDBUF_L          DOS_REG_ADDR(MC_HCMDBUF_L)
+#define MC_HCMD_H 0x094a
+#define P_MC_HCMD_H             DOS_REG_ADDR(MC_HCMD_H)
+#define MC_HCMD_L 0x094b
+#define P_MC_HCMD_L             DOS_REG_ADDR(MC_HCMD_L)
+#define MC_IDCT_DAT 0x094c
+#define P_MC_IDCT_DAT           DOS_REG_ADDR(MC_IDCT_DAT)
+#define MC_CTRL_GCLK_CTRL 0x094d
+#define P_MC_CTRL_GCLK_CTRL             DOS_REG_ADDR(MC_CTRL_GCLK_CTRL)
+#define MC_OTHER_GCLK_CTRL 0x094e
+#define P_MC_OTHER_GCLK_CTRL            DOS_REG_ADDR(MC_OTHER_GCLK_CTRL)
+#define MC_CTRL2 0x094f
+#define P_MC_CTRL2              DOS_REG_ADDR(MC_CTRL2)
+#define MDEC_PIC_DC_CTRL 0x098e
+#define P_MDEC_PIC_DC_CTRL              DOS_REG_ADDR(MDEC_PIC_DC_CTRL)
+#define MDEC_PIC_DC_STATUS 0x098f
+#define P_MDEC_PIC_DC_STATUS            DOS_REG_ADDR(MDEC_PIC_DC_STATUS)
+#define ANC0_CANVAS_ADDR 0x0990
+#define P_ANC0_CANVAS_ADDR              DOS_REG_ADDR(ANC0_CANVAS_ADDR)
+#define ANC1_CANVAS_ADDR 0x0991
+#define P_ANC1_CANVAS_ADDR              DOS_REG_ADDR(ANC1_CANVAS_ADDR)
+#define ANC2_CANVAS_ADDR 0x0992
+#define P_ANC2_CANVAS_ADDR              DOS_REG_ADDR(ANC2_CANVAS_ADDR)
+#define ANC3_CANVAS_ADDR 0x0993
+#define P_ANC3_CANVAS_ADDR              DOS_REG_ADDR(ANC3_CANVAS_ADDR)
+#define ANC4_CANVAS_ADDR 0x0994
+#define P_ANC4_CANVAS_ADDR              DOS_REG_ADDR(ANC4_CANVAS_ADDR)
+#define ANC5_CANVAS_ADDR 0x0995
+#define P_ANC5_CANVAS_ADDR              DOS_REG_ADDR(ANC5_CANVAS_ADDR)
+#define ANC6_CANVAS_ADDR 0x0996
+#define P_ANC6_CANVAS_ADDR              DOS_REG_ADDR(ANC6_CANVAS_ADDR)
+#define ANC7_CANVAS_ADDR 0x0997
+#define P_ANC7_CANVAS_ADDR              DOS_REG_ADDR(ANC7_CANVAS_ADDR)
+#define ANC8_CANVAS_ADDR 0x0998
+#define P_ANC8_CANVAS_ADDR              DOS_REG_ADDR(ANC8_CANVAS_ADDR)
+#define ANC9_CANVAS_ADDR 0x0999
+#define P_ANC9_CANVAS_ADDR              DOS_REG_ADDR(ANC9_CANVAS_ADDR)
+#define ANC10_CANVAS_ADDR 0x099a
+#define P_ANC10_CANVAS_ADDR             DOS_REG_ADDR(ANC10_CANVAS_ADDR)
+#define ANC11_CANVAS_ADDR 0x099b
+#define P_ANC11_CANVAS_ADDR             DOS_REG_ADDR(ANC11_CANVAS_ADDR)
+#define ANC12_CANVAS_ADDR 0x099c
+#define P_ANC12_CANVAS_ADDR             DOS_REG_ADDR(ANC12_CANVAS_ADDR)
+#define ANC13_CANVAS_ADDR 0x099d
+#define P_ANC13_CANVAS_ADDR             DOS_REG_ADDR(ANC13_CANVAS_ADDR)
+#define ANC14_CANVAS_ADDR 0x099e
+#define P_ANC14_CANVAS_ADDR             DOS_REG_ADDR(ANC14_CANVAS_ADDR)
+#define ANC15_CANVAS_ADDR 0x099f
+#define P_ANC15_CANVAS_ADDR             DOS_REG_ADDR(ANC15_CANVAS_ADDR)
+#define ANC16_CANVAS_ADDR 0x09a0
+#define P_ANC16_CANVAS_ADDR             DOS_REG_ADDR(ANC16_CANVAS_ADDR)
+#define ANC17_CANVAS_ADDR 0x09a1
+#define P_ANC17_CANVAS_ADDR             DOS_REG_ADDR(ANC17_CANVAS_ADDR)
+#define ANC18_CANVAS_ADDR 0x09a2
+#define P_ANC18_CANVAS_ADDR             DOS_REG_ADDR(ANC18_CANVAS_ADDR)
+#define ANC19_CANVAS_ADDR 0x09a3
+#define P_ANC19_CANVAS_ADDR             DOS_REG_ADDR(ANC19_CANVAS_ADDR)
+#define ANC20_CANVAS_ADDR 0x09a4
+#define P_ANC20_CANVAS_ADDR             DOS_REG_ADDR(ANC20_CANVAS_ADDR)
+#define ANC21_CANVAS_ADDR 0x09a5
+#define P_ANC21_CANVAS_ADDR             DOS_REG_ADDR(ANC21_CANVAS_ADDR)
+#define ANC22_CANVAS_ADDR 0x09a6
+#define P_ANC22_CANVAS_ADDR             DOS_REG_ADDR(ANC22_CANVAS_ADDR)
+#define ANC23_CANVAS_ADDR 0x09a7
+#define P_ANC23_CANVAS_ADDR             DOS_REG_ADDR(ANC23_CANVAS_ADDR)
+#define ANC24_CANVAS_ADDR 0x09a8
+#define P_ANC24_CANVAS_ADDR             DOS_REG_ADDR(ANC24_CANVAS_ADDR)
+#define ANC25_CANVAS_ADDR 0x09a9
+#define P_ANC25_CANVAS_ADDR             DOS_REG_ADDR(ANC25_CANVAS_ADDR)
+#define ANC26_CANVAS_ADDR 0x09aa
+#define P_ANC26_CANVAS_ADDR             DOS_REG_ADDR(ANC26_CANVAS_ADDR)
+#define ANC27_CANVAS_ADDR 0x09ab
+#define P_ANC27_CANVAS_ADDR             DOS_REG_ADDR(ANC27_CANVAS_ADDR)
+#define ANC28_CANVAS_ADDR 0x09ac
+#define P_ANC28_CANVAS_ADDR             DOS_REG_ADDR(ANC28_CANVAS_ADDR)
+#define ANC29_CANVAS_ADDR 0x09ad
+#define P_ANC29_CANVAS_ADDR             DOS_REG_ADDR(ANC29_CANVAS_ADDR)
+#define ANC30_CANVAS_ADDR 0x09ae
+#define P_ANC30_CANVAS_ADDR             DOS_REG_ADDR(ANC30_CANVAS_ADDR)
+#define ANC31_CANVAS_ADDR 0x09af
+#define P_ANC31_CANVAS_ADDR             DOS_REG_ADDR(ANC31_CANVAS_ADDR)
+#define DBKR_CANVAS_ADDR 0x09b0
+#define P_DBKR_CANVAS_ADDR              DOS_REG_ADDR(DBKR_CANVAS_ADDR)
+#define DBKW_CANVAS_ADDR 0x09b1
+#define P_DBKW_CANVAS_ADDR              DOS_REG_ADDR(DBKW_CANVAS_ADDR)
+#define REC_CANVAS_ADDR 0x09b2
+#define P_REC_CANVAS_ADDR               DOS_REG_ADDR(REC_CANVAS_ADDR)
+#define CURR_CANVAS_CTRL 0x09b3
+#define P_CURR_CANVAS_CTRL              DOS_REG_ADDR(CURR_CANVAS_CTRL)
+#define MDEC_PIC_DC_THRESH 0x09b8
+#define P_MDEC_PIC_DC_THRESH            DOS_REG_ADDR(MDEC_PIC_DC_THRESH)
+#define MDEC_PICR_BUF_STATUS 0x09b9
+#define P_MDEC_PICR_BUF_STATUS          DOS_REG_ADDR(MDEC_PICR_BUF_STATUS)
+#define MDEC_PICW_BUF_STATUS 0x09ba
+#define P_MDEC_PICW_BUF_STATUS          DOS_REG_ADDR(MDEC_PICW_BUF_STATUS)
+#define MCW_DBLK_WRRSP_CNT 0x09bb
+#define P_MCW_DBLK_WRRSP_CNT            DOS_REG_ADDR(MCW_DBLK_WRRSP_CNT)
+#define MC_MBBOT_WRRSP_CNT 0x09bc
+#define P_MC_MBBOT_WRRSP_CNT            DOS_REG_ADDR(MC_MBBOT_WRRSP_CNT)
+#define WRRSP_FIFO_PICW_DBK 0x09be
+#define P_WRRSP_FIFO_PICW_DBK           DOS_REG_ADDR(WRRSP_FIFO_PICW_DBK)
+#define WRRSP_FIFO_PICW_MC 0x09bf
+#define P_WRRSP_FIFO_PICW_MC            DOS_REG_ADDR(WRRSP_FIFO_PICW_MC)
+#define AV_SCRATCH_0 0x09c0
+#define P_AV_SCRATCH_0          DOS_REG_ADDR(AV_SCRATCH_0)
+#define AV_SCRATCH_1 0x09c1
+#define P_AV_SCRATCH_1          DOS_REG_ADDR(AV_SCRATCH_1)
+#define AV_SCRATCH_2 0x09c2
+#define P_AV_SCRATCH_2          DOS_REG_ADDR(AV_SCRATCH_2)
+#define AV_SCRATCH_3 0x09c3
+#define P_AV_SCRATCH_3          DOS_REG_ADDR(AV_SCRATCH_3)
+#define AV_SCRATCH_4 0x09c4
+#define P_AV_SCRATCH_4          DOS_REG_ADDR(AV_SCRATCH_4)
+#define AV_SCRATCH_5 0x09c5
+#define P_AV_SCRATCH_5          DOS_REG_ADDR(AV_SCRATCH_5)
+#define AV_SCRATCH_6 0x09c6
+#define P_AV_SCRATCH_6          DOS_REG_ADDR(AV_SCRATCH_6)
+#define AV_SCRATCH_7 0x09c7
+#define P_AV_SCRATCH_7          DOS_REG_ADDR(AV_SCRATCH_7)
+#define AV_SCRATCH_8 0x09c8
+#define P_AV_SCRATCH_8          DOS_REG_ADDR(AV_SCRATCH_8)
+#define AV_SCRATCH_9 0x09c9
+#define P_AV_SCRATCH_9          DOS_REG_ADDR(AV_SCRATCH_9)
+#define AV_SCRATCH_A 0x09ca
+#define P_AV_SCRATCH_A          DOS_REG_ADDR(AV_SCRATCH_A)
+#define AV_SCRATCH_B 0x09cb
+#define P_AV_SCRATCH_B          DOS_REG_ADDR(AV_SCRATCH_B)
+#define AV_SCRATCH_C 0x09cc
+#define P_AV_SCRATCH_C          DOS_REG_ADDR(AV_SCRATCH_C)
+#define AV_SCRATCH_D 0x09cd
+#define P_AV_SCRATCH_D          DOS_REG_ADDR(AV_SCRATCH_D)
+#define AV_SCRATCH_E 0x09ce
+#define P_AV_SCRATCH_E          DOS_REG_ADDR(AV_SCRATCH_E)
+#define AV_SCRATCH_F 0x09cf
+#define P_AV_SCRATCH_F          DOS_REG_ADDR(AV_SCRATCH_F)
+#define AV_SCRATCH_G 0x09d0
+#define P_AV_SCRATCH_G          DOS_REG_ADDR(AV_SCRATCH_G)
+#define AV_SCRATCH_H 0x09d1
+#define P_AV_SCRATCH_H          DOS_REG_ADDR(AV_SCRATCH_H)
+#define AV_SCRATCH_I 0x09d2
+#define P_AV_SCRATCH_I          DOS_REG_ADDR(AV_SCRATCH_I)
+#define AV_SCRATCH_J 0x09d3
+#define P_AV_SCRATCH_J          DOS_REG_ADDR(AV_SCRATCH_J)
+#define AV_SCRATCH_K 0x09d4
+#define P_AV_SCRATCH_K          DOS_REG_ADDR(AV_SCRATCH_K)
+#define AV_SCRATCH_L 0x09d5
+#define P_AV_SCRATCH_L          DOS_REG_ADDR(AV_SCRATCH_L)
+#define AV_SCRATCH_M 0x09d6
+#define P_AV_SCRATCH_M          DOS_REG_ADDR(AV_SCRATCH_M)
+#define AV_SCRATCH_N 0x09d7
+#define P_AV_SCRATCH_N          DOS_REG_ADDR(AV_SCRATCH_N)
+#define WRRSP_CO_MB 0x09d8
+#define P_WRRSP_CO_MB           DOS_REG_ADDR(WRRSP_CO_MB)
+#define WRRSP_DCAC 0x09d9
+#define P_WRRSP_DCAC            DOS_REG_ADDR(WRRSP_DCAC)
+/*add from M8M2*/
+#define WRRSP_VLD 0x09da
+#define P_WRRSP_VLD             DOS_REG_ADDR(WRRSP_VLD)
+#define MDEC_DOUBLEW_CFG0 0x09db
+#define P_MDEC_DOUBLEW_CFG0             DOS_REG_ADDR(MDEC_DOUBLEW_CFG0)
+#define MDEC_DOUBLEW_CFG1 0x09dc
+#define P_MDEC_DOUBLEW_CFG1             DOS_REG_ADDR(MDEC_DOUBLEW_CFG1)
+#define MDEC_DOUBLEW_CFG2 0x09dd
+#define P_MDEC_DOUBLEW_CFG2             DOS_REG_ADDR(MDEC_DOUBLEW_CFG2)
+#define MDEC_DOUBLEW_CFG3 0x09de
+#define P_MDEC_DOUBLEW_CFG3             DOS_REG_ADDR(MDEC_DOUBLEW_CFG3)
+#define MDEC_DOUBLEW_CFG4 0x09df
+#define P_MDEC_DOUBLEW_CFG4             DOS_REG_ADDR(MDEC_DOUBLEW_CFG4)
+#define MDEC_DOUBLEW_CFG5 0x09e0
+#define P_MDEC_DOUBLEW_CFG5             DOS_REG_ADDR(MDEC_DOUBLEW_CFG5)
+#define MDEC_DOUBLEW_CFG6 0x09e1
+#define P_MDEC_DOUBLEW_CFG6             DOS_REG_ADDR(MDEC_DOUBLEW_CFG6)
+#define MDEC_DOUBLEW_CFG7 0x09e2
+#define P_MDEC_DOUBLEW_CFG7             DOS_REG_ADDR(MDEC_DOUBLEW_CFG7)
+#define MDEC_DOUBLEW_STATUS 0x09e3
+#define P_MDEC_DOUBLEW_STATUS           DOS_REG_ADDR(MDEC_DOUBLEW_STATUS)
+/**/
+#define DBLK_RST 0x0950
+#define P_DBLK_RST              DOS_REG_ADDR(DBLK_RST)
+#define DBLK_CTRL 0x0951
+#define P_DBLK_CTRL             DOS_REG_ADDR(DBLK_CTRL)
+#define DBLK_MB_WID_HEIGHT 0x0952
+#define P_DBLK_MB_WID_HEIGHT            DOS_REG_ADDR(DBLK_MB_WID_HEIGHT)
+#define DBLK_STATUS 0x0953
+#define P_DBLK_STATUS           DOS_REG_ADDR(DBLK_STATUS)
+#define DBLK_CMD_CTRL 0x0954
+#define P_DBLK_CMD_CTRL                 DOS_REG_ADDR(DBLK_CMD_CTRL)
+#define DBLK_MB_XY 0x0955
+#define P_DBLK_MB_XY            DOS_REG_ADDR(DBLK_MB_XY)
+#define DBLK_QP 0x0956
+#define P_DBLK_QP               DOS_REG_ADDR(DBLK_QP)
+#define DBLK_Y_BHFILT 0x0957
+#define P_DBLK_Y_BHFILT                 DOS_REG_ADDR(DBLK_Y_BHFILT)
+#define DBLK_Y_BHFILT_HIGH 0x0958
+#define P_DBLK_Y_BHFILT_HIGH            DOS_REG_ADDR(DBLK_Y_BHFILT_HIGH)
+#define DBLK_Y_BVFILT 0x0959
+#define P_DBLK_Y_BVFILT                 DOS_REG_ADDR(DBLK_Y_BVFILT)
+#define DBLK_CB_BFILT 0x095a
+#define P_DBLK_CB_BFILT                 DOS_REG_ADDR(DBLK_CB_BFILT)
+#define DBLK_CR_BFILT 0x095b
+#define P_DBLK_CR_BFILT                 DOS_REG_ADDR(DBLK_CR_BFILT)
+#define DBLK_Y_HFILT 0x095c
+#define P_DBLK_Y_HFILT          DOS_REG_ADDR(DBLK_Y_HFILT)
+#define DBLK_Y_HFILT_HIGH 0x095d
+#define P_DBLK_Y_HFILT_HIGH             DOS_REG_ADDR(DBLK_Y_HFILT_HIGH)
+#define DBLK_Y_VFILT 0x095e
+#define P_DBLK_Y_VFILT          DOS_REG_ADDR(DBLK_Y_VFILT)
+#define DBLK_CB_FILT 0x095f
+#define P_DBLK_CB_FILT          DOS_REG_ADDR(DBLK_CB_FILT)
+#define DBLK_CR_FILT 0x0960
+#define P_DBLK_CR_FILT          DOS_REG_ADDR(DBLK_CR_FILT)
+#define DBLK_BETAX_QP_SEL 0x0961
+#define P_DBLK_BETAX_QP_SEL             DOS_REG_ADDR(DBLK_BETAX_QP_SEL)
+#define DBLK_CLIP_CTRL0 0x0962
+#define P_DBLK_CLIP_CTRL0               DOS_REG_ADDR(DBLK_CLIP_CTRL0)
+#define DBLK_CLIP_CTRL1 0x0963
+#define P_DBLK_CLIP_CTRL1               DOS_REG_ADDR(DBLK_CLIP_CTRL1)
+#define DBLK_CLIP_CTRL2 0x0964
+#define P_DBLK_CLIP_CTRL2               DOS_REG_ADDR(DBLK_CLIP_CTRL2)
+#define DBLK_CLIP_CTRL3 0x0965
+#define P_DBLK_CLIP_CTRL3               DOS_REG_ADDR(DBLK_CLIP_CTRL3)
+#define DBLK_CLIP_CTRL4 0x0966
+#define P_DBLK_CLIP_CTRL4               DOS_REG_ADDR(DBLK_CLIP_CTRL4)
+#define DBLK_CLIP_CTRL5 0x0967
+#define P_DBLK_CLIP_CTRL5               DOS_REG_ADDR(DBLK_CLIP_CTRL5)
+#define DBLK_CLIP_CTRL6 0x0968
+#define P_DBLK_CLIP_CTRL6               DOS_REG_ADDR(DBLK_CLIP_CTRL6)
+#define DBLK_CLIP_CTRL7 0x0969
+#define P_DBLK_CLIP_CTRL7               DOS_REG_ADDR(DBLK_CLIP_CTRL7)
+#define DBLK_CLIP_CTRL8 0x096a
+#define P_DBLK_CLIP_CTRL8               DOS_REG_ADDR(DBLK_CLIP_CTRL8)
+#define DBLK_STATUS1 0x096b
+#define P_DBLK_STATUS1          DOS_REG_ADDR(DBLK_STATUS1)
+#define DBLK_GCLK_FREE 0x096c
+#define P_DBLK_GCLK_FREE                DOS_REG_ADDR(DBLK_GCLK_FREE)
+#define DBLK_GCLK_OFF 0x096d
+#define P_DBLK_GCLK_OFF                 DOS_REG_ADDR(DBLK_GCLK_OFF)
+#define DBLK_AVSFLAGS 0x096e
+#define P_DBLK_AVSFLAGS                 DOS_REG_ADDR(DBLK_AVSFLAGS)
+#define DBLK_CBPY 0x0970
+#define P_DBLK_CBPY             DOS_REG_ADDR(DBLK_CBPY)
+#define DBLK_CBPY_ADJ 0x0971
+#define P_DBLK_CBPY_ADJ                 DOS_REG_ADDR(DBLK_CBPY_ADJ)
+#define DBLK_CBPC 0x0972
+#define P_DBLK_CBPC             DOS_REG_ADDR(DBLK_CBPC)
+#define DBLK_CBPC_ADJ 0x0973
+#define P_DBLK_CBPC_ADJ                 DOS_REG_ADDR(DBLK_CBPC_ADJ)
+#define DBLK_VHMVD 0x0974
+#define P_DBLK_VHMVD            DOS_REG_ADDR(DBLK_VHMVD)
+#define DBLK_STRONG 0x0975
+#define P_DBLK_STRONG           DOS_REG_ADDR(DBLK_STRONG)
+#define DBLK_RV8_QUANT 0x0976
+#define P_DBLK_RV8_QUANT                DOS_REG_ADDR(DBLK_RV8_QUANT)
+#define DBLK_CBUS_HCMD2 0x0977
+#define P_DBLK_CBUS_HCMD2               DOS_REG_ADDR(DBLK_CBUS_HCMD2)
+#define DBLK_CBUS_HCMD1 0x0978
+#define P_DBLK_CBUS_HCMD1               DOS_REG_ADDR(DBLK_CBUS_HCMD1)
+#define DBLK_CBUS_HCMD0 0x0979
+#define P_DBLK_CBUS_HCMD0               DOS_REG_ADDR(DBLK_CBUS_HCMD0)
+#define DBLK_VLD_HCMD2 0x097a
+#define P_DBLK_VLD_HCMD2                DOS_REG_ADDR(DBLK_VLD_HCMD2)
+#define DBLK_VLD_HCMD1 0x097b
+#define P_DBLK_VLD_HCMD1                DOS_REG_ADDR(DBLK_VLD_HCMD1)
+#define DBLK_VLD_HCMD0 0x097c
+#define P_DBLK_VLD_HCMD0                DOS_REG_ADDR(DBLK_VLD_HCMD0)
+#define DBLK_OST_YBASE 0x097d
+#define P_DBLK_OST_YBASE                DOS_REG_ADDR(DBLK_OST_YBASE)
+#define DBLK_OST_CBCRDIFF 0x097e
+#define P_DBLK_OST_CBCRDIFF             DOS_REG_ADDR(DBLK_OST_CBCRDIFF)
+#define DBLK_CTRL1 0x097f
+#define P_DBLK_CTRL1            DOS_REG_ADDR(DBLK_CTRL1)
+#define MCRCC_CTL1 0x0980
+#define P_MCRCC_CTL1            DOS_REG_ADDR(MCRCC_CTL1)
+#define MCRCC_CTL2 0x0981
+#define P_MCRCC_CTL2            DOS_REG_ADDR(MCRCC_CTL2)
+#define MCRCC_CTL3 0x0982
+#define P_MCRCC_CTL3            DOS_REG_ADDR(MCRCC_CTL3)
+#define GCLK_EN 0x0983
+#define P_GCLK_EN               DOS_REG_ADDR(GCLK_EN)
+#define MDEC_SW_RESET 0x0984
+#define P_MDEC_SW_RESET                 DOS_REG_ADDR(MDEC_SW_RESET)
+#define VLD_STATUS_CTRL 0x0c00
+#define P_VLD_STATUS_CTRL               DOS_REG_ADDR(VLD_STATUS_CTRL)
+#define MPEG1_2_REG 0x0c01
+#define P_MPEG1_2_REG           DOS_REG_ADDR(MPEG1_2_REG)
+#define F_CODE_REG 0x0c02
+#define P_F_CODE_REG            DOS_REG_ADDR(F_CODE_REG)
+#define PIC_HEAD_INFO 0x0c03
+#define P_PIC_HEAD_INFO                 DOS_REG_ADDR(PIC_HEAD_INFO)
+#define QP_VALUE_REG 0x0c05
+#define P_QP_VALUE_REG          DOS_REG_ADDR(QP_VALUE_REG)
+#define MBA_INC 0x0c06
+#define P_MBA_INC               DOS_REG_ADDR(MBA_INC)
+#define MB_MOTION_MODE 0x0c07
+#define P_MB_MOTION_MODE                DOS_REG_ADDR(MB_MOTION_MODE)
+#define POWER_CTL_VLD 0x0c08
+#define P_POWER_CTL_VLD                 DOS_REG_ADDR(POWER_CTL_VLD)
+#define MB_WIDTH 0x0c09
+#define P_MB_WIDTH              DOS_REG_ADDR(MB_WIDTH)
+#define SLICE_QP 0x0c0a
+#define P_SLICE_QP              DOS_REG_ADDR(SLICE_QP)
+#define PRE_START_CODE 0x0c0b
+#define P_PRE_START_CODE                DOS_REG_ADDR(PRE_START_CODE)
+#define SLICE_START_BYTE_01 0x0c0c
+#define P_SLICE_START_BYTE_01           DOS_REG_ADDR(SLICE_START_BYTE_01)
+#define SLICE_START_BYTE_23 0x0c0d
+#define P_SLICE_START_BYTE_23           DOS_REG_ADDR(SLICE_START_BYTE_23)
+#define RESYNC_MARKER_LENGTH 0x0c0e
+#define P_RESYNC_MARKER_LENGTH          DOS_REG_ADDR(RESYNC_MARKER_LENGTH)
+#define DECODER_BUFFER_INFO 0x0c0f
+#define P_DECODER_BUFFER_INFO           DOS_REG_ADDR(DECODER_BUFFER_INFO)
+#define FST_FOR_MV_X 0x0c10
+#define P_FST_FOR_MV_X          DOS_REG_ADDR(FST_FOR_MV_X)
+#define FST_FOR_MV_Y 0x0c11
+#define P_FST_FOR_MV_Y          DOS_REG_ADDR(FST_FOR_MV_Y)
+#define SCD_FOR_MV_X 0x0c12
+#define P_SCD_FOR_MV_X          DOS_REG_ADDR(SCD_FOR_MV_X)
+#define SCD_FOR_MV_Y 0x0c13
+#define P_SCD_FOR_MV_Y          DOS_REG_ADDR(SCD_FOR_MV_Y)
+#define FST_BAK_MV_X 0x0c14
+#define P_FST_BAK_MV_X          DOS_REG_ADDR(FST_BAK_MV_X)
+#define FST_BAK_MV_Y 0x0c15
+#define P_FST_BAK_MV_Y          DOS_REG_ADDR(FST_BAK_MV_Y)
+#define SCD_BAK_MV_X 0x0c16
+#define P_SCD_BAK_MV_X          DOS_REG_ADDR(SCD_BAK_MV_X)
+#define SCD_BAK_MV_Y 0x0c17
+#define P_SCD_BAK_MV_Y          DOS_REG_ADDR(SCD_BAK_MV_Y)
+#define VLD_DECODE_CONTROL 0x0c18
+#define P_VLD_DECODE_CONTROL            DOS_REG_ADDR(VLD_DECODE_CONTROL)
+#define VLD_REVERVED_19 0x0c19
+#define P_VLD_REVERVED_19               DOS_REG_ADDR(VLD_REVERVED_19)
+#define VIFF_BIT_CNT 0x0c1a
+#define P_VIFF_BIT_CNT          DOS_REG_ADDR(VIFF_BIT_CNT)
+#define BYTE_ALIGN_PEAK_HI 0x0c1b
+#define P_BYTE_ALIGN_PEAK_HI            DOS_REG_ADDR(BYTE_ALIGN_PEAK_HI)
+#define BYTE_ALIGN_PEAK_LO 0x0c1c
+#define P_BYTE_ALIGN_PEAK_LO            DOS_REG_ADDR(BYTE_ALIGN_PEAK_LO)
+#define NEXT_ALIGN_PEAK 0x0c1d
+#define P_NEXT_ALIGN_PEAK               DOS_REG_ADDR(NEXT_ALIGN_PEAK)
+#define VC1_CONTROL_REG 0x0c1e
+#define P_VC1_CONTROL_REG               DOS_REG_ADDR(VC1_CONTROL_REG)
+#define PMV1_X 0x0c20
+#define P_PMV1_X                DOS_REG_ADDR(PMV1_X)
+#define PMV1_Y 0x0c21
+#define P_PMV1_Y                DOS_REG_ADDR(PMV1_Y)
+#define PMV2_X 0x0c22
+#define P_PMV2_X                DOS_REG_ADDR(PMV2_X)
+#define PMV2_Y 0x0c23
+#define P_PMV2_Y                DOS_REG_ADDR(PMV2_Y)
+#define PMV3_X 0x0c24
+#define P_PMV3_X                DOS_REG_ADDR(PMV3_X)
+#define PMV3_Y 0x0c25
+#define P_PMV3_Y                DOS_REG_ADDR(PMV3_Y)
+#define PMV4_X 0x0c26
+#define P_PMV4_X                DOS_REG_ADDR(PMV4_X)
+#define PMV4_Y 0x0c27
+#define P_PMV4_Y                DOS_REG_ADDR(PMV4_Y)
+#define M4_TABLE_SELECT 0x0c28
+#define P_M4_TABLE_SELECT               DOS_REG_ADDR(M4_TABLE_SELECT)
+#define M4_CONTROL_REG 0x0c29
+#define P_M4_CONTROL_REG                DOS_REG_ADDR(M4_CONTROL_REG)
+#define BLOCK_NUM 0x0c2a
+#define P_BLOCK_NUM             DOS_REG_ADDR(BLOCK_NUM)
+#define PATTERN_CODE 0x0c2b
+#define P_PATTERN_CODE          DOS_REG_ADDR(PATTERN_CODE)
+#define MB_INFO 0x0c2c
+#define P_MB_INFO               DOS_REG_ADDR(MB_INFO)
+#define VLD_DC_PRED 0x0c2d
+#define P_VLD_DC_PRED           DOS_REG_ADDR(VLD_DC_PRED)
+#define VLD_ERROR_MASK 0x0c2e
+#define P_VLD_ERROR_MASK                DOS_REG_ADDR(VLD_ERROR_MASK)
+#define VLD_DC_PRED_C 0x0c2f
+#define P_VLD_DC_PRED_C                 DOS_REG_ADDR(VLD_DC_PRED_C)
+#define LAST_SLICE_MV_ADDR 0x0c30
+#define P_LAST_SLICE_MV_ADDR            DOS_REG_ADDR(LAST_SLICE_MV_ADDR)
+#define LAST_MVX 0x0c31
+#define P_LAST_MVX              DOS_REG_ADDR(LAST_MVX)
+#define LAST_MVY 0x0c32
+#define P_LAST_MVY              DOS_REG_ADDR(LAST_MVY)
+#define VLD_C38 0x0c38
+#define P_VLD_C38               DOS_REG_ADDR(VLD_C38)
+#define VLD_C39 0x0c39
+#define P_VLD_C39               DOS_REG_ADDR(VLD_C39)
+#define VLD_STATUS 0x0c3a
+#define P_VLD_STATUS            DOS_REG_ADDR(VLD_STATUS)
+#define VLD_SHIFT_STATUS 0x0c3b
+#define P_VLD_SHIFT_STATUS              DOS_REG_ADDR(VLD_SHIFT_STATUS)
+#define VOFF_STATUS 0x0c3c
+#define P_VOFF_STATUS           DOS_REG_ADDR(VOFF_STATUS)
+#define VLD_C3D 0x0c3d
+#define P_VLD_C3D               DOS_REG_ADDR(VLD_C3D)
+#define VLD_DBG_INDEX 0x0c3e
+#define P_VLD_DBG_INDEX                 DOS_REG_ADDR(VLD_DBG_INDEX)
+#define VLD_DBG_DATA 0x0c3f
+#define P_VLD_DBG_DATA          DOS_REG_ADDR(VLD_DBG_DATA)
+#define VLD_MEM_VIFIFO_START_PTR 0x0c40
+#define P_VLD_TIME_STAMP_0              DOS_REG_ADDR(VLD_TIME_STAMP_0)
+#define VLD_TIME_STAMP_1 0x0c4d
+#define P_VLD_TIME_STAMP_1              DOS_REG_ADDR(VLD_TIME_STAMP_1)
+#define VLD_TIME_STAMP_2 0x0c4e
+#define P_VLD_TIME_STAMP_2              DOS_REG_ADDR(VLD_TIME_STAMP_2)
+#define VLD_TIME_STAMP_3 0x0c4f
+#define P_VLD_TIME_STAMP_3              DOS_REG_ADDR(VLD_TIME_STAMP_3)
+#define VLD_MEM_VBUF2_RD_PTR 0x0c54
+#define P_VLD_MEM_VBUF2_RD_PTR          DOS_REG_ADDR(VLD_MEM_VBUF2_RD_PTR)
+#define VLD_MEM_SWAP_ADDR 0x0c55
+#define P_VLD_MEM_SWAP_ADDR             DOS_REG_ADDR(VLD_MEM_SWAP_ADDR)
+#define VLD_MEM_SWAP_CTL 0x0c56
+#define P_VLD_MEM_SWAP_CTL              DOS_REG_ADDR(VLD_MEM_SWAP_CTL)
+#define VCOP_CTRL_REG 0x0e00
+#define P_VCOP_CTRL_REG                 DOS_REG_ADDR(VCOP_CTRL_REG)
+#define QP_CTRL_REG 0x0e01
+#define P_QP_CTRL_REG           DOS_REG_ADDR(QP_CTRL_REG)
+#define INTRA_QUANT_MATRIX 0x0e02
+#define P_INTRA_QUANT_MATRIX            DOS_REG_ADDR(INTRA_QUANT_MATRIX)
+#define NON_I_QUANT_MATRIX 0x0e03
+#define P_NON_I_QUANT_MATRIX            DOS_REG_ADDR(NON_I_QUANT_MATRIX)
+#define DC_SCALER 0x0e04
+#define P_DC_SCALER             DOS_REG_ADDR(DC_SCALER)
+#define DC_AC_CTRL 0x0e05
+#define P_DC_AC_CTRL            DOS_REG_ADDR(DC_AC_CTRL)
+#define DC_AC_SCALE_MUL 0x0e06
+#define P_DC_AC_SCALE_MUL               DOS_REG_ADDR(DC_AC_SCALE_MUL)
+#define DC_AC_SCALE_DIV 0x0e07
+#define P_DC_AC_SCALE_DIV               DOS_REG_ADDR(DC_AC_SCALE_DIV)
+#define POWER_CTL_IQIDCT 0x0e08
+#define P_POWER_CTL_IQIDCT              DOS_REG_ADDR(POWER_CTL_IQIDCT)
+#define RV_AI_Y_X 0x0e09
+#define P_RV_AI_Y_X             DOS_REG_ADDR(RV_AI_Y_X)
+#define RV_AI_U_X 0x0e0a
+#define P_RV_AI_U_X             DOS_REG_ADDR(RV_AI_U_X)
+#define RV_AI_V_X 0x0e0b
+#define P_RV_AI_V_X             DOS_REG_ADDR(RV_AI_V_X)
+#define RV_AI_MB_COUNT 0x0e0c
+#define P_RV_AI_MB_COUNT                DOS_REG_ADDR(RV_AI_MB_COUNT)
+#define IQIDCT_CONTROL 0x0e0e
+#define P_IQIDCT_CONTROL                DOS_REG_ADDR(IQIDCT_CONTROL)
+#define IQIDCT_DEBUG_INFO_0 0x0e0f
+#define P_IQIDCT_DEBUG_INFO_0           DOS_REG_ADDR(IQIDCT_DEBUG_INFO_0)
+#define DEBLK_CMD 0x0e10
+#define P_DEBLK_CMD             DOS_REG_ADDR(DEBLK_CMD)
+#define IQIDCT_DEBUG_IDCT 0x0e11
+#define P_IQIDCT_DEBUG_IDCT             DOS_REG_ADDR(IQIDCT_DEBUG_IDCT)
+#define DCAC_DMA_CTRL 0x0e12
+#define P_DCAC_DMA_CTRL                 DOS_REG_ADDR(DCAC_DMA_CTRL)
+#define DCAC_DMA_ADDRESS 0x0e13
+#define P_DCAC_DMA_ADDRESS              DOS_REG_ADDR(DCAC_DMA_ADDRESS)
+#define DCAC_CPU_ADDRESS 0x0e14
+#define P_DCAC_CPU_ADDRESS              DOS_REG_ADDR(DCAC_CPU_ADDRESS)
+#define DCAC_CPU_DATA 0x0e15
+#define P_DCAC_CPU_DATA                 DOS_REG_ADDR(DCAC_CPU_DATA)
+#define DCAC_MB_COUNT 0x0e16
+#define P_DCAC_MB_COUNT                 DOS_REG_ADDR(DCAC_MB_COUNT)
+#define IQ_QUANT 0x0e17
+#define P_IQ_QUANT              DOS_REG_ADDR(IQ_QUANT)
+#define VC1_BITPLANE_CTL 0x0e18
+#define P_VC1_BITPLANE_CTL              DOS_REG_ADDR(VC1_BITPLANE_CTL)
+#define MSP 0x0300
+#define P_MSP           DOS_REG_ADDR(MSP)
+#define MPSR 0x0301
+#define P_MPSR          DOS_REG_ADDR(MPSR)
+#define MINT_VEC_BASE 0x0302
+#define P_MINT_VEC_BASE                 DOS_REG_ADDR(MINT_VEC_BASE)
+#define MCPU_INTR_GRP 0x0303
+#define P_MCPU_INTR_GRP                 DOS_REG_ADDR(MCPU_INTR_GRP)
+#define MCPU_INTR_MSK 0x0304
+#define P_MCPU_INTR_MSK                 DOS_REG_ADDR(MCPU_INTR_MSK)
+#define MCPU_INTR_REQ 0x0305
+#define P_MCPU_INTR_REQ                 DOS_REG_ADDR(MCPU_INTR_REQ)
+#define MPC_P 0x0306
+#define P_MPC_P                 DOS_REG_ADDR(MPC_P)
+#define MPC_D 0x0307
+#define P_MPC_D                 DOS_REG_ADDR(MPC_D)
+#define MPC_E 0x0308
+#define P_MPC_E                 DOS_REG_ADDR(MPC_E)
+#define MPC_W 0x0309
+#define P_MPC_W                 DOS_REG_ADDR(MPC_W)
+#define MINDEX0_REG 0x030a
+#define P_MINDEX0_REG           DOS_REG_ADDR(MINDEX0_REG)
+#define MINDEX1_REG 0x030b
+#define P_MINDEX1_REG           DOS_REG_ADDR(MINDEX1_REG)
+#define MINDEX2_REG 0x030c
+#define P_MINDEX2_REG           DOS_REG_ADDR(MINDEX2_REG)
+#define MINDEX3_REG 0x030d
+#define P_MINDEX3_REG           DOS_REG_ADDR(MINDEX3_REG)
+#define MINDEX4_REG 0x030e
+#define P_MINDEX4_REG           DOS_REG_ADDR(MINDEX4_REG)
+#define MINDEX5_REG 0x030f
+#define P_MINDEX5_REG           DOS_REG_ADDR(MINDEX5_REG)
+#define MINDEX6_REG 0x0310
+#define P_MINDEX6_REG           DOS_REG_ADDR(MINDEX6_REG)
+#define MINDEX7_REG 0x0311
+#define P_MINDEX7_REG           DOS_REG_ADDR(MINDEX7_REG)
+#define MMIN_REG 0x0312
+#define P_MMIN_REG              DOS_REG_ADDR(MMIN_REG)
+#define MMAX_REG 0x0313
+#define P_MMAX_REG              DOS_REG_ADDR(MMAX_REG)
+#define MBREAK0_REG 0x0314
+#define P_MBREAK0_REG           DOS_REG_ADDR(MBREAK0_REG)
+#define MBREAK1_REG 0x0315
+#define P_MBREAK1_REG           DOS_REG_ADDR(MBREAK1_REG)
+#define MBREAK2_REG 0x0316
+#define P_MBREAK2_REG           DOS_REG_ADDR(MBREAK2_REG)
+#define MBREAK3_REG 0x0317
+#define P_MBREAK3_REG           DOS_REG_ADDR(MBREAK3_REG)
+#define MBREAK_TYPE 0x0318
+#define P_MBREAK_TYPE           DOS_REG_ADDR(MBREAK_TYPE)
+#define MBREAK_CTRL 0x0319
+#define P_MBREAK_CTRL           DOS_REG_ADDR(MBREAK_CTRL)
+#define MBREAK_STAUTS 0x031a
+#define P_MBREAK_STAUTS                 DOS_REG_ADDR(MBREAK_STAUTS)
+#define MDB_ADDR_REG 0x031b
+#define P_MDB_ADDR_REG          DOS_REG_ADDR(MDB_ADDR_REG)
+#define MDB_DATA_REG 0x031c
+#define P_MDB_DATA_REG          DOS_REG_ADDR(MDB_DATA_REG)
+#define MDB_CTRL 0x031d
+#define P_MDB_CTRL              DOS_REG_ADDR(MDB_CTRL)
+#define MSFTINT0 0x031e
+#define P_MSFTINT0              DOS_REG_ADDR(MSFTINT0)
+#define MSFTINT1 0x031f
+#define P_MSFTINT1              DOS_REG_ADDR(MSFTINT1)
+#define CSP 0x0320
+#define P_CSP           DOS_REG_ADDR(CSP)
+#define CPSR 0x0321
+#define P_CPSR          DOS_REG_ADDR(CPSR)
+#define CINT_VEC_BASE 0x0322
+#define P_CINT_VEC_BASE                 DOS_REG_ADDR(CINT_VEC_BASE)
+#define CCPU_INTR_GRP 0x0323
+#define P_CCPU_INTR_GRP                 DOS_REG_ADDR(CCPU_INTR_GRP)
+#define CCPU_INTR_MSK 0x0324
+#define P_CCPU_INTR_MSK                 DOS_REG_ADDR(CCPU_INTR_MSK)
+#define CCPU_INTR_REQ 0x0325
+#define P_CCPU_INTR_REQ                 DOS_REG_ADDR(CCPU_INTR_REQ)
+#define CPC_P 0x0326
+#define P_CPC_P                 DOS_REG_ADDR(CPC_P)
+#define CPC_D 0x0327
+#define P_CPC_D                 DOS_REG_ADDR(CPC_D)
+#define CPC_E 0x0328
+#define P_CPC_E                 DOS_REG_ADDR(CPC_E)
+#define CPC_W 0x0329
+#define P_CPC_W                 DOS_REG_ADDR(CPC_W)
+#define CINDEX0_REG 0x032a
+#define P_CINDEX0_REG           DOS_REG_ADDR(CINDEX0_REG)
+#define CINDEX1_REG 0x032b
+#define P_CINDEX1_REG           DOS_REG_ADDR(CINDEX1_REG)
+#define CINDEX2_REG 0x032c
+#define P_CINDEX2_REG           DOS_REG_ADDR(CINDEX2_REG)
+#define CINDEX3_REG 0x032d
+#define P_CINDEX3_REG           DOS_REG_ADDR(CINDEX3_REG)
+#define CINDEX4_REG 0x032e
+#define P_CINDEX4_REG           DOS_REG_ADDR(CINDEX4_REG)
+#define CINDEX5_REG 0x032f
+#define P_CINDEX5_REG           DOS_REG_ADDR(CINDEX5_REG)
+#define CINDEX6_REG 0x0330
+#define P_CINDEX6_REG           DOS_REG_ADDR(CINDEX6_REG)
+#define CINDEX7_REG 0x0331
+#define P_CINDEX7_REG           DOS_REG_ADDR(CINDEX7_REG)
+#define CMIN_REG 0x0332
+#define P_CMIN_REG              DOS_REG_ADDR(CMIN_REG)
+#define CMAX_REG 0x0333
+#define P_CMAX_REG              DOS_REG_ADDR(CMAX_REG)
+#define CBREAK0_REG 0x0334
+#define P_CBREAK0_REG           DOS_REG_ADDR(CBREAK0_REG)
+#define CBREAK1_REG 0x0335
+#define P_CBREAK1_REG           DOS_REG_ADDR(CBREAK1_REG)
+#define CBREAK2_REG 0x0336
+#define P_CBREAK2_REG           DOS_REG_ADDR(CBREAK2_REG)
+#define CBREAK3_REG 0x0337
+#define P_CBREAK3_REG           DOS_REG_ADDR(CBREAK3_REG)
+#define CBREAK_TYPE 0x0338
+#define P_CBREAK_TYPE           DOS_REG_ADDR(CBREAK_TYPE)
+#define CBREAK_CTRL 0x0339
+#define P_CBREAK_CTRL           DOS_REG_ADDR(CBREAK_CTRL)
+#define CBREAK_STAUTS 0x033a
+#define P_CBREAK_STAUTS                 DOS_REG_ADDR(CBREAK_STAUTS)
+#define CDB_ADDR_REG 0x033b
+#define P_CDB_ADDR_REG          DOS_REG_ADDR(CDB_ADDR_REG)
+#define CDB_DATA_REG 0x033c
+#define P_CDB_DATA_REG          DOS_REG_ADDR(CDB_DATA_REG)
+#define CDB_CTRL 0x033d
+#define P_CDB_CTRL              DOS_REG_ADDR(CDB_CTRL)
+#define CSFTINT0 0x033e
+#define P_CSFTINT0              DOS_REG_ADDR(CSFTINT0)
+#define CSFTINT1 0x033f
+#define P_CSFTINT1              DOS_REG_ADDR(CSFTINT1)
+#define IMEM_DMA_CTRL 0x0340
+#define P_IMEM_DMA_CTRL                 DOS_REG_ADDR(IMEM_DMA_CTRL)
+#define IMEM_DMA_ADR 0x0341
+#define P_IMEM_DMA_ADR          DOS_REG_ADDR(IMEM_DMA_ADR)
+#define IMEM_DMA_COUNT 0x0342
+#define P_IMEM_DMA_COUNT                DOS_REG_ADDR(IMEM_DMA_COUNT)
+#define WRRSP_IMEM 0x0343
+#define P_WRRSP_IMEM            DOS_REG_ADDR(WRRSP_IMEM)
+#define LMEM_DMA_CTRL 0x0350
+#define P_LMEM_DMA_CTRL                 DOS_REG_ADDR(LMEM_DMA_CTRL)
+#define LMEM_DMA_ADR 0x0351
+#define P_LMEM_DMA_ADR          DOS_REG_ADDR(LMEM_DMA_ADR)
+#define LMEM_DMA_COUNT 0x0352
+#define P_LMEM_DMA_COUNT                DOS_REG_ADDR(LMEM_DMA_COUNT)
+#define WRRSP_LMEM 0x0353
+#define P_WRRSP_LMEM            DOS_REG_ADDR(WRRSP_LMEM)
+#define MAC_CTRL1 0x0360
+#define P_MAC_CTRL1             DOS_REG_ADDR(MAC_CTRL1)
+#define ACC0REG1 0x0361
+#define P_ACC0REG1              DOS_REG_ADDR(ACC0REG1)
+#define ACC1REG1 0x0362
+#define P_ACC1REG1              DOS_REG_ADDR(ACC1REG1)
+#define MAC_CTRL2 0x0370
+#define P_MAC_CTRL2             DOS_REG_ADDR(MAC_CTRL2)
+#define ACC0REG2 0x0371
+#define P_ACC0REG2              DOS_REG_ADDR(ACC0REG2)
+#define ACC1REG2 0x0372
+#define P_ACC1REG2              DOS_REG_ADDR(ACC1REG2)
+#define CPU_TRACE 0x0380
+#define P_CPU_TRACE             DOS_REG_ADDR(CPU_TRACE)
+#define HENC_SCRATCH_0 0x1ac0
+#define P_HENC_SCRATCH_0                DOS_REG_ADDR(HENC_SCRATCH_0)
+#define HENC_SCRATCH_1 0x1ac1
+#define P_HENC_SCRATCH_1                DOS_REG_ADDR(HENC_SCRATCH_1)
+#define HENC_SCRATCH_2 0x1ac2
+#define P_HENC_SCRATCH_2                DOS_REG_ADDR(HENC_SCRATCH_2)
+#define HENC_SCRATCH_3 0x1ac3
+#define P_HENC_SCRATCH_3                DOS_REG_ADDR(HENC_SCRATCH_3)
+#define HENC_SCRATCH_4 0x1ac4
+#define P_HENC_SCRATCH_4                DOS_REG_ADDR(HENC_SCRATCH_4)
+#define HENC_SCRATCH_5 0x1ac5
+#define P_HENC_SCRATCH_5                DOS_REG_ADDR(HENC_SCRATCH_5)
+#define HENC_SCRATCH_6 0x1ac6
+#define P_HENC_SCRATCH_6                DOS_REG_ADDR(HENC_SCRATCH_6)
+#define HENC_SCRATCH_7 0x1ac7
+#define P_HENC_SCRATCH_7                DOS_REG_ADDR(HENC_SCRATCH_7)
+#define HENC_SCRATCH_8 0x1ac8
+#define P_HENC_SCRATCH_8                DOS_REG_ADDR(HENC_SCRATCH_8)
+#define HENC_SCRATCH_9 0x1ac9
+#define P_HENC_SCRATCH_9                DOS_REG_ADDR(HENC_SCRATCH_9)
+#define HENC_SCRATCH_A 0x1aca
+#define P_HENC_SCRATCH_A                DOS_REG_ADDR(HENC_SCRATCH_A)
+#define HENC_SCRATCH_B 0x1acb
+#define P_HENC_SCRATCH_B                DOS_REG_ADDR(HENC_SCRATCH_B)
+#define HENC_SCRATCH_C 0x1acc
+#define P_HENC_SCRATCH_C                DOS_REG_ADDR(HENC_SCRATCH_C)
+#define HENC_SCRATCH_D 0x1acd
+#define P_HENC_SCRATCH_D                DOS_REG_ADDR(HENC_SCRATCH_D)
+#define HENC_SCRATCH_E 0x1ace
+#define P_HENC_SCRATCH_E                DOS_REG_ADDR(HENC_SCRATCH_E)
+#define HENC_SCRATCH_F 0x1acf
+#define P_HENC_SCRATCH_F                DOS_REG_ADDR(HENC_SCRATCH_F)
+#define HENC_SCRATCH_G 0x1ad0
+#define P_HENC_SCRATCH_G                DOS_REG_ADDR(HENC_SCRATCH_G)
+#define HENC_SCRATCH_H 0x1ad1
+#define P_HENC_SCRATCH_H                DOS_REG_ADDR(HENC_SCRATCH_H)
+#define HENC_SCRATCH_I 0x1ad2
+#define P_HENC_SCRATCH_I                DOS_REG_ADDR(HENC_SCRATCH_I)
+#define HENC_SCRATCH_J 0x1ad3
+#define P_HENC_SCRATCH_J                DOS_REG_ADDR(HENC_SCRATCH_J)
+#define HENC_SCRATCH_K 0x1ad4
+#define P_HENC_SCRATCH_K                DOS_REG_ADDR(HENC_SCRATCH_K)
+#define HENC_SCRATCH_L 0x1ad5
+#define P_HENC_SCRATCH_L                DOS_REG_ADDR(HENC_SCRATCH_L)
+#define HENC_SCRATCH_M 0x1ad6
+#define P_HENC_SCRATCH_M                DOS_REG_ADDR(HENC_SCRATCH_M)
+#define HENC_SCRATCH_N 0x1ad7
+#define P_HENC_SCRATCH_N                DOS_REG_ADDR(HENC_SCRATCH_N)
+#define VLC_STATUS_CTRL 0x1d00
+#define P_VLC_STATUS_CTRL               DOS_REG_ADDR(VLC_STATUS_CTRL)
+#define VLC_CONFIG 0x1d01
+#define P_VLC_CONFIG            DOS_REG_ADDR(VLC_CONFIG)
+#define VLC_VB_START_PTR 0x1d10
+#define P_VLC_VB_START_PTR              DOS_REG_ADDR(VLC_VB_START_PTR)
+#define VLC_VB_END_PTR 0x1d11
+#define P_VLC_VB_END_PTR                DOS_REG_ADDR(VLC_VB_END_PTR)
+#define VLC_VB_WR_PTR 0x1d12
+#define P_VLC_VB_WR_PTR                 DOS_REG_ADDR(VLC_VB_WR_PTR)
+#define VLC_VB_RD_PTR 0x1d13
+#define P_VLC_VB_RD_PTR                 DOS_REG_ADDR(VLC_VB_RD_PTR)
+#define VLC_VB_SW_RD_PTR 0x1d14
+#define P_VLC_VB_SW_RD_PTR              DOS_REG_ADDR(VLC_VB_SW_RD_PTR)
+#define VLC_VB_LEFT 0x1d15
+#define P_VLC_VB_LEFT           DOS_REG_ADDR(VLC_VB_LEFT)
+#define VLC_VB_CONTROL 0x1d16
+#define P_VLC_VB_CONTROL                DOS_REG_ADDR(VLC_VB_CONTROL)
+#define VLC_VB_MEM_CTL 0x1d17
+#define P_VLC_VB_MEM_CTL                DOS_REG_ADDR(VLC_VB_MEM_CTL)
+#define VLC_VB_INT_PTR 0x1d18
+#define P_VLC_VB_INT_PTR                DOS_REG_ADDR(VLC_VB_INT_PTR)
+#define VLC_WRRSP 0x1d19
+#define P_VLC_WRRSP             DOS_REG_ADDR(VLC_WRRSP)
+#define VLC_TOTAL_BYTES 0x1d1a
+#define P_VLC_TOTAL_BYTES               DOS_REG_ADDR(VLC_TOTAL_BYTES)
+#define VLC_VB_BUFF 0x1d1b
+#define P_VLC_VB_BUFF           DOS_REG_ADDR(VLC_VB_BUFF)
+#define VLC_VB_PRE_BUFF_HI 0x1d1c
+#define P_VLC_VB_PRE_BUFF_HI            DOS_REG_ADDR(VLC_VB_PRE_BUFF_HI)
+#define VLC_VB_PRE_BUFF_LOW 0x1d1d
+#define P_VLC_VB_PRE_BUFF_LOW           DOS_REG_ADDR(VLC_VB_PRE_BUFF_LOW)
+#define VLC_STREAM_BUFF 0x1d1e
+#define P_VLC_STREAM_BUFF               DOS_REG_ADDR(VLC_STREAM_BUFF)
+#define VLC_PUSH_STREAM 0x1d1f
+#define P_VLC_PUSH_STREAM               DOS_REG_ADDR(VLC_PUSH_STREAM)
+#define VLC_PUSH_ELEMENT 0x1d20
+#define P_VLC_PUSH_ELEMENT              DOS_REG_ADDR(VLC_PUSH_ELEMENT)
+#define VLC_ELEMENT_DATA 0x1d21
+#define P_VLC_ELEMENT_DATA              DOS_REG_ADDR(VLC_ELEMENT_DATA)
+/*add from M8M2*/
+#define VLC_SPECIAL_CTL 0x1d22
+#define P_VLC_SPECIAL_CTL               DOS_REG_ADDR(VLC_SPECIAL_CTL)
+#define VLC_HCMD_T_L_INFO 0x1d23
+#define P_VLC_HCMD_T_L_INFO             DOS_REG_ADDR(VLC_HCMD_T_L_INFO)
+#define VLC_HCMD_CUR_INFO 0x1d24
+#define P_VLC_HCMD_CUR_INFO             DOS_REG_ADDR(VLC_HCMD_CUR_INFO)
+/**/
+#define IE_CONTROL 0x1f40
+#define P_IE_CONTROL            DOS_REG_ADDR(IE_CONTROL)
+#define IE_MB_POSITION 0x1f41
+#define P_IE_MB_POSITION                DOS_REG_ADDR(IE_MB_POSITION)
+#define IE_ME_MB_INFO 0x1f42
+#define P_IE_ME_MB_INFO                 DOS_REG_ADDR(IE_ME_MB_INFO)
+#define SAD_CONTROL 0x1f43
+#define P_SAD_CONTROL           DOS_REG_ADDR(SAD_CONTROL)
+#define IE_RESULT_BUFFER 0x1f44
+#define P_IE_RESULT_BUFFER              DOS_REG_ADDR(IE_RESULT_BUFFER)
+#define IE_I4_PRED_MODE_HI 0x1f45
+#define P_IE_I4_PRED_MODE_HI            DOS_REG_ADDR(IE_I4_PRED_MODE_HI)
+#define IE_I4_PRED_MODE_LO 0x1f46
+#define P_IE_I4_PRED_MODE_LO            DOS_REG_ADDR(IE_I4_PRED_MODE_LO)
+#define IE_C_PRED_MODE 0x1f47
+#define P_IE_C_PRED_MODE                DOS_REG_ADDR(IE_C_PRED_MODE)
+#define IE_CUR_REF_SEL 0x1f48
+#define P_IE_CUR_REF_SEL                DOS_REG_ADDR(IE_CUR_REF_SEL)
+#define ME_CONTROL 0x1f49
+#define P_ME_CONTROL            DOS_REG_ADDR(ME_CONTROL)
+#define ME_START_POSITION 0x1f4a
+#define P_ME_START_POSITION             DOS_REG_ADDR(ME_START_POSITION)
+#define ME_STATUS 0x1f4b
+#define P_ME_STATUS             DOS_REG_ADDR(ME_STATUS)
+#define ME_DEBUG 0x1f4c
+#define P_ME_DEBUG              DOS_REG_ADDR(ME_DEBUG)
+#define ME_SKIP_LINE 0x1f4d
+#define P_ME_SKIP_LINE          DOS_REG_ADDR(ME_SKIP_LINE)
+#define ME_AB_MEM_CTL 0x1f4e
+#define P_ME_AB_MEM_CTL                 DOS_REG_ADDR(ME_AB_MEM_CTL)
+#define ME_PIC_INFO 0x1f4f
+#define P_ME_PIC_INFO           DOS_REG_ADDR(ME_PIC_INFO)
+#define ME_SAD_ENOUGH_01 0x1f50
+#define P_ME_SAD_ENOUGH_01              DOS_REG_ADDR(ME_SAD_ENOUGH_01)
+#define ME_SAD_ENOUGH_23 0x1f51
+#define P_ME_SAD_ENOUGH_23              DOS_REG_ADDR(ME_SAD_ENOUGH_23)
+#define ME_STEP0_CLOSE_MV 0x1f52
+#define P_ME_STEP0_CLOSE_MV             DOS_REG_ADDR(ME_STEP0_CLOSE_MV)
+#define ME_F_SKIP_SAD 0x1f53
+#define P_ME_F_SKIP_SAD                 DOS_REG_ADDR(ME_F_SKIP_SAD)
+#define ME_F_SKIP_WEIGHT 0x1f54
+#define P_ME_F_SKIP_WEIGHT              DOS_REG_ADDR(ME_F_SKIP_WEIGHT)
+#define ME_MV_MERGE_CTL 0x1f55
+#define P_ME_MV_MERGE_CTL               DOS_REG_ADDR(ME_MV_MERGE_CTL)
+#define ME_MV_WEIGHT_01 0x1f56
+#define P_ME_MV_WEIGHT_01               DOS_REG_ADDR(ME_MV_WEIGHT_01)
+#define ME_MV_WEIGHT_23 0x1f57
+#define P_ME_MV_WEIGHT_23               DOS_REG_ADDR(ME_MV_WEIGHT_23)
+#define ME_SAD_RANGE_INC 0x1f58
+#define P_ME_SAD_RANGE_INC              DOS_REG_ADDR(ME_SAD_RANGE_INC)
+#define ME_SUB_MERGE_CTL 0x1f59
+#define P_ME_SUB_MERGE_CTL              DOS_REG_ADDR(ME_SUB_MERGE_CTL)
+#define ME_SUB_REF_MV_CTL 0x1f5a
+#define P_ME_SUB_REF_MV_CTL             DOS_REG_ADDR(ME_SUB_REF_MV_CTL)
+#define ME_SUB_FIX_SAD 0x1f5c
+#define P_ME_SUB_FIX_SAD                DOS_REG_ADDR(ME_SUB_FIX_SAD)
+#define ME_SUB_FIX_MIN_SAD 0x1f5d
+#define P_ME_SUB_FIX_MIN_SAD            DOS_REG_ADDR(ME_SUB_FIX_MIN_SAD)
+#define ME_SUB_SNAP_GLITCH 0x1f5e
+#define P_ME_SUB_SNAP_GLITCH            DOS_REG_ADDR(ME_SUB_SNAP_GLITCH)
+#define ME_SUB_ACT_CTL 0x1f5f
+#define P_ME_SUB_ACT_CTL                DOS_REG_ADDR(ME_SUB_ACT_CTL)
+/*add from M8M2*/
+#define HEVC_ASSIST_GCLK_EN 0x3003
+#define P_HEVC_ASSIST_GCLK_EN           DOS_REG_ADDR(HEVC_ASSIST_GCLK_EN)
+#define HEVC_ASSIST_SW_RESET 0x3004
+#define P_HEVC_ASSIST_SW_RESET          DOS_REG_ADDR(HEVC_ASSIST_SW_RESET)
+#define HEVC_ASSIST_AMR1_INT0 0x3025
+#define HEVC_ASSIST_DMA_INT2 0x3066
+#define P_HEVC_ASSIST_DMA_INT2          DOS_REG_ADDR(HEVC_ASSIST_DMA_INT2)
+#define HEVC_PARSER_VERSION 0x3100
+#define P_HEVC_PARSER_VERSION           DOS_REG_ADDR(HEVC_PARSER_VERSION)
+#define HEVC_STREAM_CONTROL 0x3101
+#define P_HEVC_STREAM_CONTROL           DOS_REG_ADDR(HEVC_STREAM_CONTROL)
+#define HEVC_STREAM_END_ADDR 0x3103
+#define P_HEVC_STREAM_END_ADDR          DOS_REG_ADDR(HEVC_STREAM_END_ADDR)
+#define HEVC_STREAM_WR_PTR 0x3104
+#define P_HEVC_STREAM_WR_PTR            DOS_REG_ADDR(HEVC_STREAM_WR_PTR)
+#define HEVC_STREAM_RD_PTR 0x3105
+#define P_HEVC_STREAM_RD_PTR            DOS_REG_ADDR(HEVC_STREAM_RD_PTR)
+#define HEVC_STREAM_LEVEL 0x3106
+#define P_HEVC_STREAM_LEVEL             DOS_REG_ADDR(HEVC_STREAM_LEVEL)
+#define HEVC_STREAM_FIFO_CTL 0x3107
+#define P_HEVC_STREAM_FIFO_CTL          DOS_REG_ADDR(HEVC_STREAM_FIFO_CTL)
+#define HEVC_SHIFT_CONTROL 0x3108
+#define P_HEVC_SHIFT_CONTROL            DOS_REG_ADDR(HEVC_SHIFT_CONTROL)
+#define HEVC_SHIFT_STARTCODE 0x3109
+#define P_HEVC_SHIFT_STARTCODE          DOS_REG_ADDR(HEVC_SHIFT_STARTCODE)
+#define HEVC_SHIFT_STATUS 0x310b
+#define P_HEVC_SHIFT_STATUS             DOS_REG_ADDR(HEVC_SHIFT_STATUS)
+#define HEVC_SHIFTED_DATA 0x310c
+#define P_HEVC_SHIFTED_DATA             DOS_REG_ADDR(HEVC_SHIFTED_DATA)
+#define HEVC_PARSER_RESULT_0 0x3118
+#define P_HEVC_PARSER_RESULT_0          DOS_REG_ADDR(HEVC_PARSER_RESULT_0)
+#define HEVC_PARSER_RESULT_1 0x3119
+#define P_HEVC_PARSER_RESULT_1          DOS_REG_ADDR(HEVC_PARSER_RESULT_1)
+#define HEVC_PARSER_RESULT_2 0x311a
+#define P_HEVC_PARSER_RESULT_2          DOS_REG_ADDR(HEVC_PARSER_RESULT_2)
+#define HEVC_PARSER_RESULT_3 0x311b
+#define P_HEVC_PARSER_RESULT_3          DOS_REG_ADDR(HEVC_PARSER_RESULT_3)
+#define HEVC_CABAC_TOP_INFO 0x311c
+#define P_HEVC_CABAC_TOP_INFO           DOS_REG_ADDR(HEVC_CABAC_TOP_INFO)
+#define HEVC_SAO_IF_STATUS 0x3130
+#define P_HEVC_SAO_IF_STATUS            DOS_REG_ADDR(HEVC_SAO_IF_STATUS)
+#define HEVC_SAO_IF_DATA_Y 0x3131
+#define P_HEVC_SAO_IF_DATA_Y            DOS_REG_ADDR(HEVC_SAO_IF_DATA_Y)
+#define HEVC_SAO_IF_DATA_U 0x3132
+#define P_HEVC_SAO_IF_DATA_U            DOS_REG_ADDR(HEVC_SAO_IF_DATA_U)
+#define HEVC_SAO_IF_DATA_V 0x3133
+#define P_HEVC_SAO_IF_DATA_V            DOS_REG_ADDR(HEVC_SAO_IF_DATA_V)
+#define HEVC_STREAM_SWAP_ADDR 0x3134
+#define HEVC_MPRED_VERSION 0x3200
+#define P_HEVC_MPRED_VERSION            DOS_REG_ADDR(HEVC_MPRED_VERSION)
+#define HEVC_MPRED_CTRL0 0x3201
+#define P_HEVC_MPRED_CTRL0              DOS_REG_ADDR(HEVC_MPRED_CTRL0)
+#define HEVC_MPRED_CTRL1 0x3202
+#define P_HEVC_MPRED_CTRL1              DOS_REG_ADDR(HEVC_MPRED_CTRL1)
+#define HEVC_MPRED_INT_EN 0x3203
+#define P_HEVC_MPRED_INT_EN             DOS_REG_ADDR(HEVC_MPRED_INT_EN)
+#define HEVC_MPRED_INT_STATUS 0x3204
+
+#define HEVC_MPRED_REF_NUM 0x3209
+#define P_HEVC_MPRED_REF_NUM            DOS_REG_ADDR(HEVC_MPRED_REF_NUM)
+#define HEVC_MPRED_LT_REF 0x320a
+#define P_HEVC_MPRED_LT_REF             DOS_REG_ADDR(HEVC_MPRED_LT_REF)
+#define HEVC_MPRED_LT_COLREF 0x320b
+#define P_HEVC_MPRED_LT_COLREF          DOS_REG_ADDR(HEVC_MPRED_LT_COLREF)
+#define HEVC_MPRED_REF_EN_L0 0x320c
+#define P_HEVC_MPRED_REF_EN_L0          DOS_REG_ADDR(HEVC_MPRED_REF_EN_L0)
+#define HEVC_MPRED_REF_EN_L1 0x320d
+#define P_HEVC_MPRED_REF_EN_L1          DOS_REG_ADDR(HEVC_MPRED_REF_EN_L1)
+#define HEVC_MPRED_CURR_LCU 0x3219
+#define P_HEVC_MPRED_CURR_LCU           DOS_REG_ADDR(HEVC_MPRED_CURR_LCU)
+#define HEVC_MPRED_ABV_WPTR 0x321a
+#define P_HEVC_MPRED_ABV_WPTR           DOS_REG_ADDR(HEVC_MPRED_ABV_WPTR)
+#define HEVC_MPRED_ABV_RPTR 0x321b
+#define P_HEVC_MPRED_ABV_RPTR           DOS_REG_ADDR(HEVC_MPRED_ABV_RPTR)
+#define HEVC_MPRED_CTRL2 0x321c
+#define P_HEVC_MPRED_CTRL2              DOS_REG_ADDR(HEVC_MPRED_CTRL2)
+#define HEVC_MPRED_CTRL3 0x321d
+#define P_HEVC_MPRED_CTRL3              DOS_REG_ADDR(HEVC_MPRED_CTRL3)
+#define HEVC_MPRED_MV_WLCUY 0x321e
+#define P_HEVC_MPRED_MV_WLCUY           DOS_REG_ADDR(HEVC_MPRED_MV_WLCUY)
+#define HEVC_MPRED_MV_RLCUY 0x321f
+#define P_HEVC_MPRED_MV_RLCUY           DOS_REG_ADDR(HEVC_MPRED_MV_RLCUY)
+
+#define HEVC_MPRED_DBG_MODE0 0x3241
+#define P_HEVC_MPRED_DBG_MODE0          DOS_REG_ADDR(HEVC_MPRED_DBG_MODE0)
+#define HEVC_MPRED_DBG_MODE1 0x3242
+#define P_HEVC_MPRED_DBG_MODE1          DOS_REG_ADDR(HEVC_MPRED_DBG_MODE1)
+#define HEVC_MPRED_DBG2_MODE 0x3243
+#define P_HEVC_MPRED_DBG2_MODE          DOS_REG_ADDR(HEVC_MPRED_DBG2_MODE)
+#define HEVC_MPRED_IMP_CMD0 0x3244
+#define P_HEVC_MPRED_IMP_CMD0           DOS_REG_ADDR(HEVC_MPRED_IMP_CMD0)
+#define HEVC_MPRED_IMP_CMD1 0x3245
+#define P_HEVC_MPRED_IMP_CMD1           DOS_REG_ADDR(HEVC_MPRED_IMP_CMD1)
+#define HEVC_MPRED_IMP_CMD2 0x3246
+#define P_HEVC_MPRED_IMP_CMD2           DOS_REG_ADDR(HEVC_MPRED_IMP_CMD2)
+#define HEVC_MPRED_IMP_CMD3 0x3247
+#define P_HEVC_MPRED_IMP_CMD3           DOS_REG_ADDR(HEVC_MPRED_IMP_CMD3)
+#define HEVCD_IPP_TOP_LCUCONFIG 0x3406
+#define P_HEVC_DBLK_CFG0                DOS_REG_ADDR(HEVC_DBLK_CFG0)
+#define HEVC_DBLK_CFG1 0x3501
+#define P_HEVC_DBLK_CFG1                DOS_REG_ADDR(HEVC_DBLK_CFG1)
+#define HEVC_DBLK_CFG2 0x3502
+#define P_HEVC_DBLK_CFG2                DOS_REG_ADDR(HEVC_DBLK_CFG2)
+#define HEVC_DBLK_CFG3 0x3503
+#define P_HEVC_DBLK_CFG3                DOS_REG_ADDR(HEVC_DBLK_CFG3)
+#define HEVC_DBLK_CFG4 0x3504
+#define P_HEVC_DBLK_CFG4                DOS_REG_ADDR(HEVC_DBLK_CFG4)
+#define HEVC_DBLK_CFG5 0x3505
+#define P_HEVC_DBLK_CFG5                DOS_REG_ADDR(HEVC_DBLK_CFG5)
+#define HEVC_DBLK_CFG6 0x3506
+#define P_HEVC_DBLK_CFG6                DOS_REG_ADDR(HEVC_DBLK_CFG6)
+#define HEVC_DBLK_CFG7 0x3507
+#define P_HEVC_DBLK_CFG7                DOS_REG_ADDR(HEVC_DBLK_CFG7)
+#define HEVC_DBLK_CFG8 0x3508
+#define P_HEVC_DBLK_CFG8                DOS_REG_ADDR(HEVC_DBLK_CFG8)
+#define HEVC_DBLK_CFG9 0x3509
+#define P_HEVC_DBLK_CFG9                DOS_REG_ADDR(HEVC_DBLK_CFG9)
+#define HEVC_DBLK_CFGA 0x350a
+#define P_HEVC_DBLK_CFGA                DOS_REG_ADDR(HEVC_DBLK_CFGA)
+#define HEVC_DBLK_STS0 0x350b
+#define P_HEVC_DBLK_STS0                DOS_REG_ADDR(HEVC_DBLK_STS0)
+#define HEVC_DBLK_STS1 0x350c
+#define P_HEVC_DBLK_STS1                DOS_REG_ADDR(HEVC_DBLK_STS1)
+#define HEVC_SAO_VERSION 0x3600
+#define P_HEVC_SAO_VERSION              DOS_REG_ADDR(HEVC_SAO_VERSION)
+#define HEVC_SAO_CTRL0 0x3601
+#define P_HEVC_SAO_CTRL0                DOS_REG_ADDR(HEVC_SAO_CTRL0)
+#define HEVC_SAO_CTRL1 0x3602
+#define P_HEVC_SAO_CTRL1                DOS_REG_ADDR(HEVC_SAO_CTRL1)
+#define HEVC_SAO_INT_EN 0x3603
+#define P_HEVC_SAO_INT_EN               DOS_REG_ADDR(HEVC_SAO_INT_EN)
+#define HEVC_SAO_INT_STATUS 0x3604
+#define P_HEVC_SAO_INT_STATUS           DOS_REG_ADDR(HEVC_SAO_INT_STATUS)
+
+#define HEVC_SAO_TILE_START 0x3607
+#define P_HEVC_SAO_TILE_START           DOS_REG_ADDR(HEVC_SAO_TILE_START)
+#define HEVC_SAO_AXI_WCTRL 0x3609
+#define P_HEVC_SAO_AXI_WCTRL            DOS_REG_ADDR(HEVC_SAO_AXI_WCTRL)
+#define HEVC_SAO_AXI_RCTRL 0x360a
+#define P_HEVC_SAO_AXI_RCTRL            DOS_REG_ADDR(HEVC_SAO_AXI_RCTRL)
+
+#define HEVC_SAO_ABV_WPTR 0x3614
+#define P_HEVC_SAO_ABV_WPTR             DOS_REG_ADDR(HEVC_SAO_ABV_WPTR)
+#define HEVC_SAO_ABV_RPTR 0x3615
+#define P_HEVC_SAO_ABV_RPTR             DOS_REG_ADDR(HEVC_SAO_ABV_RPTR)
+#define HEVC_SAO_VB_WPTR 0x3616
+#define P_HEVC_SAO_VB_WPTR              DOS_REG_ADDR(HEVC_SAO_VB_WPTR)
+#define HEVC_SAO_VB_RPTR 0x3617
+#define P_HEVC_SAO_VB_RPTR              DOS_REG_ADDR(HEVC_SAO_VB_RPTR)
+#define HEVC_SAO_DBG_MODE0 0x361e
+#define P_HEVC_SAO_DBG_MODE0            DOS_REG_ADDR(HEVC_SAO_DBG_MODE0)
+#define HEVC_SAO_DBG_MODE1 0x361f
+#define P_HEVC_SAO_DBG_MODE1            DOS_REG_ADDR(HEVC_SAO_DBG_MODE1)
+#define HEVC_SAO_CTRL2 0x3620
+#define P_HEVC_SAO_CTRL2                DOS_REG_ADDR(HEVC_SAO_CTRL2)
+#define HEVC_SAO_CTRL3 0x3621
+#define P_HEVC_SAO_CTRL3                DOS_REG_ADDR(HEVC_SAO_CTRL3)
+#define HEVC_SAO_CTRL4 0x3622
+#define P_HEVC_SAO_CTRL4                DOS_REG_ADDR(HEVC_SAO_CTRL4)
+#define HEVC_SAO_CTRL5 0x3623
+#define P_HEVC_SAO_CTRL5                DOS_REG_ADDR(HEVC_SAO_CTRL5)
+#define HEVC_SAO_CTRL6 0x3624
+#define P_HEVC_SAO_CTRL6                DOS_REG_ADDR(HEVC_SAO_CTRL6)
+#define HEVC_SAO_CTRL7 0x3625
+#define P_HEVC_SAO_CTRL7                DOS_REG_ADDR(HEVC_SAO_CTRL7)
+#define HEVC_SAO_DBG_DATA_0 0x3630
+#define P_HEVC_SAO_DBG_DATA_0           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_0)
+#define HEVC_SAO_DBG_DATA_1 0x3631
+#define P_HEVC_SAO_DBG_DATA_1           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_1)
+#define HEVC_SAO_DBG_DATA_2 0x3632
+#define P_HEVC_SAO_DBG_DATA_2           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_2)
+#define HEVC_SAO_DBG_DATA_3 0x3633
+#define P_HEVC_SAO_DBG_DATA_3           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_3)
+#define HEVC_SAO_DBG_DATA_4 0x3634
+#define P_HEVC_SAO_DBG_DATA_4           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_4)
+#define HEVC_SAO_DBG_DATA_5 0x3635
+#define P_HEVC_SAO_DBG_DATA_5           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_5)
+#define HEVC_SAO_DBG_DATA_6 0x3636
+#define P_HEVC_SAO_DBG_DATA_6           DOS_REG_ADDR(HEVC_SAO_DBG_DATA_6)
+#define HEVC_IQIT_STAT_GEN0 0x3708
+#define P_HEVC_IQIT_STAT_GEN0           DOS_REG_ADDR(HEVC_IQIT_STAT_GEN0)
+#define HEVC_QP_WRITE 0x3709
+#define P_HEVC_QP_WRITE                 DOS_REG_ADDR(HEVC_QP_WRITE)
+#define HEVC_IQIT_STAT_GEN1 0x370a
+#define P_HEVC_IQIT_STAT_GEN1           DOS_REG_ADDR(HEVC_IQIT_STAT_GEN1)
+/**/
+#define DOS_SW_RESET0 0x3f00
+#define P_DOS_SW_RESET0                 DOS_REG_ADDR(DOS_SW_RESET0)
+#define DOS_GCLK_EN0 0x3f01
+#define P_DOS_GCLK_EN0          DOS_REG_ADDR(DOS_GCLK_EN0)
+#define DOS_GEN_CTRL0 0x3f02
+#define P_DOS_GEN_CTRL0                 DOS_REG_ADDR(DOS_GEN_CTRL0)
+#define DOS_APB_ERR_CTRL 0x3f03
+#define P_DOS_APB_ERR_CTRL              DOS_REG_ADDR(DOS_APB_ERR_CTRL)
+#define DOS_APB_ERR_STAT 0x3f04
+#define P_DOS_APB_ERR_STAT              DOS_REG_ADDR(DOS_APB_ERR_STAT)
+#define DOS_VDEC_INT_EN 0x3f05
+#define P_DOS_VDEC_INT_EN               DOS_REG_ADDR(DOS_VDEC_INT_EN)
+#define DOS_HCODEC_INT_EN 0x3f06
+#define P_DOS_HCODEC_INT_EN             DOS_REG_ADDR(DOS_HCODEC_INT_EN)
+#define DOS_SW_RESET1 0x3f07
+#define P_DOS_SW_RESET1                 DOS_REG_ADDR(DOS_SW_RESET1)
+#define DOS_SW_RESET2 0x3f08
+#define P_DOS_SW_RESET2                 DOS_REG_ADDR(DOS_SW_RESET2)
+#define DOS_GCLK_EN1 0x3f09
+#define P_DOS_GCLK_EN1          DOS_REG_ADDR(DOS_GCLK_EN1)
+#define DOS_VDEC2_INT_EN 0x3f0a
+#define P_DOS_VDEC2_INT_EN              DOS_REG_ADDR(DOS_VDEC2_INT_EN)
+#define DOS_VDIN_LCNT 0x3f0b
+#define P_DOS_VDIN_LCNT                 DOS_REG_ADDR(DOS_VDIN_LCNT)
+#define DOS_VDIN_FCNT 0x3f0c
+#define P_DOS_VDIN_FCNT                 DOS_REG_ADDR(DOS_VDIN_FCNT)
+#define DOS_VDIN_CCTL 0x3f0d
+#define P_DOS_VDIN_CCTL                 DOS_REG_ADDR(DOS_VDIN_CCTL)
+#define DOS_SCRATCH0 0x3f10
+#define P_DOS_SCRATCH0          DOS_REG_ADDR(DOS_SCRATCH0)
+#define DOS_SCRATCH1 0x3f11
+#define P_DOS_SCRATCH1          DOS_REG_ADDR(DOS_SCRATCH1)
+#define DOS_SCRATCH2 0x3f12
+#define P_DOS_SCRATCH2          DOS_REG_ADDR(DOS_SCRATCH2)
+#define DOS_SCRATCH3 0x3f13
+#define P_DOS_SCRATCH3          DOS_REG_ADDR(DOS_SCRATCH3)
+#define DOS_SCRATCH4 0x3f14
+#define P_DOS_SCRATCH4          DOS_REG_ADDR(DOS_SCRATCH4)
+#define DOS_SCRATCH5 0x3f15
+#define P_DOS_SCRATCH5          DOS_REG_ADDR(DOS_SCRATCH5)
+#define DOS_SCRATCH6 0x3f16
+#define P_DOS_SCRATCH6          DOS_REG_ADDR(DOS_SCRATCH6)
+#define DOS_SCRATCH7 0x3f17
+#define P_DOS_SCRATCH7          DOS_REG_ADDR(DOS_SCRATCH7)
+#define DOS_SCRATCH8 0x3f18
+#define P_DOS_SCRATCH8          DOS_REG_ADDR(DOS_SCRATCH8)
+#define DOS_SCRATCH9 0x3f19
+#define P_DOS_SCRATCH9          DOS_REG_ADDR(DOS_SCRATCH9)
+#define DOS_SCRATCH10 0x3f1a
+#define P_DOS_SCRATCH10                 DOS_REG_ADDR(DOS_SCRATCH10)
+#define DOS_SCRATCH11 0x3f1b
+#define P_DOS_SCRATCH11                 DOS_REG_ADDR(DOS_SCRATCH11)
+#define DOS_SCRATCH12 0x3f1c
+#define P_DOS_SCRATCH12                 DOS_REG_ADDR(DOS_SCRATCH12)
+#define DOS_SCRATCH13 0x3f1d
+#define P_DOS_SCRATCH13                 DOS_REG_ADDR(DOS_SCRATCH13)
+#define DOS_SCRATCH14 0x3f1e
+#define P_DOS_SCRATCH14                 DOS_REG_ADDR(DOS_SCRATCH14)
+#define DOS_SCRATCH15 0x3f1f
+#define P_DOS_SCRATCH15                 DOS_REG_ADDR(DOS_SCRATCH15)
+#define DOS_SCRATCH16 0x3f20
+#define P_DOS_SCRATCH16                 DOS_REG_ADDR(DOS_SCRATCH16)
+#define DOS_SCRATCH17 0x3f21
+#define P_DOS_SCRATCH17                 DOS_REG_ADDR(DOS_SCRATCH17)
+#define DOS_SCRATCH18 0x3f22
+#define P_DOS_SCRATCH18                 DOS_REG_ADDR(DOS_SCRATCH18)
+#define DOS_SCRATCH19 0x3f23
+#define P_DOS_SCRATCH19                 DOS_REG_ADDR(DOS_SCRATCH19)
+#define DOS_SCRATCH20 0x3f24
+#define P_DOS_SCRATCH20                 DOS_REG_ADDR(DOS_SCRATCH20)
+#define DOS_SCRATCH21 0x3f25
+#define P_DOS_SCRATCH21                 DOS_REG_ADDR(DOS_SCRATCH21)
+#define DOS_SCRATCH22 0x3f26
+#define P_DOS_SCRATCH22                 DOS_REG_ADDR(DOS_SCRATCH22)
+#define DOS_SCRATCH23 0x3f27
+#define P_DOS_SCRATCH23                 DOS_REG_ADDR(DOS_SCRATCH23)
+#define DOS_SCRATCH24 0x3f28
+#define P_DOS_SCRATCH24                 DOS_REG_ADDR(DOS_SCRATCH24)
+#define DOS_SCRATCH25 0x3f29
+#define P_DOS_SCRATCH25                 DOS_REG_ADDR(DOS_SCRATCH25)
+#define DOS_SCRATCH26 0x3f2a
+#define P_DOS_SCRATCH26                 DOS_REG_ADDR(DOS_SCRATCH26)
+#define DOS_SCRATCH27 0x3f2b
+#define P_DOS_SCRATCH27                 DOS_REG_ADDR(DOS_SCRATCH27)
+#define DOS_SCRATCH28 0x3f2c
+#define P_DOS_SCRATCH28                 DOS_REG_ADDR(DOS_SCRATCH28)
+#define DOS_SCRATCH29 0x3f2d
+#define P_DOS_SCRATCH29                 DOS_REG_ADDR(DOS_SCRATCH29)
+#define DOS_SCRATCH30 0x3f2e
+#define P_DOS_SCRATCH30                 DOS_REG_ADDR(DOS_SCRATCH30)
+#define DOS_SCRATCH31 0x3f2f
+#define P_DOS_SCRATCH31                 DOS_REG_ADDR(DOS_SCRATCH31)
+#define DOS_MEM_PD_VDEC 0x3f30
+#define P_DOS_MEM_PD_VDEC               DOS_REG_ADDR(DOS_MEM_PD_VDEC)
+#define DOS_MEM_PD_VDEC2 0x3f31
+#define P_DOS_MEM_PD_VDEC2              DOS_REG_ADDR(DOS_MEM_PD_VDEC2)
+#define DOS_MEM_PD_HCODEC 0x3f32
+#define P_DOS_MEM_PD_HCODEC             DOS_REG_ADDR(DOS_MEM_PD_HCODEC)
+/*add from M8M2*/
+#define DOS_MEM_PD_HEVC 0x3f33
+#define P_DOS_MEM_PD_HEVC               DOS_REG_ADDR(DOS_MEM_PD_HEVC)
+#define DOS_SW_RESET3 0x3f34
+#define P_DOS_SW_RESET3                 DOS_REG_ADDR(DOS_SW_RESET3)
+#define DOS_GCLK_EN3 0x3f35
+#define P_DOS_GCLK_EN3          DOS_REG_ADDR(DOS_GCLK_EN3)
+#define DOS_HEVC_INT_EN 0x3f36
+#define P_DOS_HEVC_INT_EN               DOS_REG_ADDR(DOS_HEVC_INT_EN)
+/**/
+
+#define HCODEC_MC_CTRL_REG 0x1900
+#define P_HCODEC_MC_CTRL_REG            DOS_REG_ADDR(HCODEC_MC_CTRL_REG)
+#define HCODEC_MC_MB_INFO 0x1901
+#define P_HCODEC_MC_MB_INFO             DOS_REG_ADDR(HCODEC_MC_MB_INFO)
+#define HCODEC_MC_PIC_INFO 0x1902
+#define P_HCODEC_MC_PIC_INFO            DOS_REG_ADDR(HCODEC_MC_PIC_INFO)
+#define HCODEC_POWER_CTL_MC 0x1905
+#define P_HCODEC_POWER_CTL_MC           DOS_REG_ADDR(HCODEC_POWER_CTL_MC)
+#define HCODEC_MC_CMD 0x1906
+#define P_HCODEC_MC_CMD                 DOS_REG_ADDR(HCODEC_MC_CMD)
+#define HCODEC_MC_CTRL0 0x1907
+#define P_HCODEC_MC_CTRL0               DOS_REG_ADDR(HCODEC_MC_CTRL0)
+#define HCODEC_MC_PIC_W_H 0x1908
+#define P_HCODEC_MC_PIC_W_H             DOS_REG_ADDR(HCODEC_MC_PIC_W_H)
+#define HCODEC_MC_STATUS0 0x1909
+#define P_HCODEC_MC_STATUS0             DOS_REG_ADDR(HCODEC_MC_STATUS0)
+#define HCODEC_MC_STATUS1 0x190a
+#define P_HCODEC_MC_STATUS1             DOS_REG_ADDR(HCODEC_MC_STATUS1)
+#define HCODEC_MC_CTRL1 0x190b
+#define P_HCODEC_MC_CTRL1               DOS_REG_ADDR(HCODEC_MC_CTRL1)
+#define HCODEC_MC_MIX_RATIO0 0x190c
+#define P_HCODEC_MC_MIX_RATIO0          DOS_REG_ADDR(HCODEC_MC_MIX_RATIO0)
+#define HCODEC_MC_MIX_RATIO1 0x190d
+#define P_HCODEC_MC_MIX_RATIO1          DOS_REG_ADDR(HCODEC_MC_MIX_RATIO1)
+#define HCODEC_MC_DP_MB_XY 0x190e
+#define P_HCODEC_MC_DP_MB_XY            DOS_REG_ADDR(HCODEC_MC_DP_MB_XY)
+#define HCODEC_MC_OM_MB_XY 0x190f
+#define P_HCODEC_MC_OM_MB_XY            DOS_REG_ADDR(HCODEC_MC_OM_MB_XY)
+#define HCODEC_PSCALE_RST 0x1910
+#define P_HCODEC_PSCALE_RST             DOS_REG_ADDR(HCODEC_PSCALE_RST)
+#define HCODEC_PSCALE_CTRL 0x1911
+#define P_HCODEC_PSCALE_CTRL            DOS_REG_ADDR(HCODEC_PSCALE_CTRL)
+#define HCODEC_PSCALE_PICI_W 0x1912
+#define P_HCODEC_PSCALE_PICI_W          DOS_REG_ADDR(HCODEC_PSCALE_PICI_W)
+#define HCODEC_PSCALE_PICI_H 0x1913
+#define P_HCODEC_PSCALE_PICI_H          DOS_REG_ADDR(HCODEC_PSCALE_PICI_H)
+#define HCODEC_PSCALE_PICO_W 0x1914
+#define P_HCODEC_PSCALE_PICO_W          DOS_REG_ADDR(HCODEC_PSCALE_PICO_W)
+#define HCODEC_PSCALE_PICO_H 0x1915
+#define P_HCODEC_PSCALE_PICO_H          DOS_REG_ADDR(HCODEC_PSCALE_PICO_H)
+#define HCODEC_PSCALE_PICO_START_X 0x1916
+
+
+/**/
+#define HCODEC_MC_MPORT_CTRL 0x1940
+#define P_HCODEC_MC_MPORT_CTRL          DOS_REG_ADDR(HCODEC_MC_MPORT_CTRL)
+#define HCODEC_MC_MPORT_DAT 0x1941
+#define P_HCODEC_MC_MPORT_DAT           DOS_REG_ADDR(HCODEC_MC_MPORT_DAT)
+#define HCODEC_MC_DPDN_MB_XY 0x1946
+#define P_HCODEC_MC_DPDN_MB_XY          DOS_REG_ADDR(HCODEC_MC_DPDN_MB_XY)
+#define HCODEC_MC_OMDN_MB_XY 0x1947
+#define HCODEC_AV_SCRATCH_0 0x19c0
+#define P_HCODEC_AV_SCRATCH_0           DOS_REG_ADDR(HCODEC_AV_SCRATCH_0)
+#define HCODEC_AV_SCRATCH_1 0x19c1
+#define P_HCODEC_AV_SCRATCH_1           DOS_REG_ADDR(HCODEC_AV_SCRATCH_1)
+#define HCODEC_AV_SCRATCH_2 0x19c2
+#define P_HCODEC_AV_SCRATCH_2           DOS_REG_ADDR(HCODEC_AV_SCRATCH_2)
+#define HCODEC_AV_SCRATCH_3 0x19c3
+#define P_HCODEC_AV_SCRATCH_3           DOS_REG_ADDR(HCODEC_AV_SCRATCH_3)
+#define HCODEC_AV_SCRATCH_4 0x19c4
+#define P_HCODEC_AV_SCRATCH_4           DOS_REG_ADDR(HCODEC_AV_SCRATCH_4)
+#define HCODEC_AV_SCRATCH_5 0x19c5
+#define P_HCODEC_AV_SCRATCH_5           DOS_REG_ADDR(HCODEC_AV_SCRATCH_5)
+#define HCODEC_AV_SCRATCH_6 0x19c6
+#define P_HCODEC_AV_SCRATCH_6           DOS_REG_ADDR(HCODEC_AV_SCRATCH_6)
+#define HCODEC_AV_SCRATCH_7 0x19c7
+#define P_HCODEC_AV_SCRATCH_7           DOS_REG_ADDR(HCODEC_AV_SCRATCH_7)
+#define HCODEC_AV_SCRATCH_8 0x19c8
+#define P_HCODEC_AV_SCRATCH_8           DOS_REG_ADDR(HCODEC_AV_SCRATCH_8)
+#define HCODEC_AV_SCRATCH_9 0x19c9
+#define P_HCODEC_AV_SCRATCH_9           DOS_REG_ADDR(HCODEC_AV_SCRATCH_9)
+#define HCODEC_AV_SCRATCH_A 0x19ca
+#define P_HCODEC_AV_SCRATCH_A           DOS_REG_ADDR(HCODEC_AV_SCRATCH_A)
+#define HCODEC_AV_SCRATCH_B 0x19cb
+#define P_HCODEC_AV_SCRATCH_B           DOS_REG_ADDR(HCODEC_AV_SCRATCH_B)
+#define HCODEC_AV_SCRATCH_C 0x19cc
+#define P_HCODEC_AV_SCRATCH_C           DOS_REG_ADDR(HCODEC_AV_SCRATCH_C)
+#define HCODEC_AV_SCRATCH_D 0x19cd
+#define P_HCODEC_AV_SCRATCH_D           DOS_REG_ADDR(HCODEC_AV_SCRATCH_D)
+#define HCODEC_AV_SCRATCH_E 0x19ce
+#define P_HCODEC_AV_SCRATCH_E           DOS_REG_ADDR(HCODEC_AV_SCRATCH_E)
+#define HCODEC_AV_SCRATCH_F 0x19cf
+#define P_HCODEC_AV_SCRATCH_F           DOS_REG_ADDR(HCODEC_AV_SCRATCH_F)
+#define HCODEC_AV_SCRATCH_G 0x19d0
+#define P_HCODEC_AV_SCRATCH_G           DOS_REG_ADDR(HCODEC_AV_SCRATCH_G)
+#define HCODEC_AV_SCRATCH_H 0x19d1
+#define P_HCODEC_AV_SCRATCH_H           DOS_REG_ADDR(HCODEC_AV_SCRATCH_H)
+#define HCODEC_AV_SCRATCH_I 0x19d2
+#define P_HCODEC_AV_SCRATCH_I           DOS_REG_ADDR(HCODEC_AV_SCRATCH_I)
+#define HCODEC_AV_SCRATCH_J 0x19d3
+#define P_HCODEC_AV_SCRATCH_J           DOS_REG_ADDR(HCODEC_AV_SCRATCH_J)
+#define HCODEC_AV_SCRATCH_K 0x19d4
+#define P_HCODEC_AV_SCRATCH_K           DOS_REG_ADDR(HCODEC_AV_SCRATCH_K)
+#define HCODEC_AV_SCRATCH_L 0x19d5
+#define P_HCODEC_AV_SCRATCH_L           DOS_REG_ADDR(HCODEC_AV_SCRATCH_L)
+#define HCODEC_AV_SCRATCH_M 0x19d6
+#define P_HCODEC_AV_SCRATCH_M           DOS_REG_ADDR(HCODEC_AV_SCRATCH_M)
+#define HCODEC_AV_SCRATCH_N 0x19d7
+#define P_HCODEC_AV_SCRATCH_N           DOS_REG_ADDR(HCODEC_AV_SCRATCH_N)
+#define HCODEC_WRRSP_CO_MB 0x19d8
+#define P_HCODEC_WRRSP_CO_MB            DOS_REG_ADDR(HCODEC_WRRSP_CO_MB)
+#define HCODEC_WRRSP_DCAC 0x19d9
+#define P_HCODEC_WRRSP_DCAC             DOS_REG_ADDR(HCODEC_WRRSP_DCAC)
+/*add from M8M2*/
+#define VDEC2_AV_SCRATCH_0 0x29c0
+#define P_VDEC2_AV_SCRATCH_0            DOS_REG_ADDR(VDEC2_AV_SCRATCH_0)
+#define VDEC2_AV_SCRATCH_1 0x29c1
+#define P_VDEC2_AV_SCRATCH_1            DOS_REG_ADDR(VDEC2_AV_SCRATCH_1)
+#define VDEC2_AV_SCRATCH_2 0x29c2
+#define P_VDEC2_AV_SCRATCH_2            DOS_REG_ADDR(VDEC2_AV_SCRATCH_2)
+#define VDEC2_AV_SCRATCH_3 0x29c3
+#define P_VDEC2_AV_SCRATCH_3            DOS_REG_ADDR(VDEC2_AV_SCRATCH_3)
+#define VDEC2_AV_SCRATCH_4 0x29c4
+#define P_VDEC2_AV_SCRATCH_4            DOS_REG_ADDR(VDEC2_AV_SCRATCH_4)
+#define VDEC2_AV_SCRATCH_5 0x29c5
+#define P_VDEC2_AV_SCRATCH_5            DOS_REG_ADDR(VDEC2_AV_SCRATCH_5)
+#define VDEC2_AV_SCRATCH_6 0x29c6
+#define P_VDEC2_AV_SCRATCH_6            DOS_REG_ADDR(VDEC2_AV_SCRATCH_6)
+#define VDEC2_AV_SCRATCH_7 0x29c7
+#define P_VDEC2_AV_SCRATCH_7            DOS_REG_ADDR(VDEC2_AV_SCRATCH_7)
+#define VDEC2_AV_SCRATCH_8 0x29c8
+#define P_VDEC2_AV_SCRATCH_8            DOS_REG_ADDR(VDEC2_AV_SCRATCH_8)
+#define VDEC2_AV_SCRATCH_9 0x29c9
+#define P_VDEC2_AV_SCRATCH_9            DOS_REG_ADDR(VDEC2_AV_SCRATCH_9)
+#define VDEC2_AV_SCRATCH_A 0x29ca
+#define P_VDEC2_AV_SCRATCH_A            DOS_REG_ADDR(VDEC2_AV_SCRATCH_A)
+#define VDEC2_AV_SCRATCH_B 0x29cb
+#define P_VDEC2_AV_SCRATCH_B            DOS_REG_ADDR(VDEC2_AV_SCRATCH_B)
+#define VDEC2_AV_SCRATCH_C 0x29cc
+#define P_VDEC2_AV_SCRATCH_C            DOS_REG_ADDR(VDEC2_AV_SCRATCH_C)
+#define VDEC2_AV_SCRATCH_D 0x29cd
+#define P_VDEC2_AV_SCRATCH_D            DOS_REG_ADDR(VDEC2_AV_SCRATCH_D)
+#define VDEC2_AV_SCRATCH_E 0x29ce
+#define P_VDEC2_AV_SCRATCH_E            DOS_REG_ADDR(VDEC2_AV_SCRATCH_E)
+#define VDEC2_AV_SCRATCH_F 0x29cf
+#define P_VDEC2_AV_SCRATCH_F            DOS_REG_ADDR(VDEC2_AV_SCRATCH_F)
+#define VDEC2_AV_SCRATCH_G 0x29d0
+#define P_VDEC2_AV_SCRATCH_G            DOS_REG_ADDR(VDEC2_AV_SCRATCH_G)
+#define VDEC2_AV_SCRATCH_H 0x29d1
+#define P_VDEC2_AV_SCRATCH_H            DOS_REG_ADDR(VDEC2_AV_SCRATCH_H)
+#define VDEC2_AV_SCRATCH_I 0x29d2
+#define P_VDEC2_AV_SCRATCH_I            DOS_REG_ADDR(VDEC2_AV_SCRATCH_I)
+#define VDEC2_AV_SCRATCH_J 0x29d3
+#define P_VDEC2_AV_SCRATCH_J            DOS_REG_ADDR(VDEC2_AV_SCRATCH_J)
+#define VDEC2_AV_SCRATCH_K 0x29d4
+#define P_VDEC2_AV_SCRATCH_K            DOS_REG_ADDR(VDEC2_AV_SCRATCH_K)
+#define VDEC2_AV_SCRATCH_L 0x29d5
+#define P_VDEC2_AV_SCRATCH_L            DOS_REG_ADDR(VDEC2_AV_SCRATCH_L)
+#define VDEC2_AV_SCRATCH_M 0x29d6
+#define P_VDEC2_AV_SCRATCH_M            DOS_REG_ADDR(VDEC2_AV_SCRATCH_M)
+#define VDEC2_AV_SCRATCH_N 0x29d7
+#define P_VDEC2_AV_SCRATCH_N            DOS_REG_ADDR(VDEC2_AV_SCRATCH_N)
+#define VDEC2_WRRSP_CO_MB 0x29d8
+#define P_VDEC2_WRRSP_CO_MB             DOS_REG_ADDR(VDEC2_WRRSP_CO_MB)
+#define VDEC2_WRRSP_DCAC 0x29d9
+#define P_VDEC2_WRRSP_DCAC              DOS_REG_ADDR(VDEC2_WRRSP_DCAC)
+/*add from M8M2*/
+/**/
+#define VDEC2_DBLK_RST 0x2950
+#define P_VDEC2_DBLK_RST                DOS_REG_ADDR(VDEC2_DBLK_RST)
+#define VDEC2_DBLK_CTRL 0x2951
+#define P_VDEC2_DBLK_CTRL               DOS_REG_ADDR(VDEC2_DBLK_CTRL)
+#define VDEC2_DBLK_MB_WID_HEIGHT 0x2952
+#define VDEC2_DBLK_STATUS 0x2953
+#define P_VDEC2_DBLK_STATUS             DOS_REG_ADDR(VDEC2_DBLK_STATUS)
+#define VDEC2_DBLK_CMD_CTRL 0x2954
+#define P_VDEC2_DBLK_CMD_CTRL           DOS_REG_ADDR(VDEC2_DBLK_CMD_CTRL)
+#define VDEC2_DBLK_MB_XY 0x2955
+#define P_VDEC2_DBLK_MB_XY              DOS_REG_ADDR(VDEC2_DBLK_MB_XY)
+#define VDEC2_DBLK_QP 0x2956
+#define P_VDEC2_DBLK_QP                 DOS_REG_ADDR(VDEC2_DBLK_QP)
+#define VDEC2_DBLK_Y_BHFILT 0x2957
+#define P_VDEC2_DBLK_Y_BHFILT           DOS_REG_ADDR(VDEC2_DBLK_Y_BHFILT)
+#define VDEC2_DBLK_Y_BHFILT_HIGH 0x2958
+#define VDEC2_DBLK_Y_BVFILT 0x2959
+#define P_VDEC2_DBLK_Y_BVFILT           DOS_REG_ADDR(VDEC2_DBLK_Y_BVFILT)
+#define VDEC2_DBLK_CB_BFILT 0x295a
+#define P_VDEC2_DBLK_CB_BFILT           DOS_REG_ADDR(VDEC2_DBLK_CB_BFILT)
+#define VDEC2_DBLK_CR_BFILT 0x295b
+#define P_VDEC2_DBLK_CR_BFILT           DOS_REG_ADDR(VDEC2_DBLK_CR_BFILT)
+#define VDEC2_DBLK_Y_HFILT 0x295c
+#define P_VDEC2_DBLK_Y_HFILT            DOS_REG_ADDR(VDEC2_DBLK_Y_HFILT)
+#define VDEC2_DBLK_Y_VFILT 0x295e
+#define P_VDEC2_DBLK_Y_VFILT            DOS_REG_ADDR(VDEC2_DBLK_Y_VFILT)
+#define VDEC2_DBLK_CB_FILT 0x295f
+#define P_VDEC2_DBLK_CB_FILT            DOS_REG_ADDR(VDEC2_DBLK_CB_FILT)
+#define VDEC2_DBLK_CR_FILT 0x2960
+#define P_VDEC2_DBLK_CR_FILT            DOS_REG_ADDR(VDEC2_DBLK_CR_FILT)
+#define VDEC2_DBLK_STATUS1 0x296b
+#define P_VDEC2_DBLK_STATUS1            DOS_REG_ADDR(VDEC2_DBLK_STATUS1)
+#define VDEC2_DBLK_GCLK_FREE 0x296c
+#define P_VDEC2_DBLK_GCLK_FREE          DOS_REG_ADDR(VDEC2_DBLK_GCLK_FREE)
+#define VDEC2_DBLK_GCLK_OFF 0x296d
+#define P_VDEC2_DBLK_GCLK_OFF           DOS_REG_ADDR(VDEC2_DBLK_GCLK_OFF)
+#define VDEC2_DBLK_AVSFLAGS 0x296e
+#define P_VDEC2_DBLK_AVSFLAGS           DOS_REG_ADDR(VDEC2_DBLK_AVSFLAGS)
+#define VDEC2_DBLK_CBPY 0x2970
+#define P_VDEC2_DBLK_CBPY               DOS_REG_ADDR(VDEC2_DBLK_CBPY)
+#define VDEC2_DBLK_CBPY_ADJ 0x2971
+#define P_VDEC2_DBLK_CBPY_ADJ           DOS_REG_ADDR(VDEC2_DBLK_CBPY_ADJ)
+#define VDEC2_DBLK_CBPC 0x2972
+#define P_VDEC2_DBLK_CBPC               DOS_REG_ADDR(VDEC2_DBLK_CBPC)
+#define VDEC2_DBLK_CBPC_ADJ 0x2973
+#define P_VDEC2_DBLK_CBPC_ADJ           DOS_REG_ADDR(VDEC2_DBLK_CBPC_ADJ)
+#define VDEC2_DBLK_VHMVD 0x2974
+#define P_VDEC2_DBLK_VHMVD              DOS_REG_ADDR(VDEC2_DBLK_VHMVD)
+#define VDEC2_DBLK_STRONG 0x2975
+#define P_VDEC2_DBLK_STRONG             DOS_REG_ADDR(VDEC2_DBLK_STRONG)
+#define VDEC2_DBLK_RV8_QUANT 0x2976
+#define P_VDEC2_DBLK_RV8_QUANT          DOS_REG_ADDR(VDEC2_DBLK_RV8_QUANT)
+#define VDEC2_DBLK_CBUS_HCMD2 0x2977
+#define VDEC2_DBLK_VLD_HCMD2 0x297a
+#define P_VDEC2_DBLK_VLD_HCMD2          DOS_REG_ADDR(VDEC2_DBLK_VLD_HCMD2)
+#define VDEC2_DBLK_VLD_HCMD1 0x297b
+#define P_VDEC2_DBLK_VLD_HCMD1          DOS_REG_ADDR(VDEC2_DBLK_VLD_HCMD1)
+#define VDEC2_DBLK_VLD_HCMD0 0x297c
+#define P_VDEC2_DBLK_VLD_HCMD0          DOS_REG_ADDR(VDEC2_DBLK_VLD_HCMD0)
+#define VDEC2_MCRCC_CTL1 0x2980
+#define P_VDEC2_MCRCC_CTL1              DOS_REG_ADDR(VDEC2_MCRCC_CTL1)
+#define VDEC2_MCRCC_CTL2 0x2981
+#define P_VDEC2_MCRCC_CTL2              DOS_REG_ADDR(VDEC2_MCRCC_CTL2)
+#define VDEC2_MCRCC_CTL3 0x2982
+#define P_VDEC2_MCRCC_CTL3              DOS_REG_ADDR(VDEC2_MCRCC_CTL3)
+#define VDEC2_GCLK_EN 0x2983
+#define P_VDEC2_GCLK_EN                 DOS_REG_ADDR(VDEC2_GCLK_EN)
+#define VDEC2_MDEC_SW_RESET 0x2984
+#define P_VDEC2_MDEC_SW_RESET           DOS_REG_ADDR(VDEC2_MDEC_SW_RESET)
+/*add from M8M2*/
+#define HEVC_MC_CTRL_REG 0x3900
+#define P_HEVC_MC_CTRL_REG              DOS_REG_ADDR(HEVC_MC_CTRL_REG)
+#define HEVC_MC_MB_INFO 0x3901
+#define P_HEVC_MC_MB_INFO               DOS_REG_ADDR(HEVC_MC_MB_INFO)
+#define HEVC_MC_PIC_INFO 0x3902
+#define P_HEVC_MC_PIC_INFO              DOS_REG_ADDR(HEVC_MC_PIC_INFO)
+#define HEVC_MC_HALF_PEL_ONE 0x3903
+#define P_HEVC_MC_HALF_PEL_ONE          DOS_REG_ADDR(HEVC_MC_HALF_PEL_ONE)
+#define HEVC_MC_HALF_PEL_TWO 0x3904
+#define P_HEVC_MC_HALF_PEL_TWO          DOS_REG_ADDR(HEVC_MC_HALF_PEL_TWO)
+#define HEVC_POWER_CTL_MC 0x3905
+#define P_HEVC_POWER_CTL_MC             DOS_REG_ADDR(HEVC_POWER_CTL_MC)
+#define HEVC_MC_CMD 0x3906
+#define P_HEVC_MC_CMD           DOS_REG_ADDR(HEVC_MC_CMD)
+#define HEVC_MC_CTRL0 0x3907
+#define P_HEVC_MC_CTRL0                 DOS_REG_ADDR(HEVC_MC_CTRL0)
+#define HEVC_MC_PIC_W_H 0x3908
+#define P_HEVC_MC_PIC_W_H               DOS_REG_ADDR(HEVC_MC_PIC_W_H)
+#define HEVC_MC_STATUS0 0x3909
+#define P_HEVC_MC_STATUS0               DOS_REG_ADDR(HEVC_MC_STATUS0)
+#define HEVC_MC_STATUS1 0x390a
+#define P_HEVC_MC_STATUS1               DOS_REG_ADDR(HEVC_MC_STATUS1)
+#define HEVC_MC_CTRL1 0x390b
+#define P_HEVC_MC_CTRL1                 DOS_REG_ADDR(HEVC_MC_CTRL1)
+#define HEVC_MC_MIX_RATIO0 0x390c
+#define P_HEVC_MC_MIX_RATIO0            DOS_REG_ADDR(HEVC_MC_MIX_RATIO0)
+#define HEVC_MC_MIX_RATIO1 0x390d
+#define P_HEVC_MC_MIX_RATIO1            DOS_REG_ADDR(HEVC_MC_MIX_RATIO1)
+#define HEVC_MC_DP_MB_XY 0x390e
+#define P_HEVC_MC_DP_MB_XY              DOS_REG_ADDR(HEVC_MC_DP_MB_XY)
+#define HEVC_MC_OM_MB_XY 0x390f
+#define P_HEVC_MC_OM_MB_XY              DOS_REG_ADDR(HEVC_MC_OM_MB_XY)
+#define HEVC_PSCALE_RST 0x3910
+#define P_HEVC_PSCALE_RST               DOS_REG_ADDR(HEVC_PSCALE_RST)
+#define HEVC_PSCALE_CTRL 0x3911
+#define P_HEVC_PSCALE_CTRL              DOS_REG_ADDR(HEVC_PSCALE_CTRL)
+#define HEVC_PSCALE_PICI_W 0x3912
+#define P_HEVC_PSCALE_PICI_W            DOS_REG_ADDR(HEVC_PSCALE_PICI_W)
+#define HEVC_PSCALE_PICI_H 0x3913
+#define P_HEVC_PSCALE_PICI_H            DOS_REG_ADDR(HEVC_PSCALE_PICI_H)
+#define HEVC_PSCALE_PICO_W 0x3914
+#define P_HEVC_PSCALE_PICO_W            DOS_REG_ADDR(HEVC_PSCALE_PICO_W)
+#define HEVC_PSCALE_PICO_H 0x3915
+#define P_HEVC_PSCALE_PICO_H            DOS_REG_ADDR(HEVC_PSCALE_PICO_H)
+
+#define HEVC_MC_DPDN_MB_XY 0x3946
+#define P_HEVC_MC_DPDN_MB_XY            DOS_REG_ADDR(HEVC_MC_DPDN_MB_XY)
+#define HEVC_MC_OMDN_MB_XY 0x3947
+#define P_HEVC_MC_OMDN_MB_XY            DOS_REG_ADDR(HEVC_MC_OMDN_MB_XY)
+#define HEVC_MC_HCMDBUF_H 0x3948
+#define P_HEVC_MC_HCMDBUF_H             DOS_REG_ADDR(HEVC_MC_HCMDBUF_H)
+#define HEVC_MC_HCMDBUF_L 0x3949
+#define P_HEVC_MC_HCMDBUF_L             DOS_REG_ADDR(HEVC_MC_HCMDBUF_L)
+#define HEVC_MC_HCMD_H 0x394a
+#define P_HEVC_MC_HCMD_H                DOS_REG_ADDR(HEVC_MC_HCMD_H)
+#define HEVC_MC_HCMD_L 0x394b
+#define P_HEVC_MC_HCMD_L                DOS_REG_ADDR(HEVC_MC_HCMD_L)
+#define HEVC_MC_IDCT_DAT 0x394c
+#define P_HEVC_MC_IDCT_DAT              DOS_REG_ADDR(HEVC_MC_IDCT_DAT)
+#define HEVC_MC_OTHER_GCLK_CTRL 0x394e
+
+#define HEVC_AV_SCRATCH_0 0x39c0
+#define P_HEVC_AV_SCRATCH_0             DOS_REG_ADDR(HEVC_AV_SCRATCH_0)
+#define HEVC_AV_SCRATCH_1 0x39c1
+#define P_HEVC_AV_SCRATCH_1             DOS_REG_ADDR(HEVC_AV_SCRATCH_1)
+#define HEVC_AV_SCRATCH_2 0x39c2
+#define P_HEVC_AV_SCRATCH_2             DOS_REG_ADDR(HEVC_AV_SCRATCH_2)
+#define HEVC_AV_SCRATCH_3 0x39c3
+#define P_HEVC_AV_SCRATCH_3             DOS_REG_ADDR(HEVC_AV_SCRATCH_3)
+#define HEVC_AV_SCRATCH_4 0x39c4
+#define P_HEVC_AV_SCRATCH_4             DOS_REG_ADDR(HEVC_AV_SCRATCH_4)
+#define HEVC_AV_SCRATCH_5 0x39c5
+#define P_HEVC_AV_SCRATCH_5             DOS_REG_ADDR(HEVC_AV_SCRATCH_5)
+#define HEVC_AV_SCRATCH_6 0x39c6
+#define P_HEVC_AV_SCRATCH_6             DOS_REG_ADDR(HEVC_AV_SCRATCH_6)
+#define HEVC_AV_SCRATCH_7 0x39c7
+#define P_HEVC_AV_SCRATCH_7             DOS_REG_ADDR(HEVC_AV_SCRATCH_7)
+#define HEVC_AV_SCRATCH_8 0x39c8
+#define P_HEVC_AV_SCRATCH_8             DOS_REG_ADDR(HEVC_AV_SCRATCH_8)
+#define HEVC_AV_SCRATCH_9 0x39c9
+#define P_HEVC_AV_SCRATCH_9             DOS_REG_ADDR(HEVC_AV_SCRATCH_9)
+#define HEVC_AV_SCRATCH_A 0x39ca
+#define P_HEVC_AV_SCRATCH_A             DOS_REG_ADDR(HEVC_AV_SCRATCH_A)
+#define HEVC_AV_SCRATCH_B 0x39cb
+#define P_HEVC_AV_SCRATCH_B             DOS_REG_ADDR(HEVC_AV_SCRATCH_B)
+#define HEVC_AV_SCRATCH_C 0x39cc
+#define P_HEVC_AV_SCRATCH_C             DOS_REG_ADDR(HEVC_AV_SCRATCH_C)
+#define HEVC_AV_SCRATCH_D 0x39cd
+#define P_HEVC_AV_SCRATCH_D             DOS_REG_ADDR(HEVC_AV_SCRATCH_D)
+#define HEVC_AV_SCRATCH_E 0x39ce
+#define P_HEVC_AV_SCRATCH_E             DOS_REG_ADDR(HEVC_AV_SCRATCH_E)
+#define HEVC_AV_SCRATCH_F 0x39cf
+#define P_HEVC_AV_SCRATCH_F             DOS_REG_ADDR(HEVC_AV_SCRATCH_F)
+#define HEVC_AV_SCRATCH_G 0x39d0
+#define P_HEVC_AV_SCRATCH_G             DOS_REG_ADDR(HEVC_AV_SCRATCH_G)
+#define HEVC_AV_SCRATCH_H 0x39d1
+#define P_HEVC_AV_SCRATCH_H             DOS_REG_ADDR(HEVC_AV_SCRATCH_H)
+#define HEVC_AV_SCRATCH_I 0x39d2
+#define P_HEVC_AV_SCRATCH_I             DOS_REG_ADDR(HEVC_AV_SCRATCH_I)
+#define HEVC_AV_SCRATCH_J 0x39d3
+#define P_HEVC_AV_SCRATCH_J             DOS_REG_ADDR(HEVC_AV_SCRATCH_J)
+#define HEVC_AV_SCRATCH_K 0x39d4
+#define P_HEVC_AV_SCRATCH_K             DOS_REG_ADDR(HEVC_AV_SCRATCH_K)
+#define HEVC_AV_SCRATCH_L 0x39d5
+#define P_HEVC_AV_SCRATCH_L             DOS_REG_ADDR(HEVC_AV_SCRATCH_L)
+#define HEVC_AV_SCRATCH_M 0x39d6
+#define P_HEVC_AV_SCRATCH_M             DOS_REG_ADDR(HEVC_AV_SCRATCH_M)
+#define HEVC_AV_SCRATCH_N 0x39d7
+#define P_HEVC_AV_SCRATCH_N             DOS_REG_ADDR(HEVC_AV_SCRATCH_N)
+#define HEVC_WRRSP_CO_MB 0x39d8
+#define P_HEVC_WRRSP_CO_MB              DOS_REG_ADDR(HEVC_WRRSP_CO_MB)
+
+#define HEVC_DBLK_RST 0x3950
+#define P_HEVC_DBLK_RST                 DOS_REG_ADDR(HEVC_DBLK_RST)
+#define HEVC_DBLK_CTRL 0x3951
+#define P_HEVC_DBLK_CTRL                DOS_REG_ADDR(HEVC_DBLK_CTRL)
+#define HEVC_DBLK_MB_WID_HEIGHT 0x3952
+#define HEVC_DBLK_STATUS 0x3953
+#define P_HEVC_DBLK_STATUS              DOS_REG_ADDR(HEVC_DBLK_STATUS)
+#define HEVC_DBLK_CMD_CTRL 0x3954
+#define P_HEVC_DBLK_CMD_CTRL            DOS_REG_ADDR(HEVC_DBLK_CMD_CTRL)
+#define HEVC_DBLK_MB_XY 0x3955
+#define P_HEVC_DBLK_MB_XY               DOS_REG_ADDR(HEVC_DBLK_MB_XY)
+#define HEVC_DBLK_QP 0x3956
+#define P_HEVC_DBLK_QP          DOS_REG_ADDR(HEVC_DBLK_QP)
+#define HEVC_DBLK_Y_BHFILT 0x3957
+#define P_HEVC_DBLK_Y_BHFILT            DOS_REG_ADDR(HEVC_DBLK_Y_BHFILT)
+#define HEVC_DBLK_Y_BVFILT 0x3959
+#define P_HEVC_DBLK_Y_BVFILT            DOS_REG_ADDR(HEVC_DBLK_Y_BVFILT)
+#define HEVC_DBLK_CB_BFILT 0x395a
+#define P_HEVC_DBLK_CB_BFILT            DOS_REG_ADDR(HEVC_DBLK_CB_BFILT)
+#define HEVC_DBLK_CR_BFILT 0x395b
+#define P_HEVC_DBLK_CR_BFILT            DOS_REG_ADDR(HEVC_DBLK_CR_BFILT)
+#define HEVC_DBLK_Y_HFILT 0x395c
+#define P_HEVC_DBLK_Y_HFILT             DOS_REG_ADDR(HEVC_DBLK_Y_HFILT)
+#define HEVC_DBLK_Y_VFILT 0x395e
+#define P_HEVC_DBLK_Y_VFILT             DOS_REG_ADDR(HEVC_DBLK_Y_VFILT)
+#define HEVC_DBLK_CB_FILT 0x395f
+#define P_HEVC_DBLK_CB_FILT             DOS_REG_ADDR(HEVC_DBLK_CB_FILT)
+#define HEVC_DBLK_CR_FILT 0x3960
+#define P_HEVC_DBLK_CR_FILT             DOS_REG_ADDR(HEVC_DBLK_CR_FILT)
+#define HEVC_DBLK_CLIP_CTRL0 0x3962
+#define P_HEVC_DBLK_CLIP_CTRL0          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL0)
+#define HEVC_DBLK_CLIP_CTRL1 0x3963
+#define P_HEVC_DBLK_CLIP_CTRL1          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL1)
+#define HEVC_DBLK_CLIP_CTRL2 0x3964
+#define P_HEVC_DBLK_CLIP_CTRL2          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL2)
+#define HEVC_DBLK_CLIP_CTRL3 0x3965
+#define P_HEVC_DBLK_CLIP_CTRL3          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL3)
+#define HEVC_DBLK_CLIP_CTRL4 0x3966
+#define P_HEVC_DBLK_CLIP_CTRL4          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL4)
+#define HEVC_DBLK_CLIP_CTRL5 0x3967
+#define P_HEVC_DBLK_CLIP_CTRL5          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL5)
+#define HEVC_DBLK_CLIP_CTRL6 0x3968
+#define P_HEVC_DBLK_CLIP_CTRL6          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL6)
+#define HEVC_DBLK_CLIP_CTRL7 0x3969
+#define P_HEVC_DBLK_CLIP_CTRL7          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL7)
+#define HEVC_DBLK_CLIP_CTRL8 0x396a
+#define P_HEVC_DBLK_CLIP_CTRL8          DOS_REG_ADDR(HEVC_DBLK_CLIP_CTRL8)
+#define HEVC_DBLK_STATUS1 0x396b
+#define P_HEVC_DBLK_STATUS1             DOS_REG_ADDR(HEVC_DBLK_STATUS1)
+#define HEVC_DBLK_GCLK_FREE 0x396c
+#define P_HEVC_DBLK_GCLK_FREE           DOS_REG_ADDR(HEVC_DBLK_GCLK_FREE)
+#define HEVC_DBLK_GCLK_OFF 0x396d
+#define P_HEVC_DBLK_GCLK_OFF            DOS_REG_ADDR(HEVC_DBLK_GCLK_OFF)
+#define HEVC_DBLK_AVSFLAGS 0x396e
+#define P_HEVC_DBLK_AVSFLAGS            DOS_REG_ADDR(HEVC_DBLK_AVSFLAGS)
+#define HEVC_DBLK_CBPY 0x3970
+#define P_HEVC_DBLK_CBPY                DOS_REG_ADDR(HEVC_DBLK_CBPY)
+#define HEVC_DBLK_CBPY_ADJ 0x3971
+#define P_HEVC_DBLK_CBPY_ADJ            DOS_REG_ADDR(HEVC_DBLK_CBPY_ADJ)
+#define HEVC_DBLK_CBPC 0x3972
+#define P_HEVC_DBLK_CBPC                DOS_REG_ADDR(HEVC_DBLK_CBPC)
+#define HEVC_DBLK_CBPC_ADJ 0x3973
+#define P_HEVC_DBLK_CBPC_ADJ            DOS_REG_ADDR(HEVC_DBLK_CBPC_ADJ)
+#define HEVC_DBLK_VHMVD 0x3974
+#define P_HEVC_DBLK_VHMVD               DOS_REG_ADDR(HEVC_DBLK_VHMVD)
+#define HEVC_DBLK_STRONG 0x3975
+#define P_HEVC_DBLK_STRONG              DOS_REG_ADDR(HEVC_DBLK_STRONG)
+#define HEVC_DBLK_RV8_QUANT 0x3976
+#define P_HEVC_DBLK_RV8_QUANT           DOS_REG_ADDR(HEVC_DBLK_RV8_QUANT)
+#define HEVC_DBLK_CBUS_HCMD2 0x3977
+#define P_HEVC_DBLK_CBUS_HCMD2          DOS_REG_ADDR(HEVC_DBLK_CBUS_HCMD2)
+#define HEVC_DBLK_CBUS_HCMD1 0x3978
+#define P_HEVC_DBLK_CBUS_HCMD1          DOS_REG_ADDR(HEVC_DBLK_CBUS_HCMD1)
+#define HEVC_DBLK_CBUS_HCMD0 0x3979
+#define P_HEVC_DBLK_CBUS_HCMD0          DOS_REG_ADDR(HEVC_DBLK_CBUS_HCMD0)
+#define HEVC_DBLK_VLD_HCMD2 0x397a
+#define P_HEVC_DBLK_VLD_HCMD2           DOS_REG_ADDR(HEVC_DBLK_VLD_HCMD2)
+#define HEVC_DBLK_VLD_HCMD1 0x397b
+#define P_HEVC_DBLK_VLD_HCMD1           DOS_REG_ADDR(HEVC_DBLK_VLD_HCMD1)
+#define HEVC_DBLK_VLD_HCMD0 0x397c
+#define P_HEVC_DBLK_VLD_HCMD0           DOS_REG_ADDR(HEVC_DBLK_VLD_HCMD0)
+#define HEVC_DBLK_OST_YBASE 0x397d
+#define P_HEVC_DBLK_OST_YBASE           DOS_REG_ADDR(HEVC_DBLK_OST_YBASE)
+#define HEVC_DBLK_CTRL1 0x397f
+#define P_HEVC_DBLK_CTRL1               DOS_REG_ADDR(HEVC_DBLK_CTRL1)
+#define HEVC_MCRCC_CTL1 0x3980
+#define P_HEVC_MCRCC_CTL1               DOS_REG_ADDR(HEVC_MCRCC_CTL1)
+#define HEVC_MCRCC_CTL2 0x3981
+#define P_HEVC_MCRCC_CTL2               DOS_REG_ADDR(HEVC_MCRCC_CTL2)
+#define HEVC_MCRCC_CTL3 0x3982
+#define P_HEVC_MCRCC_CTL3               DOS_REG_ADDR(HEVC_MCRCC_CTL3)
+#define HEVC_GCLK_EN 0x3983
+#define P_HEVC_GCLK_EN          DOS_REG_ADDR(HEVC_GCLK_EN)
+#define HEVC_MDEC_SW_RESET 0x3984
+#define P_HEVC_MDEC_SW_RESET            DOS_REG_ADDR(HEVC_MDEC_SW_RESET)
+/**/
+#define HEVC_DCAC_CPU_DATA 0x3e15
+#define P_HEVC_DCAC_CPU_DATA            DOS_REG_ADDR(HEVC_DCAC_CPU_DATA)
+#define HEVC_DCAC_MB_COUNT 0x3e16
+#define P_HEVC_DCAC_MB_COUNT            DOS_REG_ADDR(HEVC_DCAC_MB_COUNT)
+#define HEVC_IQ_QUANT 0x3e17
+#define P_HEVC_IQ_QUANT                 DOS_REG_ADDR(HEVC_IQ_QUANT)
+/**/
+#define HCODEC_MSP 0x1300
+#define P_HCODEC_MSP            DOS_REG_ADDR(HCODEC_MSP)
+#define HCODEC_MPSR 0x1301
+#define P_HCODEC_MPSR           DOS_REG_ADDR(HCODEC_MPSR)
+#define HCODEC_MINT_VEC_BASE 0x1302
+#define P_HCODEC_MINT_VEC_BASE          DOS_REG_ADDR(HCODEC_MINT_VEC_BASE)
+#define HCODEC_MCPU_INTR_GRP 0x1303
+#define P_HCODEC_MCPU_INTR_GRP          DOS_REG_ADDR(HCODEC_MCPU_INTR_GRP)
+#define HCODEC_MCPU_INTR_MSK 0x1304
+#define P_HCODEC_MCPU_INTR_MSK          DOS_REG_ADDR(HCODEC_MCPU_INTR_MSK)
+#define HCODEC_MCPU_INTR_REQ 0x1305
+#define P_HCODEC_MCPU_INTR_REQ          DOS_REG_ADDR(HCODEC_MCPU_INTR_REQ)
+#define HCODEC_MPC_P 0x1306
+#define P_HCODEC_MPC_P          DOS_REG_ADDR(HCODEC_MPC_P)
+#define HCODEC_MPC_D 0x1307
+#define P_HCODEC_MPC_D          DOS_REG_ADDR(HCODEC_MPC_D)
+#define HCODEC_MPC_E 0x1308
+#define P_HCODEC_MPC_E          DOS_REG_ADDR(HCODEC_MPC_E)
+#define HCODEC_MPC_W 0x1309
+#define P_HCODEC_MPC_W          DOS_REG_ADDR(HCODEC_MPC_W)
+#define HCODEC_MINDEX0_REG 0x130a
+#define P_HCODEC_MINDEX0_REG            DOS_REG_ADDR(HCODEC_MINDEX0_REG)
+#define HCODEC_MINDEX1_REG 0x130b
+#define P_HCODEC_MINDEX1_REG            DOS_REG_ADDR(HCODEC_MINDEX1_REG)
+#define HCODEC_MINDEX2_REG 0x130c
+#define P_HCODEC_MINDEX2_REG            DOS_REG_ADDR(HCODEC_MINDEX2_REG)
+#define HCODEC_MINDEX3_REG 0x130d
+#define P_HCODEC_MINDEX3_REG            DOS_REG_ADDR(HCODEC_MINDEX3_REG)
+#define HCODEC_MINDEX4_REG 0x130e
+#define P_HCODEC_MINDEX4_REG            DOS_REG_ADDR(HCODEC_MINDEX4_REG)
+#define HCODEC_MINDEX5_REG 0x130f
+#define P_HCODEC_MINDEX5_REG            DOS_REG_ADDR(HCODEC_MINDEX5_REG)
+#define HCODEC_MINDEX6_REG 0x1310
+#define P_HCODEC_MINDEX6_REG            DOS_REG_ADDR(HCODEC_MINDEX6_REG)
+#define HCODEC_MINDEX7_REG 0x1311
+#define P_HCODEC_MINDEX7_REG            DOS_REG_ADDR(HCODEC_MINDEX7_REG)
+#define HCODEC_MMIN_REG 0x1312
+#define P_HCODEC_MMIN_REG               DOS_REG_ADDR(HCODEC_MMIN_REG)
+#define HCODEC_MMAX_REG 0x1313
+#define P_HCODEC_MMAX_REG               DOS_REG_ADDR(HCODEC_MMAX_REG)
+#define HCODEC_MBREAK0_REG 0x1314
+#define P_HCODEC_MBREAK0_REG            DOS_REG_ADDR(HCODEC_MBREAK0_REG)
+#define HCODEC_MBREAK1_REG 0x1315
+#define P_HCODEC_MBREAK1_REG            DOS_REG_ADDR(HCODEC_MBREAK1_REG)
+#define HCODEC_MBREAK2_REG 0x1316
+#define P_HCODEC_MBREAK2_REG            DOS_REG_ADDR(HCODEC_MBREAK2_REG)
+#define HCODEC_MBREAK3_REG 0x1317
+#define P_HCODEC_MBREAK3_REG            DOS_REG_ADDR(HCODEC_MBREAK3_REG)
+#define HCODEC_MBREAK_TYPE 0x1318
+#define P_HCODEC_MBREAK_TYPE            DOS_REG_ADDR(HCODEC_MBREAK_TYPE)
+#define HCODEC_MBREAK_CTRL 0x1319
+#define P_HCODEC_MBREAK_CTRL            DOS_REG_ADDR(HCODEC_MBREAK_CTRL)
+#define HCODEC_MBREAK_STAUTS 0x131a
+#define P_HCODEC_MBREAK_STAUTS          DOS_REG_ADDR(HCODEC_MBREAK_STAUTS)
+#define HCODEC_MDB_ADDR_REG 0x131b
+#define P_HCODEC_MDB_ADDR_REG           DOS_REG_ADDR(HCODEC_MDB_ADDR_REG)
+#define HCODEC_MDB_DATA_REG 0x131c
+#define P_HCODEC_MDB_DATA_REG           DOS_REG_ADDR(HCODEC_MDB_DATA_REG)
+#define HCODEC_MDB_CTRL 0x131d
+#define P_HCODEC_MDB_CTRL               DOS_REG_ADDR(HCODEC_MDB_CTRL)
+#define HCODEC_MSFTINT0 0x131e
+#define P_HCODEC_MSFTINT0               DOS_REG_ADDR(HCODEC_MSFTINT0)
+#define HCODEC_MSFTINT1 0x131f
+#define P_HCODEC_MSFTINT1               DOS_REG_ADDR(HCODEC_MSFTINT1)
+#define HCODEC_CSP 0x1320
+#define P_HCODEC_CSP            DOS_REG_ADDR(HCODEC_CSP)
+#define HCODEC_CPSR 0x1321
+#define P_HCODEC_CPSR           DOS_REG_ADDR(HCODEC_CPSR)
+#define HCODEC_CINT_VEC_BASE 0x1322
+#define P_HCODEC_CINT_VEC_BASE          DOS_REG_ADDR(HCODEC_CINT_VEC_BASE)
+#define HCODEC_CCPU_INTR_GRP 0x1323
+#define P_HCODEC_CCPU_INTR_GRP          DOS_REG_ADDR(HCODEC_CCPU_INTR_GRP)
+#define HCODEC_CCPU_INTR_MSK 0x1324
+#define P_HCODEC_CCPU_INTR_MSK          DOS_REG_ADDR(HCODEC_CCPU_INTR_MSK)
+#define HCODEC_CCPU_INTR_REQ 0x1325
+#define P_HCODEC_CCPU_INTR_REQ          DOS_REG_ADDR(HCODEC_CCPU_INTR_REQ)
+#define HCODEC_CPC_P 0x1326
+#define P_HCODEC_CPC_P          DOS_REG_ADDR(HCODEC_CPC_P)
+#define HCODEC_CPC_D 0x1327
+#define P_HCODEC_CPC_D          DOS_REG_ADDR(HCODEC_CPC_D)
+#define HCODEC_CPC_E 0x1328
+#define P_HCODEC_CPC_E          DOS_REG_ADDR(HCODEC_CPC_E)
+#define HCODEC_CPC_W 0x1329
+#define P_HCODEC_CPC_W          DOS_REG_ADDR(HCODEC_CPC_W)
+#define HCODEC_CINDEX0_REG 0x132a
+#define P_HCODEC_CINDEX0_REG            DOS_REG_ADDR(HCODEC_CINDEX0_REG)
+#define HCODEC_CINDEX1_REG 0x132b
+#define P_HCODEC_CINDEX1_REG            DOS_REG_ADDR(HCODEC_CINDEX1_REG)
+#define HCODEC_CINDEX2_REG 0x132c
+#define P_HCODEC_CINDEX2_REG            DOS_REG_ADDR(HCODEC_CINDEX2_REG)
+#define HCODEC_CINDEX3_REG 0x132d
+#define P_HCODEC_CINDEX3_REG            DOS_REG_ADDR(HCODEC_CINDEX3_REG)
+#define HCODEC_CINDEX4_REG 0x132e
+#define P_HCODEC_CINDEX4_REG            DOS_REG_ADDR(HCODEC_CINDEX4_REG)
+#define HCODEC_CINDEX5_REG 0x132f
+#define P_HCODEC_CINDEX5_REG            DOS_REG_ADDR(HCODEC_CINDEX5_REG)
+#define HCODEC_CINDEX6_REG 0x1330
+#define P_HCODEC_CINDEX6_REG            DOS_REG_ADDR(HCODEC_CINDEX6_REG)
+#define HCODEC_CINDEX7_REG 0x1331
+#define P_HCODEC_CINDEX7_REG            DOS_REG_ADDR(HCODEC_CINDEX7_REG)
+#define HCODEC_CMIN_REG 0x1332
+#define P_HCODEC_CMIN_REG               DOS_REG_ADDR(HCODEC_CMIN_REG)
+#define HCODEC_CMAX_REG 0x1333
+#define P_HCODEC_CMAX_REG               DOS_REG_ADDR(HCODEC_CMAX_REG)
+#define HCODEC_CBREAK0_REG 0x1334
+#define P_HCODEC_CBREAK0_REG            DOS_REG_ADDR(HCODEC_CBREAK0_REG)
+#define HCODEC_CBREAK1_REG 0x1335
+#define P_HCODEC_CBREAK1_REG            DOS_REG_ADDR(HCODEC_CBREAK1_REG)
+#define HCODEC_CBREAK2_REG 0x1336
+#define P_HCODEC_CBREAK2_REG            DOS_REG_ADDR(HCODEC_CBREAK2_REG)
+#define HCODEC_CBREAK3_REG 0x1337
+#define P_HCODEC_CBREAK3_REG            DOS_REG_ADDR(HCODEC_CBREAK3_REG)
+#define HCODEC_CBREAK_TYPE 0x1338
+#define P_HCODEC_CBREAK_TYPE            DOS_REG_ADDR(HCODEC_CBREAK_TYPE)
+#define HCODEC_CBREAK_CTRL 0x1339
+#define P_HCODEC_CBREAK_CTRL            DOS_REG_ADDR(HCODEC_CBREAK_CTRL)
+#define HCODEC_CBREAK_STAUTS 0x133a
+#define P_HCODEC_CBREAK_STAUTS          DOS_REG_ADDR(HCODEC_CBREAK_STAUTS)
+#define HCODEC_CDB_ADDR_REG 0x133b
+#define P_HCODEC_CDB_ADDR_REG           DOS_REG_ADDR(HCODEC_CDB_ADDR_REG)
+#define HCODEC_CDB_DATA_REG 0x133c
+#define P_HCODEC_CDB_DATA_REG           DOS_REG_ADDR(HCODEC_CDB_DATA_REG)
+#define HCODEC_CDB_CTRL 0x133d
+#define P_HCODEC_CDB_CTRL               DOS_REG_ADDR(HCODEC_CDB_CTRL)
+#define HCODEC_CSFTINT0 0x133e
+#define P_HCODEC_CSFTINT0               DOS_REG_ADDR(HCODEC_CSFTINT0)
+#define HCODEC_CSFTINT1 0x133f
+#define P_HCODEC_CSFTINT1               DOS_REG_ADDR(HCODEC_CSFTINT1)
+#define HCODEC_IMEM_DMA_CTRL 0x1340
+#define P_HCODEC_IMEM_DMA_CTRL          DOS_REG_ADDR(HCODEC_IMEM_DMA_CTRL)
+#define HCODEC_IMEM_DMA_ADR 0x1341
+#define P_HCODEC_IMEM_DMA_ADR           DOS_REG_ADDR(HCODEC_IMEM_DMA_ADR)
+#define HCODEC_WRRSP_IMEM 0x1343
+#define P_HCODEC_WRRSP_IMEM             DOS_REG_ADDR(HCODEC_WRRSP_IMEM)
+#define HCODEC_LMEM_DMA_CTRL 0x1350
+#define P_HCODEC_LMEM_DMA_CTRL          DOS_REG_ADDR(HCODEC_LMEM_DMA_CTRL)
+#define HCODEC_LMEM_DMA_ADR 0x1351
+#define P_HCODEC_LMEM_DMA_ADR           DOS_REG_ADDR(HCODEC_LMEM_DMA_ADR)
+#define HCODEC_WRRSP_LMEM 0x1353
+#define P_HCODEC_WRRSP_LMEM             DOS_REG_ADDR(HCODEC_WRRSP_LMEM)
+#define HCODEC_MAC_CTRL1 0x1360
+#define P_HCODEC_MAC_CTRL1              DOS_REG_ADDR(HCODEC_MAC_CTRL1)
+#define HCODEC_ACC0REG1 0x1361
+#define P_HCODEC_ACC0REG1               DOS_REG_ADDR(HCODEC_ACC0REG1)
+#define HCODEC_ACC1REG1 0x1362
+#define P_HCODEC_ACC1REG1               DOS_REG_ADDR(HCODEC_ACC1REG1)
+#define HCODEC_MAC_CTRL2 0x1370
+#define P_HCODEC_MAC_CTRL2              DOS_REG_ADDR(HCODEC_MAC_CTRL2)
+#define HCODEC_ACC0REG2 0x1371
+#define P_HCODEC_ACC0REG2               DOS_REG_ADDR(HCODEC_ACC0REG2)
+#define HCODEC_ACC1REG2 0x1372
+#define P_HCODEC_ACC1REG2               DOS_REG_ADDR(HCODEC_ACC1REG2)
+#define HCODEC_CPU_TRACE 0x1380
+#define P_HCODEC_CPU_TRACE              DOS_REG_ADDR(HCODEC_CPU_TRACE)
+#define VDEC2_MSP 0x2300
+#define P_VDEC2_MSP             DOS_REG_ADDR(VDEC2_MSP)
+#define VDEC2_MPSR 0x2301
+#define P_VDEC2_MPSR            DOS_REG_ADDR(VDEC2_MPSR)
+#define VDEC2_MINT_VEC_BASE 0x2302
+#define P_VDEC2_MINT_VEC_BASE           DOS_REG_ADDR(VDEC2_MINT_VEC_BASE)
+#define VDEC2_MCPU_INTR_GRP 0x2303
+#define P_VDEC2_MCPU_INTR_GRP           DOS_REG_ADDR(VDEC2_MCPU_INTR_GRP)
+#define VDEC2_MCPU_INTR_MSK 0x2304
+#define P_VDEC2_MCPU_INTR_MSK           DOS_REG_ADDR(VDEC2_MCPU_INTR_MSK)
+#define VDEC2_MCPU_INTR_REQ 0x2305
+#define P_VDEC2_MCPU_INTR_REQ           DOS_REG_ADDR(VDEC2_MCPU_INTR_REQ)
+#define VDEC2_MPC_P 0x2306
+#define P_VDEC2_MPC_P           DOS_REG_ADDR(VDEC2_MPC_P)
+#define VDEC2_MPC_D 0x2307
+#define P_VDEC2_MPC_D           DOS_REG_ADDR(VDEC2_MPC_D)
+#define VDEC2_MPC_E 0x2308
+#define P_VDEC2_MPC_E           DOS_REG_ADDR(VDEC2_MPC_E)
+#define VDEC2_MPC_W 0x2309
+#define P_VDEC2_MPC_W           DOS_REG_ADDR(VDEC2_MPC_W)
+#define VDEC2_MINDEX0_REG 0x230a
+#define P_VDEC2_MINDEX0_REG             DOS_REG_ADDR(VDEC2_MINDEX0_REG)
+#define VDEC2_MINDEX1_REG 0x230b
+#define P_VDEC2_MINDEX1_REG             DOS_REG_ADDR(VDEC2_MINDEX1_REG)
+#define VDEC2_MINDEX2_REG 0x230c
+#define P_VDEC2_MINDEX2_REG             DOS_REG_ADDR(VDEC2_MINDEX2_REG)
+#define VDEC2_MINDEX3_REG 0x230d
+#define P_VDEC2_MINDEX3_REG             DOS_REG_ADDR(VDEC2_MINDEX3_REG)
+#define VDEC2_MINDEX4_REG 0x230e
+#define P_VDEC2_MINDEX4_REG             DOS_REG_ADDR(VDEC2_MINDEX4_REG)
+#define VDEC2_MINDEX5_REG 0x230f
+#define P_VDEC2_MINDEX5_REG             DOS_REG_ADDR(VDEC2_MINDEX5_REG)
+#define VDEC2_MINDEX6_REG 0x2310
+#define P_VDEC2_MINDEX6_REG             DOS_REG_ADDR(VDEC2_MINDEX6_REG)
+#define VDEC2_MINDEX7_REG 0x2311
+#define P_VDEC2_MINDEX7_REG             DOS_REG_ADDR(VDEC2_MINDEX7_REG)
+#define VDEC2_MMIN_REG 0x2312
+#define P_VDEC2_MMIN_REG                DOS_REG_ADDR(VDEC2_MMIN_REG)
+#define VDEC2_MMAX_REG 0x2313
+#define P_VDEC2_MMAX_REG                DOS_REG_ADDR(VDEC2_MMAX_REG)
+#define VDEC2_MBREAK0_REG 0x2314
+#define P_VDEC2_MBREAK0_REG             DOS_REG_ADDR(VDEC2_MBREAK0_REG)
+#define VDEC2_MBREAK1_REG 0x2315
+#define P_VDEC2_MBREAK1_REG             DOS_REG_ADDR(VDEC2_MBREAK1_REG)
+#define VDEC2_MBREAK2_REG 0x2316
+#define P_VDEC2_MBREAK2_REG             DOS_REG_ADDR(VDEC2_MBREAK2_REG)
+#define VDEC2_MBREAK3_REG 0x2317
+#define P_VDEC2_MBREAK3_REG             DOS_REG_ADDR(VDEC2_MBREAK3_REG)
+#define VDEC2_MBREAK_TYPE 0x2318
+#define P_VDEC2_MBREAK_TYPE             DOS_REG_ADDR(VDEC2_MBREAK_TYPE)
+#define VDEC2_MBREAK_CTRL 0x2319
+#define P_VDEC2_MBREAK_CTRL             DOS_REG_ADDR(VDEC2_MBREAK_CTRL)
+#define VDEC2_MBREAK_STAUTS 0x231a
+#define P_VDEC2_MBREAK_STAUTS           DOS_REG_ADDR(VDEC2_MBREAK_STAUTS)
+#define VDEC2_MDB_ADDR_REG 0x231b
+#define P_VDEC2_MDB_ADDR_REG            DOS_REG_ADDR(VDEC2_MDB_ADDR_REG)
+#define VDEC2_MDB_DATA_REG 0x231c
+#define P_VDEC2_MDB_DATA_REG            DOS_REG_ADDR(VDEC2_MDB_DATA_REG)
+#define VDEC2_MDB_CTRL 0x231d
+#define P_VDEC2_MDB_CTRL                DOS_REG_ADDR(VDEC2_MDB_CTRL)
+#define VDEC2_MSFTINT0 0x231e
+#define P_VDEC2_MSFTINT0                DOS_REG_ADDR(VDEC2_MSFTINT0)
+#define VDEC2_MSFTINT1 0x231f
+#define P_VDEC2_MSFTINT1                DOS_REG_ADDR(VDEC2_MSFTINT1)
+#define VDEC2_CSP 0x2320
+#define P_VDEC2_CSP             DOS_REG_ADDR(VDEC2_CSP)
+#define VDEC2_CPSR 0x2321
+#define P_VDEC2_CPSR            DOS_REG_ADDR(VDEC2_CPSR)
+#define VDEC2_CINT_VEC_BASE 0x2322
+#define P_VDEC2_CINT_VEC_BASE           DOS_REG_ADDR(VDEC2_CINT_VEC_BASE)
+#define VDEC2_CCPU_INTR_GRP 0x2323
+#define P_VDEC2_CCPU_INTR_GRP           DOS_REG_ADDR(VDEC2_CCPU_INTR_GRP)
+#define VDEC2_CCPU_INTR_MSK 0x2324
+#define P_VDEC2_CCPU_INTR_MSK           DOS_REG_ADDR(VDEC2_CCPU_INTR_MSK)
+#define VDEC2_CCPU_INTR_REQ 0x2325
+#define P_VDEC2_CCPU_INTR_REQ           DOS_REG_ADDR(VDEC2_CCPU_INTR_REQ)
+#define VDEC2_CPC_P 0x2326
+#define P_VDEC2_CPC_P           DOS_REG_ADDR(VDEC2_CPC_P)
+#define VDEC2_CPC_D 0x2327
+#define P_VDEC2_CPC_D           DOS_REG_ADDR(VDEC2_CPC_D)
+#define VDEC2_CPC_E 0x2328
+#define P_VDEC2_CPC_E           DOS_REG_ADDR(VDEC2_CPC_E)
+#define VDEC2_CPC_W 0x2329
+#define P_VDEC2_CPC_W           DOS_REG_ADDR(VDEC2_CPC_W)
+#define VDEC2_CINDEX0_REG 0x232a
+#define P_VDEC2_CINDEX0_REG             DOS_REG_ADDR(VDEC2_CINDEX0_REG)
+#define VDEC2_CINDEX1_REG 0x232b
+#define P_VDEC2_CINDEX1_REG             DOS_REG_ADDR(VDEC2_CINDEX1_REG)
+#define VDEC2_CINDEX2_REG 0x232c
+#define P_VDEC2_CINDEX2_REG             DOS_REG_ADDR(VDEC2_CINDEX2_REG)
+#define VDEC2_CINDEX3_REG 0x232d
+#define P_VDEC2_CINDEX3_REG             DOS_REG_ADDR(VDEC2_CINDEX3_REG)
+#define VDEC2_CINDEX4_REG 0x232e
+#define P_VDEC2_CINDEX4_REG             DOS_REG_ADDR(VDEC2_CINDEX4_REG)
+#define VDEC2_CINDEX5_REG 0x232f
+#define P_VDEC2_CINDEX5_REG             DOS_REG_ADDR(VDEC2_CINDEX5_REG)
+#define VDEC2_CINDEX6_REG 0x2330
+#define P_VDEC2_CINDEX6_REG             DOS_REG_ADDR(VDEC2_CINDEX6_REG)
+#define VDEC2_CINDEX7_REG 0x2331
+#define P_VDEC2_CINDEX7_REG             DOS_REG_ADDR(VDEC2_CINDEX7_REG)
+#define VDEC2_CMIN_REG 0x2332
+#define P_VDEC2_CMIN_REG                DOS_REG_ADDR(VDEC2_CMIN_REG)
+#define VDEC2_CMAX_REG 0x2333
+#define P_VDEC2_CMAX_REG                DOS_REG_ADDR(VDEC2_CMAX_REG)
+#define VDEC2_CBREAK0_REG 0x2334
+#define P_VDEC2_CBREAK0_REG             DOS_REG_ADDR(VDEC2_CBREAK0_REG)
+#define VDEC2_CBREAK1_REG 0x2335
+#define P_VDEC2_CBREAK1_REG             DOS_REG_ADDR(VDEC2_CBREAK1_REG)
+#define VDEC2_CBREAK2_REG 0x2336
+#define P_VDEC2_CBREAK2_REG             DOS_REG_ADDR(VDEC2_CBREAK2_REG)
+#define VDEC2_CBREAK3_REG 0x2337
+#define P_VDEC2_CBREAK3_REG             DOS_REG_ADDR(VDEC2_CBREAK3_REG)
+#define VDEC2_CBREAK_TYPE 0x2338
+#define P_VDEC2_CBREAK_TYPE             DOS_REG_ADDR(VDEC2_CBREAK_TYPE)
+#define VDEC2_CBREAK_CTRL 0x2339
+#define P_VDEC2_CBREAK_CTRL             DOS_REG_ADDR(VDEC2_CBREAK_CTRL)
+#define VDEC2_CBREAK_STAUTS 0x233a
+#define P_VDEC2_CBREAK_STAUTS           DOS_REG_ADDR(VDEC2_CBREAK_STAUTS)
+#define VDEC2_CDB_ADDR_REG 0x233b
+#define P_VDEC2_CDB_ADDR_REG            DOS_REG_ADDR(VDEC2_CDB_ADDR_REG)
+#define VDEC2_CDB_DATA_REG 0x233c
+#define P_VDEC2_CDB_DATA_REG            DOS_REG_ADDR(VDEC2_CDB_DATA_REG)
+#define VDEC2_CDB_CTRL 0x233d
+#define P_VDEC2_CDB_CTRL                DOS_REG_ADDR(VDEC2_CDB_CTRL)
+#define VDEC2_CSFTINT0 0x233e
+#define P_VDEC2_CSFTINT0                DOS_REG_ADDR(VDEC2_CSFTINT0)
+#define VDEC2_CSFTINT1 0x233f
+#define P_VDEC2_CSFTINT1                DOS_REG_ADDR(VDEC2_CSFTINT1)
+#define VDEC2_IMEM_DMA_CTRL 0x2340
+#define P_VDEC2_IMEM_DMA_CTRL           DOS_REG_ADDR(VDEC2_IMEM_DMA_CTRL)
+#define VDEC2_IMEM_DMA_ADR 0x2341
+#define P_VDEC2_IMEM_DMA_ADR            DOS_REG_ADDR(VDEC2_IMEM_DMA_ADR)
+#define VDEC2_IMEM_DMA_COUNT 0x2342
+#define P_VDEC2_IMEM_DMA_COUNT          DOS_REG_ADDR(VDEC2_IMEM_DMA_COUNT)
+#define VDEC2_WRRSP_IMEM 0x2343
+#define P_VDEC2_WRRSP_IMEM              DOS_REG_ADDR(VDEC2_WRRSP_IMEM)
+#define VDEC2_LMEM_DMA_CTRL 0x2350
+#define P_VDEC2_LMEM_DMA_CTRL           DOS_REG_ADDR(VDEC2_LMEM_DMA_CTRL)
+#define VDEC2_LMEM_DMA_ADR 0x2351
+#define P_VDEC2_LMEM_DMA_ADR            DOS_REG_ADDR(VDEC2_LMEM_DMA_ADR)
+#define VDEC2_LMEM_DMA_COUNT 0x2352
+#define P_VDEC2_LMEM_DMA_COUNT          DOS_REG_ADDR(VDEC2_LMEM_DMA_COUNT)
+#define VDEC2_WRRSP_LMEM 0x2353
+#define P_VDEC2_WRRSP_LMEM              DOS_REG_ADDR(VDEC2_WRRSP_LMEM)
+#define VDEC2_MAC_CTRL1 0x2360
+#define P_VDEC2_MAC_CTRL1               DOS_REG_ADDR(VDEC2_MAC_CTRL1)
+#define VDEC2_ACC0REG1 0x2361
+#define P_VDEC2_ACC0REG1                DOS_REG_ADDR(VDEC2_ACC0REG1)
+#define VDEC2_ACC1REG1 0x2362
+#define P_VDEC2_ACC1REG1                DOS_REG_ADDR(VDEC2_ACC1REG1)
+#define VDEC2_MAC_CTRL2 0x2370
+#define P_VDEC2_MAC_CTRL2               DOS_REG_ADDR(VDEC2_MAC_CTRL2)
+#define VDEC2_ACC0REG2 0x2371
+#define P_VDEC2_ACC0REG2                DOS_REG_ADDR(VDEC2_ACC0REG2)
+#define VDEC2_ACC1REG2 0x2372
+#define P_VDEC2_ACC1REG2                DOS_REG_ADDR(VDEC2_ACC1REG2)
+#define VDEC2_CPU_TRACE 0x2380
+#define P_VDEC2_CPU_TRACE               DOS_REG_ADDR(VDEC2_CPU_TRACE)
+/*add from M8M2*/
+#define HEVC_MSP 0x3300
+#define P_HEVC_MSP              DOS_REG_ADDR(HEVC_MSP)
+#define HEVC_MPSR 0x3301
+#define P_HEVC_MPSR             DOS_REG_ADDR(HEVC_MPSR)
+#define HEVC_MINT_VEC_BASE 0x3302
+#define P_HEVC_MINT_VEC_BASE            DOS_REG_ADDR(HEVC_MINT_VEC_BASE)
+#define HEVC_MCPU_INTR_GRP 0x3303
+#define P_HEVC_MCPU_INTR_GRP            DOS_REG_ADDR(HEVC_MCPU_INTR_GRP)
+#define HEVC_MCPU_INTR_MSK 0x3304
+#define P_HEVC_MCPU_INTR_MSK            DOS_REG_ADDR(HEVC_MCPU_INTR_MSK)
+#define HEVC_MCPU_INTR_REQ 0x3305
+#define P_HEVC_MCPU_INTR_REQ            DOS_REG_ADDR(HEVC_MCPU_INTR_REQ)
+#define HEVC_MPC_P 0x3306
+#define P_HEVC_MPC_P            DOS_REG_ADDR(HEVC_MPC_P)
+#define HEVC_MPC_D 0x3307
+#define P_HEVC_MPC_D            DOS_REG_ADDR(HEVC_MPC_D)
+#define HEVC_MPC_E 0x3308
+#define P_HEVC_MPC_E            DOS_REG_ADDR(HEVC_MPC_E)
+#define HEVC_MPC_W 0x3309
+#define P_HEVC_MPC_W            DOS_REG_ADDR(HEVC_MPC_W)
+#define HEVC_MINDEX0_REG 0x330a
+#define P_HEVC_MINDEX0_REG              DOS_REG_ADDR(HEVC_MINDEX0_REG)
+#define HEVC_MINDEX1_REG 0x330b
+#define P_HEVC_MINDEX1_REG              DOS_REG_ADDR(HEVC_MINDEX1_REG)
+#define HEVC_MINDEX2_REG 0x330c
+#define P_HEVC_MINDEX2_REG              DOS_REG_ADDR(HEVC_MINDEX2_REG)
+#define HEVC_MINDEX3_REG 0x330d
+#define P_HEVC_MINDEX3_REG              DOS_REG_ADDR(HEVC_MINDEX3_REG)
+#define HEVC_MINDEX4_REG 0x330e
+#define P_HEVC_MINDEX4_REG              DOS_REG_ADDR(HEVC_MINDEX4_REG)
+#define HEVC_MINDEX5_REG 0x330f
+#define P_HEVC_MINDEX5_REG              DOS_REG_ADDR(HEVC_MINDEX5_REG)
+#define HEVC_MINDEX6_REG 0x3310
+#define P_HEVC_MINDEX6_REG              DOS_REG_ADDR(HEVC_MINDEX6_REG)
+#define HEVC_MINDEX7_REG 0x3311
+#define P_HEVC_MINDEX7_REG              DOS_REG_ADDR(HEVC_MINDEX7_REG)
+#define HEVC_MMIN_REG 0x3312
+#define P_HEVC_MMIN_REG                 DOS_REG_ADDR(HEVC_MMIN_REG)
+#define HEVC_MMAX_REG 0x3313
+#define P_HEVC_MMAX_REG                 DOS_REG_ADDR(HEVC_MMAX_REG)
+#define HEVC_MBREAK0_REG 0x3314
+#define P_HEVC_MBREAK0_REG              DOS_REG_ADDR(HEVC_MBREAK0_REG)
+#define HEVC_MBREAK1_REG 0x3315
+#define P_HEVC_MBREAK1_REG              DOS_REG_ADDR(HEVC_MBREAK1_REG)
+#define HEVC_MBREAK2_REG 0x3316
+#define P_HEVC_MBREAK2_REG              DOS_REG_ADDR(HEVC_MBREAK2_REG)
+#define HEVC_MBREAK3_REG 0x3317
+#define P_HEVC_MBREAK3_REG              DOS_REG_ADDR(HEVC_MBREAK3_REG)
+#define HEVC_MBREAK_TYPE 0x3318
+#define P_HEVC_MBREAK_TYPE              DOS_REG_ADDR(HEVC_MBREAK_TYPE)
+#define HEVC_MBREAK_CTRL 0x3319
+#define P_HEVC_MBREAK_CTRL              DOS_REG_ADDR(HEVC_MBREAK_CTRL)
+#define HEVC_MBREAK_STAUTS 0x331a
+#define P_HEVC_MBREAK_STAUTS            DOS_REG_ADDR(HEVC_MBREAK_STAUTS)
+#define HEVC_MDB_ADDR_REG 0x331b
+#define P_HEVC_MDB_ADDR_REG             DOS_REG_ADDR(HEVC_MDB_ADDR_REG)
+#define HEVC_MDB_DATA_REG 0x331c
+#define P_HEVC_MDB_DATA_REG             DOS_REG_ADDR(HEVC_MDB_DATA_REG)
+#define HEVC_MDB_CTRL 0x331d
+#define P_HEVC_MDB_CTRL                 DOS_REG_ADDR(HEVC_MDB_CTRL)
+#define HEVC_MSFTINT0 0x331e
+#define P_HEVC_MSFTINT0                 DOS_REG_ADDR(HEVC_MSFTINT0)
+#define HEVC_MSFTINT1 0x331f
+#define P_HEVC_MSFTINT1                 DOS_REG_ADDR(HEVC_MSFTINT1)
+#define HEVC_CSP 0x3320
+#define P_HEVC_CSP              DOS_REG_ADDR(HEVC_CSP)
+#define HEVC_CPSR 0x3321
+#define P_HEVC_CPSR             DOS_REG_ADDR(HEVC_CPSR)
+#define HEVC_CINT_VEC_BASE 0x3322
+#define P_HEVC_CINT_VEC_BASE            DOS_REG_ADDR(HEVC_CINT_VEC_BASE)
+#define HEVC_CCPU_INTR_GRP 0x3323
+#define P_HEVC_CCPU_INTR_GRP            DOS_REG_ADDR(HEVC_CCPU_INTR_GRP)
+#define HEVC_CCPU_INTR_MSK 0x3324
+#define P_HEVC_CCPU_INTR_MSK            DOS_REG_ADDR(HEVC_CCPU_INTR_MSK)
+#define HEVC_CCPU_INTR_REQ 0x3325
+#define P_HEVC_CCPU_INTR_REQ            DOS_REG_ADDR(HEVC_CCPU_INTR_REQ)
+#define HEVC_CPC_P 0x3326
+#define P_HEVC_CPC_P            DOS_REG_ADDR(HEVC_CPC_P)
+#define HEVC_CPC_D 0x3327
+#define P_HEVC_CPC_D            DOS_REG_ADDR(HEVC_CPC_D)
+#define HEVC_CPC_E 0x3328
+#define P_HEVC_CPC_E            DOS_REG_ADDR(HEVC_CPC_E)
+#define HEVC_CPC_W 0x3329
+#define P_HEVC_CPC_W            DOS_REG_ADDR(HEVC_CPC_W)
+#define HEVC_CINDEX0_REG 0x332a
+#define P_HEVC_CINDEX0_REG              DOS_REG_ADDR(HEVC_CINDEX0_REG)
+#define HEVC_CINDEX1_REG 0x332b
+#define P_HEVC_CINDEX1_REG              DOS_REG_ADDR(HEVC_CINDEX1_REG)
+#define HEVC_CINDEX2_REG 0x332c
+#define P_HEVC_CINDEX2_REG              DOS_REG_ADDR(HEVC_CINDEX2_REG)
+#define HEVC_CINDEX3_REG 0x332d
+#define P_HEVC_CINDEX3_REG              DOS_REG_ADDR(HEVC_CINDEX3_REG)
+#define HEVC_CINDEX4_REG 0x332e
+#define P_HEVC_CINDEX4_REG              DOS_REG_ADDR(HEVC_CINDEX4_REG)
+#define HEVC_CINDEX5_REG 0x332f
+#define P_HEVC_CINDEX5_REG              DOS_REG_ADDR(HEVC_CINDEX5_REG)
+#define HEVC_CINDEX6_REG 0x3330
+#define P_HEVC_CINDEX6_REG              DOS_REG_ADDR(HEVC_CINDEX6_REG)
+#define HEVC_CINDEX7_REG 0x3331
+#define P_HEVC_CINDEX7_REG              DOS_REG_ADDR(HEVC_CINDEX7_REG)
+#define HEVC_CMIN_REG 0x3332
+#define P_HEVC_CMIN_REG                 DOS_REG_ADDR(HEVC_CMIN_REG)
+#define HEVC_CMAX_REG 0x3333
+#define P_HEVC_CMAX_REG                 DOS_REG_ADDR(HEVC_CMAX_REG)
+#define HEVC_CBREAK0_REG 0x3334
+#define P_HEVC_CBREAK0_REG              DOS_REG_ADDR(HEVC_CBREAK0_REG)
+#define HEVC_CBREAK1_REG 0x3335
+#define P_HEVC_CBREAK1_REG              DOS_REG_ADDR(HEVC_CBREAK1_REG)
+#define HEVC_CBREAK2_REG 0x3336
+#define P_HEVC_CBREAK2_REG              DOS_REG_ADDR(HEVC_CBREAK2_REG)
+#define HEVC_CBREAK3_REG 0x3337
+#define P_HEVC_CBREAK3_REG              DOS_REG_ADDR(HEVC_CBREAK3_REG)
+#define HEVC_CBREAK_TYPE 0x3338
+#define P_HEVC_CBREAK_TYPE              DOS_REG_ADDR(HEVC_CBREAK_TYPE)
+#define HEVC_CBREAK_CTRL 0x3339
+#define P_HEVC_CBREAK_CTRL              DOS_REG_ADDR(HEVC_CBREAK_CTRL)
+#define HEVC_CBREAK_STAUTS 0x333a
+#define P_HEVC_CBREAK_STAUTS            DOS_REG_ADDR(HEVC_CBREAK_STAUTS)
+#define HEVC_CDB_ADDR_REG 0x333b
+#define P_HEVC_CDB_ADDR_REG             DOS_REG_ADDR(HEVC_CDB_ADDR_REG)
+#define HEVC_CDB_DATA_REG 0x333c
+#define P_HEVC_CDB_DATA_REG             DOS_REG_ADDR(HEVC_CDB_DATA_REG)
+#define HEVC_CDB_CTRL 0x333d
+#define P_HEVC_CDB_CTRL                 DOS_REG_ADDR(HEVC_CDB_CTRL)
+#define HEVC_CSFTINT0 0x333e
+#define P_HEVC_CSFTINT0                 DOS_REG_ADDR(HEVC_CSFTINT0)
+#define HEVC_CSFTINT1 0x333f
+#define P_HEVC_CSFTINT1                 DOS_REG_ADDR(HEVC_CSFTINT1)
+#define HEVC_IMEM_DMA_CTRL 0x3340
+#define P_HEVC_IMEM_DMA_CTRL            DOS_REG_ADDR(HEVC_IMEM_DMA_CTRL)
+#define HEVC_IMEM_DMA_ADR 0x3341
+#define P_HEVC_IMEM_DMA_ADR             DOS_REG_ADDR(HEVC_IMEM_DMA_ADR)
+#define HEVC_IMEM_DMA_COUNT 0x3342
+#define P_HEVC_IMEM_DMA_COUNT           DOS_REG_ADDR(HEVC_IMEM_DMA_COUNT)
+#define HEVC_WRRSP_IMEM 0x3343
+#define P_HEVC_WRRSP_IMEM               DOS_REG_ADDR(HEVC_WRRSP_IMEM)
+#define HEVC_LMEM_DMA_CTRL 0x3350
+#define P_HEVC_LMEM_DMA_CTRL            DOS_REG_ADDR(HEVC_LMEM_DMA_CTRL)
+#define HEVC_LMEM_DMA_ADR 0x3351
+#define P_HEVC_LMEM_DMA_ADR             DOS_REG_ADDR(HEVC_LMEM_DMA_ADR)
+#define HEVC_LMEM_DMA_COUNT 0x3352
+#define P_HEVC_LMEM_DMA_COUNT           DOS_REG_ADDR(HEVC_LMEM_DMA_COUNT)
+#define HEVC_WRRSP_LMEM 0x3353
+#define P_HEVC_WRRSP_LMEM               DOS_REG_ADDR(HEVC_WRRSP_LMEM)
+#define HEVC_MAC_CTRL1 0x3360
+#define P_HEVC_MAC_CTRL1                DOS_REG_ADDR(HEVC_MAC_CTRL1)
+#define HEVC_ACC0REG1 0x3361
+#define P_HEVC_ACC0REG1                 DOS_REG_ADDR(HEVC_ACC0REG1)
+#define HEVC_ACC1REG1 0x3362
+#define P_HEVC_ACC1REG1                 DOS_REG_ADDR(HEVC_ACC1REG1)
+#define HEVC_MAC_CTRL2 0x3370
+#define P_HEVC_MAC_CTRL2                DOS_REG_ADDR(HEVC_MAC_CTRL2)
+#define HEVC_ACC0REG2 0x3371
+#define P_HEVC_ACC0REG2                 DOS_REG_ADDR(HEVC_ACC0REG2)
+#define HEVC_ACC1REG2 0x3372
+#define P_HEVC_ACC1REG2                 DOS_REG_ADDR(HEVC_ACC1REG2)
+#define HEVC_CPU_TRACE 0x3380
+#define P_HEVC_CPU_TRACE                DOS_REG_ADDR(HEVC_CPU_TRACE)
+/**/
+#define HCODEC_VLC_MB_INFO 0x1d35
+#define P_HCODEC_VLC_MB_INFO            DOS_REG_ADDR(HCODEC_VLC_MB_INFO)
+#define HCODEC_VLC_ENC_PEND_CMD 0x1d36
+
+#define HCODEC_VLC_DC_RD_REQ 0x1d45
+#define P_HCODEC_VLC_DC_RD_REQ          DOS_REG_ADDR(HCODEC_VLC_DC_RD_REQ)
+#define HCODEC_VLC_DC 0x1d46
+#define P_HCODEC_VLC_DC                 DOS_REG_ADDR(HCODEC_VLC_DC)
+#define HCODEC_VLC_DC_INFO 0x1d47
+#define P_HCODEC_VLC_DC_INFO            DOS_REG_ADDR(HCODEC_VLC_DC_INFO)
+#define HCODEC_VLC_MV_INDEX 0x1d48
+#define P_HCODEC_VLC_MV_INDEX           DOS_REG_ADDR(HCODEC_VLC_MV_INDEX)
+#define HCODEC_VLC_MV 0x1d49
+#define P_HCODEC_VLC_MV                 DOS_REG_ADDR(HCODEC_VLC_MV)
+#define HCODEC_HENC_TOP_MV_0 0x1d4a
+#define P_HCODEC_HENC_TOP_MV_0          DOS_REG_ADDR(HCODEC_HENC_TOP_MV_0)
+#define HCODEC_HENC_TOP_MV_1 0x1d4b
+#define P_HCODEC_HENC_TOP_MV_1          DOS_REG_ADDR(HCODEC_HENC_TOP_MV_1)
+#define HCODEC_HENC_TOP_MV_2 0x1d4c
+#define P_HCODEC_HENC_TOP_MV_2          DOS_REG_ADDR(HCODEC_HENC_TOP_MV_2)
+#define HCODEC_HENC_TOP_MV_3 0x1d4d
+#define P_HCODEC_HENC_TOP_MV_3          DOS_REG_ADDR(HCODEC_HENC_TOP_MV_3)
+#define HCODEC_HENC_LEFT_MV_0 0x1d4e
+
+/*add from M8M2*/
+#define HCODEC_QDCT_I_PRED_REF_WR_IDX 0x1f32
+#define P_HCODEC_QDCT_I_PRED_REF_WR_IDX                 \
+	DOS_REG_ADDR(HCODEC_QDCT_I_PRED_REF_WR_IDX)
+#define HCODEC_QDCT_I_PRED_REF_WR_DATA 0x1f33
+#define P_HCODEC_QDCT_I_PRED_REF_WR_DATA                \
+	DOS_REG_ADDR(HCODEC_QDCT_I_PRED_REF_WR_DATA)
+/**/
+#define HCODEC_IE_CONTROL 0x1f40
+#define P_HCODEC_IE_CONTROL             DOS_REG_ADDR(HCODEC_IE_CONTROL)
+#define HCODEC_IE_MB_POSITION 0x1f41
+#define P_HCODEC_IE_MB_POSITION                 \
+	DOS_REG_ADDR(HCODEC_IE_MB_POSITION)
+#define HCODEC_IE_ME_MB_INFO 0x1f42
+#define P_HCODEC_IE_ME_MB_INFO          DOS_REG_ADDR(HCODEC_IE_ME_MB_INFO)
+#define HCODEC_SAD_CONTROL 0x1f43
+#define P_HCODEC_SAD_CONTROL            DOS_REG_ADDR(HCODEC_SAD_CONTROL)
+#define HCODEC_IE_I4_PRED_MODE_HI 0x1f45
+#define P_HCODEC_IE_I4_PRED_MODE_HI             \
+	DOS_REG_ADDR(HCODEC_IE_I4_PRED_MODE_HI)
+#define HCODEC_IE_I4_PRED_MODE_LO 0x1f46
+#define P_HCODEC_IE_I4_PRED_MODE_LO             \
+	DOS_REG_ADDR(HCODEC_IE_I4_PRED_MODE_LO)
+#define HCODEC_IE_C_PRED_MODE 0x1f47
+#define P_HCODEC_IE_C_PRED_MODE                 \
+	DOS_REG_ADDR(HCODEC_IE_C_PRED_MODE)
+#define HCODEC_IE_CUR_REF_SEL 0x1f48
+#define P_HCODEC_IE_CUR_REF_SEL                 \
+	DOS_REG_ADDR(HCODEC_IE_CUR_REF_SEL)
+#define HCODEC_ME_CONTROL 0x1f49
+#define P_HCODEC_ME_CONTROL             DOS_REG_ADDR(HCODEC_ME_CONTROL)
+#define HCODEC_ME_START_POSITION 0x1f4a
+#define P_HCODEC_ME_START_POSITION              \
+	DOS_REG_ADDR(HCODEC_ME_START_POSITION)
+#define HCODEC_ME_STATUS 0x1f4b
+#define P_HCODEC_ME_STATUS              DOS_REG_ADDR(HCODEC_ME_STATUS)
+#define HCODEC_ME_DEBUG 0x1f4c
+#define P_HCODEC_ME_DEBUG               DOS_REG_ADDR(HCODEC_ME_DEBUG)
+#define HCODEC_ME_SKIP_LINE 0x1f4d
+#define P_HCODEC_ME_SKIP_LINE           DOS_REG_ADDR(HCODEC_ME_SKIP_LINE)
+#define HCODEC_ME_AB_MEM_CTL 0x1f4e
+#define P_HCODEC_ME_AB_MEM_CTL          DOS_REG_ADDR(HCODEC_ME_AB_MEM_CTL)
+#define HCODEC_ME_PIC_INFO 0x1f4f
+#define P_HCODEC_ME_PIC_INFO            DOS_REG_ADDR(HCODEC_ME_PIC_INFO)
+#define HCODEC_ME_SAD_ENOUGH_01 0x1f50
+#define P_HCODEC_ME_SAD_ENOUGH_01               \
+	DOS_REG_ADDR(HCODEC_ME_SAD_ENOUGH_01)
+#define HCODEC_ME_SAD_ENOUGH_23 0x1f51
+#define P_HCODEC_ME_SAD_ENOUGH_23               \
+	DOS_REG_ADDR(HCODEC_ME_SAD_ENOUGH_23)
+#define HCODEC_ME_STEP0_CLOSE_MV 0x1f52
+#define P_HCODEC_ME_STEP0_CLOSE_MV              \
+	DOS_REG_ADDR(HCODEC_ME_STEP0_CLOSE_MV)
+#define HCODEC_ME_F_SKIP_SAD 0x1f53
+#define P_HCODEC_ME_F_SKIP_SAD          \
+	DOS_REG_ADDR(HCODEC_ME_F_SKIP_SAD)
+#define HCODEC_ME_F_SKIP_WEIGHT 0x1f54
+#define P_HCODEC_ME_F_SKIP_WEIGHT               \
+	DOS_REG_ADDR(HCODEC_ME_F_SKIP_WEIGHT)
+#define HCODEC_ME_MV_MERGE_CTL 0x1f55
+#define P_HCODEC_ME_MV_MERGE_CTL                \
+	DOS_REG_ADDR(HCODEC_ME_MV_MERGE_CTL)
+#define HCODEC_ME_MV_WEIGHT_01 0x1f56
+#define P_HCODEC_ME_MV_WEIGHT_01                \
+	DOS_REG_ADDR(HCODEC_ME_MV_WEIGHT_01)
+#define HCODEC_ME_MV_WEIGHT_23 0x1f57
+#define P_HCODEC_ME_MV_WEIGHT_23                \
+	DOS_REG_ADDR(HCODEC_ME_MV_WEIGHT_23)
+#define HCODEC_ME_SAD_RANGE_INC 0x1f58
+#define P_HCODEC_ME_SAD_RANGE_INC               \
+	DOS_REG_ADDR(HCODEC_ME_SAD_RANGE_INC)
+#define HCODEC_ME_SUB_MERGE_CTL 0x1f59
+#define P_HCODEC_ME_SUB_MERGE_CTL               \
+	DOS_REG_ADDR(HCODEC_ME_SUB_MERGE_CTL)
+#define HCODEC_ME_SUB_REF_MV_CTL 0x1f5a
+#define P_HCODEC_ME_SUB_REF_MV_CTL              \
+	DOS_REG_ADDR(HCODEC_ME_SUB_REF_MV_CTL)
+#define HCODEC_ME_SUB_ANY_WEIGHT_SAD 0x1f5b
+#define P_HCODEC_ME_SUB_ANY_WEIGHT_SAD          \
+	DOS_REG_ADDR(HCODEC_ME_SUB_ANY_WEIGHT_SAD)
+#define HCODEC_ME_SUB_FIX_SAD 0x1f5c
+#define P_HCODEC_ME_SUB_FIX_SAD                 \
+	DOS_REG_ADDR(HCODEC_ME_SUB_FIX_SAD)
+#define HCODEC_ME_SUB_FIX_MIN_SAD 0x1f5d
+#define P_HCODEC_ME_SUB_FIX_MIN_SAD             \
+	DOS_REG_ADDR(HCODEC_ME_SUB_FIX_MIN_SAD)
+#define HCODEC_ME_SUB_SNAP_GLITCH 0x1f5e
+#define P_HCODEC_ME_SUB_SNAP_GLITCH             \
+	DOS_REG_ADDR(HCODEC_ME_SUB_SNAP_GLITCH)
+#define HCODEC_ME_SUB_ACT_CTL 0x1f5f
+#define P_HCODEC_ME_SUB_ACT_CTL                 \
+	DOS_REG_ADDR(HCODEC_ME_SUB_ACT_CTL)
+#define AO_RTI_STATUS_REG0 ((0x00 << 10) | (0x00 << 2))
+#define P_AO_RTI_STATUS_REG0            AOBUS_REG_ADDR(AO_RTI_STATUS_REG0)
+#define AO_RTI_STATUS_REG1 ((0x00 << 10) | (0x01 << 2))
+#define P_AO_RTI_STATUS_REG1            AOBUS_REG_ADDR(AO_RTI_STATUS_REG1)
+#define AO_RTI_STATUS_REG2 ((0x00 << 10) | (0x02 << 2))
+#define P_AO_RTI_STATUS_REG2            AOBUS_REG_ADDR(AO_RTI_STATUS_REG2)
+#define AO_RTI_PWR_CNTL_REG1 ((0x00 << 10) | (0x03 << 2))
+#define P_AO_RTI_PWR_CNTL_REG1          AOBUS_REG_ADDR(AO_RTI_PWR_CNTL_REG1)
+#define AO_RTI_PWR_CNTL_REG0 ((0x00 << 10) | (0x04 << 2))
+#define P_AO_RTI_PWR_CNTL_REG0          AOBUS_REG_ADDR(AO_RTI_PWR_CNTL_REG0)
+#define AO_RTI_PIN_MUX_REG ((0x00 << 10) | (0x05 << 2))
+#define P_AO_RTI_PIN_MUX_REG            AOBUS_REG_ADDR(AO_RTI_PIN_MUX_REG)
+#define AO_WD_GPIO_REG ((0x00 << 10) | (0x06 << 2))
+#define P_AO_WD_GPIO_REG                AOBUS_REG_ADDR(AO_WD_GPIO_REG)
+#define AO_REMAP_REG0 ((0x00 << 10) | (0x07 << 2))
+#define P_AO_REMAP_REG0                 AOBUS_REG_ADDR(AO_REMAP_REG0)
+#define AO_REMAP_REG1 ((0x00 << 10) | (0x08 << 2))
+#define P_AO_REMAP_REG1                 AOBUS_REG_ADDR(AO_REMAP_REG1)
+#define AO_GPIO_O_EN_N ((0x00 << 10) | (0x09 << 2))
+#define P_AO_GPIO_O_EN_N                AOBUS_REG_ADDR(AO_GPIO_O_EN_N)
+#define AO_GPIO_I ((0x00 << 10) | (0x0A << 2))
+#define P_AO_GPIO_I             AOBUS_REG_ADDR(AO_GPIO_I)
+#define AO_RTI_PULL_UP_REG ((0x00 << 10) | (0x0B << 2))
+#define P_AO_RTI_PULL_UP_REG            AOBUS_REG_ADDR(AO_RTI_PULL_UP_REG)
+#define AO_RTI_WD_MARK ((0x00 << 10) | (0x0D << 2))
+#define P_AO_RTI_WD_MARK                AOBUS_REG_ADDR(AO_RTI_WD_MARK)
+#define AO_CPU_CNTL ((0x00 << 10) | (0x0E << 2))
+#define P_AO_CPU_CNTL           AOBUS_REG_ADDR(AO_CPU_CNTL)
+#define AO_CPU_STAT ((0x00 << 10) | (0x0F << 2))
+#define P_AO_CPU_STAT           AOBUS_REG_ADDR(AO_CPU_STAT)
+#define AO_RTI_GEN_CNTL_REG0 ((0x00 << 10) | (0x10 << 2))
+#define P_AO_RTI_GEN_CNTL_REG0          AOBUS_REG_ADDR(AO_RTI_GEN_CNTL_REG0)
+#define AO_WATCHDOG_REG ((0x00 << 10) | (0x11 << 2))
+#define P_AO_WATCHDOG_REG               AOBUS_REG_ADDR(AO_WATCHDOG_REG)
+#define AO_WATCHDOG_RESET ((0x00 << 10) | (0x12 << 2))
+#define P_AO_WATCHDOG_RESET             AOBUS_REG_ADDR(AO_WATCHDOG_RESET)
+#define AO_TIMER_REG ((0x00 << 10) | (0x13 << 2))
+#define P_AO_TIMER_REG          AOBUS_REG_ADDR(AO_TIMER_REG)
+#define AO_TIMERA_REG ((0x00 << 10) | (0x14 << 2))
+#define P_AO_TIMERA_REG                 AOBUS_REG_ADDR(AO_TIMERA_REG)
+#define AO_TIMERE_REG ((0x00 << 10) | (0x15 << 2))
+#define P_AO_TIMERE_REG                 AOBUS_REG_ADDR(AO_TIMERE_REG)
+#define AO_AHB2DDR_CNTL ((0x00 << 10) | (0x18 << 2))
+#define P_AO_AHB2DDR_CNTL               AOBUS_REG_ADDR(AO_AHB2DDR_CNTL)
+#define AO_IRQ_MASK_FIQ_SEL ((0x00 << 10) | (0x20 << 2))
+#define P_AO_IRQ_MASK_FIQ_SEL           AOBUS_REG_ADDR(AO_IRQ_MASK_FIQ_SEL)
+#define AO_IRQ_GPIO_REG ((0x00 << 10) | (0x21 << 2))
+#define P_AO_IRQ_GPIO_REG               AOBUS_REG_ADDR(AO_IRQ_GPIO_REG)
+#define AO_IRQ_STAT ((0x00 << 10) | (0x22 << 2))
+#define P_AO_IRQ_STAT           AOBUS_REG_ADDR(AO_IRQ_STAT)
+#define AO_IRQ_STAT_CLR ((0x00 << 10) | (0x23 << 2))
+#define P_AO_IRQ_STAT_CLR               AOBUS_REG_ADDR(AO_IRQ_STAT_CLR)
+#define AO_DEBUG_REG0 ((0x00 << 10) | (0x28 << 2))
+#define P_AO_DEBUG_REG0                 AOBUS_REG_ADDR(AO_DEBUG_REG0)
+#define AO_DEBUG_REG1 ((0x00 << 10) | (0x29 << 2))
+#define P_AO_DEBUG_REG1                 AOBUS_REG_ADDR(AO_DEBUG_REG1)
+#define AO_DEBUG_REG2 ((0x00 << 10) | (0x2a << 2))
+#define P_AO_DEBUG_REG2                 AOBUS_REG_ADDR(AO_DEBUG_REG2)
+#define AO_DEBUG_REG3 ((0x00 << 10) | (0x2b << 2))
+#define P_AO_DEBUG_REG3                 AOBUS_REG_ADDR(AO_DEBUG_REG3)
+#define AO_IR_BLASTER_ADDR0 ((0x00 << 10) | (0x30 << 2))
+#define P_AO_IR_BLASTER_ADDR0           AOBUS_REG_ADDR(AO_IR_BLASTER_ADDR0)
+#define AO_IR_BLASTER_ADDR1 ((0x00 << 10) | (0x31 << 2))
+#define P_AO_IR_BLASTER_ADDR1           AOBUS_REG_ADDR(AO_IR_BLASTER_ADDR1)
+#define AO_IR_BLASTER_ADDR2 ((0x00 << 10) | (0x32 << 2))
+#define P_AO_IR_BLASTER_ADDR2           AOBUS_REG_ADDR(AO_IR_BLASTER_ADDR2)
+/*add from M8M2*/
+#define AO_JTAG_TRIGGER_CNTL ((0x00 << 10) | (0x34 << 2))
+#define P_AO_JTAG_TRIGGER_CNTL          AOBUS_REG_ADDR(AO_JTAG_TRIGGER_CNTL)
+/**/
+#define AO_RTI_PWR_A9_CNTL0 ((0x00 << 10) | (0x38 << 2))
+#define P_AO_RTI_PWR_A9_CNTL0           AOBUS_REG_ADDR(AO_RTI_PWR_A9_CNTL0)
+#define AO_RTI_PWR_A9_CNTL1 ((0x00 << 10) | (0x39 << 2))
+#define P_AO_RTI_PWR_A9_CNTL1           AOBUS_REG_ADDR(AO_RTI_PWR_A9_CNTL1)
+#define AO_RTI_GEN_PWR_SLEEP0 ((0x00 << 10) | (0x3a << 2))
+#define P_AO_RTI_GEN_PWR_SLEEP0                 \
+	AOBUS_REG_ADDR(AO_RTI_GEN_PWR_SLEEP0)
+#define AO_RTI_GEN_PWR_ISO0 ((0x00 << 10) | (0x3b << 2))
+#define P_AO_RTI_GEN_PWR_ISO0           AOBUS_REG_ADDR(AO_RTI_GEN_PWR_ISO0)
+#define AO_CEC_GEN_CNTL ((0x00 << 10) | (0x40 << 2))
+#define P_AO_CEC_GEN_CNTL               AOBUS_REG_ADDR(AO_CEC_GEN_CNTL)
+#define AO_CEC_RW_REG ((0x00 << 10) | (0x41 << 2))
+#define P_AO_CEC_RW_REG                 AOBUS_REG_ADDR(AO_CEC_RW_REG)
+#define AO_CEC_INTR_MASKN ((0x00 << 10) | (0x42 << 2))
+#define P_AO_CEC_INTR_MASKN             AOBUS_REG_ADDR(AO_CEC_INTR_MASKN)
+#define AO_CEC_INTR_CLR ((0x00 << 10) | (0x43 << 2))
+#define P_AO_CEC_INTR_CLR               AOBUS_REG_ADDR(AO_CEC_INTR_CLR)
+#define AO_CEC_INTR_STAT ((0x00 << 10) | (0x44 << 2))
+#define P_AO_CEC_INTR_STAT              AOBUS_REG_ADDR(AO_CEC_INTR_STAT)
+#define AO_IR_DEC_LDR_ACTIVE ((0x01 << 10) | (0x20 << 2))
+#define P_AO_IR_DEC_LDR_ACTIVE          AOBUS_REG_ADDR(AO_IR_DEC_LDR_ACTIVE)
+#define AO_IR_DEC_LDR_IDLE ((0x01 << 10) | (0x21 << 2))
+#define P_AO_IR_DEC_LDR_IDLE            AOBUS_REG_ADDR(AO_IR_DEC_LDR_IDLE)
+#define AO_IR_DEC_LDR_REPEAT ((0x01 << 10) | (0x22 << 2))
+#define P_AO_IR_DEC_LDR_REPEAT          AOBUS_REG_ADDR(AO_IR_DEC_LDR_REPEAT)
+#define AO_IR_DEC_BIT_0 ((0x01 << 10) | (0x23 << 2))
+#define P_AO_IR_DEC_BIT_0               AOBUS_REG_ADDR(AO_IR_DEC_BIT_0)
+#define AO_IR_DEC_REG0 ((0x01 << 10) | (0x24 << 2))
+#define P_AO_IR_DEC_REG0                AOBUS_REG_ADDR(AO_IR_DEC_REG0)
+#define AO_IR_DEC_FRAME ((0x01 << 10) | (0x25 << 2))
+#define P_AO_IR_DEC_FRAME               AOBUS_REG_ADDR(AO_IR_DEC_FRAME)
+#define AO_IR_DEC_STATUS ((0x01 << 10) | (0x26 << 2))
+#define P_AO_IR_DEC_STATUS              AOBUS_REG_ADDR(AO_IR_DEC_STATUS)
+#define AO_IR_DEC_REG1 ((0x01 << 10) | (0x27 << 2))
+#define P_AO_IR_DEC_REG1                AOBUS_REG_ADDR(AO_IR_DEC_REG1)
+#define AO_UART_WFIFO ((0x01 << 10) | (0x30 << 2))
+#define P_AO_UART_WFIFO                 AOBUS_REG_ADDR(AO_UART_WFIFO)
+#define AO_UART_RFIFO ((0x01 << 10) | (0x31 << 2))
+#define P_AO_UART_RFIFO                 AOBUS_REG_ADDR(AO_UART_RFIFO)
+#define AO_UART_CONTROL ((0x01 << 10) | (0x32 << 2))
+#define P_AO_UART_CONTROL               AOBUS_REG_ADDR(AO_UART_CONTROL)
+#define AO_UART_STATUS ((0x01 << 10) | (0x33 << 2))
+#define P_AO_UART_STATUS                AOBUS_REG_ADDR(AO_UART_STATUS)
+#define AO_UART_MISC ((0x01 << 10) | (0x34 << 2))
+#define P_AO_UART_MISC          AOBUS_REG_ADDR(AO_UART_MISC)
+#define AO_UART_REG5 ((0x01 << 10) | (0x35 << 2))
+#define P_AO_UART_REG5          AOBUS_REG_ADDR(AO_UART_REG5)
+#define AO_UART2_WFIFO ((0x01 << 10) | (0x38 << 2))
+#define P_AO_UART2_WFIFO                AOBUS_REG_ADDR(AO_UART2_WFIFO)
+#define AO_UART2_RFIFO ((0x01 << 10) | (0x39 << 2))
+#define P_AO_UART2_RFIFO                AOBUS_REG_ADDR(AO_UART2_RFIFO)
+#define AO_UART2_CONTROL ((0x01 << 10) | (0x3a << 2))
+#define P_AO_UART2_CONTROL              AOBUS_REG_ADDR(AO_UART2_CONTROL)
+#define AO_UART2_STATUS ((0x01 << 10) | (0x3b << 2))
+#define P_AO_UART2_STATUS               AOBUS_REG_ADDR(AO_UART2_STATUS)
+#define AO_UART2_MISC ((0x01 << 10) | (0x3c << 2))
+#define P_AO_UART2_MISC                 AOBUS_REG_ADDR(AO_UART2_MISC)
+#define AO_UART2_REG5 ((0x01 << 10) | (0x3d << 2))
+#define P_AO_UART2_REG5                 AOBUS_REG_ADDR(AO_UART2_REG5)
+#define AO_I2C_M_0_CONTROL_REG ((0x01 << 10) | (0x40 << 2))
+#define P_AO_I2C_M_0_CONTROL_REG                \
+	AOBUS_REG_ADDR(AO_I2C_M_0_CONTROL_REG)
+#define AO_I2C_M_0_SLAVE_ADDR ((0x01 << 10) | (0x41 << 2))
+#define P_AO_I2C_M_0_SLAVE_ADDR                 \
+	AOBUS_REG_ADDR(AO_I2C_M_0_SLAVE_ADDR)
+#define AO_I2C_M_0_TOKEN_LIST0 ((0x01 << 10) | (0x42 << 2))
+#define P_AO_I2C_M_0_TOKEN_LIST0                \
+	AOBUS_REG_ADDR(AO_I2C_M_0_TOKEN_LIST0)
+#define AO_I2C_M_0_TOKEN_LIST1 ((0x01 << 10) | (0x43 << 2))
+#define P_AO_I2C_M_0_TOKEN_LIST1                \
+	AOBUS_REG_ADDR(AO_I2C_M_0_TOKEN_LIST1)
+#define AO_I2C_M_0_WDATA_REG0 ((0x01 << 10) | (0x44 << 2))
+#define P_AO_I2C_M_0_WDATA_REG0                 \
+	AOBUS_REG_ADDR(AO_I2C_M_0_WDATA_REG0)
+#define AO_I2C_M_0_WDATA_REG1 ((0x01 << 10) | (0x45 << 2))
+#define P_AO_I2C_M_0_WDATA_REG1                 \
+	AOBUS_REG_ADDR(AO_I2C_M_0_WDATA_REG1)
+#define AO_I2C_M_0_RDATA_REG0 ((0x01 << 10) | (0x46 << 2))
+#define P_AO_I2C_M_0_RDATA_REG0                 \
+	AOBUS_REG_ADDR(AO_I2C_M_0_RDATA_REG0)
+#define AO_I2C_M_0_RDATA_REG1 ((0x01 << 10) | (0x47 << 2))
+#define P_AO_I2C_M_0_RDATA_REG1                 \
+	AOBUS_REG_ADDR(AO_I2C_M_0_RDATA_REG1)
+#define AO_I2C_S_CONTROL_REG ((0x01 << 10) | (0x50 << 2))
+#define P_AO_I2C_S_CONTROL_REG          AOBUS_REG_ADDR(AO_I2C_S_CONTROL_REG)
+#define AO_I2C_S_SEND_REG ((0x01 << 10) | (0x51 << 2))
+#define P_AO_I2C_S_SEND_REG             AOBUS_REG_ADDR(AO_I2C_S_SEND_REG)
+#define AO_I2C_S_RECV_REG ((0x01 << 10) | (0x52 << 2))
+#define P_AO_I2C_S_RECV_REG             AOBUS_REG_ADDR(AO_I2C_S_RECV_REG)
+#define AO_I2C_S_CNTL1_REG ((0x01 << 10) | (0x53 << 2))
+#define P_AO_I2C_S_CNTL1_REG            AOBUS_REG_ADDR(AO_I2C_S_CNTL1_REG)
+#define AO_RTC_ADDR0 ((0x01 << 10) | (0xd0 << 2))
+#define P_AO_RTC_ADDR0          AOBUS_REG_ADDR(AO_RTC_ADDR0)
+#define AO_RTC_ADDR1 ((0x01 << 10) | (0xd1 << 2))
+#define P_AO_RTC_ADDR1          AOBUS_REG_ADDR(AO_RTC_ADDR1)
+#define AO_RTC_ADDR2 ((0x01 << 10) | (0xd2 << 2))
+#define P_AO_RTC_ADDR2          AOBUS_REG_ADDR(AO_RTC_ADDR2)
+#define AO_RTC_ADDR3 ((0x01 << 10) | (0xd3 << 2))
+#define P_AO_RTC_ADDR3          AOBUS_REG_ADDR(AO_RTC_ADDR3)
+#define AO_RTC_ADDR4 ((0x01 << 10) | (0xd4 << 2))
+#define P_AO_RTC_ADDR4          AOBUS_REG_ADDR(AO_RTC_ADDR4)
+#define AO_MF_IR_DEC_LDR_ACTIVE ((0x01 << 10) | (0x60 << 2))
+#define P_AO_MF_IR_DEC_LDR_ACTIVE               \
+	AOBUS_REG_ADDR(AO_MF_IR_DEC_LDR_ACTIVE)
+#define AO_MF_IR_DEC_LDR_IDLE ((0x01 << 10) | (0x61 << 2))
+#define P_AO_MF_IR_DEC_LDR_IDLE                 \
+	AOBUS_REG_ADDR(AO_MF_IR_DEC_LDR_IDLE)
+#define AO_MF_IR_DEC_LDR_REPEAT ((0x01 << 10) | (0x62 << 2))
+#define P_AO_MF_IR_DEC_LDR_REPEAT               \
+	AOBUS_REG_ADDR(AO_MF_IR_DEC_LDR_REPEAT)
+#define AO_MF_IR_DEC_BIT_0 ((0x01 << 10) | (0x63 << 2))
+#define P_AO_MF_IR_DEC_BIT_0            AOBUS_REG_ADDR(AO_MF_IR_DEC_BIT_0)
+#define AO_MF_IR_DEC_REG0 ((0x01 << 10) | (0x64 << 2))
+#define P_AO_MF_IR_DEC_REG0             AOBUS_REG_ADDR(AO_MF_IR_DEC_REG0)
+#define AO_MF_IR_DEC_FRAME ((0x01 << 10) | (0x65 << 2))
+#define P_AO_MF_IR_DEC_FRAME            AOBUS_REG_ADDR(AO_MF_IR_DEC_FRAME)
+#define AO_MF_IR_DEC_STATUS ((0x01 << 10) | (0x66 << 2))
+#define P_AO_MF_IR_DEC_STATUS           AOBUS_REG_ADDR(AO_MF_IR_DEC_STATUS)
+#define AO_MF_IR_DEC_REG1 ((0x01 << 10) | (0x67 << 2))
+#define P_AO_MF_IR_DEC_REG1             AOBUS_REG_ADDR(AO_MF_IR_DEC_REG1)
+#define AO_MF_IR_DEC_REG2 ((0x01 << 10) | (0x68 << 2))
+#define P_AO_MF_IR_DEC_REG2             AOBUS_REG_ADDR(AO_MF_IR_DEC_REG2)
+#define AO_MF_IR_DEC_DURATN2 ((0x01 << 10) | (0x69 << 2))
+#define P_AO_MF_IR_DEC_DURATN2          AOBUS_REG_ADDR(AO_MF_IR_DEC_DURATN2)
+#define AO_MF_IR_DEC_DURATN3 ((0x01 << 10) | (0x6a << 2))
+#define P_AO_MF_IR_DEC_DURATN3          AOBUS_REG_ADDR(AO_MF_IR_DEC_DURATN3)
+#define AO_MF_IR_DEC_FRAME1 ((0x01 << 10) | (0x6b << 2))
+#define P_AO_MF_IR_DEC_FRAME1           AOBUS_REG_ADDR(AO_MF_IR_DEC_FRAME1)
+#define AM_DDR_PLL_CNTL 0x0400
+#define P_AM_DDR_PLL_CNTL               MMC_REG_ADDR(AM_DDR_PLL_CNTL)
+#define AM_DDR_PLL_CNTL1 0x0404
+#define P_AM_DDR_PLL_CNTL1              MMC_REG_ADDR(AM_DDR_PLL_CNTL1)
+#define AM_DDR_PLL_CNTL2 0x0408
+#define P_AM_DDR_PLL_CNTL2              MMC_REG_ADDR(AM_DDR_PLL_CNTL2)
+#define AM_DDR_PLL_CNTL3 0x040c
+#define P_AM_DDR_PLL_CNTL3              MMC_REG_ADDR(AM_DDR_PLL_CNTL3)
+#define AM_DDR_PLL_CNTL4 0x0410
+#define P_AM_DDR_PLL_CNTL4              MMC_REG_ADDR(AM_DDR_PLL_CNTL4)
+#define AM_DDR_PLL_STS 0x0414
+#define P_AM_DDR_PLL_STS                MMC_REG_ADDR(AM_DDR_PLL_STS)
+#define AM_DDR_CLK_CNTL 0x0418
+#define P_AM_DDR_CLK_CNTL               MMC_REG_ADDR(AM_DDR_CLK_CNTL)
+#define DDR0_PCTL_SCFG 0x0000
+#define P_DDR0_PCTL_SCFG                MMC_REG_ADDR(DDR0_PCTL_SCFG)
+#define DDR0_PCTL_SCTL 0x0004
+#define P_DDR0_PCTL_SCTL                MMC_REG_ADDR(DDR0_PCTL_SCTL)
+#define DDR0_PCTL_STAT 0x0008
+#define P_DDR0_PCTL_STAT                MMC_REG_ADDR(DDR0_PCTL_STAT)
+#define DDR0_PCTL_INTRSTAT 0x000c
+#define P_DDR0_PCTL_INTRSTAT            MMC_REG_ADDR(DDR0_PCTL_INTRSTAT)
+#define DDR0_PCTL_POWSTAT 0x0048
+#define P_DDR0_PCTL_POWSTAT             MMC_REG_ADDR(DDR0_PCTL_POWSTAT)
+#define DDR0_PCTL_MRRSTAT0 0x0064
+#define P_DDR0_PCTL_MRRSTAT0            MMC_REG_ADDR(DDR0_PCTL_MRRSTAT0)
+#define DDR0_PCTL_CMDTSTAT 0x004c
+#define P_DDR0_PCTL_CMDTSTAT            MMC_REG_ADDR(DDR0_PCTL_CMDTSTAT)
+#define DDR0_PCTL_MCMD 0x0040
+#define P_DDR0_PCTL_MCMD                MMC_REG_ADDR(DDR0_PCTL_MCMD)
+#define DDR0_PCTL_MRRSTAT1 0x0068
+#define P_DDR0_PCTL_MRRSTAT1            MMC_REG_ADDR(DDR0_PCTL_MRRSTAT1)
+#define DDR0_PCTL_MRRCFG0 0x0060
+#define P_DDR0_PCTL_MRRCFG0             MMC_REG_ADDR(DDR0_PCTL_MRRCFG0)
+#define DDR0_PCTL_CMDTSTATEN 0x0050
+#define P_DDR0_PCTL_CMDTSTATEN          MMC_REG_ADDR(DDR0_PCTL_CMDTSTATEN)
+#define DDR0_PCTL_POWCTL 0x0044
+#define P_DDR0_PCTL_POWCTL              MMC_REG_ADDR(DDR0_PCTL_POWCTL)
+#define DDR0_PCTL_PPCFG 0x0084
+#define P_DDR0_PCTL_PPCFG               MMC_REG_ADDR(DDR0_PCTL_PPCFG)
+#define DDR0_PCTL_MCFG1 0x007c
+#define P_DDR0_PCTL_MCFG1               MMC_REG_ADDR(DDR0_PCTL_MCFG1)
+#define DDR0_PCTL_MSTAT 0x0088
+#define P_DDR0_PCTL_MSTAT               MMC_REG_ADDR(DDR0_PCTL_MSTAT)
+#define DDR0_PCTL_MCFG 0x0080
+#define P_DDR0_PCTL_MCFG                MMC_REG_ADDR(DDR0_PCTL_MCFG)
+#define DDR0_PCTL_DTUAWDT 0x00b0
+#define P_DDR0_PCTL_DTUAWDT             MMC_REG_ADDR(DDR0_PCTL_DTUAWDT)
+#define DDR0_PCTL_DTUPRD2 0x00a8
+#define P_DDR0_PCTL_DTUPRD2             MMC_REG_ADDR(DDR0_PCTL_DTUPRD2)
+#define DDR0_PCTL_DTUPRD3 0x00ac
+#define P_DDR0_PCTL_DTUPRD3             MMC_REG_ADDR(DDR0_PCTL_DTUPRD3)
+#define DDR0_PCTL_DTUNE 0x009c
+#define P_DDR0_PCTL_DTUNE               MMC_REG_ADDR(DDR0_PCTL_DTUNE)
+#define DDR0_PCTL_DTUPDES 0x0094
+#define P_DDR0_PCTL_DTUPDES             MMC_REG_ADDR(DDR0_PCTL_DTUPDES)
+#define DDR0_PCTL_DTUNA 0x0098
+#define P_DDR0_PCTL_DTUNA               MMC_REG_ADDR(DDR0_PCTL_DTUNA)
+#define DDR0_PCTL_DTUPRD0 0x00a0
+#define P_DDR0_PCTL_DTUPRD0             MMC_REG_ADDR(DDR0_PCTL_DTUPRD0)
+#define DDR0_PCTL_DTUPRD1 0x00a4
+#define P_DDR0_PCTL_DTUPRD1             MMC_REG_ADDR(DDR0_PCTL_DTUPRD1)
+#define DDR0_PCTL_TCKSRE 0x0124
+#define P_DDR0_PCTL_TCKSRE              MMC_REG_ADDR(DDR0_PCTL_TCKSRE)
+#define DDR0_PCTL_TZQCSI 0x011c
+#define P_DDR0_PCTL_TZQCSI              MMC_REG_ADDR(DDR0_PCTL_TZQCSI)
+#define DDR0_PCTL_TINIT 0x00c4
+#define P_DDR0_PCTL_TINIT               MMC_REG_ADDR(DDR0_PCTL_TINIT)
+#define DDR0_PCTL_TDPD 0x0144
+#define P_DDR0_PCTL_TDPD                MMC_REG_ADDR(DDR0_PCTL_TDPD)
+#define DDR0_PCTL_TOGCNT1U 0x00c0
+#define P_DDR0_PCTL_TOGCNT1U            MMC_REG_ADDR(DDR0_PCTL_TOGCNT1U)
+#define DDR0_PCTL_TCKE 0x012c
+#define P_DDR0_PCTL_TCKE                MMC_REG_ADDR(DDR0_PCTL_TCKE)
+#define DDR0_PCTL_TMOD 0x0130
+#define P_DDR0_PCTL_TMOD                MMC_REG_ADDR(DDR0_PCTL_TMOD)
+#define DDR0_PCTL_TEXSR 0x010c
+#define P_DDR0_PCTL_TEXSR               MMC_REG_ADDR(DDR0_PCTL_TEXSR)
+#define DDR0_PCTL_TAL 0x00e4
+#define P_DDR0_PCTL_TAL                 MMC_REG_ADDR(DDR0_PCTL_TAL)
+#define DDR0_PCTL_TRTP 0x0100
+#define P_DDR0_PCTL_TRTP                MMC_REG_ADDR(DDR0_PCTL_TRTP)
+#define DDR0_PCTL_TCKSRX 0x0128
+#define P_DDR0_PCTL_TCKSRX              MMC_REG_ADDR(DDR0_PCTL_TCKSRX)
+#define DDR0_PCTL_TRTW 0x00e0
+#define P_DDR0_PCTL_TRTW                MMC_REG_ADDR(DDR0_PCTL_TRTW)
+#define DDR0_PCTL_TCWL 0x00ec
+#define P_DDR0_PCTL_TCWL                MMC_REG_ADDR(DDR0_PCTL_TCWL)
+#define DDR0_PCTL_TWR 0x0104
+#define P_DDR0_PCTL_TWR                 MMC_REG_ADDR(DDR0_PCTL_TWR)
+#define DDR0_PCTL_TCL 0x00e8
+#define P_DDR0_PCTL_TCL                 MMC_REG_ADDR(DDR0_PCTL_TCL)
+#define DDR0_PCTL_TDQS 0x0120
+#define P_DDR0_PCTL_TDQS                MMC_REG_ADDR(DDR0_PCTL_TDQS)
+#define DDR0_PCTL_TRSTH 0x00c8
+#define P_DDR0_PCTL_TRSTH               MMC_REG_ADDR(DDR0_PCTL_TRSTH)
+#define DDR0_PCTL_TRCD 0x00f8
+#define P_DDR0_PCTL_TRCD                MMC_REG_ADDR(DDR0_PCTL_TRCD)
+#define DDR0_PCTL_TXP 0x0110
+#define P_DDR0_PCTL_TXP                 MMC_REG_ADDR(DDR0_PCTL_TXP)
+#define DDR0_PCTL_TOGCNT100N 0x00cc
+#define P_DDR0_PCTL_TOGCNT100N          MMC_REG_ADDR(DDR0_PCTL_TOGCNT100N)
+#define DDR0_PCTL_TMRD 0x00d4
+#define P_DDR0_PCTL_TMRD                MMC_REG_ADDR(DDR0_PCTL_TMRD)
+#define DDR0_PCTL_TRSTL 0x0134
+#define P_DDR0_PCTL_TRSTL               MMC_REG_ADDR(DDR0_PCTL_TRSTL)
+#define DDR0_PCTL_TREFI 0x00d0
+#define P_DDR0_PCTL_TREFI               MMC_REG_ADDR(DDR0_PCTL_TREFI)
+#define DDR0_PCTL_TRAS 0x00f0
+#define P_DDR0_PCTL_TRAS                MMC_REG_ADDR(DDR0_PCTL_TRAS)
+#define DDR0_PCTL_TREFI_MEM_DDR3 0x0148
+#define P_DDR0_PCTL_TWTR                MMC_REG_ADDR(DDR0_PCTL_TWTR)
+#define DDR0_PCTL_TRC 0x00f4
+#define P_DDR0_PCTL_TRC                 MMC_REG_ADDR(DDR0_PCTL_TRC)
+#define DDR0_PCTL_TRFC 0x00d8
+#define P_DDR0_PCTL_TRFC                MMC_REG_ADDR(DDR0_PCTL_TRFC)
+#define DDR0_PCTL_TMRR 0x013c
+#define P_DDR0_PCTL_TMRR                MMC_REG_ADDR(DDR0_PCTL_TMRR)
+#define DDR0_PCTL_TCKESR 0x0140
+#define P_DDR0_PCTL_TCKESR              MMC_REG_ADDR(DDR0_PCTL_TCKESR)
+#define DDR0_PCTL_TZQCL 0x0138
+#define P_DDR0_PCTL_TZQCL               MMC_REG_ADDR(DDR0_PCTL_TZQCL)
+#define DDR0_PCTL_TRRD 0x00fc
+#define P_DDR0_PCTL_TRRD                MMC_REG_ADDR(DDR0_PCTL_TRRD)
+#define DDR0_PCTL_TRP 0x00dc
+#define P_DDR0_PCTL_TRP                 MMC_REG_ADDR(DDR0_PCTL_TRP)
+#define DDR0_PCTL_TZQCS 0x0118
+#define P_DDR0_PCTL_TZQCS               MMC_REG_ADDR(DDR0_PCTL_TZQCS)
+#define DDR0_PCTL_TXPDLL 0x0114
+#define P_DDR0_PCTL_TXPDLL              MMC_REG_ADDR(DDR0_PCTL_TXPDLL)
+#define DDR0_PCTL_ECCCFG 0x0180
+#define P_DDR0_PCTL_ECCCFG              MMC_REG_ADDR(DDR0_PCTL_ECCCFG)
+#define DDR0_PCTL_ECCLOG 0x018c
+#define P_DDR0_PCTL_ECCLOG              MMC_REG_ADDR(DDR0_PCTL_ECCLOG)
+#define DDR0_PCTL_ECCCLR 0x0188
+#define P_DDR0_PCTL_ECCCLR              MMC_REG_ADDR(DDR0_PCTL_ECCCLR)
+#define DDR0_PCTL_ECCTST 0x0184
+#define P_DDR0_PCTL_ECCTST              MMC_REG_ADDR(DDR0_PCTL_ECCTST)
+#define DDR0_PCTL_DTUWD0 0x0210
+#define P_DDR0_PCTL_DTUWD0              MMC_REG_ADDR(DDR0_PCTL_DTUWD0)
+#define DDR0_PCTL_DTUWD1 0x0214
+#define P_DDR0_PCTL_DTUWD1              MMC_REG_ADDR(DDR0_PCTL_DTUWD1)
+#define DDR0_PCTL_DTUWACTL 0x0200
+#define P_DDR0_PCTL_DTUWACTL            MMC_REG_ADDR(DDR0_PCTL_DTUWACTL)
+#define DDR0_PCTL_DTULFSRRD 0x0238
+#define P_DDR0_PCTL_DTULFSRRD           MMC_REG_ADDR(DDR0_PCTL_DTULFSRRD)
+#define DDR0_PCTL_DTUWD2 0x0218
+#define P_DDR0_PCTL_DTUWD2              MMC_REG_ADDR(DDR0_PCTL_DTUWD2)
+#define DDR0_PCTL_DTUWD3 0x021c
+#define P_DDR0_PCTL_DTUWD3              MMC_REG_ADDR(DDR0_PCTL_DTUWD3)
+#define DDR0_PCTL_DTULFSRWD 0x0234
+#define P_DDR0_PCTL_DTULFSRWD           MMC_REG_ADDR(DDR0_PCTL_DTULFSRWD)
+#define DDR0_PCTL_DTURACTL 0x0204
+#define P_DDR0_PCTL_DTURACTL            MMC_REG_ADDR(DDR0_PCTL_DTURACTL)
+#define DDR0_PCTL_DTUWDM 0x0220
+#define P_DDR0_PCTL_DTUWDM              MMC_REG_ADDR(DDR0_PCTL_DTUWDM)
+#define DDR0_PCTL_DTURD0 0x0224
+#define P_DDR0_PCTL_DTURD0              MMC_REG_ADDR(DDR0_PCTL_DTURD0)
+#define DDR0_PCTL_DTURD1 0x0228
+#define P_DDR0_PCTL_DTURD1              MMC_REG_ADDR(DDR0_PCTL_DTURD1)
+#define DDR0_PCTL_DTURD2 0x022c
+#define P_DDR0_PCTL_DTURD2              MMC_REG_ADDR(DDR0_PCTL_DTURD2)
+#define DDR0_PCTL_DTURD3 0x0230
+#define P_DDR0_PCTL_DTURD3              MMC_REG_ADDR(DDR0_PCTL_DTURD3)
+#define DDR0_PCTL_DTUCFG 0x0208
+#define P_DDR0_PCTL_DTUCFG              MMC_REG_ADDR(DDR0_PCTL_DTUCFG)
+#define DDR0_PCTL_DTUEAF 0x023c
+#define P_DDR0_PCTL_DTUEAF              MMC_REG_ADDR(DDR0_PCTL_DTUEAF)
+#define DDR0_PCTL_DTUECTL 0x020c
+#define P_DDR0_PCTL_DTUECTL             MMC_REG_ADDR(DDR0_PCTL_DTUECTL)
+#define DDR0_PCTL_DFIODTCFG1 0x0248
+
+#define DDR0_PCTL_DFITDRAMCLKDIS 0x02d4
+#define P_DDR0_PCTL_DFITDRAMCLKDIS              \
+	MMC_REG_ADDR(DDR0_PCTL_DFITDRAMCLKDIS)
+#define DDR0_PCTL_DFILPCFG0 0x02f0
+#define P_DDR0_PCTL_DFILPCFG0           \
+	MMC_REG_ADDR(DDR0_PCTL_DFILPCFG0)
+#define DDR0_PCTL_DFITRWRLVLDELAY0 0x0318
+#define P_DDR0_PCTL_DFITRWRLVLDELAY0            \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLDELAY0)
+#define DDR0_PCTL_DFITRWRLVLDELAY1 0x031c
+#define P_DDR0_PCTL_DFITRWRLVLDELAY1            \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLDELAY1)
+#define DDR0_PCTL_DFITRWRLVLDELAY2 0x0320
+#define P_DDR0_PCTL_DFITRWRLVLDELAY2            \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLDELAY2)
+#define DDR0_PCTL_DFITRRDLVLRESP0 0x030c
+#define P_DDR0_PCTL_DFITRRDLVLRESP0             \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLRESP0)
+#define DDR0_PCTL_DFITRRDLVLRESP1 0x0310
+#define P_DDR0_PCTL_DFITRRDLVLRESP1             \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLRESP1)
+#define DDR0_PCTL_DFITRRDLVLRESP2 0x0314
+#define P_DDR0_PCTL_DFITRRDLVLRESP2             \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLRESP2)
+#define DDR0_PCTL_DFITRWRLVLRESP0 0x0300
+#define P_DDR0_PCTL_DFITRWRLVLRESP0             \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLRESP0)
+#define DDR0_PCTL_DFITRRDLVLDELAY0 0x0324
+#define P_DDR0_PCTL_DFITRRDLVLDELAY0            \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLDELAY0)
+#define DDR0_PCTL_DFITRRDLVLDELAY1 0x0328
+#define P_DDR0_PCTL_DFITRRDLVLDELAY1            \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLDELAY1)
+#define DDR0_PCTL_DFITRWRLVLRESP1 0x0304
+#define P_DDR0_PCTL_DFITRWRLVLRESP1             \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLRESP1)
+#define DDR0_PCTL_DFITRRDLVLDELAY2 0x032c
+#define P_DDR0_PCTL_DFITRRDLVLDELAY2            \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLDELAY2)
+#define DDR0_PCTL_DFITRWRLVLRESP2 0x0308
+#define P_DDR0_PCTL_DFITRWRLVLRESP2             \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRWRLVLRESP2)
+#define DDR0_PCTL_DFITRRDLVLGATEDELAY0 0x0330
+#define P_DDR0_PCTL_DFITRRDLVLGATEDELAY0                \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLGATEDELAY0)
+#define DDR0_PCTL_DFITRCMD 0x033c
+#define P_DDR0_PCTL_DFITRCMD            MMC_REG_ADDR(DDR0_PCTL_DFITRCMD)
+#define DDR0_PCTL_DFITRRDLVLGATEDELAY1 0x0334
+#define P_DDR0_PCTL_DFITRRDLVLGATEDELAY1                \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLGATEDELAY1)
+#define DDR0_PCTL_DFITRRDLVLGATEDELAY2 0x0338
+#define P_DDR0_PCTL_DFITRRDLVLGATEDELAY2                \
+	MMC_REG_ADDR(DDR0_PCTL_DFITRRDLVLGATEDELAY2)
+#define DDR0_PCTL_IPTR 0x03fc
+#define P_DDR0_PCTL_IPTR                MMC_REG_ADDR(DDR0_PCTL_IPTR)
+#define DDR0_PCTL_IPVR 0x03f8
+#define P_DDR0_PCTL_IPVR                MMC_REG_ADDR(DDR0_PCTL_IPVR)
+#define DDR0_PUB_RIDR (0x1000 + (0x00 << 2))
+#define P_DDR0_PUB_RIDR                 MMC_REG_ADDR(DDR0_PUB_RIDR)
+#define DDR0_PUB_PIR (0x1000 + (0x01 << 2))
+#define P_DDR0_PUB_PIR          MMC_REG_ADDR(DDR0_PUB_PIR)
+#define DDR0_PUB_PGCR0 (0x1000 + (0x02 << 2))
+#define P_DDR0_PUB_PGCR0                MMC_REG_ADDR(DDR0_PUB_PGCR0)
+#define DDR0_PUB_PGCR1 (0x1000 + (0x03 << 2))
+#define P_DDR0_PUB_PGCR1                MMC_REG_ADDR(DDR0_PUB_PGCR1)
+#define DDR0_PUB_PGCR2 (0x1000 + (0x04 << 2))
+#define P_DDR0_PUB_PGCR2                MMC_REG_ADDR(DDR0_PUB_PGCR2)
+#define DDR0_PUB_PGCR3 (0x1000 + (0x05 << 2))
+#define P_DDR0_PUB_PGCR3                MMC_REG_ADDR(DDR0_PUB_PGCR3)
+#define DDR0_PUB_PGSR0 (0x1000 + (0x06 << 2))
+#define P_DDR0_PUB_PGSR0                MMC_REG_ADDR(DDR0_PUB_PGSR0)
+#define DDR0_PUB_PGSR1 (0x1000 + (0x07 << 2))
+#define P_DDR0_PUB_PGSR1                MMC_REG_ADDR(DDR0_PUB_PGSR1)
+#define DDR0_PUB_PLLCR (0x1000 + (0x08 << 2))
+#define P_DDR0_PUB_PLLCR                MMC_REG_ADDR(DDR0_PUB_PLLCR)
+#define DDR0_PUB_PTR0 (0x1000 + (0x09 << 2))
+#define P_DDR0_PUB_PTR0                 MMC_REG_ADDR(DDR0_PUB_PTR0)
+#define DDR0_PUB_PTR1 (0x1000 + (0x0A << 2))
+#define P_DDR0_PUB_PTR1                 MMC_REG_ADDR(DDR0_PUB_PTR1)
+#define DDR0_PUB_PTR2 (0x1000 + (0x0B << 2))
+#define P_DDR0_PUB_PTR2                 MMC_REG_ADDR(DDR0_PUB_PTR2)
+#define DDR0_PUB_PTR3 (0x1000 + (0x0C << 2))
+#define P_DDR0_PUB_PTR3                 MMC_REG_ADDR(DDR0_PUB_PTR3)
+#define DDR0_PUB_PTR4 (0x1000 + (0x0D << 2))
+#define P_DDR0_PUB_PTR4                 MMC_REG_ADDR(DDR0_PUB_PTR4)
+#define DDR0_PUB_ACMDLR (0x1000 + (0x0E << 2))
+#define P_DDR0_PUB_ACMDLR               MMC_REG_ADDR(DDR0_PUB_ACMDLR)
+#define DDR0_PUB_ACLCDLR (0x1000 + (0x0F << 2))
+#define P_DDR0_PUB_ACLCDLR              MMC_REG_ADDR(DDR0_PUB_ACLCDLR)
+#define DDR0_PUB_ACBDLR0 (0x1000 + (0x10 << 2))
+#define P_DDR0_PUB_ACBDLR0              MMC_REG_ADDR(DDR0_PUB_ACBDLR0)
+#define DDR0_PUB_ACBDLR1 (0x1000 + (0x11 << 2))
+#define P_DDR0_PUB_ACBDLR1              MMC_REG_ADDR(DDR0_PUB_ACBDLR1)
+#define DDR0_PUB_ACBDLR2 (0x1000 + (0x12 << 2))
+#define P_DDR0_PUB_ACBDLR2              MMC_REG_ADDR(DDR0_PUB_ACBDLR2)
+#define DDR0_PUB_ACBDLR3 (0x1000 + (0x13 << 2))
+#define P_DDR0_PUB_ACBDLR3              MMC_REG_ADDR(DDR0_PUB_ACBDLR3)
+#define DDR0_PUB_ACBDLR4 (0x1000 + (0x14 << 2))
+#define P_DDR0_PUB_ACBDLR4              MMC_REG_ADDR(DDR0_PUB_ACBDLR4)
+#define DDR0_PUB_ACBDLR5 (0x1000 + (0x15 << 2))
+#define P_DDR0_PUB_ACBDLR5              MMC_REG_ADDR(DDR0_PUB_ACBDLR5)
+#define DDR0_PUB_ACBDLR6 (0x1000 + (0x16 << 2))
+#define P_DDR0_PUB_ACBDLR6              MMC_REG_ADDR(DDR0_PUB_ACBDLR6)
+#define DDR0_PUB_ACBDLR7 (0x1000 + (0x17 << 2))
+#define P_DDR0_PUB_ACBDLR7              MMC_REG_ADDR(DDR0_PUB_ACBDLR7)
+#define DDR0_PUB_ACBDLR8 (0x1000 + (0x18 << 2))
+#define P_DDR0_PUB_ACBDLR8              MMC_REG_ADDR(DDR0_PUB_ACBDLR8)
+#define DDR0_PUB_ACBDLR9 (0x1000 + (0x19 << 2))
+#define P_DDR0_PUB_ACBDLR9              MMC_REG_ADDR(DDR0_PUB_ACBDLR9)
+#define DDR0_PUB_ACIOCR0 (0x1000 + (0x1A << 2))
+#define P_DDR0_PUB_ACIOCR0              MMC_REG_ADDR(DDR0_PUB_ACIOCR0)
+#define DDR0_PUB_ACIOCR1 (0x1000 + (0x1B << 2))
+#define P_DDR0_PUB_ACIOCR1              MMC_REG_ADDR(DDR0_PUB_ACIOCR1)
+#define DDR0_PUB_ACIOCR2 (0x1000 + (0x1C << 2))
+#define P_DDR0_PUB_ACIOCR2              MMC_REG_ADDR(DDR0_PUB_ACIOCR2)
+#define DDR0_PUB_ACIOCR3 (0x1000 + (0x1D << 2))
+#define P_DDR0_PUB_ACIOCR3              MMC_REG_ADDR(DDR0_PUB_ACIOCR3)
+#define DDR0_PUB_ACIOCR4 (0x1000 + (0x1E << 2))
+#define P_DDR0_PUB_ACIOCR4              MMC_REG_ADDR(DDR0_PUB_ACIOCR4)
+#define DDR0_PUB_ACIOCR5 (0x1000 + (0x1F << 2))
+#define P_DDR0_PUB_ACIOCR5              MMC_REG_ADDR(DDR0_PUB_ACIOCR5)
+#define DDR0_PUB_DXCCR (0x1000 + (0x20 << 2))
+#define P_DDR0_PUB_DXCCR                MMC_REG_ADDR(DDR0_PUB_DXCCR)
+#define DDR0_PUB_DSGCR (0x1000 + (0x21 << 2))
+#define P_DDR0_PUB_DSGCR                MMC_REG_ADDR(DDR0_PUB_DSGCR)
+#define DDR0_PUB_DCR (0x1000 + (0x22 << 2))
+#define P_DDR0_PUB_DCR          MMC_REG_ADDR(DDR0_PUB_DCR)
+#define DDR0_PUB_DTPR0 (0x1000 + (0x23 << 2))
+#define P_DDR0_PUB_DTPR0                MMC_REG_ADDR(DDR0_PUB_DTPR0)
+#define DDR0_PUB_DTPR1 (0x1000 + (0x24 << 2))
+#define P_DDR0_PUB_DTPR1                MMC_REG_ADDR(DDR0_PUB_DTPR1)
+#define DDR0_PUB_DTPR2 (0x1000 + (0x25 << 2))
+#define P_DDR0_PUB_DTPR2                MMC_REG_ADDR(DDR0_PUB_DTPR2)
+#define DDR0_PUB_DTPR3 (0x1000 + (0x26 << 2))
+#define P_DDR0_PUB_DTPR3                MMC_REG_ADDR(DDR0_PUB_DTPR3)
+#define DDR0_PUB_MR0 (0x1000 + (0x27 << 2))
+#define P_DDR0_PUB_MR0          MMC_REG_ADDR(DDR0_PUB_MR0)
+#define DDR0_PUB_MR1 (0x1000 + (0x28 << 2))
+#define P_DDR0_PUB_MR1          MMC_REG_ADDR(DDR0_PUB_MR1)
+#define DDR0_PUB_MR2 (0x1000 + (0x29 << 2))
+#define P_DDR0_PUB_MR2          MMC_REG_ADDR(DDR0_PUB_MR2)
+#define DDR0_PUB_MR3 (0x1000 + (0x2A << 2))
+#define P_DDR0_PUB_MR3          MMC_REG_ADDR(DDR0_PUB_MR3)
+#define DDR0_PUB_ODTCR (0x1000 + (0x2B << 2))
+#define P_DDR0_PUB_ODTCR                MMC_REG_ADDR(DDR0_PUB_ODTCR)
+#define DDR0_PUB_DTCR (0x1000 + (0x2C << 2))
+#define P_DDR0_PUB_DTCR                 MMC_REG_ADDR(DDR0_PUB_DTCR)
+#define DDR0_PUB_DTAR0 (0x1000 + (0x2D << 2))
+#define P_DDR0_PUB_DTAR0                MMC_REG_ADDR(DDR0_PUB_DTAR0)
+#define DDR0_PUB_DTAR1 (0x1000 + (0x2E << 2))
+#define P_DDR0_PUB_DTAR1                MMC_REG_ADDR(DDR0_PUB_DTAR1)
+#define DDR0_PUB_DTAR2 (0x1000 + (0x2F << 2))
+#define P_DDR0_PUB_DTAR2                MMC_REG_ADDR(DDR0_PUB_DTAR2)
+#define DDR0_PUB_DTAR3 (0x1000 + (0x30 << 2))
+#define P_DDR0_PUB_DTAR3                MMC_REG_ADDR(DDR0_PUB_DTAR3)
+#define DDR0_PUB_DTDR0 (0x1000 + (0x31 << 2))
+#define P_DDR0_PUB_DTDR0                MMC_REG_ADDR(DDR0_PUB_DTDR0)
+#define DDR0_PUB_DTDR1 (0x1000 + (0x32 << 2))
+#define P_DDR0_PUB_DTDR1                MMC_REG_ADDR(DDR0_PUB_DTDR1)
+#define DDR0_PUB_DTEDR0 (0x1000 + (0x33 << 2))
+#define P_DDR0_PUB_DTEDR0               MMC_REG_ADDR(DDR0_PUB_DTEDR0)
+#define DDR0_PUB_DTEDR1 (0x1000 + (0x34 << 2))
+#define P_DDR0_PUB_DTEDR1               MMC_REG_ADDR(DDR0_PUB_DTEDR1)
+#define DDR0_PUB_RDIMMGCR0 (0x1000 + (0x35 << 2))
+#define P_DDR0_PUB_RDIMMGCR0            MMC_REG_ADDR(DDR0_PUB_RDIMMGCR0)
+#define DDR0_PUB_RDIMMGCR1 (0x1000 + (0x36 << 2))
+#define P_DDR0_PUB_RDIMMGCR1            MMC_REG_ADDR(DDR0_PUB_RDIMMGCR1)
+#define DDR0_PUB_RDIMMCR0 (0x1000 + (0x37 << 2))
+#define P_DDR0_PUB_RDIMMCR0             MMC_REG_ADDR(DDR0_PUB_RDIMMCR0)
+#define DDR0_PUB_RDIMMCR1 (0x1000 + (0x38 << 2))
+#define P_DDR0_PUB_RDIMMCR1             MMC_REG_ADDR(DDR0_PUB_RDIMMCR1)
+#define DDR0_PUB_GPR0 (0x1000 + (0x39 << 2))
+#define P_DDR0_PUB_GPR0                 MMC_REG_ADDR(DDR0_PUB_GPR0)
+#define DDR0_PUB_GPR1 (0x1000 + (0x3A << 2))
+#define P_DDR0_PUB_GPR1                 MMC_REG_ADDR(DDR0_PUB_GPR1)
+#define DDR0_PUB_CATR0 (0x1000 + (0x3B << 2))
+#define P_DDR0_PUB_CATR0                MMC_REG_ADDR(DDR0_PUB_CATR0)
+#define DDR0_PUB_CATR1 (0x1000 + (0x3C << 2))
+#define P_DDR0_PUB_CATR1                MMC_REG_ADDR(DDR0_PUB_CATR1)
+#define DDR0_PUB_DCUAR (0x1000 + (0x60 << 2))
+#define P_DDR0_PUB_DCUAR                MMC_REG_ADDR(DDR0_PUB_DCUAR)
+#define DDR0_PUB_DCUDR (0x1000 + (0x61 << 2))
+#define P_DDR0_PUB_DCUDR                MMC_REG_ADDR(DDR0_PUB_DCUDR)
+#define DDR0_PUB_DCURR (0x1000 + (0x62 << 2))
+#define P_DDR0_PUB_DCURR                MMC_REG_ADDR(DDR0_PUB_DCURR)
+#define DDR0_PUB_DCULR (0x1000 + (0x63 << 2))
+#define P_DDR0_PUB_DCULR                MMC_REG_ADDR(DDR0_PUB_DCULR)
+#define DDR0_PUB_DCUGCR (0x1000 + (0x64 << 2))
+#define P_DDR0_PUB_DCUGCR               MMC_REG_ADDR(DDR0_PUB_DCUGCR)
+#define DDR0_PUB_DCUTPR (0x1000 + (0x65 << 2))
+#define P_DDR0_PUB_DCUTPR               MMC_REG_ADDR(DDR0_PUB_DCUTPR)
+#define DDR0_PUB_DCUSR0 (0x1000 + (0x66 << 2))
+#define P_DDR0_PUB_DCUSR0               MMC_REG_ADDR(DDR0_PUB_DCUSR0)
+#define DDR0_PUB_DCUSR1 (0x1000 + (0x67 << 2))
+#define P_DDR0_PUB_DCUSR1               MMC_REG_ADDR(DDR0_PUB_DCUSR1)
+#define DDR0_PUB_BISTRR (0x1000 + (0x70 << 2))
+#define P_DDR0_PUB_BISTRR               MMC_REG_ADDR(DDR0_PUB_BISTRR)
+#define DDR0_PUB_BISTWCR (0x1000 + (0x71 << 2))
+#define P_DDR0_PUB_BISTWCR              MMC_REG_ADDR(DDR0_PUB_BISTWCR)
+#define DDR0_PUB_BISTMSKR0 (0x1000 + (0x72 << 2))
+#define P_DDR0_PUB_BISTMSKR0            MMC_REG_ADDR(DDR0_PUB_BISTMSKR0)
+#define DDR0_PUB_BISTMSKR1 (0x1000 + (0x73 << 2))
+#define P_DDR0_PUB_BISTMSKR1            MMC_REG_ADDR(DDR0_PUB_BISTMSKR1)
+#define DDR0_PUB_BISTMSKR2 (0x1000 + (0x74 << 2))
+#define P_DDR0_PUB_BISTMSKR2            MMC_REG_ADDR(DDR0_PUB_BISTMSKR2)
+#define DDR0_PUB_BISTLSR (0x1000 + (0x75 << 2))
+#define P_DDR0_PUB_BISTLSR              MMC_REG_ADDR(DDR0_PUB_BISTLSR)
+#define DDR0_PUB_BISTAR0 (0x1000 + (0x76 << 2))
+#define P_DDR0_PUB_BISTAR0              MMC_REG_ADDR(DDR0_PUB_BISTAR0)
+#define DDR0_PUB_BISTAR1 (0x1000 + (0x77 << 2))
+#define P_DDR0_PUB_BISTAR1              MMC_REG_ADDR(DDR0_PUB_BISTAR1)
+#define DDR0_PUB_BISTAR2 (0x1000 + (0x78 << 2))
+#define P_DDR0_PUB_BISTAR2              MMC_REG_ADDR(DDR0_PUB_BISTAR2)
+#define DDR0_PUB_BISTUDPR (0x1000 + (0x79 << 2))
+#define P_DDR0_PUB_BISTUDPR             MMC_REG_ADDR(DDR0_PUB_BISTUDPR)
+#define DDR0_PUB_BISTGSR (0x1000 + (0x7A << 2))
+#define P_DDR0_PUB_BISTGSR              MMC_REG_ADDR(DDR0_PUB_BISTGSR)
+#define DDR0_PUB_BISTWER (0x1000 + (0x7B << 2))
+#define P_DDR0_PUB_BISTWER              MMC_REG_ADDR(DDR0_PUB_BISTWER)
+#define DDR0_PUB_BISTBER0 (0x1000 + (0x7C << 2))
+#define P_DDR0_PUB_BISTBER0             MMC_REG_ADDR(DDR0_PUB_BISTBER0)
+#define DDR0_PUB_BISTBER1 (0x1000 + (0x7D << 2))
+#define P_DDR0_PUB_BISTBER1             MMC_REG_ADDR(DDR0_PUB_BISTBER1)
+#define DDR0_PUB_BISTBER2 (0x1000 + (0x7E << 2))
+#define P_DDR0_PUB_BISTBER2             MMC_REG_ADDR(DDR0_PUB_BISTBER2)
+#define DDR0_PUB_BISTBER3 (0x1000 + (0x7F << 2))
+#define P_DDR0_PUB_BISTBER3             MMC_REG_ADDR(DDR0_PUB_BISTBER3)
+#define DDR0_PUB_BISTWCSR (0x1000 + (0x80 << 2))
+#define P_DDR0_PUB_BISTWCSR             MMC_REG_ADDR(DDR0_PUB_BISTWCSR)
+#define DDR0_PUB_BISTFWR0 (0x1000 + (0x81 << 2))
+#define P_DDR0_PUB_BISTFWR0             MMC_REG_ADDR(DDR0_PUB_BISTFWR0)
+#define DDR0_PUB_BISTFWR1 (0x1000 + (0x82 << 2))
+#define P_DDR0_PUB_BISTFWR1             MMC_REG_ADDR(DDR0_PUB_BISTFWR1)
+#define DDR0_PUB_BISTFWR2 (0x1000 + (0x83 << 2))
+#define P_DDR0_PUB_BISTFWR2             MMC_REG_ADDR(DDR0_PUB_BISTFWR2)
+#define DDR0_PUB_IOVCR0 (0x1000 + (0x8E << 2))
+#define P_DDR0_PUB_IOVCR0               MMC_REG_ADDR(DDR0_PUB_IOVCR0)
+#define DDR0_PUB_IOVCR1 (0x1000 + (0x8F << 2))
+#define P_DDR0_PUB_IOVCR1               MMC_REG_ADDR(DDR0_PUB_IOVCR1)
+#define DDR0_PUB_ZQCR (0x1000 + (0x90 << 2))
+#define P_DDR0_PUB_ZQCR                 MMC_REG_ADDR(DDR0_PUB_ZQCR)
+#define DDR0_PUB_ZQ0PR (0x1000 + (0x91 << 2))
+#define P_DDR0_PUB_ZQ0PR                MMC_REG_ADDR(DDR0_PUB_ZQ0PR)
+#define DDR0_PUB_ZQ0DR (0x1000 + (0x92 << 2))
+#define P_DDR0_PUB_ZQ0DR                MMC_REG_ADDR(DDR0_PUB_ZQ0DR)
+#define DDR0_PUB_ZQ0SR (0x1000 + (0x93 << 2))
+#define P_DDR0_PUB_ZQ0SR                MMC_REG_ADDR(DDR0_PUB_ZQ0SR)
+#define DDR0_PUB_ZQ1PR (0x1000 + (0x95 << 2))
+#define P_DDR0_PUB_ZQ1PR                MMC_REG_ADDR(DDR0_PUB_ZQ1PR)
+#define DDR0_PUB_ZQ1DR (0x1000 + (0x96 << 2))
+#define P_DDR0_PUB_ZQ1DR                MMC_REG_ADDR(DDR0_PUB_ZQ1DR)
+#define DDR0_PUB_ZQ1SR (0x1000 + (0x97 << 2))
+#define P_DDR0_PUB_ZQ1SR                MMC_REG_ADDR(DDR0_PUB_ZQ1SR)
+#define DDR0_PUB_ZQ2PR (0x1000 + (0x99 << 2))
+#define P_DDR0_PUB_ZQ2PR                MMC_REG_ADDR(DDR0_PUB_ZQ2PR)
+#define DDR0_PUB_ZQ2DR (0x1000 + (0x9A << 2))
+#define P_DDR0_PUB_ZQ2DR                MMC_REG_ADDR(DDR0_PUB_ZQ2DR)
+#define DDR0_PUB_ZQ2SR (0x1000 + (0x9B << 2))
+#define P_DDR0_PUB_ZQ2SR                MMC_REG_ADDR(DDR0_PUB_ZQ2SR)
+#define DDR0_PUB_ZQ3PR (0x1000 + (0x9D << 2))
+#define P_DDR0_PUB_ZQ3PR                MMC_REG_ADDR(DDR0_PUB_ZQ3PR)
+#define DDR0_PUB_ZQ3DR (0x1000 + (0x9E << 2))
+#define P_DDR0_PUB_ZQ3DR                MMC_REG_ADDR(DDR0_PUB_ZQ3DR)
+#define DDR0_PUB_ZQ3SR (0x1000 + (0x9F << 2))
+#define P_DDR0_PUB_ZQ3SR                MMC_REG_ADDR(DDR0_PUB_ZQ3SR)
+#define DDR0_PUB_DX0GCR0 (0x1000 + (0xA0 << 2))
+#define P_DDR0_PUB_DX0GCR0              MMC_REG_ADDR(DDR0_PUB_DX0GCR0)
+#define DDR0_PUB_DX0GCR1 (0x1000 + (0xA1 << 2))
+#define P_DDR0_PUB_DX0GCR1              MMC_REG_ADDR(DDR0_PUB_DX0GCR1)
+#define DDR0_PUB_DX0GCR2 (0x1000 + (0xA2 << 2))
+#define P_DDR0_PUB_DX0GCR2              MMC_REG_ADDR(DDR0_PUB_DX0GCR2)
+#define DDR0_PUB_DX0GCR3 (0x1000 + (0xA3 << 2))
+#define P_DDR0_PUB_DX0GCR3              MMC_REG_ADDR(DDR0_PUB_DX0GCR3)
+#define DDR0_PUB_DX0GSR0 (0x1000 + (0xA4 << 2))
+#define P_DDR0_PUB_DX0GSR0              MMC_REG_ADDR(DDR0_PUB_DX0GSR0)
+#define DDR0_PUB_DX0GSR1 (0x1000 + (0xA5 << 2))
+#define P_DDR0_PUB_DX0GSR1              MMC_REG_ADDR(DDR0_PUB_DX0GSR1)
+#define DDR0_PUB_DX0GSR2 (0x1000 + (0xA6 << 2))
+#define P_DDR0_PUB_DX0GSR2              MMC_REG_ADDR(DDR0_PUB_DX0GSR2)
+#define DDR0_PUB_DX0BDLR0 (0x1000 + (0xA7 << 2))
+#define P_DDR0_PUB_DX0BDLR0             MMC_REG_ADDR(DDR0_PUB_DX0BDLR0)
+#define DDR0_PUB_DX0BDLR1 (0x1000 + (0xA8 << 2))
+#define P_DDR0_PUB_DX0BDLR1             MMC_REG_ADDR(DDR0_PUB_DX0BDLR1)
+#define DDR0_PUB_DX0BDLR2 (0x1000 + (0xA9 << 2))
+#define P_DDR0_PUB_DX0BDLR2             MMC_REG_ADDR(DDR0_PUB_DX0BDLR2)
+#define DDR0_PUB_DX0BDLR3 (0x1000 + (0xAA << 2))
+#define P_DDR0_PUB_DX0BDLR3             MMC_REG_ADDR(DDR0_PUB_DX0BDLR3)
+#define DDR0_PUB_DX0BDLR4 (0x1000 + (0xAB << 2))
+#define P_DDR0_PUB_DX0BDLR4             MMC_REG_ADDR(DDR0_PUB_DX0BDLR4)
+#define DDR0_PUB_DX0BDLR5 (0x1000 + (0xAC << 2))
+#define P_DDR0_PUB_DX0BDLR5             MMC_REG_ADDR(DDR0_PUB_DX0BDLR5)
+#define DDR0_PUB_DX0BDLR6 (0x1000 + (0xAD << 2))
+#define P_DDR0_PUB_DX0BDLR6             MMC_REG_ADDR(DDR0_PUB_DX0BDLR6)
+#define DDR0_PUB_DX0LCDLR0 (0x1000 + (0xAE << 2))
+#define P_DDR0_PUB_DX0LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX0LCDLR0)
+#define DDR0_PUB_DX0LCDLR1 (0x1000 + (0xAF << 2))
+#define P_DDR0_PUB_DX0LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX0LCDLR1)
+#define DDR0_PUB_DX0LCDLR2 (0x1000 + (0xB0 << 2))
+#define P_DDR0_PUB_DX0LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX0LCDLR2)
+#define DDR0_PUB_DX0MDLR (0x1000 + (0xB1 << 2))
+#define P_DDR0_PUB_DX0MDLR              MMC_REG_ADDR(DDR0_PUB_DX0MDLR)
+#define DDR0_PUB_DX0GTR (0x1000 + (0xB2 << 2))
+#define P_DDR0_PUB_DX0GTR               MMC_REG_ADDR(DDR0_PUB_DX0GTR)
+#define DDR0_PUB_DX1GCR0 (0x1000 + (0xC0 << 2))
+#define P_DDR0_PUB_DX1GCR0              MMC_REG_ADDR(DDR0_PUB_DX1GCR0)
+#define DDR0_PUB_DX1GCR1 (0x1000 + (0xC1 << 2))
+#define P_DDR0_PUB_DX1GCR1              MMC_REG_ADDR(DDR0_PUB_DX1GCR1)
+#define DDR0_PUB_DX1GCR2 (0x1000 + (0xC2 << 2))
+#define P_DDR0_PUB_DX1GCR2              MMC_REG_ADDR(DDR0_PUB_DX1GCR2)
+#define DDR0_PUB_DX1GCR3 (0x1000 + (0xC3 << 2))
+#define P_DDR0_PUB_DX1GCR3              MMC_REG_ADDR(DDR0_PUB_DX1GCR3)
+#define DDR0_PUB_DX1GSR0 (0x1000 + (0xC4 << 2))
+#define P_DDR0_PUB_DX1GSR0              MMC_REG_ADDR(DDR0_PUB_DX1GSR0)
+#define DDR0_PUB_DX1GSR1 (0x1000 + (0xC5 << 2))
+#define P_DDR0_PUB_DX1GSR1              MMC_REG_ADDR(DDR0_PUB_DX1GSR1)
+#define DDR0_PUB_DX1GSR2 (0x1000 + (0xC6 << 2))
+#define P_DDR0_PUB_DX1GSR2              MMC_REG_ADDR(DDR0_PUB_DX1GSR2)
+#define DDR0_PUB_DX1BDLR0 (0x1000 + (0xC7 << 2))
+#define P_DDR0_PUB_DX1BDLR0             MMC_REG_ADDR(DDR0_PUB_DX1BDLR0)
+#define DDR0_PUB_DX1BDLR1 (0x1000 + (0xC8 << 2))
+#define P_DDR0_PUB_DX1BDLR1             MMC_REG_ADDR(DDR0_PUB_DX1BDLR1)
+#define DDR0_PUB_DX1BDLR2 (0x1000 + (0xC9 << 2))
+#define P_DDR0_PUB_DX1BDLR2             MMC_REG_ADDR(DDR0_PUB_DX1BDLR2)
+#define DDR0_PUB_DX1BDLR3 (0x1000 + (0xCA << 2))
+#define P_DDR0_PUB_DX1BDLR3             MMC_REG_ADDR(DDR0_PUB_DX1BDLR3)
+#define DDR0_PUB_DX1BDLR4 (0x1000 + (0xCB << 2))
+#define P_DDR0_PUB_DX1BDLR4             MMC_REG_ADDR(DDR0_PUB_DX1BDLR4)
+#define DDR0_PUB_DX1BDLR5 (0x1000 + (0xCC << 2))
+#define P_DDR0_PUB_DX1BDLR5             MMC_REG_ADDR(DDR0_PUB_DX1BDLR5)
+#define DDR0_PUB_DX1BDLR6 (0x1000 + (0xCD << 2))
+#define P_DDR0_PUB_DX1BDLR6             MMC_REG_ADDR(DDR0_PUB_DX1BDLR6)
+#define DDR0_PUB_DX1LCDLR0 (0x1000 + (0xCE << 2))
+#define P_DDR0_PUB_DX1LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX1LCDLR0)
+#define DDR0_PUB_DX1LCDLR1 (0x1000 + (0xCF << 2))
+#define P_DDR0_PUB_DX1LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX1LCDLR1)
+#define DDR0_PUB_DX1LCDLR2 (0x1000 + (0xD0 << 2))
+#define P_DDR0_PUB_DX1LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX1LCDLR2)
+#define DDR0_PUB_DX1MDLR (0x1000 + (0xD1 << 2))
+#define P_DDR0_PUB_DX1MDLR              MMC_REG_ADDR(DDR0_PUB_DX1MDLR)
+#define DDR0_PUB_DX1GTR (0x1000 + (0xD2 << 2))
+#define P_DDR0_PUB_DX1GTR               MMC_REG_ADDR(DDR0_PUB_DX1GTR)
+#define DDR0_PUB_DX2GCR0 (0x1000 + (0xE0 << 2))
+#define P_DDR0_PUB_DX2GCR0              MMC_REG_ADDR(DDR0_PUB_DX2GCR0)
+#define DDR0_PUB_DX2GCR1 (0x1000 + (0xE1 << 2))
+#define P_DDR0_PUB_DX2GCR1              MMC_REG_ADDR(DDR0_PUB_DX2GCR1)
+#define DDR0_PUB_DX2GCR2 (0x1000 + (0xE2 << 2))
+#define P_DDR0_PUB_DX2GCR2              MMC_REG_ADDR(DDR0_PUB_DX2GCR2)
+#define DDR0_PUB_DX2GCR3 (0x1000 + (0xE3 << 2))
+#define P_DDR0_PUB_DX2GCR3              MMC_REG_ADDR(DDR0_PUB_DX2GCR3)
+#define DDR0_PUB_DX2GSR0 (0x1000 + (0xE4 << 2))
+#define P_DDR0_PUB_DX2GSR0              MMC_REG_ADDR(DDR0_PUB_DX2GSR0)
+#define DDR0_PUB_DX2GSR1 (0x1000 + (0xE5 << 2))
+#define P_DDR0_PUB_DX2GSR1              MMC_REG_ADDR(DDR0_PUB_DX2GSR1)
+#define DDR0_PUB_DX2GSR2 (0x1000 + (0xE6 << 2))
+#define P_DDR0_PUB_DX2GSR2              MMC_REG_ADDR(DDR0_PUB_DX2GSR2)
+#define DDR0_PUB_DX2BDLR0 (0x1000 + (0xE7 << 2))
+#define P_DDR0_PUB_DX2BDLR0             MMC_REG_ADDR(DDR0_PUB_DX2BDLR0)
+#define DDR0_PUB_DX2BDLR1 (0x1000 + (0xE8 << 2))
+#define P_DDR0_PUB_DX2BDLR1             MMC_REG_ADDR(DDR0_PUB_DX2BDLR1)
+#define DDR0_PUB_DX2BDLR2 (0x1000 + (0xE9 << 2))
+#define P_DDR0_PUB_DX2BDLR2             MMC_REG_ADDR(DDR0_PUB_DX2BDLR2)
+#define DDR0_PUB_DX2BDLR3 (0x1000 + (0xEA << 2))
+#define P_DDR0_PUB_DX2BDLR3             MMC_REG_ADDR(DDR0_PUB_DX2BDLR3)
+#define DDR0_PUB_DX2BDLR4 (0x1000 + (0xEB << 2))
+#define P_DDR0_PUB_DX2BDLR4             MMC_REG_ADDR(DDR0_PUB_DX2BDLR4)
+#define DDR0_PUB_DX2BDLR5 (0x1000 + (0xEC << 2))
+#define P_DDR0_PUB_DX2BDLR5             MMC_REG_ADDR(DDR0_PUB_DX2BDLR5)
+#define DDR0_PUB_DX2BDLR6 (0x1000 + (0xED << 2))
+#define P_DDR0_PUB_DX2BDLR6             MMC_REG_ADDR(DDR0_PUB_DX2BDLR6)
+#define DDR0_PUB_DX2LCDLR0 (0x1000 + (0xEE << 2))
+#define P_DDR0_PUB_DX2LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX2LCDLR0)
+#define DDR0_PUB_DX2LCDLR1 (0x1000 + (0xEF << 2))
+#define P_DDR0_PUB_DX2LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX2LCDLR1)
+#define DDR0_PUB_DX2LCDLR2 (0x1000 + (0xF0 << 2))
+#define P_DDR0_PUB_DX2LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX2LCDLR2)
+#define DDR0_PUB_DX2MDLR (0x1000 + (0xF1 << 2))
+#define P_DDR0_PUB_DX2MDLR              MMC_REG_ADDR(DDR0_PUB_DX2MDLR)
+#define DDR0_PUB_DX2GTR (0x1000 + (0xF2 << 2))
+#define P_DDR0_PUB_DX2GTR               MMC_REG_ADDR(DDR0_PUB_DX2GTR)
+#define DDR0_PUB_DX3GCR0 (0x1000 + (0x100 << 2))
+#define P_DDR0_PUB_DX3GCR0              MMC_REG_ADDR(DDR0_PUB_DX3GCR0)
+#define DDR0_PUB_DX3GCR1 (0x1000 + (0x101 << 2))
+#define P_DDR0_PUB_DX3GCR1              MMC_REG_ADDR(DDR0_PUB_DX3GCR1)
+#define DDR0_PUB_DX3GCR2 (0x1000 + (0x102 << 2))
+#define P_DDR0_PUB_DX3GCR2              MMC_REG_ADDR(DDR0_PUB_DX3GCR2)
+#define DDR0_PUB_DX3GCR3 (0x1000 + (0x103 << 2))
+#define P_DDR0_PUB_DX3GCR3              MMC_REG_ADDR(DDR0_PUB_DX3GCR3)
+#define DDR0_PUB_DX3GSR0 (0x1000 + (0x104 << 2))
+#define P_DDR0_PUB_DX3GSR0              MMC_REG_ADDR(DDR0_PUB_DX3GSR0)
+#define DDR0_PUB_DX3GSR1 (0x1000 + (0x105 << 2))
+#define P_DDR0_PUB_DX3GSR1              MMC_REG_ADDR(DDR0_PUB_DX3GSR1)
+#define DDR0_PUB_DX3GSR2 (0x1000 + (0x106 << 2))
+#define P_DDR0_PUB_DX3GSR2              MMC_REG_ADDR(DDR0_PUB_DX3GSR2)
+#define DDR0_PUB_DX3BDLR0 (0x1000 + (0x107 << 2))
+#define P_DDR0_PUB_DX3BDLR0             MMC_REG_ADDR(DDR0_PUB_DX3BDLR0)
+#define DDR0_PUB_DX3BDLR1 (0x1000 + (0x108 << 2))
+#define P_DDR0_PUB_DX3BDLR1             MMC_REG_ADDR(DDR0_PUB_DX3BDLR1)
+#define DDR0_PUB_DX3BDLR2 (0x1000 + (0x109 << 2))
+#define P_DDR0_PUB_DX3BDLR2             MMC_REG_ADDR(DDR0_PUB_DX3BDLR2)
+#define DDR0_PUB_DX3BDLR3 (0x1000 + (0x10A << 2))
+#define P_DDR0_PUB_DX3BDLR3             MMC_REG_ADDR(DDR0_PUB_DX3BDLR3)
+#define DDR0_PUB_DX3BDLR4 (0x1000 + (0x10B << 2))
+#define P_DDR0_PUB_DX3BDLR4             MMC_REG_ADDR(DDR0_PUB_DX3BDLR4)
+#define DDR0_PUB_DX3BDLR5 (0x1000 + (0x10C << 2))
+#define P_DDR0_PUB_DX3BDLR5             MMC_REG_ADDR(DDR0_PUB_DX3BDLR5)
+#define DDR0_PUB_DX3BDLR6 (0x1000 + (0x10D << 2))
+#define P_DDR0_PUB_DX3BDLR6             MMC_REG_ADDR(DDR0_PUB_DX3BDLR6)
+#define DDR0_PUB_DX3LCDLR0 (0x1000 + (0x10E << 2))
+#define P_DDR0_PUB_DX3LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX3LCDLR0)
+#define DDR0_PUB_DX3LCDLR1 (0x1000 + (0x10F << 2))
+#define P_DDR0_PUB_DX3LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX3LCDLR1)
+#define DDR0_PUB_DX3LCDLR2 (0x1000 + (0x110 << 2))
+#define P_DDR0_PUB_DX3LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX3LCDLR2)
+#define DDR0_PUB_DX3MDLR (0x1000 + (0x111 << 2))
+#define P_DDR0_PUB_DX3MDLR              MMC_REG_ADDR(DDR0_PUB_DX3MDLR)
+#define DDR0_PUB_DX3GTR (0x1000 + (0x112 << 2))
+#define P_DDR0_PUB_DX3GTR               MMC_REG_ADDR(DDR0_PUB_DX3GTR)
+#define DDR0_PUB_DX4GCR0 (0x1000 + (0x120 << 2))
+#define P_DDR0_PUB_DX4GCR0              MMC_REG_ADDR(DDR0_PUB_DX4GCR0)
+#define DDR0_PUB_DX4GCR1 (0x1000 + (0x121 << 2))
+#define P_DDR0_PUB_DX4GCR1              MMC_REG_ADDR(DDR0_PUB_DX4GCR1)
+#define DDR0_PUB_DX4GCR2 (0x1000 + (0x122 << 2))
+#define P_DDR0_PUB_DX4GCR2              MMC_REG_ADDR(DDR0_PUB_DX4GCR2)
+#define DDR0_PUB_DX4GCR3 (0x1000 + (0x123 << 2))
+#define P_DDR0_PUB_DX4GCR3              MMC_REG_ADDR(DDR0_PUB_DX4GCR3)
+#define DDR0_PUB_DX4GSR0 (0x1000 + (0x124 << 2))
+#define P_DDR0_PUB_DX4GSR0              MMC_REG_ADDR(DDR0_PUB_DX4GSR0)
+#define DDR0_PUB_DX4GSR1 (0x1000 + (0x125 << 2))
+#define P_DDR0_PUB_DX4GSR1              MMC_REG_ADDR(DDR0_PUB_DX4GSR1)
+#define DDR0_PUB_DX4GSR2 (0x1000 + (0x126 << 2))
+#define P_DDR0_PUB_DX4GSR2              MMC_REG_ADDR(DDR0_PUB_DX4GSR2)
+#define DDR0_PUB_DX4BDLR0 (0x1000 + (0x127 << 2))
+#define P_DDR0_PUB_DX4BDLR0             MMC_REG_ADDR(DDR0_PUB_DX4BDLR0)
+#define DDR0_PUB_DX4BDLR1 (0x1000 + (0x128 << 2))
+#define P_DDR0_PUB_DX4BDLR1             MMC_REG_ADDR(DDR0_PUB_DX4BDLR1)
+#define DDR0_PUB_DX4BDLR2 (0x1000 + (0x129 << 2))
+#define P_DDR0_PUB_DX4BDLR2             MMC_REG_ADDR(DDR0_PUB_DX4BDLR2)
+#define DDR0_PUB_DX4BDLR3 (0x1000 + (0x12A << 2))
+#define P_DDR0_PUB_DX4BDLR3             MMC_REG_ADDR(DDR0_PUB_DX4BDLR3)
+#define DDR0_PUB_DX4BDLR4 (0x1000 + (0x12B << 2))
+#define P_DDR0_PUB_DX4BDLR4             MMC_REG_ADDR(DDR0_PUB_DX4BDLR4)
+#define DDR0_PUB_DX4BDLR5 (0x1000 + (0x12C << 2))
+#define P_DDR0_PUB_DX4BDLR5             MMC_REG_ADDR(DDR0_PUB_DX4BDLR5)
+#define DDR0_PUB_DX4BDLR6 (0x1000 + (0x12D << 2))
+#define P_DDR0_PUB_DX4BDLR6             MMC_REG_ADDR(DDR0_PUB_DX4BDLR6)
+#define DDR0_PUB_DX4LCDLR0 (0x1000 + (0x12E << 2))
+#define P_DDR0_PUB_DX4LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX4LCDLR0)
+#define DDR0_PUB_DX4LCDLR1 (0x1000 + (0x12F << 2))
+#define P_DDR0_PUB_DX4LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX4LCDLR1)
+#define DDR0_PUB_DX4LCDLR2 (0x1000 + (0x130 << 2))
+#define P_DDR0_PUB_DX4LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX4LCDLR2)
+#define DDR0_PUB_DX4MDLR (0x1000 + (0x131 << 2))
+#define P_DDR0_PUB_DX4MDLR              MMC_REG_ADDR(DDR0_PUB_DX4MDLR)
+#define DDR0_PUB_DX4GTR (0x1000 + (0x132 << 2))
+#define P_DDR0_PUB_DX4GTR               MMC_REG_ADDR(DDR0_PUB_DX4GTR)
+#define DDR0_PUB_DX5GCR0 (0x1000 + (0x140 << 2))
+#define P_DDR0_PUB_DX5GCR0              MMC_REG_ADDR(DDR0_PUB_DX5GCR0)
+#define DDR0_PUB_DX5GCR1 (0x1000 + (0x141 << 2))
+#define P_DDR0_PUB_DX5GCR1              MMC_REG_ADDR(DDR0_PUB_DX5GCR1)
+#define DDR0_PUB_DX5GCR2 (0x1000 + (0x142 << 2))
+#define P_DDR0_PUB_DX5GCR2              MMC_REG_ADDR(DDR0_PUB_DX5GCR2)
+#define DDR0_PUB_DX5GCR3 (0x1000 + (0x143 << 2))
+#define P_DDR0_PUB_DX5GCR3              MMC_REG_ADDR(DDR0_PUB_DX5GCR3)
+#define DDR0_PUB_DX5GSR0 (0x1000 + (0x144 << 2))
+#define P_DDR0_PUB_DX5GSR0              MMC_REG_ADDR(DDR0_PUB_DX5GSR0)
+#define DDR0_PUB_DX5GSR1 (0x1000 + (0x145 << 2))
+#define P_DDR0_PUB_DX5GSR1              MMC_REG_ADDR(DDR0_PUB_DX5GSR1)
+#define DDR0_PUB_DX5GSR2 (0x1000 + (0x146 << 2))
+#define P_DDR0_PUB_DX5GSR2              MMC_REG_ADDR(DDR0_PUB_DX5GSR2)
+#define DDR0_PUB_DX5BDLR0 (0x1000 + (0x147 << 2))
+#define P_DDR0_PUB_DX5BDLR0             MMC_REG_ADDR(DDR0_PUB_DX5BDLR0)
+#define DDR0_PUB_DX5BDLR1 (0x1000 + (0x148 << 2))
+#define P_DDR0_PUB_DX5BDLR1             MMC_REG_ADDR(DDR0_PUB_DX5BDLR1)
+#define DDR0_PUB_DX5BDLR2 (0x1000 + (0x149 << 2))
+#define P_DDR0_PUB_DX5BDLR2             MMC_REG_ADDR(DDR0_PUB_DX5BDLR2)
+#define DDR0_PUB_DX5BDLR3 (0x1000 + (0x14A << 2))
+#define P_DDR0_PUB_DX5BDLR3             MMC_REG_ADDR(DDR0_PUB_DX5BDLR3)
+#define DDR0_PUB_DX5BDLR4 (0x1000 + (0x14B << 2))
+#define P_DDR0_PUB_DX5BDLR4             MMC_REG_ADDR(DDR0_PUB_DX5BDLR4)
+#define DDR0_PUB_DX5BDLR5 (0x1000 + (0x14C << 2))
+#define P_DDR0_PUB_DX5BDLR5             MMC_REG_ADDR(DDR0_PUB_DX5BDLR5)
+#define DDR0_PUB_DX5BDLR6 (0x1000 + (0x14D << 2))
+#define P_DDR0_PUB_DX5BDLR6             MMC_REG_ADDR(DDR0_PUB_DX5BDLR6)
+#define DDR0_PUB_DX5LCDLR0 (0x1000 + (0x14E << 2))
+#define P_DDR0_PUB_DX5LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX5LCDLR0)
+#define DDR0_PUB_DX5LCDLR1 (0x1000 + (0x14F << 2))
+#define P_DDR0_PUB_DX5LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX5LCDLR1)
+#define DDR0_PUB_DX5LCDLR2 (0x1000 + (0x150 << 2))
+#define P_DDR0_PUB_DX5LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX5LCDLR2)
+#define DDR0_PUB_DX5MDLR (0x1000 + (0x151 << 2))
+#define P_DDR0_PUB_DX5MDLR              MMC_REG_ADDR(DDR0_PUB_DX5MDLR)
+#define DDR0_PUB_DX5GTR (0x1000 + (0x152 << 2))
+#define P_DDR0_PUB_DX5GTR               MMC_REG_ADDR(DDR0_PUB_DX5GTR)
+#define DDR0_PUB_DX6GCR0 (0x1000 + (0x160 << 2))
+#define P_DDR0_PUB_DX6GCR0              MMC_REG_ADDR(DDR0_PUB_DX6GCR0)
+#define DDR0_PUB_DX6GCR1 (0x1000 + (0x161 << 2))
+#define P_DDR0_PUB_DX6GCR1              MMC_REG_ADDR(DDR0_PUB_DX6GCR1)
+#define DDR0_PUB_DX6GCR2 (0x1000 + (0x162 << 2))
+#define P_DDR0_PUB_DX6GCR2              MMC_REG_ADDR(DDR0_PUB_DX6GCR2)
+#define DDR0_PUB_DX6GCR3 (0x1000 + (0x163 << 2))
+#define P_DDR0_PUB_DX6GCR3              MMC_REG_ADDR(DDR0_PUB_DX6GCR3)
+#define DDR0_PUB_DX6GSR0 (0x1000 + (0x164 << 2))
+#define P_DDR0_PUB_DX6GSR0              MMC_REG_ADDR(DDR0_PUB_DX6GSR0)
+#define DDR0_PUB_DX6GSR1 (0x1000 + (0x165 << 2))
+#define P_DDR0_PUB_DX6GSR1              MMC_REG_ADDR(DDR0_PUB_DX6GSR1)
+#define DDR0_PUB_DX6GSR2 (0x1000 + (0x166 << 2))
+#define P_DDR0_PUB_DX6GSR2              MMC_REG_ADDR(DDR0_PUB_DX6GSR2)
+#define DDR0_PUB_DX6BDLR0 (0x1000 + (0x167 << 2))
+#define P_DDR0_PUB_DX6BDLR0             MMC_REG_ADDR(DDR0_PUB_DX6BDLR0)
+#define DDR0_PUB_DX6BDLR1 (0x1000 + (0x168 << 2))
+#define P_DDR0_PUB_DX6BDLR1             MMC_REG_ADDR(DDR0_PUB_DX6BDLR1)
+#define DDR0_PUB_DX6BDLR2 (0x1000 + (0x169 << 2))
+#define P_DDR0_PUB_DX6BDLR2             MMC_REG_ADDR(DDR0_PUB_DX6BDLR2)
+#define DDR0_PUB_DX6BDLR3 (0x1000 + (0x16A << 2))
+#define P_DDR0_PUB_DX6BDLR3             MMC_REG_ADDR(DDR0_PUB_DX6BDLR3)
+#define DDR0_PUB_DX6BDLR4 (0x1000 + (0x16B << 2))
+#define P_DDR0_PUB_DX6BDLR4             MMC_REG_ADDR(DDR0_PUB_DX6BDLR4)
+#define DDR0_PUB_DX6BDLR5 (0x1000 + (0x16C << 2))
+#define P_DDR0_PUB_DX6BDLR5             MMC_REG_ADDR(DDR0_PUB_DX6BDLR5)
+#define DDR0_PUB_DX6BDLR6 (0x1000 + (0x16D << 2))
+#define P_DDR0_PUB_DX6BDLR6             MMC_REG_ADDR(DDR0_PUB_DX6BDLR6)
+#define DDR0_PUB_DX6LCDLR0 (0x1000 + (0x16E << 2))
+#define P_DDR0_PUB_DX6LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX6LCDLR0)
+#define DDR0_PUB_DX6LCDLR1 (0x1000 + (0x16F << 2))
+#define P_DDR0_PUB_DX6LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX6LCDLR1)
+#define DDR0_PUB_DX6LCDLR2 (0x1000 + (0x170 << 2))
+#define P_DDR0_PUB_DX6LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX6LCDLR2)
+#define DDR0_PUB_DX6MDLR (0x1000 + (0x171 << 2))
+#define P_DDR0_PUB_DX6MDLR              MMC_REG_ADDR(DDR0_PUB_DX6MDLR)
+#define DDR0_PUB_DX6GTR (0x1000 + (0x172 << 2))
+#define P_DDR0_PUB_DX6GTR               MMC_REG_ADDR(DDR0_PUB_DX6GTR)
+#define DDR0_PUB_DX7GCR0 (0x1000 + (0x180 << 2))
+#define P_DDR0_PUB_DX7GCR0              MMC_REG_ADDR(DDR0_PUB_DX7GCR0)
+#define DDR0_PUB_DX7GCR1 (0x1000 + (0x181 << 2))
+#define P_DDR0_PUB_DX7GCR1              MMC_REG_ADDR(DDR0_PUB_DX7GCR1)
+#define DDR0_PUB_DX7GCR2 (0x1000 + (0x182 << 2))
+#define P_DDR0_PUB_DX7GCR2              MMC_REG_ADDR(DDR0_PUB_DX7GCR2)
+#define DDR0_PUB_DX7GCR3 (0x1000 + (0x183 << 2))
+#define P_DDR0_PUB_DX7GCR3              MMC_REG_ADDR(DDR0_PUB_DX7GCR3)
+#define DDR0_PUB_DX7GSR0 (0x1000 + (0x184 << 2))
+#define P_DDR0_PUB_DX7GSR0              MMC_REG_ADDR(DDR0_PUB_DX7GSR0)
+#define DDR0_PUB_DX7GSR1 (0x1000 + (0x185 << 2))
+#define P_DDR0_PUB_DX7GSR1              MMC_REG_ADDR(DDR0_PUB_DX7GSR1)
+#define DDR0_PUB_DX7GSR2 (0x1000 + (0x186 << 2))
+#define P_DDR0_PUB_DX7GSR2              MMC_REG_ADDR(DDR0_PUB_DX7GSR2)
+#define DDR0_PUB_DX7BDLR0 (0x1000 + (0x187 << 2))
+#define P_DDR0_PUB_DX7BDLR0             MMC_REG_ADDR(DDR0_PUB_DX7BDLR0)
+#define DDR0_PUB_DX7BDLR1 (0x1000 + (0x188 << 2))
+#define P_DDR0_PUB_DX7BDLR1             MMC_REG_ADDR(DDR0_PUB_DX7BDLR1)
+#define DDR0_PUB_DX7BDLR2 (0x1000 + (0x189 << 2))
+#define P_DDR0_PUB_DX7BDLR2             MMC_REG_ADDR(DDR0_PUB_DX7BDLR2)
+#define DDR0_PUB_DX7BDLR3 (0x1000 + (0x18A << 2))
+#define P_DDR0_PUB_DX7BDLR3             MMC_REG_ADDR(DDR0_PUB_DX7BDLR3)
+#define DDR0_PUB_DX7BDLR4 (0x1000 + (0x18B << 2))
+#define P_DDR0_PUB_DX7BDLR4             MMC_REG_ADDR(DDR0_PUB_DX7BDLR4)
+#define DDR0_PUB_DX7BDLR5 (0x1000 + (0x18C << 2))
+#define P_DDR0_PUB_DX7BDLR5             MMC_REG_ADDR(DDR0_PUB_DX7BDLR5)
+#define DDR0_PUB_DX7BDLR6 (0x1000 + (0x18D << 2))
+#define P_DDR0_PUB_DX7BDLR6             MMC_REG_ADDR(DDR0_PUB_DX7BDLR6)
+#define DDR0_PUB_DX7LCDLR0 (0x1000 + (0x18E << 2))
+#define P_DDR0_PUB_DX7LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX7LCDLR0)
+#define DDR0_PUB_DX7LCDLR1 (0x1000 + (0x18F << 2))
+#define P_DDR0_PUB_DX7LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX7LCDLR1)
+#define DDR0_PUB_DX7LCDLR2 (0x1000 + (0x190 << 2))
+#define P_DDR0_PUB_DX7LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX7LCDLR2)
+#define DDR0_PUB_DX7MDLR (0x1000 + (0x191 << 2))
+#define P_DDR0_PUB_DX7MDLR              MMC_REG_ADDR(DDR0_PUB_DX7MDLR)
+#define DDR0_PUB_DX7GTR (0x1000 + (0x192 << 2))
+#define P_DDR0_PUB_DX7GTR               MMC_REG_ADDR(DDR0_PUB_DX7GTR)
+#define DDR0_PUB_DX8GCR0 (0x1000 + (0x1A0 << 2))
+#define P_DDR0_PUB_DX8GCR0              MMC_REG_ADDR(DDR0_PUB_DX8GCR0)
+#define DDR0_PUB_DX8GCR1 (0x1000 + (0x1A1 << 2))
+#define P_DDR0_PUB_DX8GCR1              MMC_REG_ADDR(DDR0_PUB_DX8GCR1)
+#define DDR0_PUB_DX8GCR2 (0x1000 + (0x1A2 << 2))
+#define P_DDR0_PUB_DX8GCR2              MMC_REG_ADDR(DDR0_PUB_DX8GCR2)
+#define DDR0_PUB_DX8GCR3 (0x1000 + (0x1A3 << 2))
+#define P_DDR0_PUB_DX8GCR3              MMC_REG_ADDR(DDR0_PUB_DX8GCR3)
+#define DDR0_PUB_DX8GSR0 (0x1000 + (0x1A4 << 2))
+#define P_DDR0_PUB_DX8GSR0              MMC_REG_ADDR(DDR0_PUB_DX8GSR0)
+#define DDR0_PUB_DX8GSR1 (0x1000 + (0x1A5 << 2))
+#define P_DDR0_PUB_DX8GSR1              MMC_REG_ADDR(DDR0_PUB_DX8GSR1)
+#define DDR0_PUB_DX8GSR2 (0x1000 + (0x1A6 << 2))
+#define P_DDR0_PUB_DX8GSR2              MMC_REG_ADDR(DDR0_PUB_DX8GSR2)
+#define DDR0_PUB_DX8BDLR0 (0x1000 + (0x1A7 << 2))
+#define P_DDR0_PUB_DX8BDLR0             MMC_REG_ADDR(DDR0_PUB_DX8BDLR0)
+#define DDR0_PUB_DX8BDLR1 (0x1000 + (0x1A8 << 2))
+#define P_DDR0_PUB_DX8BDLR1             MMC_REG_ADDR(DDR0_PUB_DX8BDLR1)
+#define DDR0_PUB_DX8BDLR2 (0x1000 + (0x1A9 << 2))
+#define P_DDR0_PUB_DX8BDLR2             MMC_REG_ADDR(DDR0_PUB_DX8BDLR2)
+#define DDR0_PUB_DX8BDLR3 (0x1000 + (0x1AA << 2))
+#define P_DDR0_PUB_DX8BDLR3             MMC_REG_ADDR(DDR0_PUB_DX8BDLR3)
+#define DDR0_PUB_DX8BDLR4 (0x1000 + (0x1AB << 2))
+#define P_DDR0_PUB_DX8BDLR4             MMC_REG_ADDR(DDR0_PUB_DX8BDLR4)
+#define DDR0_PUB_DX8BDLR5 (0x1000 + (0x1AC << 2))
+#define P_DDR0_PUB_DX8BDLR5             MMC_REG_ADDR(DDR0_PUB_DX8BDLR5)
+#define DDR0_PUB_DX8BDLR6 (0x1000 + (0x1AD << 2))
+#define P_DDR0_PUB_DX8BDLR6             MMC_REG_ADDR(DDR0_PUB_DX8BDLR6)
+#define DDR0_PUB_DX8LCDLR0 (0x1000 + (0x1AE << 2))
+#define P_DDR0_PUB_DX8LCDLR0            MMC_REG_ADDR(DDR0_PUB_DX8LCDLR0)
+#define DDR0_PUB_DX8LCDLR1 (0x1000 + (0x1AF << 2))
+#define P_DDR0_PUB_DX8LCDLR1            MMC_REG_ADDR(DDR0_PUB_DX8LCDLR1)
+#define DDR0_PUB_DX8LCDLR2 (0x1000 + (0x1B0 << 2))
+#define P_DDR0_PUB_DX8LCDLR2            MMC_REG_ADDR(DDR0_PUB_DX8LCDLR2)
+#define DDR0_PUB_DX8MDLR (0x1000 + (0x1B1 << 2))
+#define P_DDR0_PUB_DX8MDLR              MMC_REG_ADDR(DDR0_PUB_DX8MDLR)
+#define DDR0_PUB_DX8GTR (0x1000 + (0x1B2 << 2))
+#define P_DDR0_PUB_DX8GTR               MMC_REG_ADDR(DDR0_PUB_DX8GTR)
+
+#define DDR1_PCTL_DFILPCFG0 0x22f0
+#define P_DDR1_PCTL_DFILPCFG0           MMC_REG_ADDR(DDR1_PCTL_DFILPCFG0)
+#define DDR1_PCTL_DFITRWRLVLDELAY0 0x2318
+#define P_DDR1_PCTL_DFITRWRLVLDELAY0            \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLDELAY0)
+#define DDR1_PCTL_DFITRWRLVLDELAY1 0x231c
+#define P_DDR1_PCTL_DFITRWRLVLDELAY1            \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLDELAY1)
+#define DDR1_PCTL_DFITRWRLVLDELAY2 0x2320
+#define P_DDR1_PCTL_DFITRWRLVLDELAY2            \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLDELAY2)
+#define DDR1_PCTL_DFITRRDLVLRESP0 0x230c
+#define P_DDR1_PCTL_DFITRRDLVLRESP0             \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLRESP0)
+#define DDR1_PCTL_DFITRRDLVLRESP1 0x2310
+#define P_DDR1_PCTL_DFITRRDLVLRESP1             \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLRESP1)
+#define DDR1_PCTL_DFITRRDLVLRESP2 0x2314
+#define P_DDR1_PCTL_DFITRRDLVLRESP2             \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLRESP2)
+#define DDR1_PCTL_DFITRWRLVLRESP0 0x2300
+#define P_DDR1_PCTL_DFITRWRLVLRESP0             \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLRESP0)
+#define DDR1_PCTL_DFITRRDLVLDELAY0 0x2324
+#define P_DDR1_PCTL_DFITRRDLVLDELAY0            \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLDELAY0)
+#define DDR1_PCTL_DFITRWRLVLRESP1 0x2304
+#define P_DDR1_PCTL_DFITRWRLVLRESP1             \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLRESP1)
+#define DDR1_PCTL_DFITRRDLVLDELAY2 0x232c
+#define P_DDR1_PCTL_DFITRRDLVLDELAY2            \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLDELAY2)
+#define DDR1_PCTL_DFITRWRLVLRESP2 0x2308
+#define P_DDR1_PCTL_DFITRWRLVLRESP2             \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRWRLVLRESP2)
+#define DDR1_PCTL_DFITRRDLVLGATEDELAY0 0x2330
+#define P_DDR1_PCTL_DFITRRDLVLGATEDELAY0                \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLGATEDELAY0)
+#define DDR1_PCTL_DFITRCMD 0x233c
+#define P_DDR1_PCTL_DFITRCMD            MMC_REG_ADDR(DDR1_PCTL_DFITRCMD)
+#define DDR1_PCTL_DFITRRDLVLGATEDELAY1 0x2334
+#define P_DDR1_PCTL_DFITRRDLVLGATEDELAY1                \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLGATEDELAY1)
+#define DDR1_PCTL_DFITRRDLVLGATEDELAY2 0x2338
+#define P_DDR1_PCTL_DFITRRDLVLGATEDELAY2                \
+	MMC_REG_ADDR(DDR1_PCTL_DFITRRDLVLGATEDELAY2)
+#define DDR1_PCTL_IPTR 0x23fc
+#define P_DDR1_PCTL_IPTR                MMC_REG_ADDR(DDR1_PCTL_IPTR)
+#define DDR1_PCTL_IPVR 0x23f8
+#define P_DDR1_PCTL_IPVR                MMC_REG_ADDR(DDR1_PCTL_IPVR)
+#define DDR1_PUB_RIDR (0x3000 + (0x00 << 2))
+#define P_DDR1_PUB_RIDR                 MMC_REG_ADDR(DDR1_PUB_RIDR)
+#define DDR1_PUB_PIR (0x3000 + (0x01 << 2))
+#define P_DDR1_PUB_PIR          MMC_REG_ADDR(DDR1_PUB_PIR)
+#define DDR1_PUB_PGCR0 (0x3000 + (0x02 << 2))
+#define P_DDR1_PUB_PGCR0                MMC_REG_ADDR(DDR1_PUB_PGCR0)
+#define DDR1_PUB_PGCR1 (0x3000 + (0x03 << 2))
+#define P_DDR1_PUB_PGCR1                MMC_REG_ADDR(DDR1_PUB_PGCR1)
+#define DDR1_PUB_PGCR2 (0x3000 + (0x04 << 2))
+#define P_DDR1_PUB_PGCR2                MMC_REG_ADDR(DDR1_PUB_PGCR2)
+#define DDR1_PUB_PGCR3 (0x3000 + (0x05 << 2))
+#define P_DDR1_PUB_PGCR3                MMC_REG_ADDR(DDR1_PUB_PGCR3)
+#define DDR1_PUB_PGSR0 (0x3000 + (0x06 << 2))
+#define P_DDR1_PUB_PGSR0                MMC_REG_ADDR(DDR1_PUB_PGSR0)
+#define DDR1_PUB_PGSR1 (0x3000 + (0x07 << 2))
+#define P_DDR1_PUB_PGSR1                MMC_REG_ADDR(DDR1_PUB_PGSR1)
+#define DDR1_PUB_PLLCR (0x3000 + (0x08 << 2))
+#define P_DDR1_PUB_PLLCR                MMC_REG_ADDR(DDR1_PUB_PLLCR)
+#define DDR1_PUB_PTR0 (0x3000 + (0x09 << 2))
+#define P_DDR1_PUB_PTR0                 MMC_REG_ADDR(DDR1_PUB_PTR0)
+#define DDR1_PUB_PTR1 (0x3000 + (0x0A << 2))
+#define P_DDR1_PUB_PTR1                 MMC_REG_ADDR(DDR1_PUB_PTR1)
+#define DDR1_PUB_PTR2 (0x3000 + (0x0B << 2))
+#define P_DDR1_PUB_PTR2                 MMC_REG_ADDR(DDR1_PUB_PTR2)
+#define DDR1_PUB_PTR3 (0x3000 + (0x0C << 2))
+#define P_DDR1_PUB_PTR3                 MMC_REG_ADDR(DDR1_PUB_PTR3)
+#define DDR1_PUB_PTR4 (0x3000 + (0x0D << 2))
+#define P_DDR1_PUB_PTR4                 MMC_REG_ADDR(DDR1_PUB_PTR4)
+#define DDR1_PUB_ACMDLR (0x3000 + (0x0E << 2))
+#define P_DDR1_PUB_ACMDLR               MMC_REG_ADDR(DDR1_PUB_ACMDLR)
+#define DDR1_PUB_ACLCDLR (0x3000 + (0x0F << 2))
+#define P_DDR1_PUB_ACLCDLR              MMC_REG_ADDR(DDR1_PUB_ACLCDLR)
+#define DDR1_PUB_ACBDLR0 (0x3000 + (0x10 << 2))
+#define P_DDR1_PUB_ACBDLR0              MMC_REG_ADDR(DDR1_PUB_ACBDLR0)
+#define DDR1_PUB_ACBDLR1 (0x3000 + (0x11 << 2))
+#define P_DDR1_PUB_ACBDLR1              MMC_REG_ADDR(DDR1_PUB_ACBDLR1)
+#define DDR1_PUB_ACBDLR2 (0x3000 + (0x12 << 2))
+#define P_DDR1_PUB_ACBDLR2              MMC_REG_ADDR(DDR1_PUB_ACBDLR2)
+#define DDR1_PUB_ACBDLR3 (0x3000 + (0x13 << 2))
+#define P_DDR1_PUB_ACBDLR3              MMC_REG_ADDR(DDR1_PUB_ACBDLR3)
+#define DDR1_PUB_ACBDLR4 (0x3000 + (0x14 << 2))
+#define P_DDR1_PUB_ACBDLR4              MMC_REG_ADDR(DDR1_PUB_ACBDLR4)
+#define DDR1_PUB_ACBDLR5 (0x3000 + (0x15 << 2))
+#define P_DDR1_PUB_ACBDLR5              MMC_REG_ADDR(DDR1_PUB_ACBDLR5)
+#define DDR1_PUB_ACBDLR6 (0x3000 + (0x16 << 2))
+#define P_DDR1_PUB_ACBDLR6              MMC_REG_ADDR(DDR1_PUB_ACBDLR6)
+#define DDR1_PUB_ACBDLR7 (0x3000 + (0x17 << 2))
+#define P_DDR1_PUB_ACBDLR7              MMC_REG_ADDR(DDR1_PUB_ACBDLR7)
+#define DDR1_PUB_ACBDLR8 (0x3000 + (0x18 << 2))
+#define P_DDR1_PUB_ACBDLR8              MMC_REG_ADDR(DDR1_PUB_ACBDLR8)
+#define DDR1_PUB_ACBDLR9 (0x3000 + (0x19 << 2))
+#define P_DDR1_PUB_ACBDLR9              MMC_REG_ADDR(DDR1_PUB_ACBDLR9)
+#define DDR1_PUB_ACIOCR0 (0x3000 + (0x1A << 2))
+#define P_DDR1_PUB_ACIOCR0              MMC_REG_ADDR(DDR1_PUB_ACIOCR0)
+#define DDR1_PUB_ACIOCR1 (0x3000 + (0x1B << 2))
+#define P_DDR1_PUB_ACIOCR1              MMC_REG_ADDR(DDR1_PUB_ACIOCR1)
+#define DDR1_PUB_ACIOCR2 (0x3000 + (0x1C << 2))
+#define P_DDR1_PUB_ACIOCR2              MMC_REG_ADDR(DDR1_PUB_ACIOCR2)
+#define DDR1_PUB_ACIOCR3 (0x3000 + (0x1D << 2))
+#define P_DDR1_PUB_ACIOCR3              MMC_REG_ADDR(DDR1_PUB_ACIOCR3)
+#define DDR1_PUB_ACIOCR4 (0x3000 + (0x1E << 2))
+#define P_DDR1_PUB_ACIOCR4              MMC_REG_ADDR(DDR1_PUB_ACIOCR4)
+#define DDR1_PUB_ACIOCR5 (0x3000 + (0x1F << 2))
+#define P_DDR1_PUB_ACIOCR5              MMC_REG_ADDR(DDR1_PUB_ACIOCR5)
+#define DDR1_PUB_DXCCR (0x3000 + (0x20 << 2))
+#define P_DDR1_PUB_DXCCR                MMC_REG_ADDR(DDR1_PUB_DXCCR)
+#define DDR1_PUB_DSGCR (0x3000 + (0x21 << 2))
+#define P_DDR1_PUB_DSGCR                MMC_REG_ADDR(DDR1_PUB_DSGCR)
+#define DDR1_PUB_DCR (0x3000 + (0x22 << 2))
+#define P_DDR1_PUB_DCR          MMC_REG_ADDR(DDR1_PUB_DCR)
+#define DDR1_PUB_DTPR0 (0x3000 + (0x23 << 2))
+#define P_DDR1_PUB_DTPR0                MMC_REG_ADDR(DDR1_PUB_DTPR0)
+#define DDR1_PUB_DTPR1 (0x3000 + (0x24 << 2))
+#define P_DDR1_PUB_DTPR1                MMC_REG_ADDR(DDR1_PUB_DTPR1)
+#define DDR1_PUB_DTPR2 (0x3000 + (0x25 << 2))
+#define P_DDR1_PUB_DTPR2                MMC_REG_ADDR(DDR1_PUB_DTPR2)
+#define DDR1_PUB_DTPR3 (0x3000 + (0x26 << 2))
+#define P_DDR1_PUB_DTPR3                MMC_REG_ADDR(DDR1_PUB_DTPR3)
+#define DDR1_PUB_MR0 (0x3000 + (0x27 << 2))
+#define P_DDR1_PUB_MR0          MMC_REG_ADDR(DDR1_PUB_MR0)
+#define DDR1_PUB_MR1 (0x3000 + (0x28 << 2))
+#define P_DDR1_PUB_MR1          MMC_REG_ADDR(DDR1_PUB_MR1)
+#define DDR1_PUB_MR2 (0x3000 + (0x29 << 2))
+#define P_DDR1_PUB_MR2          MMC_REG_ADDR(DDR1_PUB_MR2)
+#define DDR1_PUB_MR3 (0x3000 + (0x2A << 2))
+#define P_DDR1_PUB_MR3          MMC_REG_ADDR(DDR1_PUB_MR3)
+#define DDR1_PUB_ODTCR (0x3000 + (0x2B << 2))
+#define P_DDR1_PUB_ODTCR                MMC_REG_ADDR(DDR1_PUB_ODTCR)
+#define DDR1_PUB_DTCR (0x3000 + (0x2C << 2))
+#define P_DDR1_PUB_DTCR                 MMC_REG_ADDR(DDR1_PUB_DTCR)
+#define DDR1_PUB_DTAR0 (0x3000 + (0x2D << 2))
+#define P_DDR1_PUB_DTAR0                MMC_REG_ADDR(DDR1_PUB_DTAR0)
+#define DDR1_PUB_DTAR1 (0x3000 + (0x2E << 2))
+#define P_DDR1_PUB_DTAR1                MMC_REG_ADDR(DDR1_PUB_DTAR1)
+#define DDR1_PUB_DTAR2 (0x3000 + (0x2F << 2))
+#define P_DDR1_PUB_DTAR2                MMC_REG_ADDR(DDR1_PUB_DTAR2)
+#define DDR1_PUB_DTAR3 (0x3000 + (0x30 << 2))
+#define P_DDR1_PUB_DTAR3                MMC_REG_ADDR(DDR1_PUB_DTAR3)
+#define DDR1_PUB_DTDR0 (0x3000 + (0x31 << 2))
+#define P_DDR1_PUB_DTDR0                MMC_REG_ADDR(DDR1_PUB_DTDR0)
+#define DDR1_PUB_DTDR1 (0x3000 + (0x32 << 2))
+#define P_DDR1_PUB_DTDR1                MMC_REG_ADDR(DDR1_PUB_DTDR1)
+#define DDR1_PUB_DTEDR0 (0x3000 + (0x33 << 2))
+#define P_DDR1_PUB_DTEDR0               MMC_REG_ADDR(DDR1_PUB_DTEDR0)
+#define DDR1_PUB_DTEDR1 (0x3000 + (0x34 << 2))
+#define P_DDR1_PUB_DTEDR1               MMC_REG_ADDR(DDR1_PUB_DTEDR1)
+#define DDR1_PUB_RDIMMGCR0 (0x3000 + (0x35 << 2))
+#define P_DDR1_PUB_RDIMMGCR0            MMC_REG_ADDR(DDR1_PUB_RDIMMGCR0)
+#define DDR1_PUB_RDIMMGCR1 (0x3000 + (0x36 << 2))
+#define P_DDR1_PUB_RDIMMGCR1            MMC_REG_ADDR(DDR1_PUB_RDIMMGCR1)
+#define DDR1_PUB_RDIMMCR0 (0x3000 + (0x37 << 2))
+#define P_DDR1_PUB_RDIMMCR0             MMC_REG_ADDR(DDR1_PUB_RDIMMCR0)
+#define DDR1_PUB_RDIMMCR1 (0x3000 + (0x38 << 2))
+#define P_DDR1_PUB_RDIMMCR1             MMC_REG_ADDR(DDR1_PUB_RDIMMCR1)
+#define DDR1_PUB_GPR0 (0x3000 + (0x39 << 2))
+#define P_DDR1_PUB_GPR0                 MMC_REG_ADDR(DDR1_PUB_GPR0)
+#define DDR1_PUB_GPR1 (0x3000 + (0x3A << 2))
+#define P_DDR1_PUB_GPR1                 MMC_REG_ADDR(DDR1_PUB_GPR1)
+#define DDR1_PUB_CATR0 (0x3000 + (0x3B << 2))
+#define P_DDR1_PUB_CATR0                MMC_REG_ADDR(DDR1_PUB_CATR0)
+#define DDR1_PUB_CATR1 (0x3000 + (0x3C << 2))
+#define P_DDR1_PUB_CATR1                MMC_REG_ADDR(DDR1_PUB_CATR1)
+#define DDR1_PUB_DCUAR (0x3000 + (0x60 << 2))
+#define P_DDR1_PUB_DCUAR                MMC_REG_ADDR(DDR1_PUB_DCUAR)
+#define DDR1_PUB_DCUDR (0x3000 + (0x61 << 2))
+#define P_DDR1_PUB_DCUDR                MMC_REG_ADDR(DDR1_PUB_DCUDR)
+#define DDR1_PUB_DCURR (0x3000 + (0x62 << 2))
+#define P_DDR1_PUB_DCURR                MMC_REG_ADDR(DDR1_PUB_DCURR)
+#define DDR1_PUB_DCULR (0x3000 + (0x63 << 2))
+#define P_DDR1_PUB_DCULR                MMC_REG_ADDR(DDR1_PUB_DCULR)
+#define DDR1_PUB_DCUGCR (0x3000 + (0x64 << 2))
+#define P_DDR1_PUB_DCUGCR               MMC_REG_ADDR(DDR1_PUB_DCUGCR)
+#define DDR1_PUB_DCUTPR (0x3000 + (0x65 << 2))
+#define P_DDR1_PUB_DCUTPR               MMC_REG_ADDR(DDR1_PUB_DCUTPR)
+#define DDR1_PUB_DCUSR0 (0x3000 + (0x66 << 2))
+#define P_DDR1_PUB_DCUSR0               MMC_REG_ADDR(DDR1_PUB_DCUSR0)
+#define DDR1_PUB_DCUSR1 (0x3000 + (0x67 << 2))
+#define P_DDR1_PUB_DCUSR1               MMC_REG_ADDR(DDR1_PUB_DCUSR1)
+#define DDR1_PUB_BISTRR (0x3000 + (0x70 << 2))
+#define P_DDR1_PUB_BISTRR               MMC_REG_ADDR(DDR1_PUB_BISTRR)
+#define DDR1_PUB_BISTWCR (0x3000 + (0x71 << 2))
+#define P_DDR1_PUB_BISTWCR              MMC_REG_ADDR(DDR1_PUB_BISTWCR)
+#define DDR1_PUB_BISTMSKR0 (0x3000 + (0x72 << 2))
+#define P_DDR1_PUB_BISTMSKR0            MMC_REG_ADDR(DDR1_PUB_BISTMSKR0)
+#define DDR1_PUB_BISTMSKR1 (0x3000 + (0x73 << 2))
+#define P_DDR1_PUB_BISTMSKR1            MMC_REG_ADDR(DDR1_PUB_BISTMSKR1)
+#define DDR1_PUB_BISTMSKR2 (0x3000 + (0x74 << 2))
+#define P_DDR1_PUB_BISTMSKR2            MMC_REG_ADDR(DDR1_PUB_BISTMSKR2)
+#define DDR1_PUB_BISTLSR (0x3000 + (0x75 << 2))
+#define P_DDR1_PUB_BISTLSR              MMC_REG_ADDR(DDR1_PUB_BISTLSR)
+#define DDR1_PUB_BISTAR0 (0x3000 + (0x76 << 2))
+#define P_DDR1_PUB_BISTAR0              MMC_REG_ADDR(DDR1_PUB_BISTAR0)
+#define DDR1_PUB_BISTAR1 (0x3000 + (0x77 << 2))
+#define P_DDR1_PUB_BISTAR1              MMC_REG_ADDR(DDR1_PUB_BISTAR1)
+#define DDR1_PUB_BISTAR2 (0x3000 + (0x78 << 2))
+#define P_DDR1_PUB_BISTAR2              MMC_REG_ADDR(DDR1_PUB_BISTAR2)
+#define DDR1_PUB_BISTUDPR (0x3000 + (0x79 << 2))
+#define P_DDR1_PUB_BISTUDPR             MMC_REG_ADDR(DDR1_PUB_BISTUDPR)
+#define DDR1_PUB_BISTGSR (0x3000 + (0x7A << 2))
+#define P_DDR1_PUB_BISTGSR              MMC_REG_ADDR(DDR1_PUB_BISTGSR)
+#define DDR1_PUB_BISTWER (0x3000 + (0x7B << 2))
+#define P_DDR1_PUB_BISTWER              MMC_REG_ADDR(DDR1_PUB_BISTWER)
+#define DDR1_PUB_BISTBER0 (0x3000 + (0x7C << 2))
+#define P_DDR1_PUB_BISTBER0             MMC_REG_ADDR(DDR1_PUB_BISTBER0)
+#define DDR1_PUB_BISTBER1 (0x3000 + (0x7D << 2))
+#define P_DDR1_PUB_BISTBER1             MMC_REG_ADDR(DDR1_PUB_BISTBER1)
+#define DDR1_PUB_BISTBER2 (0x3000 + (0x7E << 2))
+#define P_DDR1_PUB_BISTBER2             MMC_REG_ADDR(DDR1_PUB_BISTBER2)
+#define DDR1_PUB_BISTBER3 (0x3000 + (0x7F << 2))
+#define P_DDR1_PUB_BISTBER3             MMC_REG_ADDR(DDR1_PUB_BISTBER3)
+#define DDR1_PUB_BISTWCSR (0x3000 + (0x80 << 2))
+#define P_DDR1_PUB_BISTWCSR             MMC_REG_ADDR(DDR1_PUB_BISTWCSR)
+#define DDR1_PUB_BISTFWR0 (0x3000 + (0x81 << 2))
+#define P_DDR1_PUB_BISTFWR0             MMC_REG_ADDR(DDR1_PUB_BISTFWR0)
+#define DDR1_PUB_BISTFWR1 (0x3000 + (0x82 << 2))
+#define P_DDR1_PUB_BISTFWR1             MMC_REG_ADDR(DDR1_PUB_BISTFWR1)
+#define DDR1_PUB_BISTFWR2 (0x3000 + (0x83 << 2))
+#define P_DDR1_PUB_BISTFWR2             MMC_REG_ADDR(DDR1_PUB_BISTFWR2)
+#define DDR1_PUB_IOVCR0 (0x3000 + (0x8E << 2))
+#define P_DDR1_PUB_IOVCR0               MMC_REG_ADDR(DDR1_PUB_IOVCR0)
+#define DDR1_PUB_IOVCR1 (0x3000 + (0x8F << 2))
+#define P_DDR1_PUB_IOVCR1               MMC_REG_ADDR(DDR1_PUB_IOVCR1)
+#define DDR1_PUB_ZQCR (0x3000 + (0x90 << 2))
+#define P_DDR1_PUB_ZQCR                 MMC_REG_ADDR(DDR1_PUB_ZQCR)
+#define DDR1_PUB_ZQ0PR (0x3000 + (0x91 << 2))
+#define P_DDR1_PUB_ZQ0PR                MMC_REG_ADDR(DDR1_PUB_ZQ0PR)
+#define DDR1_PUB_ZQ0DR (0x3000 + (0x92 << 2))
+#define P_DDR1_PUB_ZQ0DR                MMC_REG_ADDR(DDR1_PUB_ZQ0DR)
+#define DDR1_PUB_ZQ0SR (0x3000 + (0x93 << 2))
+#define P_DDR1_PUB_ZQ0SR                MMC_REG_ADDR(DDR1_PUB_ZQ0SR)
+#define DDR1_PUB_ZQ1PR (0x3000 + (0x95 << 2))
+#define P_DDR1_PUB_ZQ1PR                MMC_REG_ADDR(DDR1_PUB_ZQ1PR)
+#define DDR1_PUB_ZQ1DR (0x3000 + (0x96 << 2))
+#define P_DDR1_PUB_ZQ1DR                MMC_REG_ADDR(DDR1_PUB_ZQ1DR)
+#define DDR1_PUB_ZQ1SR (0x3000 + (0x97 << 2))
+#define P_DDR1_PUB_ZQ1SR                MMC_REG_ADDR(DDR1_PUB_ZQ1SR)
+#define DDR1_PUB_ZQ2PR (0x3000 + (0x99 << 2))
+#define P_DDR1_PUB_ZQ2PR                MMC_REG_ADDR(DDR1_PUB_ZQ2PR)
+#define DDR1_PUB_ZQ2DR (0x3000 + (0x9A << 2))
+#define P_DDR1_PUB_ZQ2DR                MMC_REG_ADDR(DDR1_PUB_ZQ2DR)
+#define DDR1_PUB_ZQ2SR (0x3000 + (0x9B << 2))
+#define P_DDR1_PUB_ZQ2SR                MMC_REG_ADDR(DDR1_PUB_ZQ2SR)
+#define DDR1_PUB_ZQ3PR (0x3000 + (0x9D << 2))
+#define P_DDR1_PUB_ZQ3PR                MMC_REG_ADDR(DDR1_PUB_ZQ3PR)
+#define DDR1_PUB_ZQ3DR (0x3000 + (0x9E << 2))
+#define P_DDR1_PUB_ZQ3DR                MMC_REG_ADDR(DDR1_PUB_ZQ3DR)
+#define DDR1_PUB_ZQ3SR (0x3000 + (0x9F << 2))
+#define P_DDR1_PUB_ZQ3SR                MMC_REG_ADDR(DDR1_PUB_ZQ3SR)
+#define DDR1_PUB_DX0GCR0 (0x3000 + (0xA0 << 2))
+#define P_DDR1_PUB_DX0GCR0              MMC_REG_ADDR(DDR1_PUB_DX0GCR0)
+#define DDR1_PUB_DX0GCR1 (0x3000 + (0xA1 << 2))
+#define P_DDR1_PUB_DX0GCR1              MMC_REG_ADDR(DDR1_PUB_DX0GCR1)
+#define DDR1_PUB_DX0GCR2 (0x3000 + (0xA2 << 2))
+#define P_DDR1_PUB_DX0GCR2              MMC_REG_ADDR(DDR1_PUB_DX0GCR2)
+#define DDR1_PUB_DX0GCR3 (0x3000 + (0xA3 << 2))
+#define P_DDR1_PUB_DX0GCR3              MMC_REG_ADDR(DDR1_PUB_DX0GCR3)
+#define DDR1_PUB_DX0GSR0 (0x3000 + (0xA4 << 2))
+#define P_DDR1_PUB_DX0GSR0              MMC_REG_ADDR(DDR1_PUB_DX0GSR0)
+#define DDR1_PUB_DX0GSR1 (0x3000 + (0xA5 << 2))
+#define P_DDR1_PUB_DX0GSR1              MMC_REG_ADDR(DDR1_PUB_DX0GSR1)
+#define DDR1_PUB_DX0GSR2 (0x3000 + (0xA6 << 2))
+#define P_DDR1_PUB_DX0GSR2              MMC_REG_ADDR(DDR1_PUB_DX0GSR2)
+#define DDR1_PUB_DX0BDLR0 (0x3000 + (0xA7 << 2))
+#define P_DDR1_PUB_DX0BDLR0             MMC_REG_ADDR(DDR1_PUB_DX0BDLR0)
+#define DDR1_PUB_DX0BDLR1 (0x3000 + (0xA8 << 2))
+#define P_DDR1_PUB_DX0BDLR1             MMC_REG_ADDR(DDR1_PUB_DX0BDLR1)
+#define DDR1_PUB_DX0BDLR2 (0x3000 + (0xA9 << 2))
+#define P_DDR1_PUB_DX0BDLR2             MMC_REG_ADDR(DDR1_PUB_DX0BDLR2)
+#define DDR1_PUB_DX0BDLR3 (0x3000 + (0xAA << 2))
+#define P_DDR1_PUB_DX0BDLR3             MMC_REG_ADDR(DDR1_PUB_DX0BDLR3)
+#define DDR1_PUB_DX0BDLR4 (0x3000 + (0xAB << 2))
+#define P_DDR1_PUB_DX0BDLR4             MMC_REG_ADDR(DDR1_PUB_DX0BDLR4)
+#define DDR1_PUB_DX0BDLR5 (0x3000 + (0xAC << 2))
+#define P_DDR1_PUB_DX0BDLR5             MMC_REG_ADDR(DDR1_PUB_DX0BDLR5)
+#define DDR1_PUB_DX0BDLR6 (0x3000 + (0xAD << 2))
+#define P_DDR1_PUB_DX0BDLR6             MMC_REG_ADDR(DDR1_PUB_DX0BDLR6)
+#define DDR1_PUB_DX0LCDLR0 (0x3000 + (0xAE << 2))
+#define P_DDR1_PUB_DX0LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX0LCDLR0)
+#define DDR1_PUB_DX0LCDLR1 (0x3000 + (0xAF << 2))
+#define P_DDR1_PUB_DX0LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX0LCDLR1)
+#define DDR1_PUB_DX0LCDLR2 (0x3000 + (0xB0 << 2))
+#define P_DDR1_PUB_DX0LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX0LCDLR2)
+#define DDR1_PUB_DX0MDLR (0x3000 + (0xB1 << 2))
+#define P_DDR1_PUB_DX0MDLR              MMC_REG_ADDR(DDR1_PUB_DX0MDLR)
+#define DDR1_PUB_DX0GTR (0x3000 + (0xB2 << 2))
+#define P_DDR1_PUB_DX0GTR               MMC_REG_ADDR(DDR1_PUB_DX0GTR)
+#define DDR1_PUB_DX1GCR0 (0x3000 + (0xC0 << 2))
+#define P_DDR1_PUB_DX1GCR0              MMC_REG_ADDR(DDR1_PUB_DX1GCR0)
+#define DDR1_PUB_DX1GCR1 (0x3000 + (0xC1 << 2))
+#define P_DDR1_PUB_DX1GCR1              MMC_REG_ADDR(DDR1_PUB_DX1GCR1)
+#define DDR1_PUB_DX1GCR2 (0x3000 + (0xC2 << 2))
+#define P_DDR1_PUB_DX1GCR2              MMC_REG_ADDR(DDR1_PUB_DX1GCR2)
+#define DDR1_PUB_DX1GCR3 (0x3000 + (0xC3 << 2))
+#define P_DDR1_PUB_DX1GCR3              MMC_REG_ADDR(DDR1_PUB_DX1GCR3)
+#define DDR1_PUB_DX1GSR0 (0x3000 + (0xC4 << 2))
+#define P_DDR1_PUB_DX1GSR0              MMC_REG_ADDR(DDR1_PUB_DX1GSR0)
+#define DDR1_PUB_DX1GSR1 (0x3000 + (0xC5 << 2))
+#define P_DDR1_PUB_DX1GSR1              MMC_REG_ADDR(DDR1_PUB_DX1GSR1)
+#define DDR1_PUB_DX1GSR2 (0x3000 + (0xC6 << 2))
+#define P_DDR1_PUB_DX1GSR2              MMC_REG_ADDR(DDR1_PUB_DX1GSR2)
+#define DDR1_PUB_DX1BDLR0 (0x3000 + (0xC7 << 2))
+#define P_DDR1_PUB_DX1BDLR0             MMC_REG_ADDR(DDR1_PUB_DX1BDLR0)
+#define DDR1_PUB_DX1BDLR1 (0x3000 + (0xC8 << 2))
+#define P_DDR1_PUB_DX1BDLR1             MMC_REG_ADDR(DDR1_PUB_DX1BDLR1)
+#define DDR1_PUB_DX1BDLR2 (0x3000 + (0xC9 << 2))
+#define P_DDR1_PUB_DX1BDLR2             MMC_REG_ADDR(DDR1_PUB_DX1BDLR2)
+#define DDR1_PUB_DX1BDLR3 (0x3000 + (0xCA << 2))
+#define P_DDR1_PUB_DX1BDLR3             MMC_REG_ADDR(DDR1_PUB_DX1BDLR3)
+#define DDR1_PUB_DX1BDLR4 (0x3000 + (0xCB << 2))
+#define P_DDR1_PUB_DX1BDLR4             MMC_REG_ADDR(DDR1_PUB_DX1BDLR4)
+#define DDR1_PUB_DX1BDLR5 (0x3000 + (0xCC << 2))
+#define P_DDR1_PUB_DX1BDLR5             MMC_REG_ADDR(DDR1_PUB_DX1BDLR5)
+#define DDR1_PUB_DX1BDLR6 (0x3000 + (0xCD << 2))
+#define P_DDR1_PUB_DX1BDLR6             MMC_REG_ADDR(DDR1_PUB_DX1BDLR6)
+#define DDR1_PUB_DX1LCDLR0 (0x3000 + (0xCE << 2))
+#define P_DDR1_PUB_DX1LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX1LCDLR0)
+#define DDR1_PUB_DX1LCDLR1 (0x3000 + (0xCF << 2))
+#define P_DDR1_PUB_DX1LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX1LCDLR1)
+#define DDR1_PUB_DX1LCDLR2 (0x3000 + (0xD0 << 2))
+#define P_DDR1_PUB_DX1LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX1LCDLR2)
+#define DDR1_PUB_DX1MDLR (0x3000 + (0xD1 << 2))
+#define P_DDR1_PUB_DX1MDLR              MMC_REG_ADDR(DDR1_PUB_DX1MDLR)
+#define DDR1_PUB_DX1GTR (0x3000 + (0xD2 << 2))
+#define P_DDR1_PUB_DX1GTR               MMC_REG_ADDR(DDR1_PUB_DX1GTR)
+#define DDR1_PUB_DX2GCR0 (0x3000 + (0xE0 << 2))
+#define P_DDR1_PUB_DX2GCR0              MMC_REG_ADDR(DDR1_PUB_DX2GCR0)
+#define DDR1_PUB_DX2GCR1 (0x3000 + (0xE1 << 2))
+#define P_DDR1_PUB_DX2GCR1              MMC_REG_ADDR(DDR1_PUB_DX2GCR1)
+#define DDR1_PUB_DX2GCR2 (0x3000 + (0xE2 << 2))
+#define P_DDR1_PUB_DX2GCR2              MMC_REG_ADDR(DDR1_PUB_DX2GCR2)
+#define DDR1_PUB_DX2GCR3 (0x3000 + (0xE3 << 2))
+#define P_DDR1_PUB_DX2GCR3              MMC_REG_ADDR(DDR1_PUB_DX2GCR3)
+#define DDR1_PUB_DX2GSR0 (0x3000 + (0xE4 << 2))
+#define P_DDR1_PUB_DX2GSR0              MMC_REG_ADDR(DDR1_PUB_DX2GSR0)
+#define DDR1_PUB_DX2GSR1 (0x3000 + (0xE5 << 2))
+#define P_DDR1_PUB_DX2GSR1              MMC_REG_ADDR(DDR1_PUB_DX2GSR1)
+#define DDR1_PUB_DX2GSR2 (0x3000 + (0xE6 << 2))
+#define P_DDR1_PUB_DX2GSR2              MMC_REG_ADDR(DDR1_PUB_DX2GSR2)
+#define DDR1_PUB_DX2BDLR0 (0x3000 + (0xE7 << 2))
+#define P_DDR1_PUB_DX2BDLR0             MMC_REG_ADDR(DDR1_PUB_DX2BDLR0)
+#define DDR1_PUB_DX2BDLR1 (0x3000 + (0xE8 << 2))
+#define P_DDR1_PUB_DX2BDLR1             MMC_REG_ADDR(DDR1_PUB_DX2BDLR1)
+#define DDR1_PUB_DX2BDLR2 (0x3000 + (0xE9 << 2))
+#define P_DDR1_PUB_DX2BDLR2             MMC_REG_ADDR(DDR1_PUB_DX2BDLR2)
+#define DDR1_PUB_DX2BDLR3 (0x3000 + (0xEA << 2))
+#define P_DDR1_PUB_DX2BDLR3             MMC_REG_ADDR(DDR1_PUB_DX2BDLR3)
+#define DDR1_PUB_DX2BDLR4 (0x3000 + (0xEB << 2))
+#define P_DDR1_PUB_DX2BDLR4             MMC_REG_ADDR(DDR1_PUB_DX2BDLR4)
+#define DDR1_PUB_DX2BDLR5 (0x3000 + (0xEC << 2))
+#define P_DDR1_PUB_DX2BDLR5             MMC_REG_ADDR(DDR1_PUB_DX2BDLR5)
+#define DDR1_PUB_DX2BDLR6 (0x3000 + (0xED << 2))
+#define P_DDR1_PUB_DX2BDLR6             MMC_REG_ADDR(DDR1_PUB_DX2BDLR6)
+#define DDR1_PUB_DX2LCDLR0 (0x3000 + (0xEE << 2))
+#define P_DDR1_PUB_DX2LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX2LCDLR0)
+#define DDR1_PUB_DX2LCDLR1 (0x3000 + (0xEF << 2))
+#define P_DDR1_PUB_DX2LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX2LCDLR1)
+#define DDR1_PUB_DX2LCDLR2 (0x3000 + (0xF0 << 2))
+#define P_DDR1_PUB_DX2LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX2LCDLR2)
+#define DDR1_PUB_DX2MDLR (0x3000 + (0xF1 << 2))
+#define P_DDR1_PUB_DX2MDLR              MMC_REG_ADDR(DDR1_PUB_DX2MDLR)
+#define DDR1_PUB_DX2GTR (0x3000 + (0xF2 << 2))
+#define P_DDR1_PUB_DX2GTR               MMC_REG_ADDR(DDR1_PUB_DX2GTR)
+#define DDR1_PUB_DX3GCR0 (0x3000 + (0x100 << 2))
+#define P_DDR1_PUB_DX3GCR0              MMC_REG_ADDR(DDR1_PUB_DX3GCR0)
+#define DDR1_PUB_DX3GCR1 (0x3000 + (0x101 << 2))
+#define P_DDR1_PUB_DX3GCR1              MMC_REG_ADDR(DDR1_PUB_DX3GCR1)
+#define DDR1_PUB_DX3GCR2 (0x3000 + (0x102 << 2))
+#define P_DDR1_PUB_DX3GCR2              MMC_REG_ADDR(DDR1_PUB_DX3GCR2)
+#define DDR1_PUB_DX3GCR3 (0x3000 + (0x103 << 2))
+#define P_DDR1_PUB_DX3GCR3              MMC_REG_ADDR(DDR1_PUB_DX3GCR3)
+#define DDR1_PUB_DX3GSR0 (0x3000 + (0x104 << 2))
+#define P_DDR1_PUB_DX3GSR0              MMC_REG_ADDR(DDR1_PUB_DX3GSR0)
+#define DDR1_PUB_DX3GSR1 (0x3000 + (0x105 << 2))
+#define P_DDR1_PUB_DX3GSR1              MMC_REG_ADDR(DDR1_PUB_DX3GSR1)
+#define DDR1_PUB_DX3GSR2 (0x3000 + (0x106 << 2))
+#define P_DDR1_PUB_DX3GSR2              MMC_REG_ADDR(DDR1_PUB_DX3GSR2)
+#define DDR1_PUB_DX3BDLR0 (0x3000 + (0x107 << 2))
+#define P_DDR1_PUB_DX3BDLR0             MMC_REG_ADDR(DDR1_PUB_DX3BDLR0)
+#define DDR1_PUB_DX3BDLR1 (0x3000 + (0x108 << 2))
+#define P_DDR1_PUB_DX3BDLR1             MMC_REG_ADDR(DDR1_PUB_DX3BDLR1)
+#define DDR1_PUB_DX3BDLR2 (0x3000 + (0x109 << 2))
+#define P_DDR1_PUB_DX3BDLR2             MMC_REG_ADDR(DDR1_PUB_DX3BDLR2)
+#define DDR1_PUB_DX3BDLR3 (0x3000 + (0x10A << 2))
+#define P_DDR1_PUB_DX3BDLR3             MMC_REG_ADDR(DDR1_PUB_DX3BDLR3)
+#define DDR1_PUB_DX3BDLR4 (0x3000 + (0x10B << 2))
+#define P_DDR1_PUB_DX3BDLR4             MMC_REG_ADDR(DDR1_PUB_DX3BDLR4)
+#define DDR1_PUB_DX3BDLR5 (0x3000 + (0x10C << 2))
+#define P_DDR1_PUB_DX3BDLR5             MMC_REG_ADDR(DDR1_PUB_DX3BDLR5)
+#define DDR1_PUB_DX3BDLR6 (0x3000 + (0x10D << 2))
+#define P_DDR1_PUB_DX3BDLR6             MMC_REG_ADDR(DDR1_PUB_DX3BDLR6)
+#define DDR1_PUB_DX3LCDLR0 (0x3000 + (0x10E << 2))
+#define P_DDR1_PUB_DX3LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX3LCDLR0)
+#define DDR1_PUB_DX3LCDLR1 (0x3000 + (0x10F << 2))
+#define P_DDR1_PUB_DX3LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX3LCDLR1)
+#define DDR1_PUB_DX3LCDLR2 (0x3000 + (0x110 << 2))
+#define P_DDR1_PUB_DX3LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX3LCDLR2)
+#define DDR1_PUB_DX3MDLR (0x3000 + (0x111 << 2))
+#define P_DDR1_PUB_DX3MDLR              MMC_REG_ADDR(DDR1_PUB_DX3MDLR)
+#define DDR1_PUB_DX3GTR (0x3000 + (0x112 << 2))
+#define P_DDR1_PUB_DX3GTR               MMC_REG_ADDR(DDR1_PUB_DX3GTR)
+#define DDR1_PUB_DX4GCR0 (0x3000 + (0x120 << 2))
+#define P_DDR1_PUB_DX4GCR0              MMC_REG_ADDR(DDR1_PUB_DX4GCR0)
+#define DDR1_PUB_DX4GCR1 (0x3000 + (0x121 << 2))
+#define P_DDR1_PUB_DX4GCR1              MMC_REG_ADDR(DDR1_PUB_DX4GCR1)
+#define DDR1_PUB_DX4GCR2 (0x3000 + (0x122 << 2))
+#define P_DDR1_PUB_DX4GCR2              MMC_REG_ADDR(DDR1_PUB_DX4GCR2)
+#define DDR1_PUB_DX4GCR3 (0x3000 + (0x123 << 2))
+#define P_DDR1_PUB_DX4GCR3              MMC_REG_ADDR(DDR1_PUB_DX4GCR3)
+#define DDR1_PUB_DX4GSR0 (0x3000 + (0x124 << 2))
+#define P_DDR1_PUB_DX4GSR0              MMC_REG_ADDR(DDR1_PUB_DX4GSR0)
+#define DDR1_PUB_DX4GSR1 (0x3000 + (0x125 << 2))
+#define P_DDR1_PUB_DX4GSR1              MMC_REG_ADDR(DDR1_PUB_DX4GSR1)
+#define DDR1_PUB_DX4GSR2 (0x3000 + (0x126 << 2))
+#define P_DDR1_PUB_DX4GSR2              MMC_REG_ADDR(DDR1_PUB_DX4GSR2)
+#define DDR1_PUB_DX4BDLR0 (0x3000 + (0x127 << 2))
+#define P_DDR1_PUB_DX4BDLR0             MMC_REG_ADDR(DDR1_PUB_DX4BDLR0)
+#define DDR1_PUB_DX4BDLR1 (0x3000 + (0x128 << 2))
+#define P_DDR1_PUB_DX4BDLR1             MMC_REG_ADDR(DDR1_PUB_DX4BDLR1)
+#define DDR1_PUB_DX4BDLR2 (0x3000 + (0x129 << 2))
+#define P_DDR1_PUB_DX4BDLR2             MMC_REG_ADDR(DDR1_PUB_DX4BDLR2)
+#define DDR1_PUB_DX4BDLR3 (0x3000 + (0x12A << 2))
+#define P_DDR1_PUB_DX4BDLR3             MMC_REG_ADDR(DDR1_PUB_DX4BDLR3)
+#define DDR1_PUB_DX4BDLR4 (0x3000 + (0x12B << 2))
+#define P_DDR1_PUB_DX4BDLR4             MMC_REG_ADDR(DDR1_PUB_DX4BDLR4)
+#define DDR1_PUB_DX4BDLR5 (0x3000 + (0x12C << 2))
+#define P_DDR1_PUB_DX4BDLR5             MMC_REG_ADDR(DDR1_PUB_DX4BDLR5)
+#define DDR1_PUB_DX4BDLR6 (0x3000 + (0x12D << 2))
+#define P_DDR1_PUB_DX4BDLR6             MMC_REG_ADDR(DDR1_PUB_DX4BDLR6)
+#define DDR1_PUB_DX4LCDLR0 (0x3000 + (0x12E << 2))
+#define P_DDR1_PUB_DX4LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX4LCDLR0)
+#define DDR1_PUB_DX4LCDLR1 (0x3000 + (0x12F << 2))
+#define P_DDR1_PUB_DX4LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX4LCDLR1)
+#define DDR1_PUB_DX4LCDLR2 (0x3000 + (0x130 << 2))
+#define P_DDR1_PUB_DX4LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX4LCDLR2)
+#define DDR1_PUB_DX4MDLR (0x3000 + (0x131 << 2))
+#define P_DDR1_PUB_DX4MDLR              MMC_REG_ADDR(DDR1_PUB_DX4MDLR)
+#define DDR1_PUB_DX4GTR (0x3000 + (0x132 << 2))
+#define P_DDR1_PUB_DX4GTR               MMC_REG_ADDR(DDR1_PUB_DX4GTR)
+#define DDR1_PUB_DX5GCR0 (0x3000 + (0x140 << 2))
+#define P_DDR1_PUB_DX5GCR0              MMC_REG_ADDR(DDR1_PUB_DX5GCR0)
+#define DDR1_PUB_DX5GCR1 (0x3000 + (0x141 << 2))
+#define P_DDR1_PUB_DX5GCR1              MMC_REG_ADDR(DDR1_PUB_DX5GCR1)
+#define DDR1_PUB_DX5GCR2 (0x3000 + (0x142 << 2))
+#define P_DDR1_PUB_DX5GCR2              MMC_REG_ADDR(DDR1_PUB_DX5GCR2)
+#define DDR1_PUB_DX5GCR3 (0x3000 + (0x143 << 2))
+#define P_DDR1_PUB_DX5GCR3              MMC_REG_ADDR(DDR1_PUB_DX5GCR3)
+#define DDR1_PUB_DX5GSR0 (0x3000 + (0x144 << 2))
+#define P_DDR1_PUB_DX5GSR0              MMC_REG_ADDR(DDR1_PUB_DX5GSR0)
+#define DDR1_PUB_DX5GSR1 (0x3000 + (0x145 << 2))
+#define P_DDR1_PUB_DX5GSR1              MMC_REG_ADDR(DDR1_PUB_DX5GSR1)
+#define DDR1_PUB_DX5GSR2 (0x3000 + (0x146 << 2))
+#define P_DDR1_PUB_DX5GSR2              MMC_REG_ADDR(DDR1_PUB_DX5GSR2)
+#define DDR1_PUB_DX5BDLR0 (0x3000 + (0x147 << 2))
+#define P_DDR1_PUB_DX5BDLR0             MMC_REG_ADDR(DDR1_PUB_DX5BDLR0)
+#define DDR1_PUB_DX5BDLR1 (0x3000 + (0x148 << 2))
+#define P_DDR1_PUB_DX5BDLR1             MMC_REG_ADDR(DDR1_PUB_DX5BDLR1)
+#define DDR1_PUB_DX5BDLR2 (0x3000 + (0x149 << 2))
+#define P_DDR1_PUB_DX5BDLR2             MMC_REG_ADDR(DDR1_PUB_DX5BDLR2)
+#define DDR1_PUB_DX5BDLR3 (0x3000 + (0x14A << 2))
+#define P_DDR1_PUB_DX5BDLR3             MMC_REG_ADDR(DDR1_PUB_DX5BDLR3)
+#define DDR1_PUB_DX5BDLR4 (0x3000 + (0x14B << 2))
+#define P_DDR1_PUB_DX5BDLR4             MMC_REG_ADDR(DDR1_PUB_DX5BDLR4)
+#define DDR1_PUB_DX5BDLR5 (0x3000 + (0x14C << 2))
+#define P_DDR1_PUB_DX5BDLR5             MMC_REG_ADDR(DDR1_PUB_DX5BDLR5)
+#define DDR1_PUB_DX5BDLR6 (0x3000 + (0x14D << 2))
+#define P_DDR1_PUB_DX5BDLR6             MMC_REG_ADDR(DDR1_PUB_DX5BDLR6)
+#define DDR1_PUB_DX5LCDLR0 (0x3000 + (0x14E << 2))
+#define P_DDR1_PUB_DX5LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX5LCDLR0)
+#define DDR1_PUB_DX5LCDLR1 (0x3000 + (0x14F << 2))
+#define P_DDR1_PUB_DX5LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX5LCDLR1)
+#define DDR1_PUB_DX5LCDLR2 (0x3000 + (0x150 << 2))
+#define P_DDR1_PUB_DX5LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX5LCDLR2)
+#define DDR1_PUB_DX5MDLR (0x3000 + (0x151 << 2))
+#define P_DDR1_PUB_DX5MDLR              MMC_REG_ADDR(DDR1_PUB_DX5MDLR)
+#define DDR1_PUB_DX5GTR (0x3000 + (0x152 << 2))
+#define P_DDR1_PUB_DX5GTR               MMC_REG_ADDR(DDR1_PUB_DX5GTR)
+#define DDR1_PUB_DX6GCR0 (0x3000 + (0x160 << 2))
+#define P_DDR1_PUB_DX6GCR0              MMC_REG_ADDR(DDR1_PUB_DX6GCR0)
+#define DDR1_PUB_DX6GCR1 (0x3000 + (0x161 << 2))
+#define P_DDR1_PUB_DX6GCR1              MMC_REG_ADDR(DDR1_PUB_DX6GCR1)
+#define DDR1_PUB_DX6GCR2 (0x3000 + (0x162 << 2))
+#define P_DDR1_PUB_DX6GCR2              MMC_REG_ADDR(DDR1_PUB_DX6GCR2)
+#define DDR1_PUB_DX6GCR3 (0x3000 + (0x163 << 2))
+#define P_DDR1_PUB_DX6GCR3              MMC_REG_ADDR(DDR1_PUB_DX6GCR3)
+#define DDR1_PUB_DX6GSR0 (0x3000 + (0x164 << 2))
+#define P_DDR1_PUB_DX6GSR0              MMC_REG_ADDR(DDR1_PUB_DX6GSR0)
+#define DDR1_PUB_DX6GSR1 (0x3000 + (0x165 << 2))
+#define P_DDR1_PUB_DX6GSR1              MMC_REG_ADDR(DDR1_PUB_DX6GSR1)
+#define DDR1_PUB_DX6GSR2 (0x3000 + (0x166 << 2))
+#define P_DDR1_PUB_DX6GSR2              MMC_REG_ADDR(DDR1_PUB_DX6GSR2)
+#define DDR1_PUB_DX6BDLR0 (0x3000 + (0x167 << 2))
+#define P_DDR1_PUB_DX6BDLR0             MMC_REG_ADDR(DDR1_PUB_DX6BDLR0)
+#define DDR1_PUB_DX6BDLR1 (0x3000 + (0x168 << 2))
+#define P_DDR1_PUB_DX6BDLR1             MMC_REG_ADDR(DDR1_PUB_DX6BDLR1)
+#define DDR1_PUB_DX6BDLR2 (0x3000 + (0x169 << 2))
+#define P_DDR1_PUB_DX6BDLR2             MMC_REG_ADDR(DDR1_PUB_DX6BDLR2)
+#define DDR1_PUB_DX6BDLR3 (0x3000 + (0x16A << 2))
+#define P_DDR1_PUB_DX6BDLR3             MMC_REG_ADDR(DDR1_PUB_DX6BDLR3)
+#define DDR1_PUB_DX6BDLR4 (0x3000 + (0x16B << 2))
+#define P_DDR1_PUB_DX6BDLR4             MMC_REG_ADDR(DDR1_PUB_DX6BDLR4)
+#define DDR1_PUB_DX6BDLR5 (0x3000 + (0x16C << 2))
+#define P_DDR1_PUB_DX6BDLR5             MMC_REG_ADDR(DDR1_PUB_DX6BDLR5)
+#define DDR1_PUB_DX6BDLR6 (0x3000 + (0x16D << 2))
+#define P_DDR1_PUB_DX6BDLR6             MMC_REG_ADDR(DDR1_PUB_DX6BDLR6)
+#define DDR1_PUB_DX6LCDLR0 (0x3000 + (0x16E << 2))
+#define P_DDR1_PUB_DX6LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX6LCDLR0)
+#define DDR1_PUB_DX6LCDLR1 (0x3000 + (0x16F << 2))
+#define P_DDR1_PUB_DX6LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX6LCDLR1)
+#define DDR1_PUB_DX6LCDLR2 (0x3000 + (0x170 << 2))
+#define P_DDR1_PUB_DX6LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX6LCDLR2)
+#define DDR1_PUB_DX6MDLR (0x3000 + (0x171 << 2))
+#define P_DDR1_PUB_DX6MDLR              MMC_REG_ADDR(DDR1_PUB_DX6MDLR)
+#define DDR1_PUB_DX6GTR (0x3000 + (0x172 << 2))
+#define P_DDR1_PUB_DX6GTR               MMC_REG_ADDR(DDR1_PUB_DX6GTR)
+#define DDR1_PUB_DX7GCR0 (0x3000 + (0x180 << 2))
+#define P_DDR1_PUB_DX7GCR0              MMC_REG_ADDR(DDR1_PUB_DX7GCR0)
+#define DDR1_PUB_DX7GCR1 (0x3000 + (0x181 << 2))
+#define P_DDR1_PUB_DX7GCR1              MMC_REG_ADDR(DDR1_PUB_DX7GCR1)
+#define DDR1_PUB_DX7GCR2 (0x3000 + (0x182 << 2))
+#define P_DDR1_PUB_DX7GCR2              MMC_REG_ADDR(DDR1_PUB_DX7GCR2)
+#define DDR1_PUB_DX7GCR3 (0x3000 + (0x183 << 2))
+#define P_DDR1_PUB_DX7GCR3              MMC_REG_ADDR(DDR1_PUB_DX7GCR3)
+#define DDR1_PUB_DX7GSR0 (0x3000 + (0x184 << 2))
+#define P_DDR1_PUB_DX7GSR0              MMC_REG_ADDR(DDR1_PUB_DX7GSR0)
+#define DDR1_PUB_DX7GSR1 (0x3000 + (0x185 << 2))
+#define P_DDR1_PUB_DX7GSR1              MMC_REG_ADDR(DDR1_PUB_DX7GSR1)
+#define DDR1_PUB_DX7GSR2 (0x3000 + (0x186 << 2))
+#define P_DDR1_PUB_DX7GSR2              MMC_REG_ADDR(DDR1_PUB_DX7GSR2)
+#define DDR1_PUB_DX7BDLR0 (0x3000 + (0x187 << 2))
+#define P_DDR1_PUB_DX7BDLR0             MMC_REG_ADDR(DDR1_PUB_DX7BDLR0)
+#define DDR1_PUB_DX7BDLR1 (0x3000 + (0x188 << 2))
+#define P_DDR1_PUB_DX7BDLR1             MMC_REG_ADDR(DDR1_PUB_DX7BDLR1)
+#define DDR1_PUB_DX7BDLR2 (0x3000 + (0x189 << 2))
+#define P_DDR1_PUB_DX7BDLR2             MMC_REG_ADDR(DDR1_PUB_DX7BDLR2)
+#define DDR1_PUB_DX7BDLR3 (0x3000 + (0x18A << 2))
+#define P_DDR1_PUB_DX7BDLR3             MMC_REG_ADDR(DDR1_PUB_DX7BDLR3)
+#define DDR1_PUB_DX7BDLR4 (0x3000 + (0x18B << 2))
+#define P_DDR1_PUB_DX7BDLR4             MMC_REG_ADDR(DDR1_PUB_DX7BDLR4)
+#define DDR1_PUB_DX7BDLR5 (0x3000 + (0x18C << 2))
+#define P_DDR1_PUB_DX7BDLR5             MMC_REG_ADDR(DDR1_PUB_DX7BDLR5)
+#define DDR1_PUB_DX7BDLR6 (0x3000 + (0x18D << 2))
+#define P_DDR1_PUB_DX7BDLR6             MMC_REG_ADDR(DDR1_PUB_DX7BDLR6)
+#define DDR1_PUB_DX7LCDLR0 (0x3000 + (0x18E << 2))
+#define P_DDR1_PUB_DX7LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX7LCDLR0)
+#define DDR1_PUB_DX7LCDLR1 (0x3000 + (0x18F << 2))
+#define P_DDR1_PUB_DX7LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX7LCDLR1)
+#define DDR1_PUB_DX7LCDLR2 (0x3000 + (0x190 << 2))
+#define P_DDR1_PUB_DX7LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX7LCDLR2)
+#define DDR1_PUB_DX7MDLR (0x3000 + (0x191 << 2))
+#define P_DDR1_PUB_DX7MDLR              MMC_REG_ADDR(DDR1_PUB_DX7MDLR)
+#define DDR1_PUB_DX7GTR (0x3000 + (0x192 << 2))
+#define P_DDR1_PUB_DX7GTR               MMC_REG_ADDR(DDR1_PUB_DX7GTR)
+#define DDR1_PUB_DX8GCR0 (0x3000 + (0x1A0 << 2))
+#define P_DDR1_PUB_DX8GCR0              MMC_REG_ADDR(DDR1_PUB_DX8GCR0)
+#define DDR1_PUB_DX8GCR1 (0x3000 + (0x1A1 << 2))
+#define P_DDR1_PUB_DX8GCR1              MMC_REG_ADDR(DDR1_PUB_DX8GCR1)
+#define DDR1_PUB_DX8GCR2 (0x3000 + (0x1A2 << 2))
+#define P_DDR1_PUB_DX8GCR2              MMC_REG_ADDR(DDR1_PUB_DX8GCR2)
+#define DDR1_PUB_DX8GCR3 (0x3000 + (0x1A3 << 2))
+#define P_DDR1_PUB_DX8GCR3              MMC_REG_ADDR(DDR1_PUB_DX8GCR3)
+#define DDR1_PUB_DX8GSR0 (0x3000 + (0x1A4 << 2))
+#define P_DDR1_PUB_DX8GSR0              MMC_REG_ADDR(DDR1_PUB_DX8GSR0)
+#define DDR1_PUB_DX8GSR1 (0x3000 + (0x1A5 << 2))
+#define P_DDR1_PUB_DX8GSR1              MMC_REG_ADDR(DDR1_PUB_DX8GSR1)
+#define DDR1_PUB_DX8GSR2 (0x3000 + (0x1A6 << 2))
+#define P_DDR1_PUB_DX8GSR2              MMC_REG_ADDR(DDR1_PUB_DX8GSR2)
+#define DDR1_PUB_DX8BDLR0 (0x3000 + (0x1A7 << 2))
+#define P_DDR1_PUB_DX8BDLR0             MMC_REG_ADDR(DDR1_PUB_DX8BDLR0)
+#define DDR1_PUB_DX8BDLR1 (0x3000 + (0x1A8 << 2))
+#define P_DDR1_PUB_DX8BDLR1             MMC_REG_ADDR(DDR1_PUB_DX8BDLR1)
+#define DDR1_PUB_DX8BDLR2 (0x3000 + (0x1A9 << 2))
+#define P_DDR1_PUB_DX8BDLR2             MMC_REG_ADDR(DDR1_PUB_DX8BDLR2)
+#define DDR1_PUB_DX8BDLR3 (0x3000 + (0x1AA << 2))
+#define P_DDR1_PUB_DX8BDLR3             MMC_REG_ADDR(DDR1_PUB_DX8BDLR3)
+#define DDR1_PUB_DX8BDLR4 (0x3000 + (0x1AB << 2))
+#define P_DDR1_PUB_DX8BDLR4             MMC_REG_ADDR(DDR1_PUB_DX8BDLR4)
+#define DDR1_PUB_DX8BDLR5 (0x3000 + (0x1AC << 2))
+#define P_DDR1_PUB_DX8BDLR5             MMC_REG_ADDR(DDR1_PUB_DX8BDLR5)
+#define DDR1_PUB_DX8BDLR6 (0x3000 + (0x1AD << 2))
+#define P_DDR1_PUB_DX8BDLR6             MMC_REG_ADDR(DDR1_PUB_DX8BDLR6)
+#define DDR1_PUB_DX8LCDLR0 (0x3000 + (0x1AE << 2))
+#define P_DDR1_PUB_DX8LCDLR0            MMC_REG_ADDR(DDR1_PUB_DX8LCDLR0)
+#define DDR1_PUB_DX8LCDLR1 (0x3000 + (0x1AF << 2))
+#define P_DDR1_PUB_DX8LCDLR1            MMC_REG_ADDR(DDR1_PUB_DX8LCDLR1)
+#define DDR1_PUB_DX8LCDLR2 (0x3000 + (0x1B0 << 2))
+#define P_DDR1_PUB_DX8LCDLR2            MMC_REG_ADDR(DDR1_PUB_DX8LCDLR2)
+#define DDR1_PUB_DX8MDLR (0x3000 + (0x1B1 << 2))
+#define P_DDR1_PUB_DX8MDLR              MMC_REG_ADDR(DDR1_PUB_DX8MDLR)
+#define DDR1_PUB_DX8GTR (0x3000 + (0x1B2 << 2))
+#define P_DDR1_PUB_DX8GTR               MMC_REG_ADDR(DDR1_PUB_DX8GTR)
+/*add from M8m2*/
+#define S_DMC_REG_BASE 0x6000
+#define DMC_REQ_CTRL (S_DMC_REG_BASE + (0x00 << 2))
+#define P_DMC_REQ_CTRL          MMC_REG_ADDR(DMC_REQ_CTRL)
+#define DMC_SOFT_RST (S_DMC_REG_BASE + (0x01 << 2))
+#define P_DMC_SOFT_RST          MMC_REG_ADDR(DMC_SOFT_RST)
+#define DMC_SOFT_RST1 (S_DMC_REG_BASE + (0x02 << 2))
+#define P_DMC_SOFT_RST1                 MMC_REG_ADDR(DMC_SOFT_RST1)
+#define DMC_RST_STS (S_DMC_REG_BASE + (0x03 << 2))
+#define P_DMC_RST_STS           MMC_REG_ADDR(DMC_RST_STS)
+#define DMC_RST_STS1 (S_DMC_REG_BASE + (0x04 << 2))
+#define P_DMC_RST_STS1          MMC_REG_ADDR(DMC_RST_STS1)
+#define DMC_VERSION (S_DMC_REG_BASE + (0x05 << 2))
+#define P_DMC_VERSION           MMC_REG_ADDR(DMC_VERSION)
+#define DMC_DDR_CTRL (S_DMC_REG_BASE + (0x10 << 2))
+#define P_DMC_DDR_CTRL          MMC_REG_ADDR(DMC_DDR_CTRL)
+#define DMC_DDR_CTRL1 (S_DMC_REG_BASE + (0x11 << 2))
+#define P_DMC_DDR_CTRL1                 MMC_REG_ADDR(DMC_DDR_CTRL1)
+#define DC_CAV_LUT_DATAL_M8M2 (S_DMC_REG_BASE + (0x12 << 2))
+#define P_DC_CAV_LUT_DATAL_M8M2 MMC_REG_ADDR(DC_CAV_LUT_DATAL_M8M2)
+#define DC_CAV_LUT_DATAH_M8M2 (S_DMC_REG_BASE + (0x13 << 2))
+#define P_DC_CAV_LUT_DATAH_M8M2 MMC_REG_ADDR(DC_CAV_LUT_DATAH_M8M2)
+#define DC_CAV_LUT_ADDR_M8M2  (S_DMC_REG_BASE + (0x14 << 2))
+#define P_DC_CAV_LUT_ADDR_M8M2  MMC_REG_ADDR(DC_CAV_LUT_ADDR_M8M2)
+#define DC_CAV_LUT_RDATAL_M8M2  (S_DMC_REG_BASE + (0x15 << 2))
+#define P_DC_CAV_LUT_RDATAL_M8M2 MMC_REG_ADDR(DC_CAV_LUT_RDATAL_M8M2)
+#define DC_CAV_LUT_RDATAH_M8M2  (S_DMC_REG_BASE + (0x16 << 2))
+#define P_DC_CAV_LUT_RDATAH_M8M2 MMC_REG_ADDR(DC_CAV_LUT_RDATAH_M8M2)
+#define DMC_2ARB_CTRL (S_DMC_REG_BASE + (0x20 << 2))
+#define P_DMC_2ARB_CTRL                 MMC_REG_ADDR(DMC_2ARB_CTRL)
+#define DMC_REFR_CTRL1 (S_DMC_REG_BASE + (0x23 << 2))
+#define P_DMC_REFR_CTRL1                MMC_REG_ADDR(DMC_REFR_CTRL1)
+#define DMC_REFR_CTRL2 (S_DMC_REG_BASE + (0x24 << 2))
+#define P_DMC_REFR_CTRL2                MMC_REG_ADDR(DMC_REFR_CTRL2)
+#define DMC_PARB_CTRL (S_DMC_REG_BASE + (0x25 << 2))
+#define P_DMC_PARB_CTRL                 MMC_REG_ADDR(DMC_PARB_CTRL)
+#define DMC_MON_CTRL2 (S_DMC_REG_BASE + (0x26 << 2))
+#define P_DMC_MON_CTRL2                 MMC_REG_ADDR(DMC_MON_CTRL2)
+#define DMC_MON_CTRL3 (S_DMC_REG_BASE + (0x27 << 2))
+#define P_DMC_MON_CTRL3                 MMC_REG_ADDR(DMC_MON_CTRL3)
+#define DMC_MON_ALL_REQ_CNT (S_DMC_REG_BASE + (0x28 << 2))
+#define P_DMC_MON_ALL_REQ_CNT           MMC_REG_ADDR(DMC_MON_ALL_REQ_CNT)
+#define DMC_MON_ALL_GRANT_CNT (S_DMC_REG_BASE + (0x29 << 2))
+#define P_DMC_MON_ALL_GRANT_CNT                 \
+	MMC_REG_ADDR(DMC_MON_ALL_GRANT_CNT)
+#define DMC_MON_ONE_GRANT_CNT (S_DMC_REG_BASE + (0x2a << 2))
+#define P_DMC_MON_ONE_GRANT_CNT                 \
+	MMC_REG_ADDR(DMC_MON_ONE_GRANT_CNT)
+#define DMC_CLKG_CTRL0 (S_DMC_REG_BASE + (0x30 << 2))
+#define P_DMC_CLKG_CTRL0                MMC_REG_ADDR(DMC_CLKG_CTRL0)
+#define DMC_CLKG_CTRL1 (S_DMC_REG_BASE + (0x31 << 2))
+#define P_DMC_CLKG_CTRL1                MMC_REG_ADDR(DMC_CLKG_CTRL1)
+#define DMC_CHAN_STS (S_DMC_REG_BASE + (0x32 << 2))
+#define P_DMC_CHAN_STS          MMC_REG_ADDR(DMC_CHAN_STS)
+#define DMC_CMD_FILTER_CTRL1 (S_DMC_REG_BASE + (0x40 << 2))
+#define P_DMC_CMD_FILTER_CTRL1          MMC_REG_ADDR(DMC_CMD_FILTER_CTRL1)
+#define DMC_CMD_FILTER_CTRL2 (S_DMC_REG_BASE + (0x41 << 2))
+#define P_DMC_CMD_FILTER_CTRL2          MMC_REG_ADDR(DMC_CMD_FILTER_CTRL2)
+#define DMC_CMD_FILTER_CTRL3 (S_DMC_REG_BASE + (0x42 << 2))
+#define P_DMC_CMD_FILTER_CTRL3          MMC_REG_ADDR(DMC_CMD_FILTER_CTRL3)
+#define DMC_CMD_FILTER_CTRL4 (S_DMC_REG_BASE + (0x43 << 2))
+#define P_DMC_CMD_FILTER_CTRL4          MMC_REG_ADDR(DMC_CMD_FILTER_CTRL4)
+#define DMC_CMD_BUFFER_CTRL (S_DMC_REG_BASE + (0x44 << 2))
+#define P_DMC_CMD_BUFFER_CTRL           MMC_REG_ADDR(DMC_CMD_BUFFER_CTRL)
+#define DMC_AM0_CHAN_CTRL (S_DMC_REG_BASE + (0x60 << 2))
+#define P_DMC_AM0_CHAN_CTRL             MMC_REG_ADDR(DMC_AM0_CHAN_CTRL)
+#define DMC_AM0_HOLD_CTRL (S_DMC_REG_BASE + (0x61 << 2))
+#define P_DMC_AM0_HOLD_CTRL             MMC_REG_ADDR(DMC_AM0_HOLD_CTRL)
+#define DMC_AM0_QOS_INC (S_DMC_REG_BASE + (0x62 << 2))
+#define P_DMC_AM0_QOS_INC               MMC_REG_ADDR(DMC_AM0_QOS_INC)
+#define DMC_AM0_QOS_INCBK (S_DMC_REG_BASE + (0x63 << 2))
+#define P_DMC_AM0_QOS_INCBK             MMC_REG_ADDR(DMC_AM0_QOS_INCBK)
+#define DMC_AM0_QOS_DEC (S_DMC_REG_BASE + (0x64 << 2))
+#define P_DMC_AM0_QOS_DEC               MMC_REG_ADDR(DMC_AM0_QOS_DEC)
+#define DMC_AM0_QOS_DECBK (S_DMC_REG_BASE + (0x65 << 2))
+#define P_DMC_AM0_QOS_DECBK             MMC_REG_ADDR(DMC_AM0_QOS_DECBK)
+#define DMC_AM0_QOS_DIS (S_DMC_REG_BASE + (0x66 << 2))
+#define P_DMC_AM0_QOS_DIS               MMC_REG_ADDR(DMC_AM0_QOS_DIS)
+#define DMC_AM0_QOS_DISBK (S_DMC_REG_BASE + (0x67 << 2))
+#define P_DMC_AM0_QOS_DISBK             MMC_REG_ADDR(DMC_AM0_QOS_DISBK)
+#define DMC_AM0_QOS_CTRL0 (S_DMC_REG_BASE + (0x68 << 2))
+#define P_DMC_AM0_QOS_CTRL0             MMC_REG_ADDR(DMC_AM0_QOS_CTRL0)
+#define DMC_AM0_QOS_CTRL1 (S_DMC_REG_BASE + (0x69 << 2))
+#define P_DMC_AM0_QOS_CTRL1             MMC_REG_ADDR(DMC_AM0_QOS_CTRL1)
+#define DMC_AM1_CHAN_CTRL (S_DMC_REG_BASE + (0x6a << 2))
+#define P_DMC_AM1_CHAN_CTRL             MMC_REG_ADDR(DMC_AM1_CHAN_CTRL)
+#define DMC_AM1_HOLD_CTRL (S_DMC_REG_BASE + (0x6b << 2))
+#define P_DMC_AM1_HOLD_CTRL             MMC_REG_ADDR(DMC_AM1_HOLD_CTRL)
+#define DMC_AM1_QOS_INC (S_DMC_REG_BASE + (0x6c << 2))
+#define P_DMC_AM1_QOS_INC               MMC_REG_ADDR(DMC_AM1_QOS_INC)
+#define DMC_AM1_QOS_INCBK (S_DMC_REG_BASE + (0x6d << 2))
+#define P_DMC_AM1_QOS_INCBK             MMC_REG_ADDR(DMC_AM1_QOS_INCBK)
+#define DMC_AM1_QOS_DEC (S_DMC_REG_BASE + (0x6e << 2))
+#define P_DMC_AM1_QOS_DEC               MMC_REG_ADDR(DMC_AM1_QOS_DEC)
+#define DMC_AM1_QOS_DECBK (S_DMC_REG_BASE + (0x6f << 2))
+#define P_DMC_AM1_QOS_DECBK             MMC_REG_ADDR(DMC_AM1_QOS_DECBK)
+#define DMC_AM1_QOS_DIS (S_DMC_REG_BASE + (0x70 << 2))
+#define P_DMC_AM1_QOS_DIS               MMC_REG_ADDR(DMC_AM1_QOS_DIS)
+#define DMC_AM1_QOS_DISBK (S_DMC_REG_BASE + (0x71 << 2))
+#define P_DMC_AM1_QOS_DISBK             MMC_REG_ADDR(DMC_AM1_QOS_DISBK)
+#define DMC_AM1_QOS_CTRL0 (S_DMC_REG_BASE + (0x72 << 2))
+#define P_DMC_AM1_QOS_CTRL0             MMC_REG_ADDR(DMC_AM1_QOS_CTRL0)
+#define DMC_AM1_QOS_CTRL1 (S_DMC_REG_BASE + (0x73 << 2))
+#define P_DMC_AM1_QOS_CTRL1             MMC_REG_ADDR(DMC_AM1_QOS_CTRL1)
+#define DMC_AM2_CHAN_CTRL (S_DMC_REG_BASE + (0x74 << 2))
+#define P_DMC_AM2_CHAN_CTRL             MMC_REG_ADDR(DMC_AM2_CHAN_CTRL)
+#define DMC_AM2_HOLD_CTRL (S_DMC_REG_BASE + (0x75 << 2))
+#define P_DMC_AM2_HOLD_CTRL             MMC_REG_ADDR(DMC_AM2_HOLD_CTRL)
+#define DMC_AM2_QOS_INC (S_DMC_REG_BASE + (0x76 << 2))
+#define P_DMC_AM2_QOS_INC               MMC_REG_ADDR(DMC_AM2_QOS_INC)
+#define DMC_AM2_QOS_INCBK (S_DMC_REG_BASE + (0x77 << 2))
+#define P_DMC_AM2_QOS_INCBK             MMC_REG_ADDR(DMC_AM2_QOS_INCBK)
+#define DMC_AM2_QOS_DEC (S_DMC_REG_BASE + (0x78 << 2))
+#define P_DMC_AM2_QOS_DEC               MMC_REG_ADDR(DMC_AM2_QOS_DEC)
+#define DMC_AM2_QOS_DECBK (S_DMC_REG_BASE + (0x79 << 2))
+#define P_DMC_AM2_QOS_DECBK             MMC_REG_ADDR(DMC_AM2_QOS_DECBK)
+#define DMC_AM2_QOS_DIS (S_DMC_REG_BASE + (0x7a << 2))
+#define P_DMC_AM2_QOS_DIS               MMC_REG_ADDR(DMC_AM2_QOS_DIS)
+#define DMC_AM2_QOS_DISBK (S_DMC_REG_BASE + (0x7b << 2))
+#define P_DMC_AM2_QOS_DISBK             MMC_REG_ADDR(DMC_AM2_QOS_DISBK)
+#define DMC_AM2_QOS_CTRL0 (S_DMC_REG_BASE + (0x7c << 2))
+#define P_DMC_AM2_QOS_CTRL0             MMC_REG_ADDR(DMC_AM2_QOS_CTRL0)
+#define DMC_AM2_QOS_CTRL1 (S_DMC_REG_BASE + (0x7d << 2))
+#define P_DMC_AM2_QOS_CTRL1             MMC_REG_ADDR(DMC_AM2_QOS_CTRL1)
+#define DMC_AM3_CHAN_CTRL (S_DMC_REG_BASE + (0x7e << 2))
+#define P_DMC_AM3_CHAN_CTRL             MMC_REG_ADDR(DMC_AM3_CHAN_CTRL)
+#define DMC_AM3_HOLD_CTRL (S_DMC_REG_BASE + (0x7f << 2))
+#define P_DMC_AM3_HOLD_CTRL             MMC_REG_ADDR(DMC_AM3_HOLD_CTRL)
+#define DMC_AM3_QOS_INC (S_DMC_REG_BASE + (0x80 << 2))
+#define P_DMC_AM3_QOS_INC               MMC_REG_ADDR(DMC_AM3_QOS_INC)
+#define DMC_AM3_QOS_INCBK (S_DMC_REG_BASE + (0x81 << 2))
+#define P_DMC_AM3_QOS_INCBK             MMC_REG_ADDR(DMC_AM3_QOS_INCBK)
+#define DMC_AM3_QOS_DEC (S_DMC_REG_BASE + (0x82 << 2))
+#define P_DMC_AM3_QOS_DEC               MMC_REG_ADDR(DMC_AM3_QOS_DEC)
+#define DMC_AM3_QOS_DECBK (S_DMC_REG_BASE + (0x83 << 2))
+#define P_DMC_AM3_QOS_DECBK             MMC_REG_ADDR(DMC_AM3_QOS_DECBK)
+#define DMC_AM3_QOS_DIS (S_DMC_REG_BASE + (0x84 << 2))
+#define P_DMC_AM3_QOS_DIS               MMC_REG_ADDR(DMC_AM3_QOS_DIS)
+#define DMC_AM3_QOS_DISBK (S_DMC_REG_BASE + (0x85 << 2))
+#define P_DMC_AM3_QOS_DISBK             MMC_REG_ADDR(DMC_AM3_QOS_DISBK)
+#define DMC_AM3_QOS_CTRL0 (S_DMC_REG_BASE + (0x86 << 2))
+#define P_DMC_AM3_QOS_CTRL0             MMC_REG_ADDR(DMC_AM3_QOS_CTRL0)
+#define DMC_AM3_QOS_CTRL1 (S_DMC_REG_BASE + (0x87 << 2))
+#define P_DMC_AM3_QOS_CTRL1             MMC_REG_ADDR(DMC_AM3_QOS_CTRL1)
+#define DMC_AM4_CHAN_CTRL (S_DMC_REG_BASE + (0x88 << 2))
+#define P_DMC_AM4_CHAN_CTRL             MMC_REG_ADDR(DMC_AM4_CHAN_CTRL)
+#define DMC_AM4_HOLD_CTRL (S_DMC_REG_BASE + (0x89 << 2))
+#define P_DMC_AM4_HOLD_CTRL             MMC_REG_ADDR(DMC_AM4_HOLD_CTRL)
+#define DMC_AM4_QOS_INC (S_DMC_REG_BASE + (0x8a << 2))
+#define P_DMC_AM4_QOS_INC               MMC_REG_ADDR(DMC_AM4_QOS_INC)
+#define DMC_AM4_QOS_INCBK (S_DMC_REG_BASE + (0x8b << 2))
+#define P_DMC_AM4_QOS_INCBK             MMC_REG_ADDR(DMC_AM4_QOS_INCBK)
+#define DMC_AM4_QOS_DEC (S_DMC_REG_BASE + (0x8c << 2))
+#define P_DMC_AM4_QOS_DEC               MMC_REG_ADDR(DMC_AM4_QOS_DEC)
+#define DMC_AM4_QOS_DECBK (S_DMC_REG_BASE + (0x8d << 2))
+#define P_DMC_AM4_QOS_DECBK             MMC_REG_ADDR(DMC_AM4_QOS_DECBK)
+#define DMC_AM4_QOS_DIS (S_DMC_REG_BASE + (0x8e << 2))
+#define P_DMC_AM4_QOS_DIS               MMC_REG_ADDR(DMC_AM4_QOS_DIS)
+#define DMC_AM4_QOS_DISBK (S_DMC_REG_BASE + (0x8f << 2))
+#define P_DMC_AM4_QOS_DISBK             MMC_REG_ADDR(DMC_AM4_QOS_DISBK)
+#define DMC_AM4_QOS_CTRL0 (S_DMC_REG_BASE + (0x90 << 2))
+#define P_DMC_AM4_QOS_CTRL0             MMC_REG_ADDR(DMC_AM4_QOS_CTRL0)
+#define DMC_AM4_QOS_CTRL1 (S_DMC_REG_BASE + (0x91 << 2))
+#define P_DMC_AM4_QOS_CTRL1             MMC_REG_ADDR(DMC_AM4_QOS_CTRL1)
+#define DMC_AM5_CHAN_CTRL (S_DMC_REG_BASE + (0x92 << 2))
+#define P_DMC_AM5_CHAN_CTRL             MMC_REG_ADDR(DMC_AM5_CHAN_CTRL)
+#define DMC_AM5_HOLD_CTRL (S_DMC_REG_BASE + (0x93 << 2))
+#define P_DMC_AM5_HOLD_CTRL             MMC_REG_ADDR(DMC_AM5_HOLD_CTRL)
+#define DMC_AM5_QOS_INC (S_DMC_REG_BASE + (0x94 << 2))
+#define P_DMC_AM5_QOS_INC               MMC_REG_ADDR(DMC_AM5_QOS_INC)
+#define DMC_AM5_QOS_INCBK (S_DMC_REG_BASE + (0x95 << 2))
+#define P_DMC_AM5_QOS_INCBK             MMC_REG_ADDR(DMC_AM5_QOS_INCBK)
+#define DMC_AM5_QOS_DEC (S_DMC_REG_BASE + (0x96 << 2))
+#define P_DMC_AM5_QOS_DEC               MMC_REG_ADDR(DMC_AM5_QOS_DEC)
+#define DMC_AM5_QOS_DECBK (S_DMC_REG_BASE + (0x97 << 2))
+#define P_DMC_AM5_QOS_DECBK             MMC_REG_ADDR(DMC_AM5_QOS_DECBK)
+#define DMC_AM5_QOS_DIS (S_DMC_REG_BASE + (0x98 << 2))
+#define P_DMC_AM5_QOS_DIS               MMC_REG_ADDR(DMC_AM5_QOS_DIS)
+#define DMC_AM5_QOS_DISBK (S_DMC_REG_BASE + (0x99 << 2))
+#define P_DMC_AM5_QOS_DISBK             MMC_REG_ADDR(DMC_AM5_QOS_DISBK)
+#define DMC_AM5_QOS_CTRL0 (S_DMC_REG_BASE + (0x9a << 2))
+#define P_DMC_AM5_QOS_CTRL0             MMC_REG_ADDR(DMC_AM5_QOS_CTRL0)
+#define DMC_AM5_QOS_CTRL1 (S_DMC_REG_BASE + (0x9b << 2))
+#define P_DMC_AM5_QOS_CTRL1             MMC_REG_ADDR(DMC_AM5_QOS_CTRL1)
+#define DMC_AM6_CHAN_CTRL (S_DMC_REG_BASE + (0x9c << 2))
+#define P_DMC_AM6_CHAN_CTRL             MMC_REG_ADDR(DMC_AM6_CHAN_CTRL)
+#define DMC_AM6_HOLD_CTRL (S_DMC_REG_BASE + (0x9d << 2))
+#define P_DMC_AM6_HOLD_CTRL             MMC_REG_ADDR(DMC_AM6_HOLD_CTRL)
+#define DMC_AM6_QOS_INC (S_DMC_REG_BASE + (0x9e << 2))
+#define P_DMC_AM6_QOS_INC               MMC_REG_ADDR(DMC_AM6_QOS_INC)
+#define DMC_AM6_QOS_INCBK (S_DMC_REG_BASE + (0x9f << 2))
+#define P_DMC_AM6_QOS_INCBK             MMC_REG_ADDR(DMC_AM6_QOS_INCBK)
+#define DMC_AM6_QOS_DEC (S_DMC_REG_BASE + (0xa0 << 2))
+#define P_DMC_AM6_QOS_DEC               MMC_REG_ADDR(DMC_AM6_QOS_DEC)
+#define DMC_AM6_QOS_DECBK (S_DMC_REG_BASE + (0xa1 << 2))
+#define P_DMC_AM6_QOS_DECBK             MMC_REG_ADDR(DMC_AM6_QOS_DECBK)
+#define DMC_AM6_QOS_DIS (S_DMC_REG_BASE + (0xa2 << 2))
+#define P_DMC_AM6_QOS_DIS               MMC_REG_ADDR(DMC_AM6_QOS_DIS)
+#define DMC_AM6_QOS_DISBK (S_DMC_REG_BASE + (0xa3 << 2))
+#define P_DMC_AM6_QOS_DISBK             MMC_REG_ADDR(DMC_AM6_QOS_DISBK)
+#define DMC_AM6_QOS_CTRL0 (S_DMC_REG_BASE + (0xa4 << 2))
+#define P_DMC_AM6_QOS_CTRL0             MMC_REG_ADDR(DMC_AM6_QOS_CTRL0)
+#define DMC_AM6_QOS_CTRL1 (S_DMC_REG_BASE + (0xa5 << 2))
+#define P_DMC_AM6_QOS_CTRL1             MMC_REG_ADDR(DMC_AM6_QOS_CTRL1)
+#define DMC_AM7_CHAN_CTRL (S_DMC_REG_BASE + (0xa6 << 2))
+#define P_DMC_AM7_CHAN_CTRL             MMC_REG_ADDR(DMC_AM7_CHAN_CTRL)
+#define DMC_AM7_HOLD_CTRL (S_DMC_REG_BASE + (0xa7 << 2))
+#define P_DMC_AM7_HOLD_CTRL             MMC_REG_ADDR(DMC_AM7_HOLD_CTRL)
+#define DMC_AM7_QOS_INC (S_DMC_REG_BASE + (0xa8 << 2))
+#define P_DMC_AM7_QOS_INC               MMC_REG_ADDR(DMC_AM7_QOS_INC)
+#define DMC_AM7_QOS_INCBK (S_DMC_REG_BASE + (0xa9 << 2))
+#define P_DMC_AM7_QOS_INCBK             MMC_REG_ADDR(DMC_AM7_QOS_INCBK)
+#define DMC_AM7_QOS_DEC (S_DMC_REG_BASE + (0xaa << 2))
+#define P_DMC_AM7_QOS_DEC               MMC_REG_ADDR(DMC_AM7_QOS_DEC)
+#define DMC_AM7_QOS_DECBK (S_DMC_REG_BASE + (0xab << 2))
+#define P_DMC_AM7_QOS_DECBK             MMC_REG_ADDR(DMC_AM7_QOS_DECBK)
+#define DMC_AM7_QOS_DIS (S_DMC_REG_BASE + (0xac << 2))
+#define P_DMC_AM7_QOS_DIS               MMC_REG_ADDR(DMC_AM7_QOS_DIS)
+#define DMC_AM7_QOS_DISBK (S_DMC_REG_BASE + (0xad << 2))
+#define P_DMC_AM7_QOS_DISBK             MMC_REG_ADDR(DMC_AM7_QOS_DISBK)
+#define DMC_AM7_QOS_CTRL0 (S_DMC_REG_BASE + (0xae << 2))
+#define P_DMC_AM7_QOS_CTRL0             MMC_REG_ADDR(DMC_AM7_QOS_CTRL0)
+#define DMC_AM7_QOS_CTRL1 (S_DMC_REG_BASE + (0xaf << 2))
+#define P_DMC_AM7_QOS_CTRL1             MMC_REG_ADDR(DMC_AM7_QOS_CTRL1)
+#define DMC_AXI0_CHAN_CTRL (S_DMC_REG_BASE + (0xb0 << 2))
+#define P_DMC_AXI0_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI0_CHAN_CTRL)
+#define DMC_AXI0_HOLD_CTRL (S_DMC_REG_BASE + (0xb1 << 2))
+#define P_DMC_AXI0_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI0_HOLD_CTRL)
+#define DMC_AXI0_QOS_INC (S_DMC_REG_BASE + (0xb2 << 2))
+#define P_DMC_AXI0_QOS_INC              MMC_REG_ADDR(DMC_AXI0_QOS_INC)
+#define DMC_AXI0_QOS_INCBK (S_DMC_REG_BASE + (0xb3 << 2))
+#define P_DMC_AXI0_QOS_INCBK            MMC_REG_ADDR(DMC_AXI0_QOS_INCBK)
+#define DMC_AXI0_QOS_DEC (S_DMC_REG_BASE + (0xb4 << 2))
+#define P_DMC_AXI0_QOS_DEC              MMC_REG_ADDR(DMC_AXI0_QOS_DEC)
+#define DMC_AXI0_QOS_DECBK (S_DMC_REG_BASE + (0xb5 << 2))
+#define P_DMC_AXI0_QOS_DECBK            MMC_REG_ADDR(DMC_AXI0_QOS_DECBK)
+#define DMC_AXI0_QOS_DIS (S_DMC_REG_BASE + (0xb6 << 2))
+#define P_DMC_AXI0_QOS_DIS              MMC_REG_ADDR(DMC_AXI0_QOS_DIS)
+#define DMC_AXI0_QOS_DISBK (S_DMC_REG_BASE + (0xb7 << 2))
+#define P_DMC_AXI0_QOS_DISBK            MMC_REG_ADDR(DMC_AXI0_QOS_DISBK)
+#define DMC_AXI0_QOS_CTRL0 (S_DMC_REG_BASE + (0xb8 << 2))
+#define P_DMC_AXI0_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI0_QOS_CTRL0)
+#define DMC_AXI0_QOS_CTRL1 (S_DMC_REG_BASE + (0xb9 << 2))
+#define P_DMC_AXI0_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI0_QOS_CTRL1)
+#define DMC_AXI1_CHAN_CTRL (S_DMC_REG_BASE + (0xba << 2))
+#define P_DMC_AXI1_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI1_CHAN_CTRL)
+#define DMC_AXI1_HOLD_CTRL (S_DMC_REG_BASE + (0xbb << 2))
+#define P_DMC_AXI1_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI1_HOLD_CTRL)
+#define DMC_AXI1_QOS_INC (S_DMC_REG_BASE + (0xbc << 2))
+#define P_DMC_AXI1_QOS_INC              MMC_REG_ADDR(DMC_AXI1_QOS_INC)
+#define DMC_AXI1_QOS_INCBK (S_DMC_REG_BASE + (0xbd << 2))
+#define P_DMC_AXI1_QOS_INCBK            MMC_REG_ADDR(DMC_AXI1_QOS_INCBK)
+#define DMC_AXI1_QOS_DEC (S_DMC_REG_BASE + (0xbe << 2))
+#define P_DMC_AXI1_QOS_DEC              MMC_REG_ADDR(DMC_AXI1_QOS_DEC)
+#define DMC_AXI1_QOS_DECBK (S_DMC_REG_BASE + (0xbf << 2))
+#define P_DMC_AXI1_QOS_DECBK            MMC_REG_ADDR(DMC_AXI1_QOS_DECBK)
+#define DMC_AXI1_QOS_DIS (S_DMC_REG_BASE + (0xc0 << 2))
+#define P_DMC_AXI1_QOS_DIS              MMC_REG_ADDR(DMC_AXI1_QOS_DIS)
+#define DMC_AXI1_QOS_DISBK (S_DMC_REG_BASE + (0xc1 << 2))
+#define P_DMC_AXI1_QOS_DISBK            MMC_REG_ADDR(DMC_AXI1_QOS_DISBK)
+#define DMC_AXI1_QOS_CTRL0 (S_DMC_REG_BASE + (0xc2 << 2))
+#define P_DMC_AXI1_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI1_QOS_CTRL0)
+#define DMC_AXI1_QOS_CTRL1 (S_DMC_REG_BASE + (0xc3 << 2))
+#define P_DMC_AXI1_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI1_QOS_CTRL1)
+#define DMC_AXI2_CHAN_CTRL (S_DMC_REG_BASE + (0xc4 << 2))
+#define P_DMC_AXI2_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI2_CHAN_CTRL)
+#define DMC_AXI2_HOLD_CTRL (S_DMC_REG_BASE + (0xc5 << 2))
+#define P_DMC_AXI2_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI2_HOLD_CTRL)
+#define DMC_AXI2_QOS_INC (S_DMC_REG_BASE + (0xc6 << 2))
+#define P_DMC_AXI2_QOS_INC              MMC_REG_ADDR(DMC_AXI2_QOS_INC)
+#define DMC_AXI2_QOS_INCBK (S_DMC_REG_BASE + (0xc7 << 2))
+#define P_DMC_AXI2_QOS_INCBK            MMC_REG_ADDR(DMC_AXI2_QOS_INCBK)
+#define DMC_AXI2_QOS_DEC (S_DMC_REG_BASE + (0xc8 << 2))
+#define P_DMC_AXI2_QOS_DEC              MMC_REG_ADDR(DMC_AXI2_QOS_DEC)
+#define DMC_AXI2_QOS_DECBK (S_DMC_REG_BASE + (0xc9 << 2))
+#define P_DMC_AXI2_QOS_DECBK            MMC_REG_ADDR(DMC_AXI2_QOS_DECBK)
+#define DMC_AXI2_QOS_DIS (S_DMC_REG_BASE + (0xca << 2))
+#define P_DMC_AXI2_QOS_DIS              MMC_REG_ADDR(DMC_AXI2_QOS_DIS)
+#define DMC_AXI2_QOS_DISBK (S_DMC_REG_BASE + (0xcb << 2))
+#define P_DMC_AXI2_QOS_DISBK            MMC_REG_ADDR(DMC_AXI2_QOS_DISBK)
+#define DMC_AXI2_QOS_CTRL0 (S_DMC_REG_BASE + (0xcc << 2))
+#define P_DMC_AXI2_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI2_QOS_CTRL0)
+#define DMC_AXI2_QOS_CTRL1 (S_DMC_REG_BASE + (0xcd << 2))
+#define P_DMC_AXI2_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI2_QOS_CTRL1)
+#define DMC_AXI3_CHAN_CTRL (S_DMC_REG_BASE + (0xce << 2))
+#define P_DMC_AXI3_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI3_CHAN_CTRL)
+#define DMC_AXI3_HOLD_CTRL (S_DMC_REG_BASE + (0xcf << 2))
+#define P_DMC_AXI3_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI3_HOLD_CTRL)
+#define DMC_AXI3_QOS_INC (S_DMC_REG_BASE + (0xd0 << 2))
+#define P_DMC_AXI3_QOS_INC              MMC_REG_ADDR(DMC_AXI3_QOS_INC)
+#define DMC_AXI3_QOS_INCBK (S_DMC_REG_BASE + (0xd1 << 2))
+#define P_DMC_AXI3_QOS_INCBK            MMC_REG_ADDR(DMC_AXI3_QOS_INCBK)
+#define DMC_AXI3_QOS_DEC (S_DMC_REG_BASE + (0xd2 << 2))
+#define P_DMC_AXI3_QOS_DEC              MMC_REG_ADDR(DMC_AXI3_QOS_DEC)
+#define DMC_AXI3_QOS_DECBK (S_DMC_REG_BASE + (0xd3 << 2))
+#define P_DMC_AXI3_QOS_DECBK            MMC_REG_ADDR(DMC_AXI3_QOS_DECBK)
+#define DMC_AXI3_QOS_DIS (S_DMC_REG_BASE + (0xd4 << 2))
+#define P_DMC_AXI3_QOS_DIS              MMC_REG_ADDR(DMC_AXI3_QOS_DIS)
+#define DMC_AXI3_QOS_DISBK (S_DMC_REG_BASE + (0xd5 << 2))
+#define P_DMC_AXI3_QOS_DISBK            MMC_REG_ADDR(DMC_AXI3_QOS_DISBK)
+#define DMC_AXI3_QOS_CTRL0 (S_DMC_REG_BASE + (0xd6 << 2))
+#define P_DMC_AXI3_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI3_QOS_CTRL0)
+#define DMC_AXI3_QOS_CTRL1 (S_DMC_REG_BASE + (0xd7 << 2))
+#define P_DMC_AXI3_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI3_QOS_CTRL1)
+#define DMC_AXI4_CHAN_CTRL (S_DMC_REG_BASE + (0xd8 << 2))
+#define P_DMC_AXI4_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI4_CHAN_CTRL)
+#define DMC_AXI4_HOLD_CTRL (S_DMC_REG_BASE + (0xd9 << 2))
+#define P_DMC_AXI4_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI4_HOLD_CTRL)
+#define DMC_AXI4_QOS_INC (S_DMC_REG_BASE + (0xda << 2))
+#define P_DMC_AXI4_QOS_INC              MMC_REG_ADDR(DMC_AXI4_QOS_INC)
+#define DMC_AXI4_QOS_INCBK (S_DMC_REG_BASE + (0xdb << 2))
+#define P_DMC_AXI4_QOS_INCBK            MMC_REG_ADDR(DMC_AXI4_QOS_INCBK)
+#define DMC_AXI4_QOS_DEC (S_DMC_REG_BASE + (0xdc << 2))
+#define P_DMC_AXI4_QOS_DEC              MMC_REG_ADDR(DMC_AXI4_QOS_DEC)
+#define DMC_AXI4_QOS_DECBK (S_DMC_REG_BASE + (0xdd << 2))
+#define P_DMC_AXI4_QOS_DECBK            MMC_REG_ADDR(DMC_AXI4_QOS_DECBK)
+#define DMC_AXI4_QOS_DIS (S_DMC_REG_BASE + (0xde << 2))
+#define P_DMC_AXI4_QOS_DIS              MMC_REG_ADDR(DMC_AXI4_QOS_DIS)
+#define DMC_AXI4_QOS_DISBK (S_DMC_REG_BASE + (0xdf << 2))
+#define P_DMC_AXI4_QOS_DISBK            MMC_REG_ADDR(DMC_AXI4_QOS_DISBK)
+#define DMC_AXI4_QOS_CTRL0 (S_DMC_REG_BASE + (0xe0 << 2))
+#define P_DMC_AXI4_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI4_QOS_CTRL0)
+#define DMC_AXI4_QOS_CTRL1 (S_DMC_REG_BASE + (0xe1 << 2))
+#define P_DMC_AXI4_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI4_QOS_CTRL1)
+#define DMC_AXI5_CHAN_CTRL (S_DMC_REG_BASE + (0xe2 << 2))
+#define P_DMC_AXI5_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI5_CHAN_CTRL)
+#define DMC_AXI5_HOLD_CTRL (S_DMC_REG_BASE + (0xe3 << 2))
+#define P_DMC_AXI5_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI5_HOLD_CTRL)
+#define DMC_AXI5_QOS_INC (S_DMC_REG_BASE + (0xe4 << 2))
+#define P_DMC_AXI5_QOS_INC              MMC_REG_ADDR(DMC_AXI5_QOS_INC)
+#define DMC_AXI5_QOS_INCBK (S_DMC_REG_BASE + (0xe5 << 2))
+#define P_DMC_AXI5_QOS_INCBK            MMC_REG_ADDR(DMC_AXI5_QOS_INCBK)
+#define DMC_AXI5_QOS_DEC (S_DMC_REG_BASE + (0xe6 << 2))
+#define P_DMC_AXI5_QOS_DEC              MMC_REG_ADDR(DMC_AXI5_QOS_DEC)
+#define DMC_AXI5_QOS_DECBK (S_DMC_REG_BASE + (0xe7 << 2))
+#define P_DMC_AXI5_QOS_DECBK            MMC_REG_ADDR(DMC_AXI5_QOS_DECBK)
+#define DMC_AXI5_QOS_DIS (S_DMC_REG_BASE + (0xe8 << 2))
+#define P_DMC_AXI5_QOS_DIS              MMC_REG_ADDR(DMC_AXI5_QOS_DIS)
+#define DMC_AXI5_QOS_DISBK (S_DMC_REG_BASE + (0xe9 << 2))
+#define P_DMC_AXI5_QOS_DISBK            MMC_REG_ADDR(DMC_AXI5_QOS_DISBK)
+#define DMC_AXI5_QOS_CTRL0 (S_DMC_REG_BASE + (0xea << 2))
+#define P_DMC_AXI5_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI5_QOS_CTRL0)
+#define DMC_AXI5_QOS_CTRL1 (S_DMC_REG_BASE + (0xeb << 2))
+#define P_DMC_AXI5_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI5_QOS_CTRL1)
+#define DMC_AXI6_CHAN_CTRL (S_DMC_REG_BASE + (0xec << 2))
+#define P_DMC_AXI6_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI6_CHAN_CTRL)
+#define DMC_AXI6_HOLD_CTRL (S_DMC_REG_BASE + (0xed << 2))
+#define P_DMC_AXI6_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI6_HOLD_CTRL)
+#define DMC_AXI6_QOS_INC (S_DMC_REG_BASE + (0xee << 2))
+#define P_DMC_AXI6_QOS_INC              MMC_REG_ADDR(DMC_AXI6_QOS_INC)
+#define DMC_AXI6_QOS_INCBK (S_DMC_REG_BASE + (0xef << 2))
+#define P_DMC_AXI6_QOS_INCBK            MMC_REG_ADDR(DMC_AXI6_QOS_INCBK)
+#define DMC_AXI6_QOS_DEC (S_DMC_REG_BASE + (0xf0 << 2))
+#define P_DMC_AXI6_QOS_DEC              MMC_REG_ADDR(DMC_AXI6_QOS_DEC)
+#define DMC_AXI6_QOS_DECBK (S_DMC_REG_BASE + (0xf1 << 2))
+#define P_DMC_AXI6_QOS_DECBK            MMC_REG_ADDR(DMC_AXI6_QOS_DECBK)
+#define DMC_AXI6_QOS_DIS (S_DMC_REG_BASE + (0xf2 << 2))
+#define P_DMC_AXI6_QOS_DIS              MMC_REG_ADDR(DMC_AXI6_QOS_DIS)
+#define DMC_AXI6_QOS_DISBK (S_DMC_REG_BASE + (0xf3 << 2))
+#define P_DMC_AXI6_QOS_DISBK            MMC_REG_ADDR(DMC_AXI6_QOS_DISBK)
+#define DMC_AXI6_QOS_CTRL0 (S_DMC_REG_BASE + (0xf4 << 2))
+#define P_DMC_AXI6_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI6_QOS_CTRL0)
+#define DMC_AXI6_QOS_CTRL1 (S_DMC_REG_BASE + (0xf5 << 2))
+#define P_DMC_AXI6_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI6_QOS_CTRL1)
+#define DMC_AXI7_CHAN_CTRL (S_DMC_REG_BASE + (0xf6 << 2))
+#define P_DMC_AXI7_CHAN_CTRL            MMC_REG_ADDR(DMC_AXI7_CHAN_CTRL)
+#define DMC_AXI7_HOLD_CTRL (S_DMC_REG_BASE + (0xf7 << 2))
+#define P_DMC_AXI7_HOLD_CTRL            MMC_REG_ADDR(DMC_AXI7_HOLD_CTRL)
+#define DMC_AXI7_QOS_INC (S_DMC_REG_BASE + (0xf8 << 2))
+#define P_DMC_AXI7_QOS_INC              MMC_REG_ADDR(DMC_AXI7_QOS_INC)
+#define DMC_AXI7_QOS_INCBK (S_DMC_REG_BASE + (0xf9 << 2))
+#define P_DMC_AXI7_QOS_INCBK            MMC_REG_ADDR(DMC_AXI7_QOS_INCBK)
+#define DMC_AXI7_QOS_DEC (S_DMC_REG_BASE + (0xfa << 2))
+#define P_DMC_AXI7_QOS_DEC              MMC_REG_ADDR(DMC_AXI7_QOS_DEC)
+#define DMC_AXI7_QOS_DECBK (S_DMC_REG_BASE + (0xfb << 2))
+#define P_DMC_AXI7_QOS_DECBK            MMC_REG_ADDR(DMC_AXI7_QOS_DECBK)
+#define DMC_AXI7_QOS_DIS (S_DMC_REG_BASE + (0xfc << 2))
+#define P_DMC_AXI7_QOS_DIS              MMC_REG_ADDR(DMC_AXI7_QOS_DIS)
+#define DMC_AXI7_QOS_DISBK (S_DMC_REG_BASE + (0xfd << 2))
+#define P_DMC_AXI7_QOS_DISBK            MMC_REG_ADDR(DMC_AXI7_QOS_DISBK)
+#define DMC_AXI7_QOS_CTRL0 (S_DMC_REG_BASE + (0xfe << 2))
+#define P_DMC_AXI7_QOS_CTRL0            MMC_REG_ADDR(DMC_AXI7_QOS_CTRL0)
+#define DMC_AXI7_QOS_CTRL1 (S_DMC_REG_BASE + (0xff << 2))
+#define P_DMC_AXI7_QOS_CTRL1            MMC_REG_ADDR(DMC_AXI7_QOS_CTRL1)
+/**/
+#define STB_VERSION 0x1600
+#define P_STB_VERSION           CBUS_REG_ADDR(STB_VERSION)
+#define STB_VERSION_2 0x1650
+#define P_STB_VERSION_2                 CBUS_REG_ADDR(STB_VERSION_2)
+#define STB_VERSION_3 0x16a0
+#define P_STB_VERSION_3                 CBUS_REG_ADDR(STB_VERSION_3)
+#define STB_TEST_REG 0x1601
+#define P_STB_TEST_REG          CBUS_REG_ADDR(STB_TEST_REG)
+#define STB_TEST_REG_2 0x1651
+#define P_STB_TEST_REG_2                CBUS_REG_ADDR(STB_TEST_REG_2)
+#define STB_TEST_REG_3 0x16a1
+#define P_STB_TEST_REG_3                CBUS_REG_ADDR(STB_TEST_REG_3)
+#define FEC_INPUT_CONTROL 0x1602
+#define P_FEC_INPUT_CONTROL             CBUS_REG_ADDR(FEC_INPUT_CONTROL)
+#define FEC_INPUT_CONTROL_2 0x1652
+#define P_FEC_INPUT_CONTROL_2           CBUS_REG_ADDR(FEC_INPUT_CONTROL_2)
+#define FEC_INPUT_CONTROL_3 0x16a2
+#define P_FEC_INPUT_CONTROL_3           CBUS_REG_ADDR(FEC_INPUT_CONTROL_3)
+#define FEC_INPUT_DATA 0x1603
+#define P_FEC_INPUT_DATA                CBUS_REG_ADDR(FEC_INPUT_DATA)
+#define FEC_INPUT_DATA_2 0x1653
+#define P_FEC_INPUT_DATA_2              CBUS_REG_ADDR(FEC_INPUT_DATA_2)
+#define FEC_INPUT_DATA_3 0x16a3
+#define P_FEC_INPUT_DATA_3              CBUS_REG_ADDR(FEC_INPUT_DATA_3)
+#define DEMUX_CONTROL 0x1604
+#define P_DEMUX_CONTROL                 CBUS_REG_ADDR(DEMUX_CONTROL)
+#define DEMUX_CONTROL_2 0x1654
+#define P_DEMUX_CONTROL_2               CBUS_REG_ADDR(DEMUX_CONTROL_2)
+#define DEMUX_CONTROL_3 0x16a4
+#define P_DEMUX_CONTROL_3               CBUS_REG_ADDR(DEMUX_CONTROL_3)
+#define FEC_SYNC_BYTE 0x1605
+#define P_FEC_SYNC_BYTE                 CBUS_REG_ADDR(FEC_SYNC_BYTE)
+#define FEC_SYNC_BYTE_2 0x1655
+#define P_FEC_SYNC_BYTE_2               CBUS_REG_ADDR(FEC_SYNC_BYTE_2)
+#define FEC_SYNC_BYTE_3 0x16a5
+#define P_FEC_SYNC_BYTE_3               CBUS_REG_ADDR(FEC_SYNC_BYTE_3)
+#define FM_WR_DATA 0x1606
+#define P_FM_WR_DATA            CBUS_REG_ADDR(FM_WR_DATA)
+#define FM_WR_DATA_2 0x1656
+#define P_FM_WR_DATA_2          CBUS_REG_ADDR(FM_WR_DATA_2)
+#define FM_WR_DATA_3 0x16a6
+#define P_FM_WR_DATA_3          CBUS_REG_ADDR(FM_WR_DATA_3)
+#define FM_WR_ADDR 0x1607
+#define P_FM_WR_ADDR            CBUS_REG_ADDR(FM_WR_ADDR)
+#define FM_WR_ADDR_2 0x1657
+#define P_FM_WR_ADDR_2          CBUS_REG_ADDR(FM_WR_ADDR_2)
+#define FM_WR_ADDR_3 0x16a7
+#define P_FM_WR_ADDR_3          CBUS_REG_ADDR(FM_WR_ADDR_3)
+#define MAX_FM_COMP_ADDR 0x1608
+#define P_MAX_FM_COMP_ADDR              CBUS_REG_ADDR(MAX_FM_COMP_ADDR)
+#define MAX_FM_COMP_ADDR_2 0x1658
+#define P_MAX_FM_COMP_ADDR_2            CBUS_REG_ADDR(MAX_FM_COMP_ADDR_2)
+#define MAX_FM_COMP_ADDR_3 0x16a8
+#define P_MAX_FM_COMP_ADDR_3            CBUS_REG_ADDR(MAX_FM_COMP_ADDR_3)
+#define TS_HEAD_0 0x1609
+#define P_TS_HEAD_0             CBUS_REG_ADDR(TS_HEAD_0)
+#define TS_HEAD_0_2 0x1659
+#define P_TS_HEAD_0_2           CBUS_REG_ADDR(TS_HEAD_0_2)
+#define TS_HEAD_0_3 0x16a9
+#define P_TS_HEAD_0_3           CBUS_REG_ADDR(TS_HEAD_0_3)
+#define TS_HEAD_1 0x160a
+#define P_TS_HEAD_1             CBUS_REG_ADDR(TS_HEAD_1)
+#define TS_HEAD_1_2 0x165a
+#define P_TS_HEAD_1_2           CBUS_REG_ADDR(TS_HEAD_1_2)
+#define TS_HEAD_1_3 0x16aa
+#define P_TS_HEAD_1_3           CBUS_REG_ADDR(TS_HEAD_1_3)
+#define OM_CMD_STATUS 0x160b
+#define P_OM_CMD_STATUS                 CBUS_REG_ADDR(OM_CMD_STATUS)
+#define OM_CMD_STATUS_2 0x165b
+#define P_OM_CMD_STATUS_2               CBUS_REG_ADDR(OM_CMD_STATUS_2)
+#define OM_CMD_STATUS_3 0x16ab
+#define P_OM_CMD_STATUS_3               CBUS_REG_ADDR(OM_CMD_STATUS_3)
+#define OM_CMD_DATA 0x160c
+#define P_OM_CMD_DATA           CBUS_REG_ADDR(OM_CMD_DATA)
+#define OM_CMD_DATA_2 0x165c
+#define P_OM_CMD_DATA_2                 CBUS_REG_ADDR(OM_CMD_DATA_2)
+#define OM_CMD_DATA_3 0x16ac
+#define P_OM_CMD_DATA_3                 CBUS_REG_ADDR(OM_CMD_DATA_3)
+#define OM_CMD_DATA2 0x160d
+#define P_OM_CMD_DATA2          CBUS_REG_ADDR(OM_CMD_DATA2)
+#define OM_CMD_DATA2_2 0x165d
+#define P_OM_CMD_DATA2_2                CBUS_REG_ADDR(OM_CMD_DATA2_2)
+#define OM_CMD_DATA2_3 0x16ad
+#define P_OM_CMD_DATA2_3                CBUS_REG_ADDR(OM_CMD_DATA2_3)
+#define SEC_BUFF_01_START 0x160e
+#define P_SEC_BUFF_01_START             CBUS_REG_ADDR(SEC_BUFF_01_START)
+#define SEC_BUFF_01_START_2 0x165e
+#define P_SEC_BUFF_01_START_2           CBUS_REG_ADDR(SEC_BUFF_01_START_2)
+#define SEC_BUFF_01_START_3 0x16ae
+#define P_SEC_BUFF_01_START_3           CBUS_REG_ADDR(SEC_BUFF_01_START_3)
+#define SEC_BUFF_23_START 0x160f
+#define P_SEC_BUFF_23_START             CBUS_REG_ADDR(SEC_BUFF_23_START)
+#define SEC_BUFF_23_START_2 0x165f
+#define P_SEC_BUFF_23_START_2           CBUS_REG_ADDR(SEC_BUFF_23_START_2)
+#define SEC_BUFF_23_START_3 0x16af
+#define P_SEC_BUFF_23_START_3           CBUS_REG_ADDR(SEC_BUFF_23_START_3)
+#define SEC_BUFF_SIZE 0x1610
+#define P_SEC_BUFF_SIZE                 CBUS_REG_ADDR(SEC_BUFF_SIZE)
+#define SEC_BUFF_SIZE_2 0x1660
+#define P_SEC_BUFF_SIZE_2               CBUS_REG_ADDR(SEC_BUFF_SIZE_2)
+#define SEC_BUFF_SIZE_3 0x16b0
+#define P_SEC_BUFF_SIZE_3               CBUS_REG_ADDR(SEC_BUFF_SIZE_3)
+#define SEC_BUFF_BUSY 0x1611
+#define P_SEC_BUFF_BUSY                 CBUS_REG_ADDR(SEC_BUFF_BUSY)
+#define SEC_BUFF_BUSY_2 0x1661
+#define P_SEC_BUFF_BUSY_2               CBUS_REG_ADDR(SEC_BUFF_BUSY_2)
+#define SEC_BUFF_BUSY_3 0x16b1
+#define P_SEC_BUFF_BUSY_3               CBUS_REG_ADDR(SEC_BUFF_BUSY_3)
+#define SEC_BUFF_READY 0x1612
+#define P_SEC_BUFF_READY                CBUS_REG_ADDR(SEC_BUFF_READY)
+#define SEC_BUFF_READY_2 0x1662
+#define P_SEC_BUFF_READY_2              CBUS_REG_ADDR(SEC_BUFF_READY_2)
+#define SEC_BUFF_READY_3 0x16b2
+#define P_SEC_BUFF_READY_3              CBUS_REG_ADDR(SEC_BUFF_READY_3)
+#define SEC_BUFF_NUMBER 0x1613
+#define P_SEC_BUFF_NUMBER               CBUS_REG_ADDR(SEC_BUFF_NUMBER)
+#define SEC_BUFF_NUMBER_2 0x1663
+#define P_SEC_BUFF_NUMBER_2             CBUS_REG_ADDR(SEC_BUFF_NUMBER_2)
+#define SEC_BUFF_NUMBER_3 0x16b3
+#define P_SEC_BUFF_NUMBER_3             CBUS_REG_ADDR(SEC_BUFF_NUMBER_3)
+#define ASSIGN_PID_NUMBER 0x1614
+#define P_ASSIGN_PID_NUMBER             CBUS_REG_ADDR(ASSIGN_PID_NUMBER)
+#define ASSIGN_PID_NUMBER_2 0x1664
+#define P_ASSIGN_PID_NUMBER_2           CBUS_REG_ADDR(ASSIGN_PID_NUMBER_2)
+#define ASSIGN_PID_NUMBER_3 0x16b4
+#define P_ASSIGN_PID_NUMBER_3           CBUS_REG_ADDR(ASSIGN_PID_NUMBER_3)
+#define VIDEO_STREAM_ID 0x1615
+#define P_VIDEO_STREAM_ID               CBUS_REG_ADDR(VIDEO_STREAM_ID)
+#define VIDEO_STREAM_ID_2 0x1665
+#define P_VIDEO_STREAM_ID_2             CBUS_REG_ADDR(VIDEO_STREAM_ID_2)
+#define VIDEO_STREAM_ID_3 0x16b5
+#define P_VIDEO_STREAM_ID_3             CBUS_REG_ADDR(VIDEO_STREAM_ID_3)
+#define AUDIO_STREAM_ID 0x1616
+#define P_AUDIO_STREAM_ID               CBUS_REG_ADDR(AUDIO_STREAM_ID)
+#define AUDIO_STREAM_ID_2 0x1666
+#define P_AUDIO_STREAM_ID_2             CBUS_REG_ADDR(AUDIO_STREAM_ID_2)
+#define AUDIO_STREAM_ID_3 0x16b6
+#define P_AUDIO_STREAM_ID_3             CBUS_REG_ADDR(AUDIO_STREAM_ID_3)
+#define SUB_STREAM_ID 0x1617
+#define P_SUB_STREAM_ID                 CBUS_REG_ADDR(SUB_STREAM_ID)
+#define SUB_STREAM_ID_2 0x1667
+#define P_SUB_STREAM_ID_2               CBUS_REG_ADDR(SUB_STREAM_ID_2)
+#define SUB_STREAM_ID_3 0x16b7
+#define P_SUB_STREAM_ID_3               CBUS_REG_ADDR(SUB_STREAM_ID_3)
+#define OTHER_STREAM_ID 0x1618
+#define P_OTHER_STREAM_ID               CBUS_REG_ADDR(OTHER_STREAM_ID)
+#define OTHER_STREAM_ID_2 0x1668
+#define P_OTHER_STREAM_ID_2             CBUS_REG_ADDR(OTHER_STREAM_ID_2)
+#define OTHER_STREAM_ID_3 0x16b8
+#define P_OTHER_STREAM_ID_3             CBUS_REG_ADDR(OTHER_STREAM_ID_3)
+#define PCR90K_CTL 0x1619
+#define P_PCR90K_CTL            CBUS_REG_ADDR(PCR90K_CTL)
+#define PCR90K_CTL_2 0x1669
+#define P_PCR90K_CTL_2          CBUS_REG_ADDR(PCR90K_CTL_2)
+#define PCR90K_CTL_3 0x16b9
+#define P_PCR90K_CTL_3          CBUS_REG_ADDR(PCR90K_CTL_3)
+#define PCR_DEMUX 0x161a
+#define P_PCR_DEMUX             CBUS_REG_ADDR(PCR_DEMUX)
+#define PCR_DEMUX_2 0x166a
+#define P_PCR_DEMUX_2           CBUS_REG_ADDR(PCR_DEMUX_2)
+#define PCR_DEMUX_3 0x16ba
+#define P_PCR_DEMUX_3           CBUS_REG_ADDR(PCR_DEMUX_3)
+#define VIDEO_PTS_DEMUX 0x161b
+#define P_VIDEO_PTS_DEMUX               CBUS_REG_ADDR(VIDEO_PTS_DEMUX)
+#define VIDEO_PTS_DEMUX_2 0x166b
+#define P_VIDEO_PTS_DEMUX_2             CBUS_REG_ADDR(VIDEO_PTS_DEMUX_2)
+#define VIDEO_PTS_DEMUX_3 0x16bb
+#define P_VIDEO_PTS_DEMUX_3             CBUS_REG_ADDR(VIDEO_PTS_DEMUX_3)
+#define VIDEO_DTS_DEMUX 0x161c
+#define P_VIDEO_DTS_DEMUX               CBUS_REG_ADDR(VIDEO_DTS_DEMUX)
+#define VIDEO_DTS_DEMUX_2 0x166c
+#define P_VIDEO_DTS_DEMUX_2             CBUS_REG_ADDR(VIDEO_DTS_DEMUX_2)
+#define VIDEO_DTS_DEMUX_3 0x16bc
+#define P_VIDEO_DTS_DEMUX_3             CBUS_REG_ADDR(VIDEO_DTS_DEMUX_3)
+#define AUDIO_PTS_DEMUX 0x161d
+#define P_AUDIO_PTS_DEMUX               CBUS_REG_ADDR(AUDIO_PTS_DEMUX)
+#define AUDIO_PTS_DEMUX_2 0x166d
+#define P_AUDIO_PTS_DEMUX_2             CBUS_REG_ADDR(AUDIO_PTS_DEMUX_2)
+#define AUDIO_PTS_DEMUX_3 0x16bd
+#define P_AUDIO_PTS_DEMUX_3             CBUS_REG_ADDR(AUDIO_PTS_DEMUX_3)
+#define SUB_PTS_DEMUX 0x161e
+#define P_SUB_PTS_DEMUX                 CBUS_REG_ADDR(SUB_PTS_DEMUX)
+#define SUB_PTS_DEMUX_2 0x166e
+#define P_SUB_PTS_DEMUX_2               CBUS_REG_ADDR(SUB_PTS_DEMUX_2)
+#define SUB_PTS_DEMUX_3 0x16be
+#define P_SUB_PTS_DEMUX_3               CBUS_REG_ADDR(SUB_PTS_DEMUX_3)
+#define STB_PTS_DTS_STATUS 0x161f
+#define P_STB_PTS_DTS_STATUS            CBUS_REG_ADDR(STB_PTS_DTS_STATUS)
+#define STB_PTS_DTS_STATUS_2 0x166f
+#define P_STB_PTS_DTS_STATUS_2          CBUS_REG_ADDR(STB_PTS_DTS_STATUS_2)
+#define STB_PTS_DTS_STATUS_3 0x16bf
+#define P_STB_PTS_DTS_STATUS_3          CBUS_REG_ADDR(STB_PTS_DTS_STATUS_3)
+#define STB_DEBUG_INDEX 0x1620
+#define P_STB_DEBUG_INDEX               CBUS_REG_ADDR(STB_DEBUG_INDEX)
+#define STB_DEBUG_INDEX_2 0x1670
+#define P_STB_DEBUG_INDEX_2             CBUS_REG_ADDR(STB_DEBUG_INDEX_2)
+#define STB_DEBUG_INDEX_3 0x16c0
+#define P_STB_DEBUG_INDEX_3             CBUS_REG_ADDR(STB_DEBUG_INDEX_3)
+#define STB_DEBUG_DATAUT_O 0x1621
+#define P_STB_DEBUG_DATAUT_O            CBUS_REG_ADDR(STB_DEBUG_DATAUT_O)
+#define STB_DEBUG_DATAUT_O_2 0x1671
+#define P_STB_DEBUG_DATAUT_O_2          CBUS_REG_ADDR(STB_DEBUG_DATAUT_O_2)
+#define STB_DEBUG_DATAUT_O_3 0x16c1
+#define P_STB_DEBUG_DATAUT_O_3          CBUS_REG_ADDR(STB_DEBUG_DATAUT_O_3)
+#define STBM_CTL_O 0x1622
+#define P_STBM_CTL_O            CBUS_REG_ADDR(STBM_CTL_O)
+#define STBM_CTL_O_2 0x1672
+#define P_STBM_CTL_O_2          CBUS_REG_ADDR(STBM_CTL_O_2)
+#define STBM_CTL_O_3 0x16c2
+#define P_STBM_CTL_O_3          CBUS_REG_ADDR(STBM_CTL_O_3)
+#define STB_INT_STATUS 0x1623
+#define P_STB_INT_STATUS                CBUS_REG_ADDR(STB_INT_STATUS)
+#define STB_INT_STATUS_2 0x1673
+#define P_STB_INT_STATUS_2              CBUS_REG_ADDR(STB_INT_STATUS_2)
+#define STB_INT_STATUS_3 0x16c3
+#define P_STB_INT_STATUS_3              CBUS_REG_ADDR(STB_INT_STATUS_3)
+#define DEMUX_ENDIAN 0x1624
+#define P_DEMUX_ENDIAN          CBUS_REG_ADDR(DEMUX_ENDIAN)
+#define DEMUX_ENDIAN_2 0x1674
+#define P_DEMUX_ENDIAN_2                CBUS_REG_ADDR(DEMUX_ENDIAN_2)
+#define DEMUX_ENDIAN_3 0x16c4
+#define P_DEMUX_ENDIAN_3                CBUS_REG_ADDR(DEMUX_ENDIAN_3)
+#define TS_HIU_CTL 0x1625
+#define P_TS_HIU_CTL            CBUS_REG_ADDR(TS_HIU_CTL)
+#define TS_HIU_CTL_2 0x1675
+#define P_TS_HIU_CTL_2          CBUS_REG_ADDR(TS_HIU_CTL_2)
+#define TS_HIU_CTL_3 0x16c5
+#define P_TS_HIU_CTL_3          CBUS_REG_ADDR(TS_HIU_CTL_3)
+#define SEC_BUFF_BASE 0x1626
+#define P_SEC_BUFF_BASE                 CBUS_REG_ADDR(SEC_BUFF_BASE)
+#define SEC_BUFF_BASE_2 0x1676
+#define P_SEC_BUFF_BASE_2               CBUS_REG_ADDR(SEC_BUFF_BASE_2)
+#define SEC_BUFF_BASE_3 0x16c6
+#define P_SEC_BUFF_BASE_3               CBUS_REG_ADDR(SEC_BUFF_BASE_3)
+#define DEMUX_MEM_REQ_EN 0x1627
+#define P_DEMUX_MEM_REQ_EN              CBUS_REG_ADDR(DEMUX_MEM_REQ_EN)
+#define DEMUX_MEM_REQ_EN_2 0x1677
+#define P_DEMUX_MEM_REQ_EN_2            CBUS_REG_ADDR(DEMUX_MEM_REQ_EN_2)
+#define DEMUX_MEM_REQ_EN_3 0x16c7
+#define P_DEMUX_MEM_REQ_EN_3            CBUS_REG_ADDR(DEMUX_MEM_REQ_EN_3)
+#define VIDEO_PDTS_WR_PTR 0x1628
+#define P_VIDEO_PDTS_WR_PTR             CBUS_REG_ADDR(VIDEO_PDTS_WR_PTR)
+#define VIDEO_PDTS_WR_PTR_2 0x1678
+#define P_VIDEO_PDTS_WR_PTR_2           CBUS_REG_ADDR(VIDEO_PDTS_WR_PTR_2)
+#define VIDEO_PDTS_WR_PTR_3 0x16c8
+#define P_VIDEO_PDTS_WR_PTR_3           CBUS_REG_ADDR(VIDEO_PDTS_WR_PTR_3)
+#define AUDIO_PDTS_WR_PTR 0x1629
+#define P_AUDIO_PDTS_WR_PTR             CBUS_REG_ADDR(AUDIO_PDTS_WR_PTR)
+#define AUDIO_PDTS_WR_PTR_2 0x1679
+#define P_AUDIO_PDTS_WR_PTR_2           CBUS_REG_ADDR(AUDIO_PDTS_WR_PTR_2)
+#define AUDIO_PDTS_WR_PTR_3 0x16c9
+#define P_AUDIO_PDTS_WR_PTR_3           CBUS_REG_ADDR(AUDIO_PDTS_WR_PTR_3)
+#define SUB_WR_PTR 0x162a
+#define P_SUB_WR_PTR            CBUS_REG_ADDR(SUB_WR_PTR)
+#define SUB_WR_PTR_2 0x167a
+#define P_SUB_WR_PTR_2          CBUS_REG_ADDR(SUB_WR_PTR_2)
+#define SUB_WR_PTR_3 0x16ca
+#define P_SUB_WR_PTR_3          CBUS_REG_ADDR(SUB_WR_PTR_3)
+#define SB_START 0x162b
+#define P_SB_START              CBUS_REG_ADDR(SB_START)
+#define SB_START_2 0x167b
+#define P_SB_START_2            CBUS_REG_ADDR(SB_START_2)
+#define SB_START_3 0x16cb
+#define P_SB_START_3            CBUS_REG_ADDR(SB_START_3)
+#define SB_LAST_ADDR 0x162c
+#define P_SB_LAST_ADDR          CBUS_REG_ADDR(SB_LAST_ADDR)
+#define SB_LAST_ADDR_2 0x167c
+#define P_SB_LAST_ADDR_2                CBUS_REG_ADDR(SB_LAST_ADDR_2)
+#define SB_LAST_ADDR_3 0x16cc
+#define P_SB_LAST_ADDR_3                CBUS_REG_ADDR(SB_LAST_ADDR_3)
+#define SB_PES_WR_PTR 0x162d
+#define P_SB_PES_WR_PTR                 CBUS_REG_ADDR(SB_PES_WR_PTR)
+#define SB_PES_WR_PTR_2 0x167d
+#define P_SB_PES_WR_PTR_2               CBUS_REG_ADDR(SB_PES_WR_PTR_2)
+#define SB_PES_WR_PTR_3 0x16cd
+#define P_SB_PES_WR_PTR_3               CBUS_REG_ADDR(SB_PES_WR_PTR_3)
+#define OTHER_WR_PTR 0x162e
+#define P_OTHER_WR_PTR          CBUS_REG_ADDR(OTHER_WR_PTR)
+#define OTHER_WR_PTR_2 0x167e
+#define P_OTHER_WR_PTR_2                CBUS_REG_ADDR(OTHER_WR_PTR_2)
+#define OTHER_WR_PTR_3 0x16ce
+#define P_OTHER_WR_PTR_3                CBUS_REG_ADDR(OTHER_WR_PTR_3)
+#define OB_START 0x162f
+#define P_OB_START              CBUS_REG_ADDR(OB_START)
+#define OB_START_2 0x167f
+#define P_OB_START_2            CBUS_REG_ADDR(OB_START_2)
+#define OB_START_3 0x16cf
+#define P_OB_START_3            CBUS_REG_ADDR(OB_START_3)
+#define OB_LAST_ADDR 0x1630
+#define P_OB_LAST_ADDR          CBUS_REG_ADDR(OB_LAST_ADDR)
+#define OB_LAST_ADDR_2 0x1680
+#define P_OB_LAST_ADDR_2                CBUS_REG_ADDR(OB_LAST_ADDR_2)
+#define OB_LAST_ADDR_3 0x16d0
+#define P_OB_LAST_ADDR_3                CBUS_REG_ADDR(OB_LAST_ADDR_3)
+#define OB_PES_WR_PTR 0x1631
+#define P_OB_PES_WR_PTR                 CBUS_REG_ADDR(OB_PES_WR_PTR)
+#define OB_PES_WR_PTR_2 0x1681
+#define P_OB_PES_WR_PTR_2               CBUS_REG_ADDR(OB_PES_WR_PTR_2)
+#define OB_PES_WR_PTR_3 0x16d1
+#define P_OB_PES_WR_PTR_3               CBUS_REG_ADDR(OB_PES_WR_PTR_3)
+#define STB_INT_MASK 0x1632
+#define P_STB_INT_MASK          CBUS_REG_ADDR(STB_INT_MASK)
+#define STB_INT_MASK_2 0x1682
+#define P_STB_INT_MASK_2                CBUS_REG_ADDR(STB_INT_MASK_2)
+#define STB_INT_MASK_3 0x16d2
+#define P_STB_INT_MASK_3                CBUS_REG_ADDR(STB_INT_MASK_3)
+#define VIDEO_SPLICING_CTL 0x1633
+#define P_VIDEO_SPLICING_CTL            CBUS_REG_ADDR(VIDEO_SPLICING_CTL)
+#define VIDEO_SPLICING_CTL_2 0x1683
+#define P_VIDEO_SPLICING_CTL_2          CBUS_REG_ADDR(VIDEO_SPLICING_CTL_2)
+#define VIDEO_SPLICING_CTL_3 0x16d3
+#define P_VIDEO_SPLICING_CTL_3          CBUS_REG_ADDR(VIDEO_SPLICING_CTL_3)
+#define AUDIO_SPLICING_CTL 0x1634
+#define P_AUDIO_SPLICING_CTL            CBUS_REG_ADDR(AUDIO_SPLICING_CTL)
+#define AUDIO_SPLICING_CTL_2 0x1684
+#define P_AUDIO_SPLICING_CTL_2          CBUS_REG_ADDR(AUDIO_SPLICING_CTL_2)
+#define AUDIO_SPLICING_CTL_3 0x16d4
+#define P_AUDIO_SPLICING_CTL_3          CBUS_REG_ADDR(AUDIO_SPLICING_CTL_3)
+#define TS_PACKAGE_BYTE_COUNT 0x1635
+#define P_TS_PACKAGE_BYTE_COUNT                 \
+	CBUS_REG_ADDR(TS_PACKAGE_BYTE_COUNT)
+#define TS_PACKAGE_BYTE_COUNT_2 0x1685
+#define P_TS_PACKAGE_BYTE_COUNT_2               \
+	CBUS_REG_ADDR(TS_PACKAGE_BYTE_COUNT_2)
+#define TS_PACKAGE_BYTE_COUNT_3 0x16d5
+#define P_TS_PACKAGE_BYTE_COUNT_3               \
+	CBUS_REG_ADDR(TS_PACKAGE_BYTE_COUNT_3)
+#define PES_STRONG_SYNC 0x1636
+#define P_PES_STRONG_SYNC               CBUS_REG_ADDR(PES_STRONG_SYNC)
+#define PES_STRONG_SYNC_2 0x1686
+#define P_PES_STRONG_SYNC_2             CBUS_REG_ADDR(PES_STRONG_SYNC_2)
+#define PES_STRONG_SYNC_3 0x16d6
+#define P_PES_STRONG_SYNC_3             CBUS_REG_ADDR(PES_STRONG_SYNC_3)
+#define OM_DATA_RD_ADDR 0x1637
+#define P_OM_DATA_RD_ADDR               CBUS_REG_ADDR(OM_DATA_RD_ADDR)
+#define OM_DATA_RD_ADDR_2 0x1687
+#define P_OM_DATA_RD_ADDR_2             CBUS_REG_ADDR(OM_DATA_RD_ADDR_2)
+#define OM_DATA_RD_ADDR_3 0x16d7
+#define P_OM_DATA_RD_ADDR_3             CBUS_REG_ADDR(OM_DATA_RD_ADDR_3)
+#define OM_DATA_RD 0x1638
+#define P_OM_DATA_RD            CBUS_REG_ADDR(OM_DATA_RD)
+#define OM_DATA_RD_2 0x1688
+#define P_OM_DATA_RD_2          CBUS_REG_ADDR(OM_DATA_RD_2)
+#define OM_DATA_RD_3 0x16d8
+#define P_OM_DATA_RD_3          CBUS_REG_ADDR(OM_DATA_RD_3)
+#define SECTION_AUTO_STOP_3 0x1639
+#define P_SECTION_AUTO_STOP_3           CBUS_REG_ADDR(SECTION_AUTO_STOP_3)
+#define SECTION_AUTO_STOP_3_2 0x1689
+#define P_SECTION_AUTO_STOP_3_2                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_3_2)
+#define SECTION_AUTO_STOP_3_3 0x16d9
+#define P_SECTION_AUTO_STOP_3_3                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_3_3)
+#define SECTION_AUTO_STOP_2 0x163a
+#define P_SECTION_AUTO_STOP_2           \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_2)
+#define SECTION_AUTO_STOP_2_2 0x168a
+#define P_SECTION_AUTO_STOP_2_2                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_2_2)
+#define SECTION_AUTO_STOP_2_3 0x16da
+#define P_SECTION_AUTO_STOP_2_3                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_2_3)
+#define SECTION_AUTO_STOP_1 0x163b
+#define P_SECTION_AUTO_STOP_1           CBUS_REG_ADDR(SECTION_AUTO_STOP_1)
+#define SECTION_AUTO_STOP_1_2 0x168b
+#define P_SECTION_AUTO_STOP_1_2                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_1_2)
+#define SECTION_AUTO_STOP_1_3 0x16db
+#define P_SECTION_AUTO_STOP_1_3                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_1_3)
+#define SECTION_AUTO_STOP_0 0x163c
+#define P_SECTION_AUTO_STOP_0           \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_0)
+#define SECTION_AUTO_STOP_0_2 0x168c
+#define P_SECTION_AUTO_STOP_0_2                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_0_2)
+#define SECTION_AUTO_STOP_0_3 0x16dc
+#define P_SECTION_AUTO_STOP_0_3                 \
+	CBUS_REG_ADDR(SECTION_AUTO_STOP_0_3)
+#define DEMUX_CHANNEL_RESET 0x163d
+#define P_DEMUX_CHANNEL_RESET           \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_RESET)
+#define DEMUX_CHANNEL_RESET_2 0x168d
+#define P_DEMUX_CHANNEL_RESET_2                 \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_RESET_2)
+#define DEMUX_CHANNEL_RESET_3 0x16dd
+#define P_DEMUX_CHANNEL_RESET_3                 \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_RESET_3)
+#define DEMUX_SCRAMBLING_STATE 0x163e
+#define DEMUX_SCRAMBLING_STATE_2 0x168e
+#define P_DEMUX_SCRAMBLING_STATE_2              \
+	CBUS_REG_ADDR(DEMUX_SCRAMBLING_STATE_2)
+#define DEMUX_SCRAMBLING_STATE_3 0x16de
+#define P_DEMUX_SCRAMBLING_STATE_3              \
+	CBUS_REG_ADDR(DEMUX_SCRAMBLING_STATE_3)
+#define DEMUX_CHANNEL_ACTIVITY 0x163f
+#define P_DEMUX_CHANNEL_ACTIVITY                \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_ACTIVITY)
+#define DEMUX_CHANNEL_ACTIVITY_2 0x168f
+#define P_DEMUX_CHANNEL_ACTIVITY_2              \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_ACTIVITY_2)
+#define DEMUX_CHANNEL_ACTIVITY_3 0x16df
+#define P_DEMUX_CHANNEL_ACTIVITY_3              \
+	CBUS_REG_ADDR(DEMUX_CHANNEL_ACTIVITY_3)
+#define DEMUX_STAMP_CTL 0x1640
+#define P_DEMUX_STAMP_CTL               CBUS_REG_ADDR(DEMUX_STAMP_CTL)
+#define DEMUX_STAMP_CTL_2 0x1690
+#define P_DEMUX_STAMP_CTL_2             \
+	CBUS_REG_ADDR(DEMUX_STAMP_CTL_2)
+#define DEMUX_STAMP_CTL_3 0x16e0
+#define P_DEMUX_STAMP_CTL_3             \
+	CBUS_REG_ADDR(DEMUX_STAMP_CTL_3)
+#define DEMUX_VIDEO_STAMP_SYNC_0 0x1641
+#define P_DEMUX_VIDEO_STAMP_SYNC_0              \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_0)
+#define DEMUX_VIDEO_STAMP_SYNC_0_2 0x1691
+#define P_DEMUX_VIDEO_STAMP_SYNC_0_2            \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_0_2)
+#define DEMUX_VIDEO_STAMP_SYNC_0_3 0x16e1
+#define P_DEMUX_VIDEO_STAMP_SYNC_0_3            \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_0_3)
+#define DEMUX_VIDEO_STAMP_SYNC_1 0x1642
+#define P_DEMUX_VIDEO_STAMP_SYNC_1              \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_1)
+#define DEMUX_VIDEO_STAMP_SYNC_1_2 0x1692
+#define P_DEMUX_VIDEO_STAMP_SYNC_1_2            \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_1_2)
+#define DEMUX_VIDEO_STAMP_SYNC_1_3 0x16e2
+#define P_DEMUX_VIDEO_STAMP_SYNC_1_3            \
+	CBUS_REG_ADDR(DEMUX_VIDEO_STAMP_SYNC_1_3)
+#define DEMUX_AUDIO_STAMP_SYNC_0 0x1643
+#define P_DEMUX_AUDIO_STAMP_SYNC_0              \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_0)
+#define DEMUX_AUDIO_STAMP_SYNC_0_2 0x1693
+#define P_DEMUX_AUDIO_STAMP_SYNC_0_2            \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_0_2)
+#define DEMUX_AUDIO_STAMP_SYNC_0_3 0x16e3
+#define P_DEMUX_AUDIO_STAMP_SYNC_0_3            \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_0_3)
+#define DEMUX_AUDIO_STAMP_SYNC_1 0x1644
+#define P_DEMUX_AUDIO_STAMP_SYNC_1              \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_1)
+#define DEMUX_AUDIO_STAMP_SYNC_1_2 0x1694
+#define P_DEMUX_AUDIO_STAMP_SYNC_1_2            \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_1_2)
+#define DEMUX_AUDIO_STAMP_SYNC_1_3 0x16e4
+#define P_DEMUX_AUDIO_STAMP_SYNC_1_3            \
+	CBUS_REG_ADDR(DEMUX_AUDIO_STAMP_SYNC_1_3)
+#define DEMUX_SECTION_RESET 0x1645
+#define P_DEMUX_SECTION_RESET           CBUS_REG_ADDR(DEMUX_SECTION_RESET)
+#define DEMUX_SECTION_RESET_2 0x1695
+#define P_DEMUX_SECTION_RESET_2                 \
+	CBUS_REG_ADDR(DEMUX_SECTION_RESET_2)
+#define DEMUX_SECTION_RESET_3 0x16e5
+#define P_DEMUX_SECTION_RESET_3                 \
+	CBUS_REG_ADDR(DEMUX_SECTION_RESET_3)
+#define EFUSE_CNTL0 0x0
+#define P_EFUSE_CNTL0           SECBUS_REG_ADDR(EFUSE_CNTL0)
+#define EFUSE_CNTL1 0x1
+#define P_EFUSE_CNTL1           SECBUS_REG_ADDR(EFUSE_CNTL1)
+#define EFUSE_CNTL2 0x2
+#define P_EFUSE_CNTL2           SECBUS_REG_ADDR(EFUSE_CNTL2)
+#define EFUSE_CNTL3 0x3
+#define P_EFUSE_CNTL3           SECBUS_REG_ADDR(EFUSE_CNTL3)
+#define EFUSE_CNTL4 0x4
+#define P_EFUSE_CNTL4           SECBUS_REG_ADDR(EFUSE_CNTL4)
+#define AO_SECURE_REG0 0x00
+#define P_AO_SECURE_REG0                SECBUS2_REG_ADDR(AO_SECURE_REG0)
+#define AO_SECURE_REG1 0x01
+#define P_AO_SECURE_REG1                SECBUS2_REG_ADDR(AO_SECURE_REG1)
+#define AO_SECURE_REG2 0x02
+#define P_AO_SECURE_REG2                SECBUS2_REG_ADDR(AO_SECURE_REG2)
+#define SEC_BLKMV_AES_REG0 0x00
+#define P_SEC_BLKMV_AES_REG0            SECBUS3_REG_ADDR(SEC_BLKMV_AES_REG0)
+#define SEC_BLKMV_AES_W0 0x01
+#define P_SEC_BLKMV_AES_W0              SECBUS3_REG_ADDR(SEC_BLKMV_AES_W0)
+#define SEC_BLKMV_AES_W1 0x02
+#define P_SEC_BLKMV_AES_W1              SECBUS3_REG_ADDR(SEC_BLKMV_AES_W1)
+#define SEC_BLKMV_AES_W2 0x03
+#define P_SEC_BLKMV_AES_W2              SECBUS3_REG_ADDR(SEC_BLKMV_AES_W2)
+#define SEC_BLKMV_AES_W3 0x04
+#define P_SEC_BLKMV_AES_W3              SECBUS3_REG_ADDR(SEC_BLKMV_AES_W3)
+#define SEC_BLKMV_AES_R0 0x05
+#define P_SEC_BLKMV_AES_R0              SECBUS3_REG_ADDR(SEC_BLKMV_AES_R0)
+#define SEC_BLKMV_AES_R1 0x06
+#define P_SEC_BLKMV_AES_R1              SECBUS3_REG_ADDR(SEC_BLKMV_AES_R1)
+#define SEC_BLKMV_AES_R2 0x07
+#define P_SEC_BLKMV_AES_R2              SECBUS3_REG_ADDR(SEC_BLKMV_AES_R2)
+#define SEC_BLKMV_AES_R3 0x08
+#define P_SEC_BLKMV_AES_R3              SECBUS3_REG_ADDR(SEC_BLKMV_AES_R3)
+#define SEC_BLKMV_TDES_LAST_IV_LO 0x09
+#define P_SEC_BLKMV_TDES_LAST_IV_LO             \
+	SECBUS3_REG_ADDR(SEC_BLKMV_TDES_LAST_IV_LO)
+#define SEC_BLKMV_TDES_LAST_IV_HI 0x0a
+#define P_SEC_BLKMV_TDES_LAST_IV_HI             \
+	SECBUS3_REG_ADDR(SEC_BLKMV_TDES_LAST_IV_HI)
+#define SEC_BLKMV_AES_IV_0 0x0b
+#define P_SEC_BLKMV_AES_IV_0            SECBUS3_REG_ADDR(SEC_BLKMV_AES_IV_0)
+#define SEC_BLKMV_AES_IV_1 0x0c
+#define P_SEC_BLKMV_AES_IV_1            SECBUS3_REG_ADDR(SEC_BLKMV_AES_IV_1)
+#define SEC_BLKMV_AES_IV_2 0x0d
+#define P_SEC_BLKMV_AES_IV_2            SECBUS3_REG_ADDR(SEC_BLKMV_AES_IV_2)
+#define SEC_BLKMV_AES_IV_3 0x0e
+#define P_SEC_BLKMV_AES_IV_3            SECBUS3_REG_ADDR(SEC_BLKMV_AES_IV_3)
+/*add from M8M2*/
+#define SEC_BLKMV_AES_KEY_0 0x10
+#define P_SEC_BLKMV_AES_KEY_0           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_0)
+#define SEC_BLKMV_AES_KEY_1 0x11
+#define P_SEC_BLKMV_AES_KEY_1           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_1)
+#define SEC_BLKMV_AES_KEY_2 0x12
+#define P_SEC_BLKMV_AES_KEY_2           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_2)
+#define SEC_BLKMV_AES_KEY_3 0x13
+#define P_SEC_BLKMV_AES_KEY_3           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_3)
+#define SEC_BLKMV_AES_KEY_4 0x14
+#define P_SEC_BLKMV_AES_KEY_4           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_4)
+#define SEC_BLKMV_AES_KEY_5 0x15
+#define P_SEC_BLKMV_AES_KEY_5           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_5)
+#define SEC_BLKMV_AES_KEY_6 0x16
+#define P_SEC_BLKMV_AES_KEY_6           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_6)
+#define SEC_BLKMV_AES_KEY_7 0x17
+#define P_SEC_BLKMV_AES_KEY_7           SECBUS3_REG_ADDR(SEC_BLKMV_AES_KEY_7)
+#define SEC_BLKMV_THREAD_TABLE_START0 0x18
+#define P_SEC_BLKMV_THREAD_TABLE_START0                 \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_START0)
+#define SEC_BLKMV_THREAD_TABLE_CURR0 0x19
+#define P_SEC_BLKMV_THREAD_TABLE_CURR0          \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_CURR0)
+#define SEC_BLKMV_THREAD_TABLE_END0 0x1a
+#define P_SEC_BLKMV_THREAD_TABLE_END0           \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_END0)
+#define SEC_BLKMV_THREAD_TABLE_START1 0x1b
+#define P_SEC_BLKMV_THREAD_TABLE_START1                 \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_START1)
+#define SEC_BLKMV_THREAD_TABLE_CURR1 0x1c
+#define P_SEC_BLKMV_THREAD_TABLE_CURR1          \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_CURR1)
+#define SEC_BLKMV_THREAD_TABLE_END1 0x1d
+#define P_SEC_BLKMV_THREAD_TABLE_END1           \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_END1)
+#define SEC_BLKMV_THREAD_TABLE_START2 0x1e
+#define P_SEC_BLKMV_THREAD_TABLE_START2                 \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_START2)
+#define SEC_BLKMV_THREAD_TABLE_CURR2 0x1f
+#define P_SEC_BLKMV_THREAD_TABLE_CURR2          \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_CURR2)
+#define SEC_BLKMV_THREAD_TABLE_END2 0x20
+#define P_SEC_BLKMV_THREAD_TABLE_END2           \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_END2)
+#define SEC_BLKMV_THREAD_TABLE_START3 0x21
+#define P_SEC_BLKMV_THREAD_TABLE_START3                 \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_START3)
+#define SEC_BLKMV_THREAD_TABLE_CURR3 0x22
+#define P_SEC_BLKMV_THREAD_TABLE_CURR3          \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_CURR3)
+#define SEC_BLKMV_THREAD_TABLE_END3 0x23
+#define P_SEC_BLKMV_THREAD_TABLE_END3           \
+	SECBUS3_REG_ADDR(SEC_BLKMV_THREAD_TABLE_END3)
+#define SEC_BLKMV_GEN_REG0 0x24
+#define P_SEC_BLKMV_GEN_REG0            SECBUS3_REG_ADDR(SEC_BLKMV_GEN_REG0)
+#endif
diff --git a/drivers/amlogic/wetek/wetek_streambuf.h b/drivers/amlogic/wetek/wetek_streambuf.h
new file mode 100644
index 0000000..0892146
--- /dev/null
+++ b/drivers/amlogic/wetek/wetek_streambuf.h
@@ -0,0 +1,131 @@
+/*
+ * drivers/amlogic/amports/streambuf.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef STREAMBUF_H
+#define STREAMBUF_H
+#include "wetek_amports_config.h"
+
+#define BUF_FLAG_ALLOC          0x01
+#define BUF_FLAG_IN_USE         0x02
+#define BUF_FLAG_PARSER         0x04
+#define BUF_FLAG_FIRST_TSTAMP   0x08
+#define BUF_FLAG_IOMEM          0x10
+
+#define BUF_TYPE_VIDEO      0
+#define BUF_TYPE_AUDIO      1
+#define BUF_TYPE_SUBTITLE   2
+#define BUF_TYPE_USERDATA   3
+#define BUF_TYPE_HEVC       4
+#define BUF_MAX_NUM         5
+
+#define INVALID_PTS 0xffffffff
+
+#define FETCHBUF_SIZE   (64*1024)
+#define USER_DATA_SIZE  (8*1024)
+
+struct stream_buf_s {
+	s32 flag;
+	u32 type;
+	unsigned long buf_start;
+	struct page *buf_pages;
+	int buf_page_num;
+	u32 buf_size;
+	u32 default_buf_size;
+	u32 canusebuf_size;
+	u32 first_tstamp;
+	const ulong reg_base;
+	wait_queue_head_t wq;
+	struct timer_list timer;
+	u32 wcnt;
+	u32 buf_wp;
+	u32 buf_rp;
+	u32 max_buffer_delay_ms;
+	u64 last_write_jiffies64;
+	void *write_thread;
+	int for_4k;
+} /*stream_buf_t */;
+
+struct stream_port_s {
+	/* driver info */
+	const char *name;
+	struct device *class_dev;
+	const struct file_operations *fops;
+
+	/* ports control */
+	s32 type;
+	s32 flag;
+	s32 pcr_inited;
+
+	/* decoder info */
+	s32 vformat;
+	s32 aformat;
+	s32 achanl;
+	s32 asamprate;
+	s32 adatawidth;
+
+	/* parser info */
+	u32 vid;
+	u32 aid;
+	u32 sid;
+	u32 pcrid;
+} /*stream_port_t */;
+enum drm_level_e {
+	DRM_LEVEL1 = 1,
+	DRM_LEVEL2 = 2,
+	DRM_LEVEL3 = 3,
+	DRM_NONE = 4,
+};
+
+struct drm_info {
+	enum drm_level_e drm_level;
+	u32 drm_flag;
+	u32 drm_hasesdata;
+	u32 drm_priv;
+	u32 drm_pktsize;
+	u32 drm_pktpts;
+	u32 drm_phy;
+	u32 drm_vir;
+	u32 drm_remap;
+	u32 data_offset;
+	u32 extpad[8];
+} /*drminfo_t */;
+
+#define TYPE_DRMINFO   0x80
+
+extern void *fetchbuf;
+
+extern u32 stbuf_level(struct stream_buf_s *buf);
+extern u32 stbuf_rp(struct stream_buf_s *buf);
+extern u32 stbuf_space(struct stream_buf_s *buf);
+extern u32 stbuf_size(struct stream_buf_s *buf);
+extern u32 stbuf_canusesize(struct stream_buf_s *buf);
+extern s32 stbuf_init(struct stream_buf_s *buf);
+extern s32 stbuf_wait_space(struct stream_buf_s *stream_buf, size_t count);
+extern void stbuf_release(struct stream_buf_s *buf);
+extern int stbuf_change_size(struct stream_buf_s *buf, int size);
+extern int stbuf_fetch_init(void);
+extern void stbuf_fetch_release(void);
+extern u32 stbuf_sub_rp_get(void);
+extern void stbuf_sub_rp_set(unsigned int sub_rp);
+extern u32 stbuf_sub_wp_get(void);
+extern u32 stbuf_sub_start_get(void);
+extern u32 stbuf_userdata_start_get(void);
+extern struct stream_buf_s *get_stream_buffer(int id);
+
+extern void stbuf_vdec2_init(struct stream_buf_s *buf);
+
+#endif				/* STREAMBUF_H */
