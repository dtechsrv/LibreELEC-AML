diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index 68e8469..36e4c1d 100755
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -77,7 +77,7 @@ source "drivers/amlogic/mipi/Kconfig"
 source "drivers/amlogic/d2d3/Kconfig"
 source "drivers/amlogic/amvecm/Kconfig"
 source "drivers/amlogic/dvb_tv/Kconfig"
-
+source "drivers/amlogic/wetek/Kconfig"
 #
 #	GPU
 #
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index c65a3e5..de6924f 100755
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -84,6 +84,7 @@ obj-$(CONFIG_AMAUDIO2) += amaudio2/
 obj-y += mhl/
 obj-y += hdmi/
 
+obj-$(CONFIG_WETEK) += wetek/
 obj-$(CONFIG_AM_DVB) += dvb_tv/
 obj-$(CONFIG_AM_SMARTCARD) += smartcard/
 
diff --git a/drivers/amlogic/wetek/Kconfig b/drivers/amlogic/wetek/Kconfig
new file mode 100644
index 0000000..8598b6d
--- /dev/null
+++ b/drivers/amlogic/wetek/Kconfig
@@ -0,0 +1,13 @@
+#
+# Wetek Play driver configuration
+#
+
+menu "WeTek Play driver"
+
+config WETEK
+	tristate "Wetek Play driver"
+	default n
+	select DVB_CORE
+	help
+		Select to enable Wetek Play driver.
+endmenu
diff --git a/drivers/amlogic/wetek/Makefile b/drivers/amlogic/wetek/Makefile
new file mode 100644
index 0000000..f6c59c0
--- /dev/null
+++ b/drivers/amlogic/wetek/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the Wetek Play driver.
+#
+
+obj-$(CONFIG_WETEK) += wetekplay.o
+
+wetekplay-objs = nimdetect.o mxl603.o avl6211.o mn88436.o cxd2837.o cxd2841er_wetek.o ascot3.o
+
+EXTRA_CFLAGS += -Idrivers/media/dvb-core -Idrivers/media/tuners
diff --git a/drivers/amlogic/wetek/ascot3.c b/drivers/amlogic/wetek/ascot3.c
new file mode 100644
index 0000000..0b424e8
--- /dev/null
+++ b/drivers/amlogic/wetek/ascot3.c
@@ -0,0 +1,563 @@
+/*
+ * ascot3.c
+ *
+ * Sony Ascot3 DVB-T/T2/C tuner driver
+ *
+ * Copyright (C) 2015 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ * Based on ascot2e driver
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/dvb/frontend.h>
+#include <linux/types.h>
+#include "ascot3.h"
+#include "dvb_frontend.h"
+
+#define MAX_WRITE_REGSIZE 32
+
+enum ascot3_state {
+	STATE_UNKNOWN,
+	STATE_SLEEP,
+	STATE_ACTIVE
+};
+
+struct ascot3_priv {
+	u32			frequency;
+	u8			i2c_address;
+	struct i2c_adapter	*i2c;
+	enum ascot3_state	state;
+};
+
+enum ascot3_tv_system_t {
+	ASCOT3_DTV_DVBT_5,
+	ASCOT3_DTV_DVBT_6,
+	ASCOT3_DTV_DVBT_7,
+	ASCOT3_DTV_DVBT_8,
+	ASCOT3_DTV_DVBT2_1_7,
+	ASCOT3_DTV_DVBT2_5,
+	ASCOT3_DTV_DVBT2_6,
+	ASCOT3_DTV_DVBT2_7,
+	ASCOT3_DTV_DVBT2_8,
+	ASCOT3_DTV_DVBC_6,
+	ASCOT3_DTV_DVBC_8,
+	ASCOT3_DTV_DVBC2_6,
+	ASCOT3_DTV_DVBC2_8,
+	ASCOT3_DTV_UNKNOWN
+};
+
+struct ascot3_band_sett {
+	u8 	outlmt;
+	u8	rf_gain;
+	u8	if_bpf_gc;
+	u8	rfovld_det_lv1_vl;
+	u8	rfovld_det_lv1_vh;
+	u8	rfovld_det_lv1_u;
+	u8	ifovld_det_lv_vl;
+	u8	ifovld_det_lv_vh;
+	u8	ifovld_det_lv_u;
+	u8	if_bpf_f0;
+	u8	bw;
+	u8	fif_offset;
+	u8	bw_offset;
+	u8	agc_sel;
+	u8	if_out_sel;	
+	u8	is_lowerlocal;	
+};
+
+#define ASCOT3_AUTO		0xff
+#define ASCOT3_OFFSET(ofs)	((u8)(ofs) & 0x1F)
+#define ASCOT3_BW_6		0x00
+#define ASCOT3_BW_7		0x01
+#define ASCOT3_BW_8		0x02
+#define ASCOT3_BW_1_7	0x03
+
+static struct ascot3_band_sett ascot3_sett[] = {
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6, ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_7,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-5), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-4), ASCOT3_OFFSET(-6), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_1_7,ASCOT3_OFFSET(-10),ASCOT3_OFFSET(-10),ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-8), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_7,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-5), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x09, 0x0C, 0x0C, 0x0C, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-4), ASCOT3_OFFSET(-6), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x05, 0x09, 0x09, 0x09, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-4), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x05, 0x09, 0x09, 0x09, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-2), ASCOT3_OFFSET(-3), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }, 
+	{ 0x00, ASCOT3_AUTO, 0x03, 0x0A, 0x0A, 0x0A, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_6,  ASCOT3_OFFSET(-6), ASCOT3_OFFSET(-2), ASCOT3_AUTO, ASCOT3_AUTO, 0x00 },
+	{ 0x00, ASCOT3_AUTO, 0x03, 0x0A, 0x0A, 0x0A, 0x02, 0x02, 0x02, 0x00, 
+	  ASCOT3_BW_8,  ASCOT3_OFFSET(-2), ASCOT3_OFFSET(0),  ASCOT3_AUTO, ASCOT3_AUTO, 0x00 }
+};
+  
+static int ascot3_write_regs(struct ascot3_priv *priv,
+			      u8 reg, const u8 *data, u32 len)
+{
+	int ret;
+	u8 buf[MAX_WRITE_REGSIZE + 1];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.len = len + 1,
+			.buf = buf,
+		}
+	};
+
+	if (len + 1 >= sizeof(buf)) {
+		dev_warn(&priv->i2c->dev,"wr reg=%04x: len=%d is too big!\n",
+			 reg, len + 1);
+		return -E2BIG;
+	}
+
+
+	buf[0] = reg;
+	memcpy(&buf[1], data, len);
+	ret = i2c_transfer(priv->i2c, msg, 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EREMOTEIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"i2c wr failed=%d reg=%02x len=%d\n",
+			ret, reg, len);
+		return ret;
+	}
+	return 0;
+}
+
+static int ascot3_write_reg(struct ascot3_priv *priv, u8 reg, u8 val)
+{
+	return ascot3_write_regs(priv, reg, &val, 1);
+}
+
+static int ascot3_read_regs(struct ascot3_priv *priv,
+			     u8 reg, u8 *val, u32 len)
+{
+	int ret;
+	struct i2c_msg msg[2] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.len = 1,
+			.buf = &reg,
+		}, {
+			.addr = priv->i2c_address,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val,
+		}
+	};
+
+	ret = i2c_transfer(priv->i2c, &msg[0], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EREMOTEIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"I2C rw failed=%d addr=%02x reg=%02x\n",
+			ret, priv->i2c_address, reg);
+		return ret;
+	}
+	ret = i2c_transfer(priv->i2c, &msg[1], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EREMOTEIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"i2c rd failed=%d addr=%02x reg=%02x\n",
+			 ret, priv->i2c_address, reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ascot3_read_reg(struct ascot3_priv *priv, u8 reg, u8 *val)
+{
+	return ascot3_read_regs(priv, reg, val, 1);
+}
+
+static int ascot3_set_reg_bits(struct ascot3_priv *priv,
+				u8 reg, u8 data, u8 mask)
+{
+	int res;
+	u8 rdata;
+
+	if (mask != 0xff) {
+		res = ascot3_read_reg(priv, reg, &rdata);
+		if (res != 0)
+			return res;
+		data = ((data & mask) | (rdata & (mask ^ 0xFF)));
+	}
+	return ascot3_write_reg(priv, reg, data);
+}
+
+static int ascot3_enter_power_save(struct ascot3_priv *priv)
+{
+	u8 data[3];
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	
+	if (priv->state == STATE_SLEEP)
+		return 0;
+		
+	/* Loop Through setting And RFIN matching in Power Save */
+	ascot3_write_reg(priv, 0x67, 0x06);
+	/* Disable IF signal output (IF_OUT_SEL setting) */
+	ascot3_set_reg_bits(priv, 0x74, 0x02, 0x03);
+	/* Power save setting for analog block */
+	data[0] = 0x15;
+	data[1] = 0x00;
+	data[2] = 0x00;
+	ascot3_write_regs(priv, 0x5E, data, 3);
+	/* Standby setting for CPU */
+	ascot3_write_reg(priv, 0x88, 0x00);
+	/* Standby setting for internal logic block */
+	ascot3_write_reg(priv, 0x87, 0xC0);	
+	priv->state = STATE_SLEEP;	
+	return 0;
+}
+
+static int ascot3_init(struct dvb_frontend *fe)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	return 0;
+}
+
+static int ascot3_release(struct dvb_frontend *fe)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int ascot3_sleep(struct dvb_frontend *fe)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+		
+	ascot3_enter_power_save(priv);
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	return 0;
+}
+
+static enum ascot3_tv_system_t ascot3_get_tv_system(struct dvb_frontend *fe)
+{
+	enum ascot3_tv_system_t system = ASCOT3_DTV_UNKNOWN;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	if (p->delivery_system == SYS_DVBT) {
+		if (p->bandwidth_hz <= 5000000)
+			system = ASCOT3_DTV_DVBT_5;
+		else if (p->bandwidth_hz <= 6000000)
+			system = ASCOT3_DTV_DVBT_6;
+		else if (p->bandwidth_hz <= 7000000)
+			system = ASCOT3_DTV_DVBT_7;
+		else if (p->bandwidth_hz <= 8000000)
+			system = ASCOT3_DTV_DVBT_8;
+		else {
+			system = ASCOT3_DTV_DVBT_8;
+			p->bandwidth_hz = 8000000;
+		}
+	} else if (p->delivery_system == SYS_DVBT2) {
+		if (p->bandwidth_hz <= 5000000)
+			system = ASCOT3_DTV_DVBT2_5;
+		else if (p->bandwidth_hz <= 6000000)
+			system = ASCOT3_DTV_DVBT2_6;
+		else if (p->bandwidth_hz <= 7000000)
+			system = ASCOT3_DTV_DVBT2_7;
+		else if (p->bandwidth_hz <= 8000000)
+			system = ASCOT3_DTV_DVBT2_8;
+		else {
+			system = ASCOT3_DTV_DVBT2_8;
+			p->bandwidth_hz = 8000000;
+		}
+	} else if (p->delivery_system == SYS_DVBC_ANNEX_A) {
+		if (p->bandwidth_hz <= 6000000)
+			system = ASCOT3_DTV_DVBC_6;
+		else if (p->bandwidth_hz <= 8000000)
+			system = ASCOT3_DTV_DVBC_8;
+	}
+	dev_dbg(&priv->i2c->dev,
+		"%s(): ASCOT2E DTV system %d (delsys %d, bandwidth %d)\n",
+		__func__, (int)system, p->delivery_system, p->bandwidth_hz);
+	return system;
+}
+
+static int ascot3_set_params(struct dvb_frontend *fe)
+{
+	u8 data[20];
+	u32 frequency;
+	enum ascot3_tv_system_t tv_system;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): tune frequency %dkHz\n",
+		__func__, p->frequency / 1000);
+	tv_system = ascot3_get_tv_system(fe);
+
+	if (tv_system == ASCOT3_DTV_UNKNOWN) {
+		dev_dbg(&priv->i2c->dev, "%s(): unknown DTV system\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	frequency = roundup(p->frequency / 1000, 25);
+
+	/* Disable IF signal output (IF_OUT_SEL setting) */
+	ascot3_set_reg_bits(priv, 0x74, 0x02, 0x03);
+	/* Clock enable for internal logic block, CPU wake-up */
+	data[0] = 0xC4;
+	data[1] = 0x40;
+	ascot3_write_regs(priv, 0x87, data, 2);
+	
+	/* Initial setting for internal analog block */	
+	if (tv_system == ASCOT3_DTV_DVBC_6 ||
+			tv_system == ASCOT3_DTV_DVBC_8) {		
+		data[0] = 0x16;
+		data[1] = 0x26;
+	} else {		
+		data[0] = 0x10;
+		data[1] = 0x20;
+	}
+	ascot3_write_regs(priv, 0x91, data, 2);
+	
+	/* Setting for analog block */
+	data[0] = 0x00;
+	data[1] = (u8)(ascot3_sett[tv_system].is_lowerlocal & 0x01);
+	ascot3_write_regs(priv, 0x9C, data, 2);
+	
+	/* Enable for analog block */
+	data[0] = 0xEE;
+	data[1] = 0x02;
+	data[2] = 0x1E;
+	/* Tuning setting for CPU */
+	data[3] = 0x67;
+	/* Setting for PLL reference divider (REF_R) */
+	data[4] = 0x02;
+	/* Tuning setting for analog block*/
+	if (tv_system == ASCOT3_DTV_DVBC_6 ||
+			tv_system == ASCOT3_DTV_DVBC_8) {		
+		data[5] = 0x50;
+		data[6] = 0x78;
+		data[7] = 0x08;
+		data[8] = 0x30;
+	} else {		
+		data[5] = 0xAF;
+		data[6] = 0x78;
+		data[7] = 0x08;
+		data[8] = 0x30;
+	}
+	ascot3_write_regs(priv, 0x5E, data, 9);
+	
+	/* Setting for IFOUT_LIMIT */
+	data[0] = (u8)(ascot3_sett[tv_system].outlmt & 0x03);
+	/* Setting for IF BPF buffer gain */
+	/* RF_GAIN setting */
+	if (ascot3_sett[tv_system].rf_gain == ASCOT3_AUTO) 
+		data[1] = 0x80;
+	else
+		data[1] = (u8)((ascot3_sett[tv_system].rf_gain << 4) & 0x70);
+	
+	/* IF_BPF_GC setting */
+	data[1] |= (u8)(ascot3_sett[tv_system].if_bpf_gc & 0x0F);
+
+	/* Setting for internal RFAGC */
+	data[2] = 0x00;	
+	if (frequency <= 172000) {
+		data[3] = (u8)(ascot3_sett[tv_system].rfovld_det_lv1_vl & 0x0F);
+		data[4] = (u8)(ascot3_sett[tv_system].ifovld_det_lv_vl & 0x07);
+	} else if (frequency <= 464000) {		
+		data[3] = (u8)(ascot3_sett[tv_system].rfovld_det_lv1_vh & 0x0F);
+		data[4] = (u8)(ascot3_sett[tv_system].ifovld_det_lv_vh & 0x07);
+	} else {	
+		data[3] = (u8)(ascot3_sett[tv_system].rfovld_det_lv1_u & 0x0F);
+		data[4] = (u8)(ascot3_sett[tv_system].ifovld_det_lv_u & 0x07);
+	}	
+	data[4] |= 0x20;
+	
+	/* Setting for IF frequency and bandwidth */
+	data[5] = (u8)((ascot3_sett[tv_system].if_bpf_f0 << 4) & 0x30);
+	data[5] |= (u8)(ascot3_sett[tv_system].bw & 0x03);
+	data[6] = (u8)(ascot3_sett[tv_system].fif_offset & 0x1F);
+	data[7] = (u8)(ascot3_sett[tv_system].bw_offset & 0x1F);
+	
+	/* RF tuning frequency setting */
+	data[8] = (u8)(frequency & 0xFF);         /* 0x10: FRF_L */
+	data[9] = (u8)((frequency >> 8) & 0xFF);  /* 0x11: FRF_M */
+	data[10] = (u8)((frequency >> 16) & 0x0F); /* 0x12: FRF_H (bit[3:0]) */
+	/* Tuning command */
+	data[11] = 0xFF;
+	/* Enable IF output, AGC and IFOUT pin selection */
+	data[12] = 0x11;
+	/* Tuning setting for analog block*/
+	if (tv_system == ASCOT3_DTV_DVBC_6 ||
+			tv_system == ASCOT3_DTV_DVBC_8) {		
+		data[13] = 0xD9;
+		data[14] = 0x0F;
+		data[15] = 0x25;
+		data[16] = 0x87;
+	} else {		
+		data[13] = 0x99;
+		data[14] = 0x00;
+		data[15] = 0x24;
+		data[16] = 0x87;
+	}
+	ascot3_write_regs(priv, 0x68, data, 17);
+
+	msleep(50);
+	
+	priv->state = STATE_ACTIVE;	
+	ascot3_write_reg(priv, 0x88, 0x00);
+	ascot3_write_reg(priv, 0x87, 0xC0);
+	
+	priv->frequency = frequency;
+	return 0;
+}
+
+static int ascot3_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct ascot3_priv *priv = fe->tuner_priv;
+
+	*frequency = priv->frequency * 1000;
+	return 0;
+}
+
+static struct dvb_tuner_ops ascot3_tuner_ops = {
+	.info = {
+		.name = "Sony ASCOT3",
+		.frequency_min = 1000000,
+		.frequency_max = 1200000000,
+		.frequency_step = 25000,
+	},
+	.init = ascot3_init,
+	.release = ascot3_release,
+	.sleep = ascot3_sleep,
+	.set_params = ascot3_set_params,
+	.get_frequency = ascot3_get_frequency,
+};
+
+struct dvb_frontend *ascot3_attach(struct dvb_frontend *fe,
+				    const struct ascot3_config *config,
+				    struct i2c_adapter *i2c)
+{
+	u8 data[20];
+	struct ascot3_priv *priv = NULL;
+
+	priv = kzalloc(sizeof(struct ascot3_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
+	priv->i2c_address = config->i2c_address;
+	priv->i2c = i2c;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	/* Check if tuner is Sony ASCOT3 */
+	data[0] = 0x00;
+	ascot3_read_reg(priv, 0x7F, data);
+	if (((data[0] & 0xF0) != 0xC0) && ((data[0] & 0xF0) != 0xD0)) {
+		kfree(priv);
+		return NULL;	
+	}	
+	/* Initial setting for internal logic block */	
+	data[0] = 0x7A;
+	data[1] = 0x01;
+	ascot3_write_regs(priv, 0x99, data, 2);
+	/* 16 MHz xTal frequency */
+	data[0] = 16;
+	/* Driver current setting for crystal oscillator */	
+	/* Load capacitance setting for crystal oscillator */
+	data[1] = 0x84;
+	data[2] = 0xB0;
+	/* Setting for REFOUT signal output */
+	data[3] = 0x00;
+	/* GPIO0, GPIO1 port setting */
+	data[4] = 0x00;
+	data[5] = 0x00;
+	/* Logic wake up, CPU boot */
+	data[6] = 0xC4;
+	data[7] = 0x40;
+	/* For burst-write */
+	data[8] = 0x10;
+	/* Setting for internal RFAGC */
+	data[9] = 0x00;
+	data[10] = 0x45;
+	data[11] = 0x56;
+	/* Setting for analog block */
+	data[12] = 0x07;
+	/* Initial setting for internal analog block */
+	data[13] = 0x1C;
+	data[14] = 0x3F;
+	data[15] = 0x02;
+	data[16] = 0x10;
+	data[17] = 0x20;
+	data[18] = 0x0A;
+	data[19] = 0x00;
+	ascot3_write_regs(priv, 0x81, data, 20);
+	/* Setting for internal RFAGC */
+	ascot3_write_reg(priv, 0x9B, 0x00);
+	msleep(10);
+	/* VCO current setting */
+	data[0] = 0x8D;
+	data[1] = 0x06;
+	ascot3_write_regs(priv, 0x17, data, 2);
+	msleep(1);
+	ascot3_read_reg(priv, 0x19, data);
+	ascot3_write_reg(priv, 0x95, ((data[0] >> 4) & 0x0F));
+	ascot3_enter_power_save(priv);	
+	/* Load capacitance control setting for crystal oscillator */
+	ascot3_write_reg(priv, 0x80, 0x01);
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	memcpy(&fe->ops.tuner_ops, &ascot3_tuner_ops,
+				sizeof(struct dvb_tuner_ops));
+	fe->tuner_priv = priv;
+	dev_info(&priv->i2c->dev,
+		"Sony ASCOT3 attached on addr=%x at I2C adapter %p\n",
+		priv->i2c_address, priv->i2c);
+	return fe;
+}
+EXPORT_SYMBOL(ascot3_attach);
+
+MODULE_DESCRIPTION("Sony ASCOT3 terr/cab tuner driver");
+MODULE_AUTHOR("sasa.savic.sr@gmail.com");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/ascot3.h b/drivers/amlogic/wetek/ascot3.h
new file mode 100644
index 0000000..e245539
--- /dev/null
+++ b/drivers/amlogic/wetek/ascot3.h
@@ -0,0 +1,46 @@
+/*
+ * ascot3.h
+ *
+ * Sony Ascot3 DVB-T/T2/C tuner driver
+ *
+ * Copyright (C) 2015 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ * Based on ascot2e driver
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#ifndef __DVB_ASCOT3_H__
+#define __DVB_ASCOT3_H__
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+#include <linux/i2c.h>
+
+/**
+ * struct ascot3_config - the configuration of Ascot2E tuner driver
+ * @i2c_address:	I2C address of the tuner
+ * @xtal_freq_mhz:	Oscillator frequency, MHz
+ */
+struct ascot3_config {
+	u8	i2c_address;
+	u8	xtal_freq_mhz;
+};
+
+extern struct dvb_frontend *ascot3_attach(struct dvb_frontend *fe,
+					const struct ascot3_config *config,
+					struct i2c_adapter *i2c);
+#endif
diff --git a/drivers/amlogic/wetek/avl6211.c b/drivers/amlogic/wetek/avl6211.c
new file mode 100644
index 0000000..5a53ac7
--- /dev/null
+++ b/drivers/amlogic/wetek/avl6211.c
@@ -0,0 +1,1981 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "dvb_frontend.h"
+#include "avl6211_reg.h"
+#include "avl6211.h"
+
+
+const struct avl6211_pllconf pll_conf[] = {
+	/* The following set of PLL configuration at different reference clock frequencies refer to demod operation */
+	/* in standard performance mode. */
+	 { 503,  1, 7, 4, 2,  4000, 11200, 16800, 25200 } /* Reference clock 4 MHz,   Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 447,  1, 7, 4, 2,  4500, 11200, 16800, 25200 } /* Reference clock 4.5 MHz, Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 503,  4, 7, 4, 2, 10000, 11200, 16800, 25200 } /* Reference clock 10 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 503,  7, 7, 4, 2, 16000, 11200, 16800, 25200 } /* Reference clock 16 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 111,  2, 7, 4, 2, 27000, 11200, 16800, 25200 } /* Reference clock 27 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	
+	/* The following set of PLL configuration at different reference clock frequencies refer to demod operation */
+	/* in high performance mode. */
+	,{ 566,  1, 7, 4, 2,  4000, 12600, 18900, 28350 } /* Reference clock 4 MHz,   Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 503,  1, 7, 4, 2,  4500, 12600, 18900, 28350 } /* Reference clock 4.5 MHz, Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 566,  4, 7, 4, 2, 10000, 12600, 18900, 28350 } /* Reference clock 10 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 566,  7, 7, 4, 2, 16000, 12600, 18900, 28350 } /* Reference clock 16 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 377,  8, 7, 4, 2, 27000, 12600, 18900, 28350 } /* Reference clock 27 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+};
+
+const unsigned short pll_array_size = sizeof(pll_conf) / sizeof(struct avl6211_pllconf);
+
+struct avl6211_state
+{
+	struct i2c_adapter* i2c;
+	struct avl6211_config* config;
+	struct dvb_frontend frontend;
+	
+	u8 diseqc_status;
+	u16 locked;
+	u32 frequency;
+	u32 symbol_rate;	
+	u32 flags;
+	
+	int demod_id;
+	
+	u16 tuner_lpf;
+	u16 demod_freq;	/* Demod clock in 10kHz units */
+	u16 fec_freq;	/* FEC clock in 10kHz units */
+	u16 mpeg_freq;	/* MPEG clock in 10kHz units */
+	
+	bool boot;
+	bool gpio_on;
+};
+struct avl6211_diseqc_tx_status
+{
+	u8 tx_done;		
+	u8 tx_fifo_cnt;
+};
+static u16 extract_16(const u8 * buf)
+{
+	u16 data;
+	data = buf[0];
+	data = (u16)(data << 8) + buf[1];
+	return data;
+}
+static u32 extract_32(const u8 * buf)
+{
+	unsigned int data;
+	data = buf[0];
+	data = (data << 8) + buf[1];
+	data = (data << 8) + buf[2];
+	data = (data << 8) + buf[3];
+	return data;
+}
+static int avl6211_i2c_writereg(struct avl6211_state *state, u8 *data, u16 *size)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+				.addr = state->config->demod_address, 
+				.flags = 0,
+				.buf = data,
+				.len = *size,
+			}
+	};
+	
+	ret = i2c_transfer(state->i2c, msg, 1);	
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d", ret);
+		ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+static int avl6211_i2c_readreg(struct avl6211_state* state, u8 * data, u16 * size)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+					.addr = state->config->demod_address, 
+					.flags = I2C_M_RD,
+					.buf = data,
+					.len = *size,
+			}
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 1);
+	
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d", ret);
+		ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+static int avl6211_i2c_read(struct avl6211_state* state, u32 offset, u8 * buf, u16 buf_size)
+{
+	int ret;
+	u8 buf_tmp[3];
+	u16 x1 = 3, x2 = 0;
+	u16 size;
+
+	format_addr(offset, buf_tmp);
+	ret = avl6211_i2c_writereg(state, buf_tmp, &x1);  
+	if (ret)
+		goto err;
+
+	if (buf_size & 1)
+		size = buf_size - 1;
+	else
+		size = buf_size;
+
+	while (size > I2C_MAX_READ) {
+		x1 = I2C_MAX_READ;
+		ret = avl6211_i2c_readreg(state, buf + x2, &x1);
+		if (ret)
+			goto err;			
+		x2 += I2C_MAX_READ;
+		size -= I2C_MAX_READ;
+	}
+
+	if (size != 0) {
+		ret = avl6211_i2c_readreg(state, buf + x2, &size);
+		if (ret)
+			goto err;
+	}
+
+	if (buf_size & 1) {
+		x1 = 2;
+		ret = avl6211_i2c_readreg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+		buf[buf_size-1] = buf_tmp[0];
+	}
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write(struct avl6211_state* state, u8 * buf, u16 buf_size)
+{
+	int ret;
+	u8 buf_tmp[5], *x3;
+	u16 x1, x2 = 0, tmp;
+	u16 size;
+	u32 addr;
+
+	if (WARN_ON(buf_size < 3))
+		return -EINVAL;	
+		
+	/* Actual data size */
+	buf_size -= 3;
+	/* Dump address */
+	addr = buf[0];
+	addr = addr << 8;
+	addr += buf[1];
+	addr = addr << 8;
+	addr += buf[2];
+	
+	if (buf_size & 1)
+		size = buf_size -1;
+	else
+		size = buf_size;
+	
+	tmp = (I2C_MAX_WRITE - 3) & 0xfffe; /* How many bytes data we can transfer every time */
+	
+	x2 = 0;
+	while( size > tmp ) {
+		x1 = tmp + 3;
+		/* Save the data */
+		buf_tmp[0] = buf[x2];
+		buf_tmp[1] = buf[x2 + 1];
+		buf_tmp[2] = buf[x2 + 2];
+		x3 = buf + x2;
+		format_addr(addr, x3);
+		ret = avl6211_i2c_writereg(state, buf + x2, &x1);
+		if (ret)
+			goto err;
+		/* Restore data */
+		buf[x2] = buf_tmp[0];
+		buf[x2 + 1] = buf_tmp[1];
+		buf[x2 + 2] = buf_tmp[2];
+		addr += tmp;
+		x2 += tmp;
+		size -= tmp;
+	}
+
+	x1 = size + 3;
+	/* Save the data */
+	buf_tmp[0] = buf[x2];
+	buf_tmp[1] = buf[x2 + 1];
+	buf_tmp[2] = buf[x2 + 2];
+	x3 = buf + x2;
+	format_addr(addr, x3);
+	ret = avl6211_i2c_writereg(state, buf + x2, &x1);
+	if (ret)
+		goto err;
+	/* Restore data */
+	buf[x2] = buf_tmp[0];
+	buf[x2 + 1] = buf_tmp[1];
+	buf[x2 + 2] = buf_tmp[2];
+	addr += size;
+	x2 += size;
+		
+	if (buf_size & 1) {
+		format_addr(addr, buf_tmp);
+		x1 = 3;
+		ret = avl6211_i2c_writereg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+		x1 = 2;
+		ret = avl6211_i2c_readreg(state, buf_tmp + 3, &x1);
+			goto err;
+		buf_tmp[3] = buf[x2 + 3];
+		x1 = 5;
+		ret = avl6211_i2c_writereg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+	}
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_read16(struct avl6211_state* state, u32 addr, u16 *data)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, addr, buf, 2);
+	if (ret)
+		goto err;
+		
+	*data = extract_16(buf);
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_read32(struct avl6211_state* state, u32 addr, u32 *data)
+{
+	int ret;
+	u8 buf[4];
+
+	ret = avl6211_i2c_read(state, addr, buf, 4);
+	if (ret)
+		goto err;
+		
+	*data = extract_32(buf);
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write16(struct avl6211_state* state, u32 addr, u16 data)
+{
+	int ret;
+	u8 buf[5], *p;
+
+	format_addr(addr, buf);
+	p = buf + 3;
+	format_16(data, p);
+
+	ret = avl6211_i2c_write(state, buf, 5);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write32(struct avl6211_state* state, u32 addr, u32 data)
+{
+	int ret;
+	u8 buf[7], *p;
+
+	format_addr(addr, buf);
+	p = buf + 3;
+	format_32(data, p);
+	ret = avl6211_i2c_write(state, buf, 7);
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_get_op_status(struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, rx_cmd_addr, buf, 2);
+	if (ret)
+		goto err;
+		
+	if (buf[1] != 0) {
+		ret = -EINVAL;
+		goto err;
+	}
+	
+	return 0;
+err:	
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_send_op(u8 ucOpCmd, struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+	u16 x1;
+	int cnt = 20;
+
+	do {
+		ret = avl6211_get_op_status(state);
+		if (!ret)
+			break;
+	
+		msleep(10);
+		cnt--;
+	} while (cnt != 0);
+	
+	if (ret)
+		goto err;
+		
+	buf[0] = 0;
+	buf[1] = ucOpCmd;
+	x1 = extract_16(buf);
+	ret = avl6211_i2c_write16(state, rx_cmd_addr, x1);   
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_get_status(struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, i2cm_cmd_addr + I2CM_CMD_LENGTH - 2, buf, 2);
+	if (ret)
+		goto err;
+		
+	if (buf[1] != 0) {
+		ret = -EINVAL;
+		goto err;
+	}
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_i2c_repeater_exec(struct avl6211_state* state, u8 * buf, u8 size)
+{
+	int ret, i = 0;
+
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 60 < i++) 
+			goto err;
+			
+		msleep(5);
+	
+	} while (ret);
+	
+	ret = avl6211_i2c_write(state, buf, size);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_send(struct avl6211_state* state, u8 * buf, u16 size)
+{
+	int ret;
+	u8 tmp_buf[I2CM_CMD_LENGTH + 3];
+	u16 i, j;
+	u16 cmd_size;
+
+	if (WARN_ON(size > I2CM_CMD_LENGTH - 3))
+		return -EINVAL;
+
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	
+	cmd_size = ((size + 3) % 2) + 3 + size;
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - cmd_size, tmp_buf);
+
+	i = 3 + ((3 + size) % 2);	  /* skip one byte if the size +3 is odd */
+
+	for (j = 0; j < size; j++)
+		tmp_buf[i++] = buf[j];
+
+	tmp_buf[i++] = (u8)size;
+	tmp_buf[i++] = state->config->tuner_address;
+	tmp_buf[i++] = OP_I2CM_WRITE;
+
+			
+	ret = avl6211_i2c_repeater_exec(state, tmp_buf, (u8)(cmd_size + 3));
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_i2c_repeater_recv(struct avl6211_state* state, u8 * buf, u16 size)
+{
+	int ret, i = 0;
+	u8 tmp_buf[I2CM_RSP_LENGTH];
+
+	if (WARN_ON(size > I2CM_RSP_LENGTH))
+		return -EINVAL;
+
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - 4, tmp_buf);
+	tmp_buf[3] = 0x0;
+	tmp_buf[4] = (u8)size;
+	tmp_buf[5] = state->config->tuner_address;
+	tmp_buf[6] = OP_I2CM_READ;
+
+	ret = avl6211_i2c_repeater_exec(state, tmp_buf, 7);
+	if (ret)
+		goto err;
+	
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 100 < i++) 
+			goto err;
+			
+		msleep(10);
+	
+	} while (ret);
+
+	ret = avl6211_i2c_read(state, i2cm_rsp_addr, buf, size);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_init(u16 bus_clk, struct avl6211_state* state)
+{
+	u8 buf[5];
+	int ret;
+
+	ret = avl6211_i2c_write16(state, rc_i2cm_speed_kHz_addr, bus_clk);
+	if (ret)
+		goto err;
+		
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - 2, buf);
+	buf[3] = 0x01;
+	buf[4] = OP_I2CM_INIT;
+	ret = avl6211_i2c_repeater_exec(state, buf, 5);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int AV2011_I2C_write(u8 reg_start, u8* buff, u8 len, struct avl6211_state* state)
+{
+	int ret, i = 0;
+	u8 ucTemp[50] = { 0 };
+	
+	msleep(5);
+	ucTemp[0] = reg_start;
+	ret = avl6211_i2c_repeater_get_status(state);
+	
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 100 < i++) 
+			goto err;
+			
+		msleep(1);
+	
+	} while (ret);
+		
+	for (i = 1; i < len + 1; i++)			
+		ucTemp[i] = *(buff + i - 1);
+			
+	ret = avl6211_i2c_repeater_send(state, ucTemp, len+1);
+	if (ret)
+		goto err;
+	
+	msleep(5);
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int av2011_tuner_lock_status(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;	
+	int ret;
+	u8 lock = 0x0b;
+	u8 locked = 0;
+	ret = avl6211_i2c_repeater_send(state, &lock, 1);
+	if (ret)
+		goto err;
+		
+	ret = avl6211_i2c_repeater_recv(state, &locked, 1);
+	if (ret)
+		goto err;
+
+	if (!(locked & 0x01)) 
+		return -EINVAL;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_lock(struct dvb_frontend* fe)
+{
+	int ret;
+	struct avl6211_state *state = fe->demodulator_priv;	
+	u8 reg[50];
+	u32 fracN;
+	u32 BW;
+	u32 BF;
+	u32 freq = state->frequency / 1000;
+	u32 LPF = state->tuner_lpf * 100;
+
+	memset(reg, 0, sizeof(reg));
+
+	msleep(50);
+	
+	fracN = (freq + 27/2) / 27;
+	if (fracN > 0xff)
+		fracN = 0xff;
+		
+	reg[0] = (char)(fracN & 0xff);
+	fracN = (freq << 17) / 27;
+	fracN = fracN & 0x1ffff;
+	reg[1] = (char)((fracN >> 9) & 0xff);
+	reg[2] = (char)((fracN >> 1) & 0xff);
+	reg[3] = (char)((fracN << 7) & 0x80) | 0x50;
+
+	BW = (LPF * 135) / 200;
+	if (LPF < 6500)
+		BW = BW + 6000;
+   	BW = BW + 2000;
+	BW = BW*108/100;
+
+	if (BW < 4000)
+		BW = 4000;
+	if ( BW > 40000)
+		BW = 40000;
+	BF = (BW * 127 + 21100/2) / 21100; 
+	
+	dev_dbg(&state->i2c->dev, "BF is %d,BW is %d\n", BF, BW);
+	
+	reg[5] = (u8)BF;
+
+	msleep(5);
+	ret = AV2011_I2C_write(0, reg, 4, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+		
+	ret = AV2011_I2C_write(5, reg+5, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+			
+	reg[37] = 0x06;
+	ret = AV2011_I2C_write(37, reg+37, 1, state);
+	if (ret)
+		goto err;;
+		
+	msleep(5);
+		
+	reg[12] = 0x96 + (1 << 6);
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_tuner_reg_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+    int ret;
+	
+	u8 reg[50] = { 
+		0x38, 0x00, 0x00, 0x50, 0x1f, 0xa3, 0xfd, 0x58, 0x0e,
+		0xc2, 0x88, 0xb4, 0xd6, 0x40, 0x94, 0x9a, 0x66, 0x40,
+		0x80, 0x2b, 0x6a, 0x50, 0x91, 0x27, 0x8f, 0xcc, 0x21,
+		0x10, 0x80, 0x02, 0xf5, 0x7f, 0x4a, 0x9b, 0xe0, 0xe0,
+		0x36, 0x00, 0xab, 0x97, 0xc5, 0xa8,
+	};
+	
+	ret = AV2011_I2C_write(0, reg, 12, state);
+	if (ret)
+		goto err;
+		
+	msleep(1);
+		
+	ret = AV2011_I2C_write(13, reg+13, 12, state);
+	if (ret)
+		goto err;
+		
+	ret = AV2011_I2C_write(25, reg+25, 11, state);
+	if (ret)
+		goto err;
+		
+	ret = AV2011_I2C_write(36, reg+36, 6, state);
+	if (ret)
+		goto err;
+		
+	msleep(1);
+		
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(10);
+	
+	ret = AV2011_I2C_write(0, reg, 12, state);
+	if (ret)
+		goto err;
+			
+	msleep(1);
+					
+	ret = AV2011_I2C_write(13, reg+13 , 12, state);
+	if (ret)
+		goto err;
+			
+	ret = AV2011_I2C_write(25, reg+25 , 11, state);
+	if (ret)
+		goto err;
+			
+	ret = AV2011_I2C_write(36, reg+36, 6, state);
+	if (ret)
+		goto err;
+			
+	msleep(1);
+		
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+	
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_tuner_init(struct dvb_frontend* fe) 
+{
+    struct avl6211_state *state = fe->demodulator_priv;
+    int ret;
+	
+    ret = avl6211_i2c_write16(state, rc_tuner_slave_addr_addr, state->config->tuner_address);
+	if (ret)
+		goto err;
+	/* Use external control */
+	ret = avl6211_i2c_write16(state, rc_tuner_use_internal_control_addr, 0);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_tuner_LPF_margin_100kHz_addr, 0);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_tuner_max_LPF_100kHz_addr, 360 );
+	if (ret)
+		goto err;
+	
+    ret = avl6211_i2c_repeater_init(state->config->tuner_i2c_clock, state);
+	if (ret)
+		goto err;
+
+	ret = av2011_tuner_reg_init(fe);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+    return ret;
+}
+
+static int avl6211_diseqc_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+	
+	ret = avl6211_i2c_write32(state, diseqc_srst_addr, 1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_samp_frac_n_addr, 200);	/* 2M = 200 * 10kHz */
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_samp_frac_d_addr, state->demod_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_tone_frac_n_addr, (22 << 1));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_tone_frac_d_addr, state->demod_freq * 10);
+	if (ret)
+		goto err;
+
+	/* Initialize the tx_control */
+	ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+	if (ret)
+		goto err;
+	x1 &= 0x00000300;
+	x1 |= 0x20;		/* Reset tx_fifo */
+	x1 |= (u32)(0 << 6);
+	x1 |= (u32)(0 << 4);
+	x1 |= (1 << 3);			/* Enable tx gap */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	x1 &= ~(0x20);	/* Release tx_fifo reset */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+
+	/* Initialize the rx_control */
+	x1 = (u32)(0 << 2);
+	x1 |= (1 << 1);	/* Activate the receiver */
+	x1 |= (1 << 3);	/* Envelop high when tone present */
+	ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	x1 = (u32)(0 >> 12);
+	ret = avl6211_i2c_write32(state, diseqc_rx_msg_tim_addr, x1);
+	if (ret)
+		goto err;
+
+	ret = avl6211_i2c_write32(state, diseqc_srst_addr, 0);
+	if (ret)
+		goto err;
+
+	
+	state->diseqc_status = DISEQC_STATUS_INIT;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_switch_mode(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret = 0;
+	u32 x1;
+
+	switch (state->diseqc_status) {
+		case DISEQC_STATUS_MOD:
+		case DISEQC_STATUS_TONE:
+			ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+			if (ret)
+				goto err;
+			if (((x1 & 0x00000040) >> 6) != 1)
+				ret = -EINVAL;
+			break;
+		case DISEQC_STATUS_CONTINUOUS:
+		case DISEQC_STATUS_INIT:
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_get_tx_status(struct dvb_frontend* fe, struct avl6211_diseqc_tx_status * pTxStatus)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+
+	if ((state->diseqc_status == DISEQC_STATUS_MOD) || 
+		(state->diseqc_status == DISEQC_STATUS_TONE)) {
+		ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+		if (ret)
+			goto err;
+			
+		pTxStatus->tx_done = (u8)((x1 & 0x00000040) >> 6);
+		pTxStatus->tx_fifo_cnt = (u8)((x1 & 0x0000003c) >> 2);
+	}
+	else
+		ret = -EINVAL;
+
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_send_mod_data(struct dvb_frontend* fe, const u8 * buf, u8 size)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1, x2;
+	int cnt = 0;
+	u8 buf_tmp[8];
+	u8 Continuousflag = 0;
+
+
+	if (WARN_ON(size > 8))
+		return -EINVAL;		
+	else {
+		ret = avl6211_diseqc_switch_mode(fe);
+		if (ret)
+			goto err;
+		
+		if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			if ((x1 >> 10) & 0x01) {
+				Continuousflag = 1;
+				x1 &= 0xfffff3ff;
+				ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+				if (ret)
+					goto err;
+				msleep(20);
+			}
+		}
+			/* Reset rx_fifo */
+		ret = avl6211_i2c_read32(state, diseqc_rx_cntrl_addr, &x2);
+		if (ret)
+			goto err;
+		ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, (x2 | 0x01));
+		if (ret)
+			goto err;
+		ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, (x2 & 0xfffffffe));
+		if (ret)
+			goto err;
+
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8;	//set to modulation mode and put it to FIFO load mode
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+			
+			/* Trunk address */
+		format_addr(diseqc_tx_fifo_map_addr, buf_tmp);
+		buf_tmp[3] = 0;
+		buf_tmp[4] = 0;
+		buf_tmp[5] = 0;
+		for (x2 = 0; x2 < size; x2++) {
+			buf_tmp[6] = buf[x2];
+			ret = avl6211_i2c_write(state, buf_tmp, 7);
+			if (ret)
+				goto err;
+		}
+
+		x1 |= (1 << 2);  //start fifo transmit.
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		
+		state->diseqc_status = DISEQC_STATUS_MOD;
+		do 
+		{
+			msleep(1);
+			if (++cnt > 500) {
+				ret = -ETIME;
+				goto err;
+			}
+			ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+			if (ret)
+				goto err;
+		} while ( 1 != ((x1 & 0x00000040) >> 6) );
+
+		msleep(20);
+		if (Continuousflag == 1)			//resume to send out wave
+		{
+			//No data in FIFO
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffff8; 
+			x1 |= 0x03;		//switch to continuous mode
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+
+			//start to send out wave
+			x1 |= (1<<10);  
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			
+			state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+		}
+	}
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;;
+}
+
+static int avl6211_send_diseqc_msg(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *d)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct avl6211_diseqc_tx_status tx_status;
+	int cnt = 100;
+	int ret;
+
+	if ((d->msg_len < 3) || (d->msg_len > 6))
+        	return -EINVAL;
+
+	ret = avl6211_diseqc_send_mod_data(fe, d->msg, d->msg_len);
+	if (ret)
+		goto err;
+	
+	msleep(55);		
+		
+	do {
+		ret = avl6211_diseqc_get_tx_status(fe, &tx_status);
+		if (ret)
+			goto err;
+			
+		if ( tx_status.tx_done == 1 )
+			break;
+
+		msleep(10);
+		cnt--;
+		if (!cnt) {
+			ret = -ETIME;
+			goto err;
+		}
+	} while (tx_status.tx_done != 1);
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_diseqc_send_burst(struct dvb_frontend* fe, enum fe_sec_mini_cmd burst)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct avl6211_diseqc_tx_status tx_status;
+	int cnt = 100;
+	int tx_cnt = 0;
+	int ret;
+	u32 x1;
+	u8 buf[8];
+	u8 Continuousflag = 0;
+	
+	ret = avl6211_diseqc_switch_mode(fe);
+	if (ret)
+		goto err;
+
+	if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		if ((x1 >> 10) & 0x01) {
+			Continuousflag = 1;
+			x1 &= 0xfffff3ff;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+		}
+	}
+	/* No data in the FIFO */
+	ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+	if (ret)
+		goto err;
+	x1 &= 0xfffffff8;  /* Put it into the FIFO load mode */
+	if (burst == SEC_MINI_A)
+		x1 |= 0x02;
+	else
+		x1 |= 0x01;
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	/* Trunk address */
+	format_addr(diseqc_tx_fifo_map_addr, buf);
+	buf[3] = 0;
+	buf[4] = 0;
+	buf[5] = 0;
+	buf[6] = 1;
+
+	ret = avl6211_i2c_write(state, buf, 7);
+	if (ret)
+		goto err;
+
+	x1 |= (1<<2);  /* Start fifo transmit */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	
+	state->diseqc_status = DISEQC_STATUS_TONE;
+	
+	do 
+	{
+		msleep(1);
+		if (++tx_cnt > 500) {
+			ret = -ETIME;
+			goto err;
+		}
+		ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+		if (ret)
+			goto err;
+	} while ( 1 != ((x1 & 0x00000040) >> 6) );
+
+	msleep(20);
+	
+	if (Continuousflag == 1)			//resume to send out wave
+	{
+		//No data in FIFO
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8; 
+		x1 |= 0x03;		//switch to continuous mode
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+
+		//start to send out wave
+		x1 |= (1<<10);  
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		
+		state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+			
+	}	
+	do {
+		ret = avl6211_diseqc_get_tx_status(fe, &tx_status);
+		if ( tx_status.tx_done == 1 )
+			break;
+
+		msleep(10);
+		cnt--;
+		if (!cnt) {
+			ret = -ETIME;
+			goto err;
+		}
+	} while (tx_status.tx_done != 1);
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_set_tone(struct dvb_frontend* fe, enum fe_sec_tone_mode tone)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+
+	if (tone == SEC_TONE_ON) {
+		
+		ret = avl6211_diseqc_switch_mode(fe);
+		if (ret)
+			goto err;
+
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8;
+		x1 |= 0x03;	
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		x1 |= (1 << 10);
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+			
+		state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+	} else {
+	
+		if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffff3ff;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+		}
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_set_voltage(struct dvb_frontend *fe,
+	enum fe_sec_voltage voltage)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+	
+	if (voltage == SEC_VOLTAGE_OFF) {
+	
+		if (state->config->set_external_vol_gpio)
+			state->config->set_external_vol_gpio(&state->demod_id, 0);
+		
+		state->gpio_on = false;
+		
+		return 0;
+	}
+	if (voltage == SEC_VOLTAGE_13) {
+		if (state->config->use_lnb_pin59) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffdff;		
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);	//delay 20ms
+		}
+		
+		if (state->config->use_lnb_pin60) {
+					
+			ret = avl6211_i2c_read32(state, gpio_reg_enb, &x1);
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1);
+			ret = avl6211_i2c_write32(state, gpio_reg_enb, x1);  
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, gpio_data_reg_out, &x1);	
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1) ;			
+			ret = avl6211_i2c_write32(state, gpio_data_reg_out, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+
+		}						
+	} else if (voltage == SEC_VOLTAGE_18) {
+	
+		if (state->config->use_lnb_pin59) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffdff;
+			x1 |= 0x200;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);	//delay 20ms
+		}
+		if (state->config->use_lnb_pin60) {
+			ret = avl6211_i2c_read32(state, gpio_reg_enb, &x1);
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1);
+			ret = avl6211_i2c_write32(state, gpio_reg_enb, x1);  
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, gpio_data_reg_out, &x1);	
+			if (ret)
+				goto err;
+			x1 |= 1<<1 ;			
+			ret = avl6211_i2c_write32(state, gpio_data_reg_out, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+		}		
+	}
+	
+	if (!state->gpio_on) {	
+		state->gpio_on = true;		
+		if (state->config->set_external_vol_gpio) 
+			state->config->set_external_vol_gpio(&state->demod_id, 1);
+	}
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_ber(struct dvb_frontend* fe, u32* ber)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 r_ber;
+
+	*ber = 0;
+	
+	if (state->locked == 1) {		
+		ret = avl6211_i2c_read32(state, rp_uint_BER_addr, &r_ber);
+		if (ret)
+			goto err;
+			
+		if (r_ber > 0)			
+			*ber = r_ber / 1000000000;			
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+u8 DVBS_SNR[6] = { 12, 32, 41, 52, 58, 62 };
+u8 DVBS2Qpsk_SNR[8] = { 10, 24, 32, 41, 47, 52, 63, 65 };
+u8 DVBS28psk_SNR[6] = { 57, 67, 80, 95, 100, 110 };
+static int avl6211_read_snr(struct dvb_frontend* fe, u16 *snr)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u8 SNRrefer = 0;
+	u32 r_snr, code_rate, modulation;
+
+	*snr = 0;
+	
+	if (state->locked == 1) {
+		ret = avl6211_i2c_read32(state, rs_int_SNR_dB_addr, &r_snr);
+		if (ret)
+			goto err;
+		if (r_snr < 10000) {
+			ret = avl6211_i2c_read32(state, rs_code_rate_addr, &code_rate);
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, rs_modulation_addr, &modulation);
+			if (ret)
+				goto err;
+				
+			if (code_rate < 6)
+				SNRrefer = DVBS_SNR[code_rate];			
+			else {
+				if (modulation == 1)
+					SNRrefer = DVBS28psk_SNR[code_rate - 10];
+				else	
+					SNRrefer = DVBS2Qpsk_SNR[code_rate - 9];
+			}	
+			if ((r_snr / 10) > SNRrefer) {
+				r_snr = r_snr/10 - SNRrefer;
+				if (r_snr >= 100)
+					*snr = 99;
+				else if (r_snr >= 50)  //  >5.0dB
+					*snr = 80+ (r_snr - 50)*20/50;
+				else if (r_snr >= 25)  //  > 2.5dB
+					*snr = 50+ (r_snr - 25)*30/25;
+				else if (r_snr >= 10)  //  > 1dB
+					*snr = 25+ (r_snr - 10)*25/15;			
+				else 
+					*snr = 5 + (r_snr)*20/10;
+					
+					*snr = (*snr * 65535) / 100;
+			}
+		}
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+struct Signal_Level
+{
+	u16 SignalLevel;
+	short SignalDBM;
+};
+struct Signal_Level  AGC_LUT [91]=
+{
+    {63688,  0},{62626, -1},{61840, -2},{61175, -3},{60626, -4},{60120, -5},{59647, -6},{59187, -7},{58741, -8},{58293, -9},
+    {57822,-10},{57387,-11},{56913,-12},{56491,-13},{55755,-14},{55266,-15},{54765,-16},{54221,-17},{53710,-18},{53244,-19},
+    {52625,-20},{52043,-21},{51468,-22},{50904,-23},{50331,-24},{49772,-25},{49260,-26},{48730,-27},{48285,-28},{47804,-29},
+    {47333,-30},{46880,-31},{46460,-32},{46000,-33},{45539,-34},{45066,-35},{44621,-36},{44107,-37},{43611,-38},{43082,-39},
+    {42512,-40},{41947,-41},{41284,-42},{40531,-43},{39813,-44},{38978,-45},{38153,-46},{37294,-47},{36498,-48},{35714,-49},
+    {35010,-50},{34432,-51},{33814,-52},{33315,-53},{32989,-54},{32504,-55},{32039,-56},{31608,-57},{31141,-58},{30675,-59},
+    {30215,-60},{29711,-61},{29218,-62},{28688,-63},{28183,-64},{27593,-65},{26978,-66},{26344,-67},{25680,-68},{24988,-69},
+    {24121,-70},{23285,-71},{22460,-72},{21496,-73},{20495,-74},{19320,-75},{18132,-76},{16926,-77},{15564,-78},{14398,-79},
+    {12875,-80},{11913,-81},{10514,-82},{ 9070,-83},{ 7588,-84},{ 6044,-85},{ 4613,-86},{ 3177,-87},{ 1614,-88},{  123,-89},
+    {    0,-90}
+};
+static int avl6211_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)
+{
+	#define Level_High_Stage	36
+	#define Level_Low_Stage		76
+
+	#define Percent_Space_High	10
+	#define Percent_Space_Mid	30
+	#define Percent_Space_Low	60
+	
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 rf;
+	u16 Level;
+	int i = 0;
+	int Percent = 0;
+	*signal_strength = 0;
+		
+	if (state->locked == 1) {
+		ret = avl6211_i2c_read32(state, rx_aagc_gain, &rf);
+		if (ret)
+			goto err;
+		
+		rf += 0x800000;
+		rf &= 0xffffff;	
+		Level = (u16)(rf >> 8);
+
+	while( Level < AGC_LUT[i++].SignalLevel);
+	
+	if (i <= Level_High_Stage)
+		Percent = Percent_Space_Low+Percent_Space_Mid+ (Level_High_Stage-i)*Percent_Space_High/Level_High_Stage;
+	else if(i<=Level_Low_Stage)
+		Percent = Percent_Space_Low+ (Level_Low_Stage-i)*Percent_Space_Mid/(Level_Low_Stage-Level_High_Stage);
+	else
+		Percent =(90-i)*Percent_Space_Low/(90-Level_Low_Stage);
+
+	*signal_strength = (Percent * 65535) / 100;	
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_status(struct dvb_frontend* fe, enum fe_status* status)
+{
+	struct avl6211_state *state = fe->demodulator_priv;	
+	int ret;
+	*status = 0;
+	
+	ret = avl6211_i2c_read16(state, rs_fec_lock_addr, &state->locked);
+	if (ret)
+		goto err;
+
+	if (state->locked == 1) 
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | 
+				FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+static int avl6211_get_frontend(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 code_rate;
+	u16 ret;
+		
+	if (!state->locked)
+		return 0;
+	
+	ret = avl6211_i2c_read32(state, rs_code_rate_addr, &code_rate);
+	if (ret)
+		goto err;
+		
+	p->frequency = state->frequency;
+	p->inversion = INVERSION_AUTO;
+	p->symbol_rate = state->symbol_rate;
+	
+	switch (code_rate) { 
+		case 0:
+		p->fec_inner = FEC_1_2;
+		break;
+		case 1:
+		p->fec_inner = FEC_2_3;
+		break;
+		case 2:
+		p->fec_inner = FEC_3_4;
+		break;
+		case 13:
+		p->fec_inner = FEC_4_5;
+		break;
+		case 14:
+		p->fec_inner = FEC_5_6;
+		break;
+		case 4:
+		p->fec_inner = FEC_6_7;
+		break;
+		case 5:
+		p->fec_inner = FEC_7_8;
+		break;
+		case 15:
+		p->fec_inner = FEC_8_9;
+		break;
+		case 10:
+		p->fec_inner = FEC_3_5;
+		break;
+		case 16:
+		p->fec_inner = FEC_9_10;
+		break;
+		default:
+		p->fec_inner = FEC_AUTO;
+		break;
+	}
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_channel_lock(struct dvb_frontend* fe)
+{
+    struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 IQ;
+	u32 autoIQ_Detect;
+	u16 Standard;
+	u16 auto_manual_lock;
+	int cnt = 0;
+
+	ret = avl6211_i2c_write16(state, rc_lock_mode_addr, 0);	
+	if (ret)
+		goto err;
+		
+	IQ = ((state->flags) & CI_FLAG_IQ_BIT_MASK) >> CI_FLAG_IQ_BIT;
+	ret = avl6211_i2c_write32(state, rc_specinv_addr, IQ);
+	if (ret)
+		goto err;
+	
+	Standard = (u16)(((state->flags) & CI_FLAG_DVBS2_BIT_MASK) >> CI_FLAG_DVBS2_BIT);
+	autoIQ_Detect = (((state->flags) & CI_FLAG_IQ_AUTO_BIT_MASK) >> CI_FLAG_IQ_AUTO_BIT);
+	auto_manual_lock = (u16)(((state->flags) & CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK) >> CI_FLAG_MANUAL_LOCK_MODE_BIT);
+
+	
+	if((Standard == CI_FLAG_DVBS2_UNDEF) || (autoIQ_Detect == 1))
+		Standard = 0x14;
+
+	if (state->symbol_rate == 0)
+		state->symbol_rate = 1;
+	
+	ret = avl6211_i2c_write16(state, rc_fec_bypass_coderate_addr, auto_manual_lock);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_decode_mode_addr, Standard);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_iq_mode_addr, (u16)autoIQ_Detect);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_int_sym_rate_MHz_addr, state->symbol_rate);
+	if (ret)
+		goto err;
+	
+	
+	ret = avl6211_send_op(OP_RX_INIT_GO, state);
+	if (ret)
+		goto err;
+		
+	do {
+		ret = avl6211_get_op_status(state);
+		if(!ret)
+			break;
+		msleep(1);
+	} while(cnt++ < 200);
+	
+	if (ret)
+		goto err;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_set_frontend(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	u16 cnt;
+	u32 max_time;
+	
+	
+	state->frequency = c->frequency;
+	state->symbol_rate = c->symbol_rate;
+	
+	state->locked = 0;
+
+	dev_dbg(&state->i2c->dev, 
+		"%s: delivery_system=%d frequency=%d symbol_rate=%d\n", 
+		__func__, c->delivery_system, c->frequency, c->symbol_rate);
+
+	state->tuner_lpf = (state->symbol_rate / 100000);
+	if (state->tuner_lpf > 440)
+		state->tuner_lpf = 440;
+
+	ret = av2011_lock(fe);
+	if (ret)
+		goto err;
+
+	/* Wait for tuner locking */
+	max_time = 150;  /* Max waiting time: 150ms */
+
+	cnt = max_time / 10;
+	do {	
+		ret = av2011_tuner_lock_status(fe);		
+
+		if (!ret)
+			break;
+		else {		
+			msleep(10);    /* Wait 10ms for demod to lock the channel */			
+			continue;
+		}		
+		
+	} while (--cnt);
+
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	dev_dbg(&state->i2c->dev, "Tuner successfully lock!\n");
+
+	state->flags = (CI_FLAG_IQ_NO_SWAPPED) << CI_FLAG_IQ_BIT;			//Normal IQ
+	state->flags |= (CI_FLAG_IQ_AUTO_BIT_AUTO) << CI_FLAG_IQ_AUTO_BIT;	//Enable automatic IQ swap detection
+	state->flags |= (CI_FLAG_DVBS2_UNDEF) << CI_FLAG_DVBS2_BIT;			//Enable automatic standard detection
+
+	//This function should be called after tuner locked to lock the channel.
+	ret = avl6211_channel_lock(fe);
+	if (ret)
+		goto err;
+		
+	/* Wait a bit more when we have slow symbol rates */
+	if (c->symbol_rate < 5000000)
+		max_time = 5000*2; /* Max waiting time: 1000ms */
+	else if (c->symbol_rate < 10000000)
+		max_time = 600*2;  /* Max waiting time: 600ms */
+	else
+		max_time = 250*2;  /* Max waiting time: 250ms */
+
+	cnt = max_time / 10;
+	do {
+		ret = avl6211_i2c_read16(state, rs_fec_lock_addr, &state->locked);
+
+		if (!ret && state->locked == 1)
+				break;
+
+		msleep(10);    /* Wait 10ms for demod to lock the channel */		
+	} while (--cnt);
+	
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	dev_dbg(&state->i2c->dev, "Service locked!!!\n");
+
+	ret = avl6211_send_op(OP_RX_RESET_BERPER, state);
+	if (ret)
+		goto err;
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+
+static int avl6211_get_demod_status(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u8	buf[2]; 
+	u32 x1 = 0;
+	
+	ret = avl6211_i2c_read32(state, core_reset_b_reg, &x1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_read16(state, core_ready_word_addr, (u16 *)buf);	
+	if (ret)
+		goto err;
+	
+	if ((x1 == 0) || (buf[0] != 0x5a) || (buf[1] != 0xa5)) {
+		ret = -EINVAL;
+		goto err;
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_setup_pll(struct avl6211_state* state, const struct avl6211_pllconf * pll_ptr)
+{
+	int ret;
+	
+	ret = avl6211_i2c_write32(state, pll_clkf_map_addr, pll_ptr->m_uiClkf);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_bwadj_map_addr, pll_ptr->m_uiClkf);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_clkr_map_addr, pll_ptr->m_uiClkr);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od_map_addr, pll_ptr->m_uiPllod);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od2_map_addr, pll_ptr->m_uiPllod2);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od3_map_addr, pll_ptr->m_uiPllod3);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_softvalue_en_map_addr, 1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, reset_register_addr, 0);
+	if (ret)
+		goto err;
+	
+	/* Reset do not check for error */
+	avl6211_i2c_write32(state, reset_register_addr, 1);
+	
+	state->demod_freq = pll_ptr->demod_freq;
+	state->fec_freq = pll_ptr->fec_freq;
+	state->mpeg_freq = pll_ptr->mpeg_freq;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_load_firmware(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	const struct firmware *fw = NULL;
+	u8 *buffer = NULL;
+	u32 buf_size, data_size;
+	u32 i = 4;
+	int ret;
+	
+	ret = avl6211_i2c_write32(state, core_reset_b_reg, 0);
+	if (ret)
+		goto err;
+
+	dev_dbg(&state->i2c->dev, "Uploading demod firmware (%s)...\n", AVL6211_DEMOD_FW);
+	ret = request_firmware(&fw, AVL6211_DEMOD_FW, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Firmware upload failed. Timeout or file not found\n");
+		goto err;
+	}    
+
+	buffer = kmalloc(fw->size , GFP_KERNEL);
+	if (!buffer) {
+		release_firmware(fw);
+		fw = NULL;
+		dev_dbg(&state->i2c->dev, "Failed to allocate tmp memory for firmware\n");
+		return -ENOMEM;
+	}
+	memcpy(buffer, fw->data, fw->size);
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	data_size = extract_32(buffer);
+	while (i < data_size)
+	{
+		buf_size = extract_32(buffer + i);
+		i += 4;
+		ret = avl6211_i2c_write(state, buffer + i + 1, (u16)(buf_size + 3));
+		if (ret)
+			goto err;
+			
+		i += 4 + buf_size;
+	}
+	
+	ret = avl6211_i2c_write32(state, 0x00000000, 0x00003ffc);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write16(state, core_ready_word_addr, 0x0000);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write32(state, error_msg_addr, 0x00000000);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write32(state, error_msg_addr + 4, 0x00000000);
+	if (ret)
+			goto err;
+
+	/* Reset do not check for error */
+	avl6211_i2c_write32(state, core_reset_b_reg, 1);
+	
+	kfree(buffer);
+	return 0;
+	
+err:
+	kfree(buffer);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	int ret;
+
+	if (state->boot)
+		return 0;
+		
+	ret = avl6211_setup_pll(state, (const struct avl6211_pllconf * )(pll_conf + state->config->demod_refclk));
+	if (ret)
+		goto err;
+		
+	msleep(100);
+	
+	ret = avl6211_load_firmware(fe);
+	if (ret)
+		goto err;
+		
+	msleep(100);
+	
+	ret = avl6211_get_demod_status(fe);
+	if (ret)
+		goto err;
+	
+	
+	ret = avl6211_i2c_write32(state, 0x263E, 50000);
+	if (ret)
+		goto err;
+	/* Set clk to match the PLL */
+	ret = avl6211_i2c_write16(state, rc_int_dmd_clk_MHz_addr,  state->demod_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_int_fec_clk_MHz_addr, state->fec_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_int_mpeg_clk_MHz_addr, state->mpeg_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_format_addr, 1);
+	if (ret)
+		goto err;
+	
+	/* Set AGC polarization */
+	ret = avl6211_i2c_write32(state, rc_rfagc_pol_addr, (u32)state->config->tuner_rfagc);
+	if (ret)
+		goto err;	
+	/* Drive RF AGC */
+	ret = avl6211_i2c_write16(state, rc_aagc_ref_addr, 0x30);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_rfagc_tri_enb, 1);
+	if (ret)
+		goto err;
+
+	ret = avl6211_i2c_write16(state, rc_blind_scan_tuner_spectrum_inversion_addr, (u16)state->config->tuner_spectrum);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state, rc_mpeg_mode_addr, (u32)(state->config->mpeg_format));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_mpeg_serial_addr, (u16)(state->config->mpeg_mode));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_mpeg_posedge_addr, (u16)(state->config->mpeg_pol));
+	if (ret)
+		goto err;
+	
+	if (state->config->mpeg_mode) {
+		ret = avl6211_i2c_write32(state, rc_outpin_sel_addr, (u32)(state->config->mpeg_pin));		
+		if (ret)
+			goto err;
+	}
+	
+	ret = avl6211_i2c_write32(state, rc_mpeg_bus_tri_enb, 1);
+	if (ret)
+		goto err;
+	
+	ret = av2011_tuner_init(fe);
+	if (ret)
+		goto err;
+	ret = avl6211_diseqc_init(fe);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state,  gpio_data_reg_out, 0);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state, gpio_reg_enb, 0);
+	if (ret)
+		goto err;
+	
+	state->boot = true;
+	
+	dev_dbg(&state->i2c->dev, "AVL6211+AV2011 init OK\n");
+	
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static void avl6211_release(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static struct dvb_frontend_ops avl6211_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 }, 
+	.info = {
+		.name = "Availink AVL6211+AV2011 DVB-S/S2",	
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+		.frequency_stepsize = 0,		
+		.frequency_tolerance = 0,
+		.symbol_rate_min = 800000,		/* Min = 800K */
+		.symbol_rate_max = 50000000,	/* Max = 50M */
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK    | FE_CAN_RECOVER | FE_CAN_2G_MODULATION			
+	},
+
+	.init = avl6211_init,
+	.release = avl6211_release,
+	.read_status = avl6211_read_status,
+	.read_ber = avl6211_read_ber,
+	.read_signal_strength = avl6211_read_signal_strength,
+	.read_snr = avl6211_read_snr,
+	.read_ucblocks = avl6211_read_ucblocks,
+	.set_tone = avl6211_set_tone,	
+	.set_voltage = avl6211_set_voltage,
+	.diseqc_send_master_cmd = avl6211_send_diseqc_msg,
+	.diseqc_send_burst = avl6211_diseqc_send_burst,
+	.set_frontend = avl6211_set_frontend,
+	.get_frontend = avl6211_get_frontend,
+};
+
+struct dvb_frontend* avl6211_attach(struct i2c_adapter* i2c,
+									struct avl6211_config* config,
+									int id)
+									
+{
+	struct avl6211_state* state = NULL;
+	int ret;
+	u32 ChipID = 0;
+	
+	state = kzalloc(sizeof(struct avl6211_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+
+	state->config = config;
+	state->i2c = i2c;	
+	state->demod_id = id;
+	
+	ret = avl6211_i2c_read32(state, rs_cust_chip_id_addr, &ChipID);
+	if (ret || ChipID != 0x0000000F)
+		goto err2;
+
+	dev_info(&i2c->dev, "AVL6211+AV2011 DVB-S/S2 successfully attached\n");	
+	
+	memcpy(&state->frontend.ops, &avl6211_ops, sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+
+	return &state->frontend;
+	
+err2:	
+	kfree(state);
+err1:	
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);	
+	return NULL;
+}
+
+EXPORT_SYMBOL(avl6211_attach);
+
+MODULE_DESCRIPTION("Availink AVL6211+AV2011 demod+tuner driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/avl6211.h b/drivers/amlogic/wetek/avl6211.h
new file mode 100644
index 0000000..6a7d633
--- /dev/null
+++ b/drivers/amlogic/wetek/avl6211.h
@@ -0,0 +1,156 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __AVL6211_H_
+#define __AVL6211_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+
+#define AVL6211_DEMOD_FW 		"dvb-fe-avl6211.fw" 
+
+#define I2C_MAX_READ	64
+#define I2C_MAX_WRITE	64
+
+
+#define CI_FLAG_IQ_BIT							0x00000000
+#define CI_FLAG_IQ_BIT_MASK						0x00000001
+#define CI_FLAG_IQ_NO_SWAPPED					0x00000000
+#define CI_FLAG_IQ_SWAPPED						0x00000001
+#define CI_FLAG_IQ_AUTO_BIT_MASK				0x00000020  
+
+
+#define CI_FLAG_IQ_AUTO_BIT						0x00000005
+#define CI_FLAG_IQ_AUTO_BIT_AUTO				0x00000001
+
+#define CI_FLAG_DVBS2_BIT						0x00000002
+#define CI_FLAG_DVBS2_UNDEF						0x00000004
+#define CI_FLAG_DVBS2_BIT_MASK					0x0000001c
+
+#define CI_FLAG_MANUAL_LOCK_MODE_BIT			0x00000001
+#define CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK		0x00000002
+#define CI_FLAG_LOCK_MODE_BIT_MASK				0x00000040
+
+
+#define ENABLE_FAST_REACQ           0x01
+#define DISABLE_FAST_REACQ          0x00
+#define ENABLE_CCI                  0x03
+#define DISABLE_CCI                 0x02
+#define MAX_LOWIF_SR                5000000
+#define IF_OFFSET                   500
+
+
+/* Demod commands */
+#define OP_RX_NOOP                  0x00
+#define OP_RX_LD_DEFAULT            0x01
+#define OP_RX_INIT_GO               0x02
+#define OP_RX_RESET_BERPER          0x03
+#define OP_RX_HALT                  0x04
+#define OP_RX_SLEEP                 0x05
+#define OP_RX_WAKE                  0x06
+#define OP_RX_BLIND_SCAN            0x08
+#define OP_RX_STDOUT_MODE           0x09
+	
+/* Diseqc status */
+#define DISEQC_STATUS_UNINIT				0x00
+#define DISEQC_STATUS_INIT					0x01
+#define DISEQC_STATUS_CONTINUOUS			0x02
+#define DISEQC_STATUS_TONE					0x03
+#define DISEQC_STATUS_MOD					0x04
+
+#define I2CM_CMD_LENGTH   0x14
+#define I2CM_RSP_LENGTH   0x14
+
+#define OP_I2CM_NOOP      0x00
+#define OP_I2CM_INIT	  0x01
+#define OP_I2CM_WRITE     0x02
+#define OP_I2CM_READ      0x03
+
+	
+
+#define format_addr(X, Y)		\
+	do {						\
+		Y[0] =(u8)((X) >> 16);	\
+		Y[1] =(u8)((X) >> 8);	\
+		Y[2] =(u8)(X);			\
+	} while (0)
+
+
+#define format_16(X, Y)			\
+	do {						\
+		Y[0] =(u8)((X) >> 8);	\
+		Y[1] =(u8)((X) & 0xFF);	\
+	} while (0)
+
+
+#define format_32(X, Y)			\
+	do {						\
+		Y[0] =(u8)((X) >> 24);	\
+		Y[1] =(u8)((X) >> 16);	\
+		Y[2] =(u8)((X) >> 8);	\
+		Y[3] =(u8)((X) & 0xFF);	\
+	} while (0)
+
+
+struct avl6211_pllconf
+{
+	u16 m_uiClkf; /* Feedback clock divider */
+	u16 m_uiClkr; /* Reference clock divider */
+	u16 m_uiPllod; /* PLL output divider */
+	u16 m_uiPllod2; /* PLL output divider 2 */
+	u16 m_uiPllod3; /* PLL output divider 3 */
+	u16 ref_freq; /* Reference clock in kHz */
+	u16 demod_freq; /* Demod clock in 10kHz */
+	u16 fec_freq; /* FEC clock in 10kHz */
+	u16 mpeg_freq; /* MPEG clock in 10kHz */
+};
+
+struct avl6211_config
+{
+	u8 tuner_address; /* Tuner i2c address */
+	u16 tuner_i2c_clock;	
+	u8 demod_address;	/* The demodulator's i2c address  0x0C */ 
+				
+	u8 mpeg_pol; /* 0 - Falling, 1 - Rising */
+	u8 mpeg_mode; /* 0 - Parallel, 1 - Serial */
+	u8 mpeg_format; /* 0 - Default TS stream, 1 - TS stream plus parity format */
+	
+	u8 demod_refclk; /* Reference clock frequency selection */
+
+	/* Serial data is output on pin */
+	u8 mpeg_pin; /* 0 -  MPEG_DATA_0, 1 - MPEG_DATA_7 */
+	
+	u8 tuner_rfagc; /* 0 - Normal pol, 1 - Inverted pol */
+	u8 tuner_spectrum; /* 0 - signal spectrum normal, 1 - signal spectrum inverted */
+	
+	u8 use_lnb_pin59; /* control 13/18V over demod GPIO pin59 */
+	u8 use_lnb_pin60; /* control 13/18V over demod GPIO pin60 */
+
+	int (*set_external_vol_gpio)(int *demod_id, int on); /* external 13/18V control */
+};
+
+
+
+extern struct dvb_frontend* avl6211_attach(struct i2c_adapter* i2c,
+											struct avl6211_config* config,
+											int id);
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/wetek/avl6211_reg.h b/drivers/amlogic/wetek/avl6211_reg.h
new file mode 100644
index 0000000..76e865f
--- /dev/null
+++ b/drivers/amlogic/wetek/avl6211_reg.h
@@ -0,0 +1,101 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __AVL6211_REG_H_
+#define __AVL6211_REG_H_
+
+
+#define core_reset_b_reg            				0x600000
+#define gpio_data_in_to_reg         				0x6C0004
+#define gpio_data_reg_out           				0x6C0008
+#define gpio_reg_enb                				0x6C000C
+
+#define pll_clkr_map_addr           				0x6C40C0
+#define pll_clkf_map_addr          					0x6C4100
+#define pll_od_map_addr             				0x6C4080
+#define pll_od2_map_addr            				0x6C4140
+#define pll_od3_map_addr            				0x6C4180
+#define pll_bwadj_map_addr          				0x6C41C0
+#define pll_softvalue_en_map_addr   				0x6C4200
+#define reset_register_addr         				0x6C4000
+
+	
+#define rx_aagc_gain                                0x0040004C
+#define rc_rfagc_tri_enb                            0x006C002C
+#define rc_mpeg_bus_tri_enb                         0x006C0028
+
+
+#define raptor_status_addr						   (0x00000860 + 0x0)
+#define rx_state_addr                              (0x00000690 + 0x0)
+#define rx_cmd_addr                                (0x00000400 + 0x0)
+#define i2cm_cmd_addr                              (0x00000404 + 0x0)
+#define i2cm_rsp_addr                              (0x00000418 + 0x0)
+#define error_msg_addr                             (0x0000042c + 0x0)
+#define rx_config_addr                             (0x0000043c + 0x0)
+#define core_ready_word_addr                       (0x00000434 + 0x0)
+
+#define rs_cust_chip_id_addr                        0x006C0034
+
+#define	rp_uint_BER_addr                           (raptor_status_addr + 0x0)
+#define	rc_rfagc_pol_addr                          (rx_config_addr + 0x0)
+#define	rc_equalizer_addr                          (rx_config_addr + 0x8)
+#define	rs_code_rate_addr                          (rx_state_addr + 0x8)
+#define	rs_modulation_addr                         (rx_state_addr + 0xc)
+#define	rc_format_addr                             (rx_config_addr + 0x10)
+#define	rc_mpeg_mode_addr                          (rx_config_addr + 0x20)
+#define	rc_outpin_sel_addr                         (rx_config_addr + 0x24)
+#define	rs_int_SNR_dB_addr                         (rx_state_addr + 0x40)
+#define	rc_aagc_ref_addr                           (rx_config_addr + 0xaa)
+#define	rc_mpeg_posedge_addr                       (rx_config_addr + 0xbc)
+#define	rc_mpeg_serial_addr                        (rx_config_addr + 0xbe)
+#define	rs_fec_lock_addr                           (rx_state_addr + 0x164)
+#define	rc_specinv_addr                            (rx_config_addr + 0x34)
+#define	rc_int_sym_rate_MHz_addr                   (rx_config_addr + 0x54)
+#define	rc_dvbs_ber_addr                           (rx_config_addr + 0x98)
+#define	rc_int_dmd_clk_MHz_addr                    (rx_config_addr + 0x162)
+#define	rc_int_fec_clk_MHz_addr                    (rx_config_addr + 0x164)
+#define	rc_int_mpeg_clk_MHz_addr                   (rx_config_addr + 0x166)
+#define	rc_int_carrier_freq_half_range_MHz_addr    (rx_config_addr + 0x16c)
+#define	rc_fec_bypass_coderate_addr                (rx_config_addr + 0x194)
+#define	rc_i2cm_speed_kHz_addr                     (rx_config_addr + 0x1ae)
+#define	rc_tuner_slave_addr_addr                   (rx_config_addr + 0x1b6)
+#define	rc_tuner_max_LPF_100kHz_addr               (rx_config_addr + 0x1b8)
+#define	rc_tuner_LPF_margin_100kHz_addr            (rx_config_addr + 0x1ba)
+#define	rc_tuner_use_internal_control_addr         (rx_config_addr + 0x1bc)
+
+#define	rc_decode_mode_addr                        (rx_config_addr + 0x202)
+#define	rc_iq_mode_addr                            (rx_config_addr + 0x204)
+#define	rc_lock_mode_addr                          (rx_config_addr + 0x20a)
+#define	rc_blind_scan_tuner_spectrum_inversion_addr (rx_config_addr + 0x220)
+
+
+
+#define diseqc_tx_cntrl_addr						0x00700000
+#define diseqc_tone_frac_n_addr						0x00700004
+#define diseqc_tone_frac_d_addr						0x00700008
+#define diseqc_tx_st_addr							0x0070000c
+#define diseqc_rx_msg_tim_addr						0x00700014
+#define diseqc_rx_cntrl_addr						0x0070001c
+#define diseqc_srst_addr							0x00700020
+#define diseqc_samp_frac_n_addr						0x00700028
+#define diseqc_samp_frac_d_addr						0x0070002c
+#define diseqc_tx_fifo_map_addr						0x00700080
+
+#endif
diff --git a/drivers/amlogic/wetek/cxd2837.c b/drivers/amlogic/wetek/cxd2837.c
new file mode 100644
index 0000000..44193a7
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2837.c
@@ -0,0 +1,1790 @@
+/*
+ * Sony CXD2837 DVB-T/T2/C demodulator driver
+ *
+ * Copyright (C) 2010-2013 Digital Devices GmbH
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <asm/div64.h>
+#include "dvb_math.h"
+#include "dvb_frontend.h"
+#include "cxd2837.h"
+
+
+struct ts_clk {
+	u8 serialClkMode;      
+	u8 serialDutyMode;
+	u8 tsClkPeriod; 
+	u8 clkSelTsIf;
+};
+
+struct cxd_state {
+	struct dvb_frontend   frontend;
+	struct i2c_adapter   *i2c;
+	struct mutex          mutex;
+
+	u8  adrt;
+	u8  curbankt;
+
+	u8  adrx;
+	u8  curbankx;
+	
+	enum fe_delivery_system delivery_system;
+	u32 freq;
+	
+	enum EDemodState state;	
+	enum xtal_freq xtal;
+
+	u8	IF_AGC;
+	u8    IF_FS;
+	int   ContinuousClock;
+	int   SerialMode;
+	u8    SerialClockFrequency;
+	u8	ErrorPolarity;
+	u8	ClockPolarity;
+	u8	RfainMon;
+	u32   LockTimeout;
+	u32   TSLockTimeout;
+	u32   L1PostTimeout;
+	u32   DataSliceID;
+	int   FirstTimeLock;
+	u32   plp;
+	u32   last_status;
+
+	u32   bandwidth;
+	u32   bw;
+
+	unsigned long tune_time;
+
+	u32   LastBERNominator;
+	u32   LastBERDenominator;
+	u8    BERScaleMax;
+};
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+					.addr = adr, 
+					.flags = 0,
+					.buf = data,
+					.len = len,
+			}
+	};
+
+	ret = i2c_transfer(adap, msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+			dev_warn(&adap->dev, "i2c wr failed=%d reg=%02x "
+							, ret, data[0]);
+			ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+
+static int writeregs(struct cxd_state *state, u8 adr, u8 reg,
+		     u8 *regd, u16 len)
+{
+	u8 data[len + 1];
+
+	data[0] = reg;
+	memcpy(data + 1, regd, len);
+	return i2c_write(state->i2c, adr, data, len + 1);
+}
+
+static int writereg(struct cxd_state *state, u8 adr, u8 reg, u8 dat)
+{
+	u8 mm[2] = {reg, dat};
+
+	return i2c_write(state->i2c, adr, mm, 2);
+}
+
+static int i2c_read(struct i2c_adapter *adap,
+		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
+{
+	int ret;
+	struct i2c_msg msgs[2] = { 
+			{ 
+					.addr = adr, 
+					.flags = 0,
+				    .buf = msg,
+					.len = len
+			}, { 
+					.addr = adr,
+					.flags = I2C_M_RD,					
+				    .buf = answ, 
+					.len = alen, 
+			} 
+	};
+	ret = i2c_transfer(adap, msgs, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+			dev_warn(&adap->dev, "i2c rd failed=%d reg=%02x "
+							, ret, *msg);
+			ret = -EREMOTEIO;
+	}
+	return ret;
+}
+
+static int readregs(struct cxd_state *state, u8 adr, u8 reg,
+		    u8 *val, int count)
+{
+	return i2c_read(state->i2c, adr, &reg, 1, val, count);
+}
+
+static int readregst_unlocked(struct cxd_state *cxd, u8 bank,
+			      u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (bank != 0xFF && cxd->curbankt != bank) {
+		status = writereg(cxd, cxd->adrt, 0, bank);
+		if (status < 0) {
+			cxd->curbankt = 0xFF;
+			return status;
+		}
+		cxd->curbankt = bank;
+	}
+	status = readregs(cxd, cxd->adrt, Address, pValue, count);
+	return status;
+}
+
+static int readregst(struct cxd_state *cxd, u8 Bank,
+		     u8 Address, u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = readregst_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int readregsx_unlocked(struct cxd_state *cxd, u8 Bank,
+			      u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (Bank != 0xFF && cxd->curbankx != Bank) {
+		status = writereg(cxd, cxd->adrx, 0, Bank);
+		if (status < 0) {
+			cxd->curbankx = 0xFF;
+			return status;
+		}
+		cxd->curbankx = Bank;
+	}
+	status = readregs(cxd, cxd->adrx, Address, pValue, count);
+	return status;
+}
+
+static int readregsx(struct cxd_state *cxd, u8 Bank,
+		     u8 Address, u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = readregsx_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writeregsx_unlocked(struct cxd_state *cxd, u8 Bank,
+			       u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (Bank != 0xFF && cxd->curbankx != Bank) {
+		status = writereg(cxd, cxd->adrx, 0, Bank);
+		if (status < 0) {
+			cxd->curbankx = 0xFF;
+			return status;
+		}
+		cxd->curbankx = Bank;
+	}
+	status = writeregs(cxd, cxd->adrx, Address, pValue, count);
+	return status;
+}
+
+static int writeregsx(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = writeregsx_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writeregx(struct cxd_state *cxd, u8 Bank, u8 Address, u8 val)
+{
+	return writeregsx(cxd, Bank, Address, &val, 1);
+}
+
+static int writeregst_unlocked(struct cxd_state *cxd, u8 Bank,
+			       u8 Address, u8 *pValue, u16 count)
+{
+	int status = 0;
+
+	if (Bank != 0xFF && cxd->curbankt != Bank) {
+		status = writereg(cxd, cxd->adrt, 0, Bank);
+		if (status < 0) {
+			cxd->curbankt = 0xFF;
+			return status;
+		}
+		cxd->curbankt = Bank;
+	}
+	status = writeregs(cxd, cxd->adrt, Address, pValue, count);
+	return status;
+}
+
+static int writeregst(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 *pValue, u16 count)
+{
+	int status;
+
+	mutex_lock(&cxd->mutex);
+	status = writeregst_unlocked(cxd, Bank, Address, pValue, count);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writeregt(struct cxd_state *cxd, u8 Bank, u8 Address, u8 val)
+{
+	return writeregst(cxd, Bank, Address, &val, 1);
+}
+
+static int writebitsx(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 Value, u8 Mask)
+{
+	int status = 0;
+	u8 tmp;
+
+	mutex_lock(&cxd->mutex);
+	status = readregsx_unlocked(cxd, Bank, Address, &tmp, 1);
+	if (status < 0)
+		return status;
+	tmp = (tmp & ~Mask) | Value;
+	status = writeregsx_unlocked(cxd, Bank, Address, &tmp, 1);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int writebitst(struct cxd_state *cxd, u8 Bank, u8 Address,
+		      u8 Value, u8 Mask)
+{
+	int status = 0;
+	u8 Tmp = 0x00;
+
+	mutex_lock(&cxd->mutex);
+	status = readregst_unlocked(cxd, Bank, Address, &Tmp, 1);
+	if (status < 0)
+		return status;
+	Tmp = (Tmp & ~Mask) | Value;
+	status = writeregst_unlocked(cxd, Bank, Address, &Tmp, 1);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static int freeze_regst(struct cxd_state *cxd)
+{
+	mutex_lock(&cxd->mutex);
+	return writereg(cxd, cxd->adrt, 1, 1);
+}
+
+static int unfreeze_regst(struct cxd_state *cxd)
+{
+	int status = 0;
+
+	status = writereg(cxd, cxd->adrt, 1, 0);
+	mutex_unlock(&cxd->mutex);
+	return status;
+}
+
+static inline u32 MulDiv32(u32 a, u32 b, u32 c)
+{
+	u64 tmp64;
+
+	tmp64 = ((u64)a * (u64)b) + (u64)20500000;
+	do_div(tmp64, c);
+
+	return (u32) tmp64;
+}
+
+/* TPSData[0] [7:6]  CNST[1:0] */
+/* TPSData[0] [5:3]  HIER[2:0] */
+/* TPSData[0] [2:0]  HRATE[2:0] */
+/* TPSData[1] [7:5]  LRATE[2:0] */
+/* TPSData[1] [4:3]  GI[1:0] */
+/* TPSData[1] [2:1]  MODE[1:0] */
+/* TPSData[2] [7:6]  FNUM[1:0] */
+/* TPSData[2] [5:0]  LENGTH_INDICATOR[5:0] */
+/* TPSData[3] [7:0]  CELLID[15:8] */
+/* TPSData[4] [7:0]  CELLID[7:0] */
+/* TPSData[5] [5:0]  RESERVE_EVEN[5:0] */
+/* TPSData[6] [5:0]  RESERVE_ODD[5:0] */
+
+static int read_tps(struct cxd_state *state, u8 *tps)
+{
+	if (state->last_status != 0x1f)
+		return 0;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x10, 0x2f, tps, 7);
+	readregst_unlocked(state, 0x10, 0x3f, &tps[7], 1);
+	unfreeze_regst(state);
+	return 0;
+}
+
+static void Active_to_Sleep(struct cxd_state *state)
+{
+	if (state->state <= Sleep)
+		return;
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+	writeregt(state, 0x00, 0x80, 0x3F); /* Enable HighZ 1 */
+	writeregt(state, 0x00, 0x81, 0xFF); /* Enable HighZ 2 */
+	writeregx(state, 0x00, 0x18, 0x01); /* Disable ADC 4 */
+	writeregt(state, 0x00, 0x43, 0x0A); /* Disable ADC 2 */
+	writeregt(state, 0x00, 0x41, 0x0A); /* Disable ADC 1 */
+	writeregt(state, 0x00, 0x30, 0x00); /* Disable ADC Clock */
+	writeregt(state, 0x00, 0x2F, 0x00); /* Disable RF level Monitor */
+	writeregt(state, 0x00, 0x2C, 0x00); /* Disable Demod Clock */
+	state->state = Sleep;
+}
+
+static void ActiveT2_to_Sleep(struct cxd_state *state)
+{
+	if (state->state <= Sleep)
+		return;
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+	writeregt(state, 0x00, 0x80, 0x3F); /* Enable HighZ 1 */
+	writeregt(state, 0x00, 0x81, 0xFF); /* Enable HighZ 2 */
+
+	writeregt(state, 0x13, 0x83, 0x40);
+	writeregt(state, 0x13, 0x86, 0x21);
+	writebitst(state, 0x13, 0x9E, 0x09, 0x0F);
+	writeregt(state, 0x13, 0x9F, 0xFB);
+
+	writeregx(state, 0x00, 0x18, 0x01); /* Disable ADC 4 */
+	writeregt(state, 0x00, 0x43, 0x0A); /* Disable ADC 2 */
+	writeregt(state, 0x00, 0x41, 0x0A); /* Disable ADC 1 */
+	writeregt(state, 0x00, 0x30, 0x00); /* Disable ADC Clock */
+	writeregt(state, 0x00, 0x2F, 0x00); /* Disable RF level Monitor */
+	writeregt(state, 0x00, 0x2C, 0x00); /* Disable Demod Clock */
+	state->state = Sleep;
+}
+
+static int ConfigureTS(struct cxd_state *state,
+		       enum fe_delivery_system delivery_system)
+{
+	int ret = 0;
+	u8 serialTs;
+    u8 tsRateCtrlOff;
+    u8 tsInOff;
+    u8 backwardsCompatible = 0;
+	struct ts_clk tsClk;
+	
+	struct ts_clk sTsClk[2][6] = {
+		{ 			
+			{ 3, 1, 8, 0 }, 
+			{ 3, 1, 8, 1 },
+			{ 3, 1, 8, 2 }, 
+			{ 0, 2, 16, 0 }, 
+			{ 0, 2, 16, 1 }, 
+			{ 0, 2, 16, 2 }  
+		},
+		{ 		
+			{ 1, 1, 8, 0 },			
+			{ 1, 1, 8, 1 },
+			{ 1, 1, 8, 2 }, 
+			{ 2, 2, 16, 0 }, 
+			{ 2, 2, 16, 1 }, 
+			{ 2, 2, 16, 2 }			
+		}
+	};
+
+    struct ts_clk pTsClk = { 0, 0, 8, 0 };
+	
+    struct ts_clk bsTsClk[2] = {
+		{ 3, 1, 8, 1 },		
+		{ 1, 1, 8, 1 }		
+	}; 
+    struct ts_clk bpTsClk = { 0, 0, 8, 1 };
+	
+	readregst(state, 0x00, 0xC4, &serialTs, 1);
+	readregst(state, 0x00, 0xD3, &tsRateCtrlOff, 1);
+	readregst(state, 0x00, 0xDE, &tsInOff, 1);
+	
+	if ((tsRateCtrlOff & 0x01) != (tsInOff & 0x01)) {
+		ret = -EINVAL;
+		goto error;
+	}
+	if ((tsRateCtrlOff & 0x01) && (tsInOff & 0x01)) {
+        backwardsCompatible = 1;
+          
+        if (serialTs & 0x80) 
+            tsClk = bsTsClk[state->ContinuousClock];
+        else           
+            tsClk = bpTsClk;
+        
+    }
+    else if (serialTs & 0x80) 
+		tsClk = sTsClk[state->ContinuousClock][state->SerialClockFrequency];
+    else       
+		tsClk = pTsClk;
+	
+	if (serialTs & 0x80) {
+		writebitst(state, 0x00, 0xC4, tsClk.serialClkMode, 0x03); 
+		writebitst(state, 0x00, 0xD1, tsClk.serialDutyMode, 0x03);
+	}
+	writeregt(state, 0x00, 0xD9, tsClk.tsClkPeriod);
+	writebitst(state, 0x00, 0x32, 0x00, 0x01); /* Disable TS IF */
+	
+	writebitst(state, 0x00, 0x33, tsClk.clkSelTsIf, 0x03);
+	writebitst(state, 0x00, 0x32, 0x01, 0x01); /* Enable TS IF */
+
+	if (delivery_system == SYS_DVBT)
+		writebitst(state, 0x10, 0x66, 0x01, 0x01);
+	if (delivery_system == SYS_DVBC_ANNEX_A)
+		writebitst(state, 0x40, 0x66, 0x01, 0x01);
+
+error:
+	return ret;
+}
+
+static void BandSettingT(struct cxd_state *state, u32 iffreq)
+{
+	u8 IF_data[3] = { (iffreq >> 16) & 0xff,
+			  (iffreq >> 8) & 0xff, iffreq & 0xff};
+
+	switch (state->bw) {
+	default:
+	case 8:
+	{
+		u8 TR_data[] = { 0x11, 0xF0, 0x00, 0x00, 0x00 };
+		u8 CL_data[] = { 0x01, 0xE0 };
+		u8 NF_data[] = { 0x01, 0x02 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x00, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	case 7:
+	{
+		u8 TR_data[] = { 0x14, 0x80, 0x00, 0x00, 0x00 };
+		u8 CL_data[] = { 0x12, 0xF8 };
+		u8 NF_data[] = { 0x00, 0x03 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x02, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	case 6:
+	{
+		u8 TR_data[] = { 0x17, 0xEA, 0xAA, 0xAA, 0xAA };
+		u8 CL_data[] = { 0x1F, 0xDC };
+		u8 NF_data[] = { 0x00, 0x03 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x04, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	case 5:
+	{
+		static u8 TR_data[] = { 0x1C, 0xB3, 0x33, 0x33, 0x33 };
+		static u8 CL_data[] = { 0x26, 0x3C };
+		static u8 NF_data[] = { 0x00, 0x03 };
+
+		writeregst(state, 0x10, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x06, 0x07);
+		writeregst(state, 0x10, 0xD9, CL_data, sizeof(CL_data));
+		writeregst(state, 0x17, 0x38, NF_data, sizeof(NF_data));
+		break;
+	}
+	}
+}
+
+static void Sleep_to_ActiveT(struct cxd_state *state, u32 iffreq)
+{
+	u8 data[2] = { 0x00, 0x00 }; 
+	
+	if( state->xtal == XTAL_41000KHz) {
+		data[0] = 0x0A;
+        data[1] = 0xD4;
+	} else {
+		data[0] = 0x09;
+        data[1] = 0x54;
+	}
+	
+	ConfigureTS(state, SYS_DVBT);
+	writeregx(state, 0x00, 0x17, 0x01);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, 0x00);   /* Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+	
+	writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x0C, 0x1F); /* IF AGC Gain */
+	writeregt(state, 0x11, 0x6A, 0x48); /* BB AGC Target Level */
+
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writebitst(state, 0x18, 0x36, 0x40, 0x07); /* Pre RS Monitoring */
+	writebitst(state, 0x18, 0x30, 0x01, 0x01); /* FEC Autorecover */
+	writebitst(state, 0x18, 0x31, 0x01, 0x01); /* FEC Autorecover */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	BandSettingT(state, iffreq);
+
+	writebitst(state, 0x10, 0x60, 11, 0x1f); /* BER scaling */
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+
+static void BandSettingT2(struct cxd_state *state, u32 iffreq)
+{
+	u8 IF_data[3] = {(iffreq >> 16) & 0xff, (iffreq >> 8) & 0xff,
+			 iffreq & 0xff};
+
+	switch (state->bw) {
+	default:
+	case 8:
+	{
+		u8 TR_data[] = { 0x11, 0xF0, 0x00, 0x00, 0x00 };
+		/* Timing recovery */
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		/* Add EQ Optimisation for tuner here */
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		/* System Bandwidth */
+		writebitst(state, 0x10, 0xD7, 0x00, 0x07);
+	}
+	break;
+	case 7:
+	{
+		u8 TR_data[] = { 0x14, 0x80, 0x00, 0x00, 0x00 };
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x02, 0x07);
+	}
+	break;
+	case 6:
+	{
+		u8 TR_data[] = { 0x17, 0xEA, 0xAA, 0xAA, 0xAA };
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x04, 0x07);
+	}
+	break;
+	case 5:
+	{
+		u8 TR_data[] = { 0x1C, 0xB3, 0x33, 0x33, 0x33 };
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x06, 0x07);
+	}
+	break;
+	case 1: /* 1.7 MHz */
+	{
+		u8 TR_data[] = { 0x58, 0xE2, 0xAF, 0xE0, 0xBC };
+		writeregst(state, 0x20, 0x9F, TR_data, sizeof(TR_data));
+		writeregst(state, 0x10, 0xB6, IF_data, sizeof(IF_data));
+		writebitst(state, 0x10, 0xD7, 0x03, 0x07);
+	}
+	break;
+	}
+}
+
+
+static void Sleep_to_ActiveT2(struct cxd_state *state, u32 iffreq)
+{
+	u8 data[2] = { 0x00, 0x00 }; 
+	
+	if( state->xtal == XTAL_41000KHz) {
+		data[0] = 0x0A;
+        data[1] = 0xD4;
+	} else {
+		data[0] = 0x09;
+        data[1] = 0x54;
+	}
+	
+	ConfigureTS(state, SYS_DVBT2);
+
+	writeregx(state, 0x00, 0x17, 0x02);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, state->RfainMon ? 0x01 : 0x00);   /* Enable/Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+
+	writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x0C, 0x1F); /* IFAGC  coarse gain */
+	writeregt(state, 0x11, 0x6A, 0x50); /* BB AGC Target Level */
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writeregt(state, 0x20, 0x8B, 0x3C); /* SNR Good count */
+	writebitst(state, 0x2B, 0x76, 0x20, 0x70); /* Noise Gain ACQ */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	writeregt(state, 0x13, 0x83, 0x10); /* T2 Inital settings */
+	writeregt(state, 0x13, 0x86, 0x34);
+	writebitst(state, 0x13, 0x9E, 0x09, 0x0F);
+	writeregt(state, 0x13, 0x9F, 0xD8);
+
+	BandSettingT2(state, iffreq);
+
+	writebitst(state, 0x20, 0x72, 0x08, 0x0f); /* BER scaling */
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+
+
+static void BandSettingC(struct cxd_state *state, u32 iffreq)
+{
+	u8 data[3];
+
+	data[0] = (iffreq >> 16) & 0xFF;
+	data[1] = (iffreq >>  8) & 0xFF;
+	data[2] = (iffreq) & 0xFF;
+	writeregst(state, 0x10, 0xB6, data, 3);
+}
+
+static void Sleep_to_ActiveC(struct cxd_state *state, u32 iffreq)
+{
+	u8 data[2] = { 0x00, 0x00 }; 
+	
+	if( state->xtal == XTAL_41000KHz) {
+		data[0] = 0x0A;
+        data[1] = 0xD4;
+	} else {
+		data[0] = 0x09;
+        data[1] = 0x54;
+	}
+	
+	ConfigureTS(state, SYS_DVBC_ANNEX_A);
+
+	writeregx(state, 0x00, 0x17, 0x04);   /* Mode */
+	writeregt(state, 0x00, 0x2C, 0x01);   /* Demod Clock */
+	writeregt(state, 0x00, 0x2F, 0x00);   /* Disable RF Monitor */
+	writeregt(state, 0x00, 0x30, 0x00);   /* Enable ADC Clock */
+	writeregt(state, 0x00, 0x41, 0x1A);   /* Enable ADC1 */
+
+
+	writeregst(state, 0x00, 0x43, data, 2);   /* Enable ADC 2+3 */
+	
+	writeregx(state, 0x00, 0x18, 0x00);   /* Enable ADC 4 */
+
+	writebitst(state, 0x10, 0xD2, 0x09, 0x1F); /* IF AGC Gain */
+	writeregt(state, 0x11, 0x6A, 0x48); /* BB AGC Target Level */
+	writebitst(state, 0x10, 0xA5, 0x00, 0x01); /* ASCOT Off */
+
+	writebitst(state, 0x40, 0xC3, 0x00, 0x04); /* OREG_BNDET_EN_64 */
+
+	writebitst(state, 0x00, 0xCE, 0x01, 0x01); /* TSIF ONOPARITY */
+	writebitst(state, 0x00, 0xCF, 0x01, 0x01);/*TSIF ONOPARITY_MANUAL_ON*/
+
+	BandSettingC(state, iffreq);
+
+	writebitst(state, 0x40, 0x60, 11, 0x1f); /* BER scaling */
+
+	writeregt(state, 0x00, 0x80, 0x28); /* Disable HiZ Setting 1 */
+	writeregt(state, 0x00, 0x81, 0x00); /* Disable HiZ Setting 2 */
+}
+static void T2_SetParameters(struct cxd_state *state)
+{
+	u8 Profile = 0x00;    /* Automatic Profile detection */
+	u8 notT2time = 40;    /* early unlock detection time */
+	
+	writeregt(state, 0x23, 0xAD, 0x00);
+	
+	writebitst(state, 0x2E, 0x10, Profile, 0x07);
+	writeregt(state, 0x2B, 0x9D, notT2time);
+	
+}
+static void Stop(struct cxd_state *state)
+{
+
+	writeregt(state, 0x00, 0xC3, 0x01); /* Disable TS */
+}
+
+static void ShutDown(struct cxd_state *state)
+{
+	switch (state->delivery_system) {
+	case SYS_DVBT2:
+		ActiveT2_to_Sleep(state);
+		break;
+	default:
+		Active_to_Sleep(state);
+		break;
+	}
+}
+
+static int gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	return writebitsx(state, 0xFF, 0x08, enable ? 0x01 : 0x00, 0x01);
+}
+
+static void release(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	Stop(state);
+	ShutDown(state);
+	kfree(state);
+}
+static int read_status(struct dvb_frontend *fe, enum fe_status *status);
+
+static int set_parameters(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	u32 IF = 0;
+
+	if (c->frequency == state->freq && c->delivery_system == state->delivery_system) {
+		enum fe_status status;
+		ret = read_status(fe, &status);
+		if (!ret && status == 0x1F) {
+			dev_dbg(&state->i2c->dev, "Ignoring tuning to same freq, allready locked!\n");	
+			return 0;
+		}
+	}
+	if (c->delivery_system != SYS_DVBC_ANNEX_A) {	
+		switch (c->bandwidth_hz) {
+		case 1700000:
+			state->bw = 1;
+			break;
+		case 5000000:
+			state->bw = 5;
+			break;
+		case 6000000:
+			state->bw = 6;
+			break;
+		case 7000000:
+			state->bw = 7;
+			break;
+		case 8000000:
+			state->bw = 8;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}	
+		
+		
+	if (fe->ops.tuner_ops.set_params) {
+		ret = fe->ops.tuner_ops.set_params(fe);
+		if (ret)
+			goto err;
+	}
+		
+	if (fe->ops.tuner_ops.get_if_frequency) {
+		ret = fe->ops.tuner_ops.get_if_frequency(fe, &IF);
+		if (ret)
+			goto err;
+	}
+		
+	IF = MulDiv32(IF, 16777216, 41000000);
+	
+	state->LockTimeout = 0;
+	state->TSLockTimeout = 0;
+	state->L1PostTimeout = 0;
+	state->last_status = 0;
+	state->FirstTimeLock = 1;
+	state->LastBERNominator = 0;
+	state->LastBERDenominator = 1;
+	state->BERScaleMax = 19;
+	
+	switch (c->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		state->BERScaleMax = 19;
+		if ( state->state == Active && c->delivery_system == state->delivery_system) {
+			writeregt(state, 0x00, 0xC3, 0x01);   /* Disable TS Output */
+		} else if (state->state == Active && c->delivery_system != state->delivery_system) {
+			Active_to_Sleep(state);
+			Sleep_to_ActiveC(state, IF);
+			state->delivery_system = c->delivery_system;
+		} else if (state->state == Sleep) {
+			Sleep_to_ActiveC(state, IF);
+			state->delivery_system = c->delivery_system;
+			state->state = Active;
+		}
+	break;
+	case SYS_DVBT:
+		state->BERScaleMax = 18;
+		/* Stick with HP ( 0x01 = LP ) */
+		writeregt(state, 0x10, 0x67, 0x00);
+		if ( state->state == Active && c->delivery_system == state->delivery_system) {
+			writeregt(state, 0x00, 0xC3, 0x01);   /* Disable TS Output */
+			BandSettingT(state, IF);
+		} else if (state->state == Active && c->delivery_system != state->delivery_system) {	
+			Active_to_Sleep(state);
+			Sleep_to_ActiveT(state, IF);
+			state->delivery_system = c->delivery_system;
+		} else if (state->state == Sleep) {
+			Sleep_to_ActiveT(state, IF);
+			state->delivery_system = c->delivery_system;
+			state->state = Active;
+		}
+	break;
+	case SYS_DVBT2:
+		state->BERScaleMax = 12;
+		T2_SetParameters(state);
+		if ( state->state == Active && c->delivery_system == state->delivery_system) {
+			writeregt(state, 0x00, 0xC3, 0x01);   /* Disable TS Output */
+			BandSettingT2(state, IF);
+		} else if (state->state == Active && c->delivery_system != state->delivery_system) {	
+			ActiveT2_to_Sleep(state);
+			Sleep_to_ActiveT2(state, IF);
+			state->delivery_system = c->delivery_system;
+		} else if (state->state == Sleep) {
+			Sleep_to_ActiveT2(state, IF);
+			state->delivery_system = c->delivery_system;
+			state->state = Active;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	writeregt(state, 0x00, 0xFE, 0x01);   /* SW Reset */
+	writeregt(state, 0x00, 0xC3, 0x00);   /* Enable TS Output */
+	state->freq = c->frequency;
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "failed=%d\n", ret);	
+	return ret;
+}
+
+
+static int init(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	u8 data[2] = { 0x00, state->xtal == XTAL_41000KHz ? 0x01 : 0x00 }; 
+	
+	
+	state->delivery_system = SYS_UNDEFINED;
+	state->state = Unknown;
+
+	state->curbankt = 0xff;
+	state->curbankx = 0xff;
+	
+	/* Start: demod any state to Sleep T / C state. */
+	writeregx(state, 0xFF, 0x02, 0x00);
+	usleep_range(4000, 5000);
+	
+	writeregx(state, 0x00, 0x10, 0x01);
+
+	writeregsx(state, 0x00, 0x13, data, 2);
+	
+	writeregx(state, 0x00, 0x10, 0x00);
+	usleep_range(2000, 3000);
+	
+	writeregt(state, 0x00, 0x43, 0x0A);
+	writeregt(state, 0x00, 0x41, 0x0A);	
+	
+	state->state = Sleep;
+	
+	/* Set demod config */
+	writebitst(state, 0x10, 0xCB, state->IF_AGC ? 0x40 : 0x00, 0x40);
+	writeregt(state, 0x10, 0xCD, state->IF_FS);
+
+	writebitst(state, 0x00, 0xCB, state->ErrorPolarity ? 0x00 : 0x01, 0x01); 
+	writebitst(state, 0x00, 0xC5, state->ClockPolarity ? 0x01 : 0x00, 0x01); 
+	
+	return 0;
+}
+
+
+static void init_state(struct cxd_state *state, struct cxd2837_cfg *cfg)
+{
+	state->adrt = cfg->adr;
+	state->adrx = cfg->adr + 0x02;
+	state->curbankt = 0xff;
+	state->curbankx = 0xff;
+	mutex_init(&state->mutex);
+
+	state->RfainMon = cfg->rfain_monitoring;
+	state->ErrorPolarity = cfg->ts_error_polarity;
+	state->ClockPolarity = cfg->clock_polarity;
+	state->IF_AGC = cfg->if_agc_polarity;
+	state->xtal = cfg->xtal;
+	state->ContinuousClock = 1;
+	state->SerialClockFrequency = cfg->ts_clock; /* 1 = fastest (82 MBit/s), 5 = slowest */
+	state->IF_FS = 0x50; /* 1.4Vpp - Default */
+		
+		
+	switch(cfg->ifagc_adc_range) {
+	case 0:	
+		break;
+	case 1:		        
+        state->IF_FS = 0x39; /* 1.0Vpp */
+		break;
+	case 2:          
+        state->IF_FS = 0x28; /* 0.7Vpp */
+        break;
+	default:	
+		break;
+	}	
+}
+
+static int get_tune_settings(struct dvb_frontend *fe,
+			     struct dvb_frontend_tune_settings *s)
+{
+	s->min_delay_ms = 1500;
+	s->step_size = fe->ops.info.frequency_stepsize;
+	
+	return 0;
+}
+
+static int read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	u8 rdata;
+
+	*status = 0;
+	switch (state->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		readregst(state, 0x40, 0x88, &rdata, 1);
+		if (rdata & 0x02)
+			break;
+		if (rdata & 0x01) {
+			*status |= 0x07;
+			readregst(state, 0x40, 0x10, &rdata, 1);
+			if (rdata & 0x20)
+				*status |= 0x1f;
+		}
+		break;
+	case SYS_DVBT:
+		readregst(state, 0x10, 0x10, &rdata, 1);
+		if (rdata & 0x10)
+			break;
+		if ((rdata & 0x07) == 0x06) {
+			*status |= 0x07;
+			if (rdata & 0x20)
+				*status |= 0x1f;
+		}
+		break;
+	case SYS_DVBT2:
+		readregst(state, 0x20, 0x10, &rdata, 1);		
+		if (rdata & 0x10)
+			break;
+		if ((rdata & 0x07) == 0x06) {
+			*status |= 0x07;
+			if (rdata & 0x20)
+				*status |= 0x08;
+		}
+		if (*status & 0x08) {
+			readregst(state, 0x22, 0x12, &rdata, 1);
+			if (rdata & 0x01)
+				*status |= 0x10;
+		}
+		break;
+	default:
+		break;
+	}
+	state->last_status = *status;
+	return 0;
+}
+
+static int get_ber_t(struct cxd_state *state, u32 *ber)
+{
+	u8 BERRegs[3];
+	u8 Scale;
+	u32 bitError = 0;
+    u32 period = 0;
+	u32 div = 0;
+    u32 Q = 0;
+    u32 R = 0;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x10, 0x39, BERRegs, 1);
+	readregst_unlocked(state, 0x10, 0x6F, &Scale, 1);
+	readregst_unlocked(state, 0x10, 0x22, &BERRegs[1], 2);
+	unfreeze_regst(state);
+	
+	if (!(BERRegs[0] & 0x10)) {
+		dev_dbg(&state->i2c->dev, "%s: no valid BER data\n", __func__);	
+		return 0;
+	}
+	
+	bitError = ((u32)BERRegs[1] << 8) | (u32)BERRegs[2];
+	period = ((Scale & 0x07) == 0) ? 256 : (4096 << (Scale & 0x07));
+	
+	div = period / 128;
+	Q = (bitError * 3125) / div;
+    R = (bitError * 3125) % div;
+	R *= 25;
+    Q = Q * 25 + R / div;
+    R = R % div;
+	*ber = (R >= div / 2) ? Q + 1 : Q;
+	
+	return 0;
+}
+
+static int get_ber_t2(struct cxd_state *state, u32 *ber)
+{
+	u8 BERRegs[4];
+	u8 Scale;
+	u8 plp;
+	u32 bitError = 0;
+    u32 periodExp = 0;
+	u32 div = 0;
+    u32 Q = 0;
+    u32 R = 0;
+	u32 n_ldpc = 0;
+	
+	freeze_regst(state);
+	readregst_unlocked(state, 0x20, 0x39, BERRegs, 4);
+	readregst_unlocked(state, 0x20, 0x6F, &Scale, 1);
+	readregst_unlocked(state, 0x22, 0x5E, &plp, 1);
+	unfreeze_regst(state);
+	
+	if (!(BERRegs[0] & 0x10)) {
+		dev_dbg(&state->i2c->dev, "%s: no valid BER data\n", __func__);	
+		return 0;
+	}
+	
+	bitError = ((BERRegs[0] & 0x0F) << 24) | (BERRegs[1] << 16) | (BERRegs[2] << 8) | BERRegs[3];	
+	periodExp = (Scale & 0x0F);
+	n_ldpc = ((plp & 0x03) == 0 ? 16200 : 64800);
+			
+	if (bitError > ((1U << periodExp) * n_ldpc)) {
+		dev_dbg(&state->i2c->dev, "%s: invalid BER value\n", __func__);	
+        return -EINVAL;
+    }
+
+    if (periodExp >= 4) {    
+		div = (1U << (periodExp - 4)) * (n_ldpc / 200);
+		Q = (bitError * 5) / div;
+		R = (bitError * 5) % div;
+		R *= 625;
+		Q = Q * 625 + R / div;
+		R = R % div;
+	} 
+	else {            
+		div = (1U << periodExp) * (n_ldpc / 200);
+		Q = (bitError * 10) / div;
+		R = (bitError * 10) % div;
+		R *= 5000;
+		Q = Q * 5000 + R / div;
+		R = R % div;
+	}
+
+	*ber = (R >= div/2) ? Q + 1 : Q;	
+	return 0;
+}
+
+static int get_ber_c(struct cxd_state *state, u32 *ber)
+{	
+	u8 BERRegs[3];
+	u8 Scale;
+	u32 bitError = 0;
+    u32 periodExp = 0;
+	u32 div = 0;
+    u32 Q = 0;
+    u32 R = 0;
+
+	readregst(state, 0x40, 0x62, BERRegs, 3);
+	readregst(state, 0x40, 0x60, &Scale, 1);
+
+		
+	if ((BERRegs[0] & 0x80) == 0) {
+		dev_dbg(&state->i2c->dev, "%s: no valid BER data\n", __func__);	
+		return 0;
+	}
+	
+	bitError = ((BERRegs[0] & 0x3F) << 16) | (BERRegs[1] << 8) | BERRegs[2];
+	periodExp = (Scale & 0x1F);
+
+	if ((periodExp <= 11) && (bitError > (1U << periodExp) * 204 * 8)) {
+		dev_dbg(&state->i2c->dev, "%s: invalid BER value\n", __func__);	
+        return -EINVAL;
+    }
+	
+	div = (periodExp <= 8) ? ((1U << periodExp) * 51) : ((1U << 8) * 51);
+    Q = (bitError * 250) / div;
+    R = (bitError * 250) % div;
+    R *= 1250;
+    Q = Q * 1250 + R / div;
+    R = R % div;
+
+    if (periodExp > 8) 
+		*ber = (Q + (1 << (periodExp - 9))) >> (periodExp - 8);
+    else 
+		*ber = (R >= div/2) ? Q + 1 : Q;
+		
+	return 0;
+}
+static int read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int ret = 0;
+
+	*ber = 0;
+	
+	if (state->last_status != 0x1f)
+		return 0;
+		
+	switch (state->delivery_system) {
+	case SYS_DVBT:
+		ret = get_ber_t(state, ber);
+		break;
+	case SYS_DVBT2:
+		ret = get_ber_t2(state, ber);
+		break;
+	case SYS_DVBC_ANNEX_A:
+		ret = get_ber_c(state, ber);
+		break;
+	default:
+		break;
+	}
+	
+	return 0;
+}
+static u32 sony_math_log10(u32 x)
+{
+	u32 count = 0;
+
+	for (x >>= 1; x > 0; x >>= 1)
+		count++;
+	return 10000 * count / 332;
+}
+
+static u32 sony_math_log(u32 x)
+{
+	u32 count = 0;
+
+	for (x >>= 1; x > 0; x >>= 1)
+		count++;
+	return 10000 * count / 144;
+}
+
+static void GetSignalToNoiseT2(struct cxd_state *state, int *SignalToNoise)
+{
+	u8 Data[2];
+	u32 reg;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x20, 0x28, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = ((u32)Data[0] << 8) | (u32)Data[1];
+	if (reg == 0) {
+		dev_dbg(&state->i2c->dev, "%s(): reg value out of range\n", __func__);
+		return;
+	}
+	if (reg > 10876)
+		reg = 10876;
+
+	*SignalToNoise = 100 * ((int)sony_math_log10(reg) - (int)sony_math_log10(12600 - reg));
+	*SignalToNoise += 32000;
+	
+}
+
+static void GetSignalToNoiseT(struct cxd_state *state, int *SignalToNoise)
+{
+	u8 Data[2];
+	u32 reg;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x10, 0x28, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = ((u32)Data[0] << 8) | (u32)Data[1];
+	if (reg == 0) {
+		dev_dbg(&state->i2c->dev, "%s(): reg value out of range\n", __func__);
+		return;
+	}
+	if (reg > 4996)
+		reg = 4996;
+
+	*SignalToNoise = 100 * ((int)sony_math_log10(reg) - (int)sony_math_log10(5350 - reg));
+	*SignalToNoise += 28500;
+	
+	
+	return;
+}
+static void GetSignalToNoiseC(struct cxd_state *state, int *SignalToNoise)
+{
+	u8 Data[2];
+	u8 Constellation = 0;
+	u32 reg;
+		
+	*SignalToNoise = 0;
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x40, 0x19, &Constellation, 1);
+	readregst_unlocked(state, 0x40, 0x4C, Data, sizeof(Data));
+	unfreeze_regst(state);
+
+	reg = ((u32)(Data[0] & 0x1F) << 8) | ((u32)Data[1]);
+	if (reg == 0) {
+		dev_dbg(&state->i2c->dev, "%s(): reg value out of range\n", __func__);
+		return;
+	}
+
+	switch (Constellation & 0x07) {
+	case 0: /* QAM 16 */
+	case 2: /* QAM 64 */
+	case 4: /* QAM 256 */
+		if (reg < 126)
+			reg = 126;
+		*SignalToNoise = -95 * (int)sony_math_log(reg) + 95941;
+		break;
+	case 1: /* QAM 32 */
+	case 3: /* QAM 128 */
+		if (reg < 69)
+			reg = 69;
+		*SignalToNoise = -88 * (int)sony_math_log(reg) + 86999;
+		break;
+	}
+	
+}
+
+static int read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int tSnr = 0;
+	*snr = 0;
+	
+	if (state->last_status != 0x1f)
+		return 0;
+
+	switch (state->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		GetSignalToNoiseC(state, &tSnr);	
+		break;
+	case SYS_DVBT:
+		GetSignalToNoiseT(state, &tSnr);	
+		break;
+	case SYS_DVBT2:
+		GetSignalToNoiseT2(state, &tSnr);	
+		break;
+	default:
+		break;
+	}
+	*snr = tSnr & 0xffff;
+	return 0;
+}
+static int get_signal_strengthC(struct cxd_state *state, u16 *strength)
+{
+	u8 data[2];
+	
+	readregst(state, 0x40, 0x49, data, 2);
+	*strength = 65535 - (((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4);
+	return 0;
+}
+static int get_signal_strengthT(struct cxd_state *state, u16 *strength)
+{
+	u8 data[2];
+	
+	readregst(state, 0x10, 0x26, data, 2);
+	*strength = 65535 - (((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4);
+	return 0;
+	
+}
+static int get_signal_strengthT2(struct cxd_state *state, u16 *strength)
+{	
+	u8 data[2];
+	
+	readregst(state, 0x20, 0x26, data, 2);
+	*strength = 65535 - (((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4);
+	return 0;
+}
+
+static int read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int ret = 0;
+	*strength = 0;
+				
+	if (state->last_status != 0x1f)
+		return 0;
+			
+	switch (state->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		ret = get_signal_strengthC(state, strength);
+		break;
+	case SYS_DVBT:
+		ret = get_signal_strengthT(state, strength);
+		break;
+	case SYS_DVBT2:
+		ret = get_signal_strengthT2(state, strength);
+		break;
+	default:
+		break;
+	}
+	
+	return ret;
+}
+static int get_ucblocksC(struct cxd_state *state, u32 *ucblocks)
+{
+	u8 data[3];
+	
+	readregst(state, 0x40, 0xEA, data, 3);
+	
+	if (!(data[2] & 0x01))
+		return 0;
+
+    *ucblocks = (data[0] << 8) | data[1]; 
+	return 0;
+}
+static int get_ucblocksT(struct cxd_state *state, u32 *ucblocks)
+{
+	u8 data[3];
+	
+	readregst(state, 0x10, 0xEA, data, 3);
+	
+	if (!(data[2] & 0x01))
+		return 0;
+
+    *ucblocks = (data[0] << 8) | data[1]; 
+	return 0;
+	
+}
+static int get_ucblocksT2(struct cxd_state *state, u32 *ucblocks)
+{	
+	u8 data[3];
+	
+	readregst(state, 0x24, 0xFD, data, 3);
+	if (!(data[0] & 0x01))
+		return 0;
+   
+	*ucblocks =  ((data[1] << 0x08) | data[2]);
+	
+	return 0;
+}
+
+
+static int read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+	int ret = 0;
+	*ucblocks = 0;
+				
+	if (state->last_status != 0x1f)
+		return 0;
+			
+	switch (state->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		ret = get_ucblocksC(state, ucblocks);
+		break;
+	case SYS_DVBT:
+		ret = get_ucblocksT(state, ucblocks);
+		break;
+	case SYS_DVBT2:
+		ret = get_ucblocksT2(state, ucblocks);
+		break;
+	default:
+		break;
+	}
+	
+	return 0;
+}
+static int get_fe_t(struct cxd_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8 tps[8];
+
+	read_tps(state, tps);
+
+/*  TPSData[0] [7:6]  CNST[1:0]
+    TPSData[0] [5:3]  HIER[2:0]
+    TPSData[0] [2:0]  HRATE[2:0]
+*/
+	switch ((tps[0] >> 6) & 0x03) {
+	case 0:
+		p->modulation = QPSK;
+		break;
+	case 1:
+		p->modulation = QAM_16;
+		break;
+	case 2:
+		p->modulation = QAM_64;
+		break;
+	}
+	switch ((tps[0] >> 3) & 0x07) {
+	case 0:
+		p->hierarchy = HIERARCHY_NONE;
+		break;
+	case 1:
+		p->hierarchy = HIERARCHY_1;
+		break;
+	case 2:
+		p->hierarchy = HIERARCHY_2;
+		break;
+	case 3:
+		p->hierarchy = HIERARCHY_4;
+		break;
+	}
+	switch ((tps[0] >> 0) & 0x07) {
+	case 0:
+		p->code_rate_HP = FEC_1_2;
+		break;
+	case 1:
+		p->code_rate_HP = FEC_2_3;
+		break;
+	case 2:
+		p->code_rate_HP = FEC_3_4;
+		break;
+	case 3:
+		p->code_rate_HP = FEC_5_6;
+		break;
+	case 4:
+		p->code_rate_HP = FEC_7_8;
+		break;
+	}
+
+/*  TPSData[1] [7:5]  LRATE[2:0]
+    TPSData[1] [4:3]  GI[1:0]
+    TPSData[1] [2:1]  MODE[1:0]
+*/
+	switch ((tps[1] >> 5) & 0x07) {
+	case 0:
+		p->code_rate_LP = FEC_1_2;
+		break;
+	case 1:
+		p->code_rate_LP = FEC_2_3;
+		break;
+	case 2:
+		p->code_rate_LP = FEC_3_4;
+		break;
+	case 3:
+		p->code_rate_LP = FEC_5_6;
+		break;
+	case 4:
+		p->code_rate_LP = FEC_7_8;
+		break;
+	}
+	switch ((tps[1] >> 3) & 0x03) {
+	case 0:
+		p->guard_interval = GUARD_INTERVAL_1_32;
+		break;
+	case 1:
+		p->guard_interval = GUARD_INTERVAL_1_16;
+		break;
+	case 2:
+		p->guard_interval = GUARD_INTERVAL_1_8;
+		break;
+	case 3:
+		p->guard_interval = GUARD_INTERVAL_1_4;
+		break;
+	}
+	switch ((tps[1] >> 1) & 0x03) {
+	case 0:
+		p->transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case 1:
+		p->transmission_mode = TRANSMISSION_MODE_8K;
+		break;
+	}
+
+	switch ((tps[7] >> 0) & 0x01) {
+	case 0:
+		p->inversion = INVERSION_OFF;
+		break;
+	case 1:
+		p->inversion = INVERSION_ON;
+		break;
+	}
+	
+	return 0;
+}
+static int get_fe_t2(struct cxd_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8 tps[5];
+	
+	freeze_regst(state);
+	readregst_unlocked(state, 0x20, 0x5C, tps, 2); 
+	readregst_unlocked(state, 0x22, 0x5B, &tps[2], 1); 
+	readregst_unlocked(state, 0x22, 0x5C, &tps[3], 1); 
+	readregst_unlocked(state, 0x28, 0xE6, &tps[4], 1); 
+	unfreeze_regst(state);
+	
+	switch ((tps[0] >> 0) & 0x07) {
+	case 0:
+		p->transmission_mode = TRANSMISSION_MODE_2K;
+		break;
+	case 1:
+		p->transmission_mode = TRANSMISSION_MODE_8K;
+		break;
+	case 2:
+		p->transmission_mode = TRANSMISSION_MODE_4K;
+		break;
+	case 3:
+		p->transmission_mode = TRANSMISSION_MODE_1K;
+		break;
+	case 4:
+		p->transmission_mode = TRANSMISSION_MODE_16K;
+		break;
+	case 5:
+		p->transmission_mode = TRANSMISSION_MODE_32K;
+		break;
+	}
+
+	switch ((tps[1] >> 4) & 0x07) {
+	case 0:
+		p->guard_interval = GUARD_INTERVAL_1_32;
+		break;
+	case 1:
+		p->guard_interval = GUARD_INTERVAL_1_16;
+		break;
+	case 2:
+		p->guard_interval = GUARD_INTERVAL_1_8;
+		break;
+	case 3:
+		p->guard_interval = GUARD_INTERVAL_1_4;
+		break;
+	case 4:
+		p->guard_interval = GUARD_INTERVAL_1_128;
+		break;
+	case 5:
+		p->guard_interval = GUARD_INTERVAL_19_128;
+		break;
+	case 6:
+		p->guard_interval = GUARD_INTERVAL_19_256;
+		break;
+	}
+	
+	switch ((tps[2] >> 0) & 0x07) {
+	case 0:
+		p->fec_inner = FEC_1_2;
+		break;
+	case 1:
+		p->fec_inner = FEC_3_5;
+		break;
+	case 2:
+		p->fec_inner = FEC_2_3;
+		break;
+	case 3:
+		p->fec_inner = FEC_3_4;
+		break;
+	case 4:
+		p->fec_inner = FEC_4_5;
+		break;
+	case 5:
+		p->fec_inner = FEC_5_6;
+		break;
+	}
+
+	switch ((tps[3] >> 0) & 0x07) {
+	case 0:
+		p->modulation = QPSK;
+		break;
+	case 1:
+		p->modulation = QAM_16;
+		break;
+	case 2:
+		p->modulation = QAM_64;
+		break;
+	case 3:
+		p->modulation = QAM_256;
+		break;
+	}
+	
+	switch (tps[4] & 0x01) {
+	case 0:
+		p->inversion = INVERSION_OFF;
+		break;
+	case 1:
+		p->inversion = INVERSION_ON;
+		break;
+	}
+	
+	return 0;
+	
+}
+static int get_fe_c(struct cxd_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8 qam;
+	u8 rate[2];
+
+	freeze_regst(state);
+	readregst_unlocked(state, 0x40, 0x19, &qam, 1);
+	readregst_unlocked(state, 0x40, 0x1A, rate, 2);
+	unfreeze_regst(state);
+	
+	p->symbol_rate = 2500 * ((rate[0] & 0x0f) << 8 | rate[1]);
+	
+	p->modulation = qam & 0x07;
+	
+	switch (qam & 0x80) {
+	case 0:
+		p->inversion = INVERSION_OFF;
+		break;
+	case 1:
+		p->inversion = INVERSION_ON;
+		break;
+	}
+	
+	return 0;
+}
+
+static int get_frontend(struct dvb_frontend *fe)
+{
+	struct cxd_state *state = fe->demodulator_priv;
+
+	if (state->last_status != 0x1f)
+		return 0;
+
+	switch (state->delivery_system) {
+	case SYS_DVBT:
+		get_fe_t(state);
+		break;
+	case SYS_DVBT2:
+		get_fe_t2(state);
+		break;
+	case SYS_DVBC_ANNEX_A:
+		get_fe_c(state);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static struct dvb_frontend_ops cxd_2837_ops = {
+	.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBT, SYS_DVBT2 },
+	.info = {
+		.name = "CXD2837 DVB-C DVB-T/T2",
+		.frequency_min = 47000000,	/* DVB-T: 47125000 */
+		.frequency_max = 865000000,	/* DVB-C: 862000000 */
+		.caps = 	FE_CAN_FEC_1_2 |
+					FE_CAN_FEC_2_3 |
+					FE_CAN_FEC_3_4 |
+					FE_CAN_FEC_5_6 |
+					FE_CAN_FEC_7_8 |
+					FE_CAN_FEC_AUTO |
+					FE_CAN_QPSK |
+					FE_CAN_QAM_16 |
+					FE_CAN_QAM_32 |
+					FE_CAN_QAM_64 |
+					FE_CAN_QAM_128 |
+					FE_CAN_QAM_256 |
+					FE_CAN_QAM_AUTO |
+					FE_CAN_TRANSMISSION_MODE_AUTO |
+					FE_CAN_GUARD_INTERVAL_AUTO |
+					FE_CAN_HIERARCHY_AUTO |
+					FE_CAN_MUTE_TS |
+					FE_CAN_2G_MODULATION |
+					FE_CAN_MULTISTREAM
+	},
+	.init = init,
+	.release = release,
+	.i2c_gate_ctrl = gate_ctrl,
+	.set_frontend = set_parameters,
+	.get_tune_settings = get_tune_settings,
+	.read_status = read_status,
+	.read_ber = read_ber,
+	.read_signal_strength = read_signal_strength,
+	.read_snr = read_snr,
+	.read_ucblocks = read_ucblocks,
+	.get_frontend = get_frontend,
+	
+};
+
+struct dvb_frontend *cxd2837_attach(struct i2c_adapter *i2c,
+				    struct cxd2837_cfg *cfg)
+{
+	struct cxd_state *state = NULL;
+	int ret;
+	u8 ChipID = 0x00;
+	
+	state = kzalloc(sizeof(struct cxd_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+
+	state->i2c = i2c;
+	init_state(state, cfg);
+	
+	ret = readregst(state, 0x00, 0xFD, &ChipID, 1);
+	if (ret) {
+		ret = readregsx(state, 0x00, 0xFD, &ChipID, 1);
+		if (ret)
+			goto err2;
+	}
+		
+	if (ChipID != 0xB1)
+		goto err2;
+		
+	dev_info(&i2c->dev, "CXD2837 DVB-T/T2/C successfully attached\n");						
+		
+	memcpy(&state->frontend.ops, &cxd_2837_ops,
+		       sizeof(struct dvb_frontend_ops));
+			   
+	state->frontend.demodulator_priv = state;
+	
+	return &state->frontend;
+	
+err2:	
+	kfree(state);
+err1:	
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);	
+	return NULL;
+}
+EXPORT_SYMBOL(cxd2837_attach);
+
+MODULE_DESCRIPTION("Sony CXD2837 DVB-T/T2/C demodulator driver");
+MODULE_AUTHOR("Ralph Metzler, Manfred Voelkel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/cxd2837.h b/drivers/amlogic/wetek/cxd2837.h
new file mode 100644
index 0000000..98300a8
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2837.h
@@ -0,0 +1,107 @@
+/*
+ * Driver for the Sony CXD2837ER DVB-T/T2/C demodulator.
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#ifndef _CXD2837_H_
+#define _CXD2837_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+enum EDemodState { 
+	Unknown,
+	Shutdown,
+	Sleep,
+	Active 
+};
+
+enum xtal_freq {
+	XTAL_20500KHz,           /* 20.5 MHz */
+	XTAL_41000KHz            /* 41 MHz */
+};
+
+enum ts_serial_clk {
+	SERIAL_TS_CLK_HIGH_FULL,   /* High frequency, full rate */
+	SERIAL_TS_CLK_MID_FULL,    /* Mid frequency, full rate */
+	SERIAL_TS_CLK_LOW_FULL,    /* Low frequency, full rate */
+	SERIAL_TS_CLK_HIGH_HALF,   /* High frequency, half rate */
+	SERIAL_TS_CLK_MID_HALF,    /* Mid frequency, half rate */
+	SERIAL_TS_CLK_LOW_HALF     /* Low frequency, half rate */
+};
+
+struct cxd2837_cfg {
+
+	/* Demodulator I2C address.
+	 * Default: none, must set
+	 * Values: 0x6c, 0x6d
+	 */
+	u8 adr;
+
+	/* IF AGC polarity.
+	 * Default: 0
+	 * Values: 0, 1
+	 */
+	bool if_agc_polarity;
+	
+	/* RFAIN monitoring.
+	 * Default: 0
+	 * Values: 0, 1
+	 */
+	bool rfain_monitoring;
+		
+	/* TS error polarity.
+	 * Default: 0
+	 * Values: 0 : low, 1 : high
+	 */
+	bool ts_error_polarity;
+	
+	/* Clock polarity.
+	 * Default: 0
+	 * Values:  0 : Falling edge, 1 : Rising edge
+	 */
+	bool clock_polarity;
+	
+	/* IFAGC ADC range/
+	 * Default: 0
+	 * Values:  0 : 1.4Vpp, 1 : 1.0Vpp, 2 : 0.7Vpp 
+	 */
+	u8 ifagc_adc_range;
+
+	/* Spectrum inversion.
+	 * Default: 0
+	 * Values: 0, 1
+	 */
+	bool spec_inv;
+	
+	/* Demodulator crystal frequency.
+	*/
+	enum xtal_freq xtal;
+	
+	
+	/* TS serial clock frequency
+	*/
+	enum ts_serial_clk ts_clock;
+};
+
+
+extern struct dvb_frontend *cxd2837_attach(struct i2c_adapter *i2c,
+					   struct cxd2837_cfg *cfg);
+
+#endif
diff --git a/drivers/amlogic/wetek/cxd2841er_priv_wetek.h b/drivers/amlogic/wetek/cxd2841er_priv_wetek.h
new file mode 100644
index 0000000..5e2b8d8
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2841er_priv_wetek.h
@@ -0,0 +1,45 @@
+/*
+ * cxd2841er_priv.h
+ *
+ * Sony CXD2441ER digital demodulator driver internal definitions
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef CXD2841ER_PRIV_H
+#define CXD2841ER_PRIV_H
+
+#define I2C_SLVX			0
+#define I2C_SLVT			1
+
+#define CXD2841ER_CHIP_ID		0xa7
+#define CXD2854ER_CHIP_ID		0xc1
+#define CXD2837ER_CHIP_ID		0xb1
+
+#define CXD2841ER_DVBS_POLLING_INVL	10
+
+struct cxd2841er_cnr_data {
+	u32 value;
+	int cnr_x1000;
+};
+
+enum cxd2841er_dvbt2_profile_t {
+	DVBT2_PROFILE_ANY = 0,
+	DVBT2_PROFILE_BASE = 1,
+	DVBT2_PROFILE_LITE = 2
+};
+
+#endif
diff --git a/drivers/amlogic/wetek/cxd2841er_wetek.c b/drivers/amlogic/wetek/cxd2841er_wetek.c
new file mode 100644
index 0000000..ebe3353
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2841er_wetek.c
@@ -0,0 +1,3812 @@
+/*
+ * cxd2841er.c
+ *
+ * Sony digital demodulator driver for
+ *	CXD2841ER - DVB-S/S2/T/T2/C/C2
+ *	CXD2854ER - DVB-S/S2/T/T2/C/C2, ISDB-T/S
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/bitops.h>
+#include <linux/math64.h>
+#include <linux/log2.h>
+#include <linux/dynamic_debug.h>
+
+#include "dvb_math.h"
+#include "dvb_frontend.h"
+#include "cxd2841er_wetek.h"
+#include "cxd2841er_priv_wetek.h"
+
+#define MAX_WRITE_REGSIZE	16
+#define LOG2_E_100X 144
+
+/* DVB-C constellation */
+enum sony_dvbc_constellation_t {
+	SONY_DVBC_CONSTELLATION_16QAM,
+	SONY_DVBC_CONSTELLATION_32QAM,
+	SONY_DVBC_CONSTELLATION_64QAM,
+	SONY_DVBC_CONSTELLATION_128QAM,
+	SONY_DVBC_CONSTELLATION_256QAM
+};
+
+enum cxd2841er_state {
+	STATE_SHUTDOWN = 0,
+	STATE_SLEEP_S,
+	STATE_ACTIVE_S,
+	STATE_SLEEP_TC,
+	STATE_ACTIVE_TC
+};
+
+struct cxd2841er_priv {
+	struct dvb_frontend		frontend;
+	struct i2c_adapter		*i2c;
+	u8				i2c_addr_slvx;
+	u8				i2c_addr_slvt;
+	const struct cxd2841er_config	*config;
+	enum cxd2841er_state		state;
+	u8				system;
+	enum cxd2841er_xtal		xtal;
+	enum fe_caps caps;
+};
+
+static const struct cxd2841er_cnr_data s_cn_data[] = {
+	{ 0x033e, 0 }, { 0x0339, 100 }, { 0x0333, 200 },
+	{ 0x032e, 300 }, { 0x0329, 400 }, { 0x0324, 500 },
+	{ 0x031e, 600 }, { 0x0319, 700 }, { 0x0314, 800 },
+	{ 0x030f, 900 }, { 0x030a, 1000 }, { 0x02ff, 1100 },
+	{ 0x02f4, 1200 }, { 0x02e9, 1300 }, { 0x02de, 1400 },
+	{ 0x02d4, 1500 }, { 0x02c9, 1600 }, { 0x02bf, 1700 },
+	{ 0x02b5, 1800 }, { 0x02ab, 1900 }, { 0x02a1, 2000 },
+	{ 0x029b, 2100 }, { 0x0295, 2200 }, { 0x0290, 2300 },
+	{ 0x028a, 2400 }, { 0x0284, 2500 }, { 0x027f, 2600 },
+	{ 0x0279, 2700 }, { 0x0274, 2800 }, { 0x026e, 2900 },
+	{ 0x0269, 3000 }, { 0x0262, 3100 }, { 0x025c, 3200 },
+	{ 0x0255, 3300 }, { 0x024f, 3400 }, { 0x0249, 3500 },
+	{ 0x0242, 3600 }, { 0x023c, 3700 }, { 0x0236, 3800 },
+	{ 0x0230, 3900 }, { 0x022a, 4000 }, { 0x0223, 4100 },
+	{ 0x021c, 4200 }, { 0x0215, 4300 }, { 0x020e, 4400 },
+	{ 0x0207, 4500 }, { 0x0201, 4600 }, { 0x01fa, 4700 },
+	{ 0x01f4, 4800 }, { 0x01ed, 4900 }, { 0x01e7, 5000 },
+	{ 0x01e0, 5100 }, { 0x01d9, 5200 }, { 0x01d2, 5300 },
+	{ 0x01cb, 5400 }, { 0x01c4, 5500 }, { 0x01be, 5600 },
+	{ 0x01b7, 5700 }, { 0x01b1, 5800 }, { 0x01aa, 5900 },
+	{ 0x01a4, 6000 }, { 0x019d, 6100 }, { 0x0196, 6200 },
+	{ 0x018f, 6300 }, { 0x0189, 6400 }, { 0x0182, 6500 },
+	{ 0x017c, 6600 }, { 0x0175, 6700 }, { 0x016f, 6800 },
+	{ 0x0169, 6900 }, { 0x0163, 7000 }, { 0x015c, 7100 },
+	{ 0x0156, 7200 }, { 0x0150, 7300 }, { 0x014a, 7400 },
+	{ 0x0144, 7500 }, { 0x013e, 7600 }, { 0x0138, 7700 },
+	{ 0x0132, 7800 }, { 0x012d, 7900 }, { 0x0127, 8000 },
+	{ 0x0121, 8100 }, { 0x011c, 8200 }, { 0x0116, 8300 },
+	{ 0x0111, 8400 }, { 0x010b, 8500 }, { 0x0106, 8600 },
+	{ 0x0101, 8700 }, { 0x00fc, 8800 }, { 0x00f7, 8900 },
+	{ 0x00f2, 9000 }, { 0x00ee, 9100 }, { 0x00ea, 9200 },
+	{ 0x00e6, 9300 }, { 0x00e2, 9400 }, { 0x00de, 9500 },
+	{ 0x00da, 9600 }, { 0x00d7, 9700 }, { 0x00d3, 9800 },
+	{ 0x00d0, 9900 }, { 0x00cc, 10000 }, { 0x00c7, 10100 },
+	{ 0x00c3, 10200 }, { 0x00bf, 10300 }, { 0x00ba, 10400 },
+	{ 0x00b6, 10500 }, { 0x00b2, 10600 }, { 0x00ae, 10700 },
+	{ 0x00aa, 10800 }, { 0x00a7, 10900 }, { 0x00a3, 11000 },
+	{ 0x009f, 11100 }, { 0x009c, 11200 }, { 0x0098, 11300 },
+	{ 0x0094, 11400 }, { 0x0091, 11500 }, { 0x008e, 11600 },
+	{ 0x008a, 11700 }, { 0x0087, 11800 }, { 0x0084, 11900 },
+	{ 0x0081, 12000 }, { 0x007e, 12100 }, { 0x007b, 12200 },
+	{ 0x0079, 12300 }, { 0x0076, 12400 }, { 0x0073, 12500 },
+	{ 0x0071, 12600 }, { 0x006e, 12700 }, { 0x006c, 12800 },
+	{ 0x0069, 12900 }, { 0x0067, 13000 }, { 0x0065, 13100 },
+	{ 0x0062, 13200 }, { 0x0060, 13300 }, { 0x005e, 13400 },
+	{ 0x005c, 13500 }, { 0x005a, 13600 }, { 0x0058, 13700 },
+	{ 0x0056, 13800 }, { 0x0054, 13900 }, { 0x0052, 14000 },
+	{ 0x0050, 14100 }, { 0x004e, 14200 }, { 0x004c, 14300 },
+	{ 0x004b, 14400 }, { 0x0049, 14500 }, { 0x0047, 14600 },
+	{ 0x0046, 14700 }, { 0x0044, 14800 }, { 0x0043, 14900 },
+	{ 0x0041, 15000 }, { 0x003f, 15100 }, { 0x003e, 15200 },
+	{ 0x003c, 15300 }, { 0x003b, 15400 }, { 0x003a, 15500 },
+	{ 0x0037, 15700 }, { 0x0036, 15800 }, { 0x0034, 15900 },
+	{ 0x0033, 16000 }, { 0x0032, 16100 }, { 0x0031, 16200 },
+	{ 0x0030, 16300 }, { 0x002f, 16400 }, { 0x002e, 16500 },
+	{ 0x002d, 16600 }, { 0x002c, 16700 }, { 0x002b, 16800 },
+	{ 0x002a, 16900 }, { 0x0029, 17000 }, { 0x0028, 17100 },
+	{ 0x0027, 17200 }, { 0x0026, 17300 }, { 0x0025, 17400 },
+	{ 0x0024, 17500 }, { 0x0023, 17600 }, { 0x0022, 17800 },
+	{ 0x0021, 17900 }, { 0x0020, 18000 }, { 0x001f, 18200 },
+	{ 0x001e, 18300 }, { 0x001d, 18500 }, { 0x001c, 18700 },
+	{ 0x001b, 18900 }, { 0x001a, 19000 }, { 0x0019, 19200 },
+	{ 0x0018, 19300 }, { 0x0017, 19500 }, { 0x0016, 19700 },
+	{ 0x0015, 19900 }, { 0x0014, 20000 },
+};
+
+static const struct cxd2841er_cnr_data s2_cn_data[] = {
+	{ 0x05af, 0 }, { 0x0597, 100 }, { 0x057e, 200 },
+	{ 0x0567, 300 }, { 0x0550, 400 }, { 0x0539, 500 },
+	{ 0x0522, 600 }, { 0x050c, 700 }, { 0x04f6, 800 },
+	{ 0x04e1, 900 }, { 0x04cc, 1000 }, { 0x04b6, 1100 },
+	{ 0x04a1, 1200 }, { 0x048c, 1300 }, { 0x0477, 1400 },
+	{ 0x0463, 1500 }, { 0x044f, 1600 }, { 0x043c, 1700 },
+	{ 0x0428, 1800 }, { 0x0416, 1900 }, { 0x0403, 2000 },
+	{ 0x03ef, 2100 }, { 0x03dc, 2200 }, { 0x03c9, 2300 },
+	{ 0x03b6, 2400 }, { 0x03a4, 2500 }, { 0x0392, 2600 },
+	{ 0x0381, 2700 }, { 0x036f, 2800 }, { 0x035f, 2900 },
+	{ 0x034e, 3000 }, { 0x033d, 3100 }, { 0x032d, 3200 },
+	{ 0x031d, 3300 }, { 0x030d, 3400 }, { 0x02fd, 3500 },
+	{ 0x02ee, 3600 }, { 0x02df, 3700 }, { 0x02d0, 3800 },
+	{ 0x02c2, 3900 }, { 0x02b4, 4000 }, { 0x02a6, 4100 },
+	{ 0x0299, 4200 }, { 0x028c, 4300 }, { 0x027f, 4400 },
+	{ 0x0272, 4500 }, { 0x0265, 4600 }, { 0x0259, 4700 },
+	{ 0x024d, 4800 }, { 0x0241, 4900 }, { 0x0236, 5000 },
+	{ 0x022b, 5100 }, { 0x0220, 5200 }, { 0x0215, 5300 },
+	{ 0x020a, 5400 }, { 0x0200, 5500 }, { 0x01f6, 5600 },
+	{ 0x01ec, 5700 }, { 0x01e2, 5800 }, { 0x01d8, 5900 },
+	{ 0x01cf, 6000 }, { 0x01c6, 6100 }, { 0x01bc, 6200 },
+	{ 0x01b3, 6300 }, { 0x01aa, 6400 }, { 0x01a2, 6500 },
+	{ 0x0199, 6600 }, { 0x0191, 6700 }, { 0x0189, 6800 },
+	{ 0x0181, 6900 }, { 0x0179, 7000 }, { 0x0171, 7100 },
+	{ 0x0169, 7200 }, { 0x0161, 7300 }, { 0x015a, 7400 },
+	{ 0x0153, 7500 }, { 0x014b, 7600 }, { 0x0144, 7700 },
+	{ 0x013d, 7800 }, { 0x0137, 7900 }, { 0x0130, 8000 },
+	{ 0x012a, 8100 }, { 0x0124, 8200 }, { 0x011e, 8300 },
+	{ 0x0118, 8400 }, { 0x0112, 8500 }, { 0x010c, 8600 },
+	{ 0x0107, 8700 }, { 0x0101, 8800 }, { 0x00fc, 8900 },
+	{ 0x00f7, 9000 }, { 0x00f2, 9100 }, { 0x00ec, 9200 },
+	{ 0x00e7, 9300 }, { 0x00e2, 9400 }, { 0x00dd, 9500 },
+	{ 0x00d8, 9600 }, { 0x00d4, 9700 }, { 0x00cf, 9800 },
+	{ 0x00ca, 9900 }, { 0x00c6, 10000 }, { 0x00c2, 10100 },
+	{ 0x00be, 10200 }, { 0x00b9, 10300 }, { 0x00b5, 10400 },
+	{ 0x00b1, 10500 }, { 0x00ae, 10600 }, { 0x00aa, 10700 },
+	{ 0x00a6, 10800 }, { 0x00a3, 10900 }, { 0x009f, 11000 },
+	{ 0x009b, 11100 }, { 0x0098, 11200 }, { 0x0095, 11300 },
+	{ 0x0091, 11400 }, { 0x008e, 11500 }, { 0x008b, 11600 },
+	{ 0x0088, 11700 }, { 0x0085, 11800 }, { 0x0082, 11900 },
+	{ 0x007f, 12000 }, { 0x007c, 12100 }, { 0x007a, 12200 },
+	{ 0x0077, 12300 }, { 0x0074, 12400 }, { 0x0072, 12500 },
+	{ 0x006f, 12600 }, { 0x006d, 12700 }, { 0x006b, 12800 },
+	{ 0x0068, 12900 }, { 0x0066, 13000 }, { 0x0064, 13100 },
+	{ 0x0061, 13200 }, { 0x005f, 13300 }, { 0x005d, 13400 },
+	{ 0x005b, 13500 }, { 0x0059, 13600 }, { 0x0057, 13700 },
+	{ 0x0055, 13800 }, { 0x0053, 13900 }, { 0x0051, 14000 },
+	{ 0x004f, 14100 }, { 0x004e, 14200 }, { 0x004c, 14300 },
+	{ 0x004a, 14400 }, { 0x0049, 14500 }, { 0x0047, 14600 },
+	{ 0x0045, 14700 }, { 0x0044, 14800 }, { 0x0042, 14900 },
+	{ 0x0041, 15000 }, { 0x003f, 15100 }, { 0x003e, 15200 },
+	{ 0x003c, 15300 }, { 0x003b, 15400 }, { 0x003a, 15500 },
+	{ 0x0038, 15600 }, { 0x0037, 15700 }, { 0x0036, 15800 },
+	{ 0x0034, 15900 }, { 0x0033, 16000 }, { 0x0032, 16100 },
+	{ 0x0031, 16200 }, { 0x0030, 16300 }, { 0x002f, 16400 },
+	{ 0x002e, 16500 }, { 0x002d, 16600 }, { 0x002c, 16700 },
+	{ 0x002b, 16800 }, { 0x002a, 16900 }, { 0x0029, 17000 },
+	{ 0x0028, 17100 }, { 0x0027, 17200 }, { 0x0026, 17300 },
+	{ 0x0025, 17400 }, { 0x0024, 17500 }, { 0x0023, 17600 },
+	{ 0x0022, 17800 }, { 0x0021, 17900 }, { 0x0020, 18000 },
+	{ 0x001f, 18200 }, { 0x001e, 18300 }, { 0x001d, 18500 },
+	{ 0x001c, 18700 }, { 0x001b, 18900 }, { 0x001a, 19000 },
+	{ 0x0019, 19200 }, { 0x0018, 19300 }, { 0x0017, 19500 },
+	{ 0x0016, 19700 }, { 0x0015, 19900 }, { 0x0014, 20000 },
+};
+
+#define MAKE_IFFREQ_CONFIG(iffreq) ((u32)(((iffreq)/41.0)*16777216.0 + 0.5))
+#define MAKE_IFFREQ_CONFIG_XTAL(xtal, iffreq) ((xtal == SONY_XTAL_24000) ? \
+		(u32)(((iffreq)/48.0)*16777216.0 + 0.5) : \
+		(u32)(((iffreq)/41.0)*16777216.0 + 0.5))
+
+static void cxd2841er_i2c_debug(struct cxd2841er_priv *priv,
+				u8 addr, u8 reg, u8 write,
+				const u8 *data, u32 len)
+{
+	dev_dbg(&priv->i2c->dev,
+		"cxd2841er: I2C %s addr %02x reg 0x%02x size %d\n",
+		(write == 0 ? "read" : "write"), addr, reg, len);
+	print_hex_dump_bytes("cxd2841er: I2C data: ",
+		DUMP_PREFIX_OFFSET, data, len);
+}
+
+static int cxd2841er_write_regs(struct cxd2841er_priv *priv,
+				u8 addr, u8 reg, const u8 *data, u32 len)
+{
+	int ret;
+	u8 buf[MAX_WRITE_REGSIZE + 1];
+	u8 i2c_addr = (addr == I2C_SLVX ?
+		priv->i2c_addr_slvx : priv->i2c_addr_slvt);
+	struct i2c_msg msg[1] = {
+		{
+			.addr = i2c_addr,
+			.flags = 0,
+			.len = len + 1,
+			.buf = buf,
+		}
+	};
+
+	if (len + 1 >= sizeof(buf)) {
+		dev_warn(&priv->i2c->dev, "wr reg=%04x: len=%d is too big!\n",
+			 reg, len + 1);
+		return -E2BIG;
+	}
+
+	cxd2841er_i2c_debug(priv, i2c_addr, reg, 1, data, len);
+	buf[0] = reg;
+	memcpy(&buf[1], data, len);
+
+	ret = i2c_transfer(priv->i2c, msg, 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c wr failed=%d addr=%02x reg=%02x len=%d\n",
+			KBUILD_MODNAME, ret, i2c_addr, reg, len);
+		return ret;
+	}
+	return 0;
+}
+
+static int cxd2841er_write_reg(struct cxd2841er_priv *priv,
+			       u8 addr, u8 reg, u8 val)
+{
+	return cxd2841er_write_regs(priv, addr, reg, &val, 1);
+}
+
+static int cxd2841er_read_regs(struct cxd2841er_priv *priv,
+			       u8 addr, u8 reg, u8 *val, u32 len)
+{
+	int ret;
+	u8 i2c_addr = (addr == I2C_SLVX ?
+		priv->i2c_addr_slvx : priv->i2c_addr_slvt);
+	struct i2c_msg msg[2] = {
+		{
+			.addr = i2c_addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &reg,
+		}, {
+			.addr = i2c_addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = val,
+		}
+	};
+
+	ret = i2c_transfer(priv->i2c, &msg[0], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c rw failed=%d addr=%02x reg=%02x\n",
+			KBUILD_MODNAME, ret, i2c_addr, reg);
+		return ret;
+	}
+	ret = i2c_transfer(priv->i2c, &msg[1], 1);
+	if (ret >= 0 && ret != 1)
+		ret = -EIO;
+	if (ret < 0) {
+		dev_warn(&priv->i2c->dev,
+			"%s: i2c rd failed=%d addr=%02x reg=%02x\n",
+			KBUILD_MODNAME, ret, i2c_addr, reg);
+		return ret;
+	}
+	cxd2841er_i2c_debug(priv, i2c_addr, reg, 0, val, len);
+	return 0;
+}
+
+static int cxd2841er_read_reg(struct cxd2841er_priv *priv,
+			      u8 addr, u8 reg, u8 *val)
+{
+	return cxd2841er_read_regs(priv, addr, reg, val, 1);
+}
+
+static int cxd2841er_set_reg_bits(struct cxd2841er_priv *priv,
+				  u8 addr, u8 reg, u8 data, u8 mask)
+{
+	int res;
+	u8 rdata;
+
+	if (mask != 0xff) {
+		res = cxd2841er_read_reg(priv, addr, reg, &rdata);
+		if (res)
+			return res;
+		data = ((data & mask) | (rdata & (mask ^ 0xFF)));
+	}
+	return cxd2841er_write_reg(priv, addr, reg, data);
+}
+
+static int cxd2841er_dvbs2_set_symbol_rate(struct cxd2841er_priv *priv,
+					   u32 symbol_rate)
+{
+	u32 reg_value = 0;
+	u8 data[3] = {0, 0, 0};
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	/*
+	 * regValue = (symbolRateKSps * 2^14 / 1000) + 0.5
+	 *          = ((symbolRateKSps * 2^14) + 500) / 1000
+	 *          = ((symbolRateKSps * 16384) + 500) / 1000
+	 */
+	reg_value = DIV_ROUND_CLOSEST(symbol_rate * 16384, 1000);
+	if ((reg_value == 0) || (reg_value > 0xFFFFF)) {
+		dev_err(&priv->i2c->dev,
+			"%s(): reg_value is out of range\n", __func__);
+		return -EINVAL;
+	}
+	data[0] = (u8)((reg_value >> 16) & 0x0F);
+	data[1] = (u8)((reg_value >>  8) & 0xFF);
+	data[2] = (u8)(reg_value & 0xFF);
+	/* Set SLV-T Bank : 0xAE */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x20, data, 3);
+	return 0;
+}
+
+static void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,
+					u8 system);
+
+static int cxd2841er_sleep_s_to_active_s(struct cxd2841er_priv *priv,
+					 u8 system, u32 symbol_rate)
+{
+	int ret;
+	u8 data[4] = { 0, 0, 0, 0 };
+
+	if (priv->state != STATE_SLEEP_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, (int)priv->state);
+		return -EINVAL;
+	}
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBS);
+	/* Set demod mode */
+	if (system == SYS_DVBS) {
+		data[0] = 0x0A;
+	} else if (system == SYS_DVBS2) {
+		data[0] = 0x0B;
+	} else {
+		dev_err(&priv->i2c->dev, "%s(): invalid delsys %d\n",
+			__func__, system);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, data[0]);
+	/* DVB-S/S2 */
+	data[0] = 0x00;
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable S/S2 auto detection 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2d, data[0]);
+	/* Set SLV-T Bank : 0xAE */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);
+	/* Enable S/S2 auto detection 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, data[0]);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x01);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	/* Enable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x3f);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Enable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0xA3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa3);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xac, 0x00);
+	data[0] = 0x07;
+	data[1] = 0x3B;
+	data[2] = 0x08;
+	data[3] = 0xC5;
+	/* Set SLV-T Bank : 0xAB */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xab);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x98, data, 4);
+	data[0] = 0x05;
+	data[1] = 0x80;
+	data[2] = 0x0A;
+	data[3] = 0x80;
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xa8, data, 4);
+	data[0] = 0x0C;
+	data[1] = 0xCC;
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xc3, data, 2);
+	/* Set demod parameter */
+	ret = cxd2841er_dvbs2_set_symbol_rate(priv, symbol_rate);
+	if (ret != 0)
+		return ret;
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x10);
+	/* disable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_S;
+	return 0;
+}
+
+static int cxd2841er_init_tc(struct dvb_frontend *fe);
+
+static int cxd2841er_sleep_tc_to_active_t_band(struct cxd2841er_priv *priv,
+					       u32 bandwidth);
+
+static int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,
+						u32 bandwidth);
+
+static int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,
+					       u32 bandwidth);
+
+static int cxd2841er_sleep_tc_to_active_i(struct cxd2841er_priv *priv,
+		u32 bandwidth);
+
+static int cxd2841er_active_i_to_sleep_tc(struct cxd2841er_priv *priv);
+
+static int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv);
+
+static int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv);
+
+static int cxd2841er_retune_active(struct cxd2841er_priv *priv,
+				   struct dtv_frontend_properties *p)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_S &&
+			priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	if (priv->state == STATE_ACTIVE_S)
+		return cxd2841er_dvbs2_set_symbol_rate(
+				priv, p->symbol_rate / 1000);
+	else if (priv->state == STATE_ACTIVE_TC) {
+		switch (priv->system) {
+		case SYS_DVBT:
+			return cxd2841er_sleep_tc_to_active_t_band(
+					priv, p->bandwidth_hz);
+		case SYS_DVBT2:
+			return cxd2841er_sleep_tc_to_active_t2_band(
+					priv, p->bandwidth_hz);
+		case SYS_DVBC_ANNEX_A:
+			return cxd2841er_sleep_tc_to_active_c_band(
+					priv, p->bandwidth_hz);
+		case SYS_ISDBT:
+			cxd2841er_active_i_to_sleep_tc(priv);
+			cxd2841er_sleep_tc_to_shutdown(priv);
+			cxd2841er_shutdown_to_sleep_tc(priv);
+			return cxd2841er_sleep_tc_to_active_i(
+					priv, p->bandwidth_hz);
+		}
+	}
+	dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+		__func__, priv->system);
+	return -EINVAL;
+}
+
+static int cxd2841er_active_s_to_sleep_s(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x00);
+	/* disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	/* disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);
+	/* SADC Bias ON */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);
+	/* disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	/* Set SLV-T Bank : 0xAE */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);
+	/* disable S/S2 auto detection1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable S/S2 auto detection2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2d, 0x00);
+	priv->state = STATE_SLEEP_S;
+	return 0;
+}
+
+static int cxd2841er_sleep_s_to_shutdown(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SLEEP_S) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable DSQOUT */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* Disable DSQIN */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9c, 0x00);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Disable oscillator */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);
+	priv->state = STATE_SHUTDOWN;
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SLEEP_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Disable oscillator */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);
+	priv->state = STATE_SHUTDOWN;
+	return 0;
+}
+
+static int cxd2841er_active_t_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_active_t2_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Cancel DVB-T2 setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x40);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x21);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xfb);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x00, 0x0f);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x00, 0x3f);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_active_c_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+	/* Cancel DVB-C setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa3, 0x00, 0x1f);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_active_i_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* disable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);
+	/* enable Hi-Z setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);
+	/* enable Hi-Z setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);
+
+	/* TODO: Cancel demod parameter */
+
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* disable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable ADC 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	/* Disable ADC 3 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* Disable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Disable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_shutdown_to_sleep_s(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SHUTDOWN) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Clear all demodulator registers */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);
+	usleep_range(3000, 5000);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);
+
+	switch (priv->xtal) {
+	case SONY_XTAL_20500:
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x00);
+		break;
+	case SONY_XTAL_24000:
+		/* Select demod frequency */
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x03);
+		break;
+	case SONY_XTAL_41000:
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x01);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod xtal %d\n",
+				__func__, priv->xtal);
+		return -EINVAL;
+	}
+
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x0a);
+	/* Clear demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);
+	usleep_range(1000, 2000);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* enable DSQOUT */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1F);
+	/* enable DSQIN */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9C, 0x40);
+	/* TADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* SADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);
+	priv->state = STATE_SLEEP_S;
+	return 0;
+}
+
+static int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv)
+{
+	u8 data = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_SHUTDOWN) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Clear all demodulator registers */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);
+	usleep_range(3000, 5000);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);
+  /* Select ADC clock mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x13, 0x00);
+
+	switch (priv->xtal) {
+	case SONY_XTAL_20500:
+		data = 0x0;
+		break;
+	case SONY_XTAL_24000:
+		/* Select demod frequency */
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);
+		data = 0x3;
+		break;
+	case SONY_XTAL_41000:
+		cxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);
+		data = 0x1;
+		break;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x14, data);
+	/* Clear demod SW reset */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);
+	usleep_range(1000, 2000);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);
+	/* SADC Bias On */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);
+	priv->state = STATE_SLEEP_TC;
+	return 0;
+}
+
+static int cxd2841er_tune_done(struct cxd2841er_priv *priv)
+{
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0, 0);
+	/* SW Reset */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xfe, 0x01);
+	/* Enable TS output */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x00);
+	return 0;
+}
+
+/* Set TS parallel mode */
+static void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,
+					u8 system)
+{
+	u8 serial_ts, ts_rate_ctrl_off, ts_in_off;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0xc4, &serial_ts);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0xd3, &ts_rate_ctrl_off);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0xde, &ts_in_off);
+	dev_dbg(&priv->i2c->dev, "%s(): ser_ts=0x%02x rate_ctrl_off=0x%02x in_off=0x%02x\n",
+		__func__, serial_ts, ts_rate_ctrl_off, ts_in_off);
+
+	/*
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     D9h     [7:0]  8'h08      OTSCKPERIOD
+	 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xd9, 0x08);
+	/*
+	 * Disable TS IF Clock
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     32h     [0]    1'b1       OREG_CK_TSIF_EN
+	 */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x00, 0x01);
+	/*
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     33h     [1:0]  2'b01      OREG_CKSEL_TSIF
+	 */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x33, 0x00, 0x03);
+	/*
+	 * Enable TS IF Clock
+	 * slave    Bank    Addr    Bit    default    Name
+	 * <SLV-T>  00h     32h     [0]    1'b1       OREG_CK_TSIF_EN
+	 */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x01, 0x01);
+
+	if (system == SYS_DVBT) {
+		/* Enable parity period for DVB-T */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);
+	} else if (system == SYS_DVBC_ANNEX_A) {
+		/* Enable parity period for DVB-C */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);
+	}
+}
+
+static u8 cxd2841er_chip_id(struct cxd2841er_priv *priv)
+{
+	u8 chip_id = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (cxd2841er_write_reg(priv, I2C_SLVT, 0, 0) == 0)
+		cxd2841er_read_reg(priv, I2C_SLVT, 0xfd, &chip_id);
+	else if (cxd2841er_write_reg(priv, I2C_SLVX, 0, 0) == 0)
+		cxd2841er_read_reg(priv, I2C_SLVX, 0xfd, &chip_id);
+
+	return chip_id;
+}
+
+static int cxd2841er_read_status_s(struct dvb_frontend *fe,
+				   enum fe_status *status)
+{
+	u8 reg = 0;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	*status = 0;
+	if (priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0xA0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       11h       [2]      ITSLOCK
+	 */
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x11, &reg);
+	if (reg & 0x04) {
+		*status = FE_HAS_SIGNAL
+			| FE_HAS_CARRIER
+			| FE_HAS_VITERBI
+			| FE_HAS_SYNC
+			| FE_HAS_LOCK;
+	}
+	dev_dbg(&priv->i2c->dev, "%s(): result 0x%x\n", __func__, *status);
+	return 0;
+}
+
+static int cxd2841er_read_status_t_t2(struct cxd2841er_priv *priv,
+				      u8 *sync, u8 *tslock, u8 *unlock)
+{
+	u8 data = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC)
+		return -EINVAL;
+	if (priv->system == SYS_DVBT) {
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	} else {
+		/* Set SLV-T Bank : 0x20 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	}
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);
+	if ((data & 0x07) == 0x07) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid hardware state detected\n", __func__);
+		*sync = 0;
+		*tslock = 0;
+		*unlock = 0;
+	} else {
+		*sync = ((data & 0x07) == 0x6 ? 1 : 0);
+		*tslock = ((data & 0x20) ? 1 : 0);
+		*unlock = ((data & 0x10) ? 1 : 0);
+	}
+	return 0;
+}
+
+static int cxd2841er_read_status_c(struct cxd2841er_priv *priv, u8 *tslock)
+{
+	u8 data;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC)
+		return -EINVAL;
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x88, &data);
+	if ((data & 0x01) == 0) {
+		*tslock = 0;
+	} else {
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);
+		*tslock = ((data & 0x20) ? 1 : 0);
+	}
+	return 0;
+}
+
+static int cxd2841er_read_status_i(struct cxd2841er_priv *priv,
+		u8 *sync, u8 *tslock, u8 *unlock)
+{
+	u8 data = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC)
+		return -EINVAL;
+	/* Set SLV-T Bank : 0x60 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);
+	dev_dbg(&priv->i2c->dev,
+			"%s(): lock=0x%x\n", __func__, data);
+	*sync = ((data & 0x02) ? 1 : 0);
+	*tslock = ((data & 0x01) ? 1 : 0);
+	*unlock = ((data & 0x10) ? 1 : 0);
+	return 0;
+}
+
+static int cxd2841er_read_status_tc(struct dvb_frontend *fe,
+				    enum fe_status *status)
+{
+	int ret = 0;
+	u8 sync = 0;
+	u8 tslock = 0;
+	u8 unlock = 0;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	*status = 0;
+	if (priv->state == STATE_ACTIVE_TC) {
+		if (priv->system == SYS_DVBT || priv->system == SYS_DVBT2) {
+			ret = cxd2841er_read_status_t_t2(
+				priv, &sync, &tslock, &unlock);
+			if (ret)
+				goto done;
+			if (unlock)
+				goto done;
+			if (sync)
+				*status = FE_HAS_SIGNAL |
+					FE_HAS_CARRIER |
+					FE_HAS_VITERBI |
+					FE_HAS_SYNC;
+			if (tslock)
+				*status |= FE_HAS_LOCK;
+		} else if (priv->system == SYS_ISDBT) {
+			ret = cxd2841er_read_status_i(
+					priv, &sync, &tslock, &unlock);
+			if (ret)
+				goto done;
+			if (unlock)
+				goto done;
+			if (sync)
+				*status = FE_HAS_SIGNAL |
+					FE_HAS_CARRIER |
+					FE_HAS_VITERBI |
+					FE_HAS_SYNC;
+			if (tslock)
+				*status |= FE_HAS_LOCK;
+		} else if (priv->system == SYS_DVBC_ANNEX_A) {
+			ret = cxd2841er_read_status_c(priv, &tslock);
+			if (ret)
+				goto done;
+			if (tslock)
+				*status = FE_HAS_SIGNAL |
+					FE_HAS_CARRIER |
+					FE_HAS_VITERBI |
+					FE_HAS_SYNC |
+					FE_HAS_LOCK;
+		}
+	}
+done:
+	dev_dbg(&priv->i2c->dev, "%s(): status 0x%x\n", __func__, *status);
+	return ret;
+}
+
+static int cxd2841er_get_carrier_offset_s_s2(struct cxd2841er_priv *priv,
+					     int *offset)
+{
+	u8 data[3];
+	u8 is_hs_mode;
+	s32 cfrl_ctrlval;
+	s32 temp_div, temp_q, temp_r;
+
+	if (priv->state != STATE_ACTIVE_S) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	/*
+	 * Get High Sampling Rate mode
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       10h       [0]      ITRL_LOCK
+	 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data[0]);
+	if (data[0] & 0x01) {
+		/*
+		 *  slave     Bank      Addr      Bit      Signal name
+		 * <SLV-T>    A0h       50h       [4]      IHSMODE
+		 */
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x50, &data[0]);
+		is_hs_mode = (data[0] & 0x10 ? 1 : 0);
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): unable to detect sampling rate mode\n",
+			__func__);
+		return -EINVAL;
+	}
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       45h       [4:0]    ICFRL_CTRLVAL[20:16]
+	 * <SLV-T>    A0h       46h       [7:0]    ICFRL_CTRLVAL[15:8]
+	 * <SLV-T>    A0h       47h       [7:0]    ICFRL_CTRLVAL[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x45, data, 3);
+	cfrl_ctrlval = sign_extend32((((u32)data[0] & 0x1F) << 16) |
+				(((u32)data[1] & 0xFF) <<  8) |
+				((u32)data[2] & 0xFF), 20);
+	temp_div = (is_hs_mode ? 1048576 : 1572864);
+	if (cfrl_ctrlval > 0) {
+		temp_q = div_s64_rem(97375LL * cfrl_ctrlval,
+			temp_div, &temp_r);
+	} else {
+		temp_q = div_s64_rem(-97375LL * cfrl_ctrlval,
+			temp_div, &temp_r);
+	}
+	if (temp_r >= temp_div / 2)
+		temp_q++;
+	if (cfrl_ctrlval > 0)
+		temp_q *= -1;
+	*offset = temp_q;
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_i(struct cxd2841er_priv *priv,
+					   u32 bandwidth, int *offset)
+{
+	u8 data[4];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_ISDBT) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));
+	*offset = -1 * sign_extend32(
+		((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |
+		((u32)data[2] << 8) | (u32)data[3], 29);
+
+	switch (bandwidth) {
+	case 6000000:
+		*offset = -1 * ((*offset) * 8/264);
+		break;
+	case 7000000:
+		*offset = -1 * ((*offset) * 8/231);
+		break;
+	case 8000000:
+		*offset = -1 * ((*offset) * 8/198);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",
+				__func__, bandwidth);
+		return -EINVAL;
+	}
+
+	dev_dbg(&priv->i2c->dev, "%s(): bandwidth %d offset %d\n",
+			__func__, bandwidth, *offset);
+
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_t(struct cxd2841er_priv *priv,
+					   u32 bandwidth, int *offset)
+{
+	u8 data[4];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_DVBT) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));
+	*offset = -1 * sign_extend32(
+		((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |
+		((u32)data[2] << 8) | (u32)data[3], 29);
+	*offset *= (bandwidth / 1000000);
+	*offset /= 235;
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_t2(struct cxd2841er_priv *priv,
+					   u32 bandwidth, int *offset)
+{
+	u8 data[4];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_DVBT2) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));
+	*offset = -1 * sign_extend32(
+		((u32)(data[0] & 0x0F) << 24) | ((u32)data[1] << 16) |
+		((u32)data[2] << 8) | (u32)data[3], 27);
+	switch (bandwidth) {
+	case 1712000:
+		*offset /= 582;
+		break;
+	case 5000000:
+	case 6000000:
+	case 7000000:
+	case 8000000:
+		*offset *= (bandwidth / 1000000);
+		*offset /= 940;
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",
+			__func__, bandwidth);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cxd2841er_get_carrier_offset_c(struct cxd2841er_priv *priv,
+					  int *offset)
+{
+	u8 data[2];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	if (priv->system != SYS_DVBC_ANNEX_A) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",
+			__func__, priv->system);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x15, data, sizeof(data));
+	*offset = div_s64(41000LL * sign_extend32((((u32)data[0] & 0x3f) << 8)
+						| (u32)data[1], 13), 16384);
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_c(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[3];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));
+	if (data[2] & 0x01)
+		*penum = ((u32)data[0] << 8) | (u32)data[1];
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_t(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[3];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));
+	if (data[2] & 0x01)
+		*penum = ((u32)data[0] << 8) | (u32)data[1];
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_t2(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[3];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xfd, data, sizeof(data));
+	if (data[0] & 0x01)
+		*penum = ((u32)data[1] << 8) | (u32)data[2];
+	return 0;
+}
+
+static int cxd2841er_read_packet_errors_i(
+		struct cxd2841er_priv *priv, u32 *penum)
+{
+	u8 data[2];
+
+	*penum = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA1, data, 1);
+
+	if (!(data[0] & 0x01))
+		return 0;
+
+	/* Layer A */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA2, data, sizeof(data));
+	*penum = ((u32)data[0] << 8) | (u32)data[1];
+
+	/* Layer B */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA4, data, sizeof(data));
+	*penum += ((u32)data[0] << 8) | (u32)data[1];
+
+	/* Layer C */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0xA6, data, sizeof(data));
+	*penum += ((u32)data[0] << 8) | (u32)data[1];
+
+	return 0;
+}
+
+static int cxd2841er_read_ber_c(struct cxd2841er_priv *priv,
+		u32 *bit_error, u32 *bit_count)
+{
+	u8 data[3];
+	u32 bit_err, period_exp;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x62, data, sizeof(data));
+	if (!(data[0] & 0x80)) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): no valid BER data\n", __func__);
+		return -EINVAL;
+	}
+	bit_err = ((u32)(data[0] & 0x3f) << 16) |
+		((u32)data[1] << 8) |
+		(u32)data[2];
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x60, data);
+	period_exp = data[0] & 0x1f;
+
+	if ((period_exp <= 11) && (bit_err > (1 << period_exp) * 204 * 8)) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): period_exp(%u) or bit_err(%u)  not in range. no valid BER data\n",
+				__func__, period_exp, bit_err);
+		return -EINVAL;
+	}
+
+	dev_dbg(&priv->i2c->dev,
+			"%s(): period_exp(%u) or bit_err(%u) count=%d\n",
+			__func__, period_exp, bit_err,
+			((1 << period_exp) * 204 * 8));
+
+	*bit_error = bit_err;
+	*bit_count = ((1 << period_exp) * 204 * 8);
+
+	return 0;
+}
+
+static int cxd2841er_mon_read_ber_s(struct cxd2841er_priv *priv,
+				    u32 *bit_error, u32 *bit_count)
+{
+	u8 data[11];
+
+	/* Set SLV-T Bank : 0xA0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    A0h       35h       [0]      IFVBER_VALID
+	 * <SLV-T>    A0h       36h       [5:0]    IFVBER_BITERR[21:16]
+	 * <SLV-T>    A0h       37h       [7:0]    IFVBER_BITERR[15:8]
+	 * <SLV-T>    A0h       38h       [7:0]    IFVBER_BITERR[7:0]
+	 * <SLV-T>    A0h       3Dh       [5:0]    IFVBER_BITNUM[21:16]
+	 * <SLV-T>    A0h       3Eh       [7:0]    IFVBER_BITNUM[15:8]
+	 * <SLV-T>    A0h       3Fh       [7:0]    IFVBER_BITNUM[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x35, data, 11);
+	if (data[0] & 0x01) {
+		*bit_error = ((u32)(data[1]  & 0x3F) << 16) |
+			     ((u32)(data[2]  & 0xFF) <<  8) |
+			     (u32)(data[3]  & 0xFF);
+		*bit_count = ((u32)(data[8]  & 0x3F) << 16) |
+			     ((u32)(data[9]  & 0xFF) <<  8) |
+			     (u32)(data[10] & 0xFF);
+		if ((*bit_count == 0) || (*bit_error > *bit_count)) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): invalid bit_error %d, bit_count %d\n",
+				__func__, *bit_error, *bit_count);
+			return -EINVAL;
+		}
+		return 0;
+	}
+	dev_dbg(&priv->i2c->dev, "%s(): no data available\n", __func__);
+	return -EINVAL;
+}
+
+
+static int cxd2841er_mon_read_ber_s2(struct cxd2841er_priv *priv,
+				     u32 *bit_error, u32 *bit_count)
+{
+	u8 data[5];
+	u32 period;
+
+	/* Set SLV-T Bank : 0xB2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xb2);
+	/*
+	 *  slave     Bank      Addr      Bit      Signal name
+	 * <SLV-T>    B2h       30h       [0]      IFLBER_VALID
+	 * <SLV-T>    B2h       31h       [3:0]    IFLBER_BITERR[27:24]
+	 * <SLV-T>    B2h       32h       [7:0]    IFLBER_BITERR[23:16]
+	 * <SLV-T>    B2h       33h       [7:0]    IFLBER_BITERR[15:8]
+	 * <SLV-T>    B2h       34h       [7:0]    IFLBER_BITERR[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x30, data, 5);
+	if (data[0] & 0x01) {
+		/* Bit error count */
+		*bit_error = ((u32)(data[1] & 0x0F) << 24) |
+			     ((u32)(data[2] & 0xFF) << 16) |
+			     ((u32)(data[3] & 0xFF) <<  8) |
+			     (u32)(data[4] & 0xFF);
+
+		/* Set SLV-T Bank : 0xA0 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x7a, data);
+		/* Measurement period */
+		period = (u32)(1 << (data[0] & 0x0F));
+		if (period == 0) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): period is 0\n", __func__);
+			return -EINVAL;
+		}
+		if (*bit_error > (period * 64800)) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): invalid bit_err 0x%x period 0x%x\n",
+				__func__, *bit_error, period);
+			return -EINVAL;
+		}
+		*bit_count = period * 64800;
+
+		return 0;
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no data available\n", __func__);
+	}
+	return -EINVAL;
+}
+
+static int cxd2841er_read_ber_t2(struct cxd2841er_priv *priv,
+				 u32 *bit_error, u32 *bit_count)
+{
+	u8 data[4];
+	u32 period_exp, n_ldpc;
+
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x39, data, sizeof(data));
+	if (!(data[0] & 0x10)) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no valid BER data\n", __func__);
+		return -EINVAL;
+	}
+	*bit_error = ((u32)(data[0] & 0x0f) << 24) |
+		     ((u32)data[1] << 16) |
+		     ((u32)data[2] << 8) |
+		     (u32)data[3];
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);
+	period_exp = data[0] & 0x0f;
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x22);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x5e, data);
+	n_ldpc = ((data[0] & 0x03) == 0 ? 16200 : 64800);
+	if (*bit_error > ((1U << period_exp) * n_ldpc)) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid BER value\n", __func__);
+		return -EINVAL;
+	}
+
+	/*
+	 * FIXME: the right thing would be to return bit_error untouched,
+	 * but, as we don't know the scale returned by the counters, let's
+	 * at least preserver BER = bit_error/bit_count.
+	 */
+	if (period_exp >= 4) {
+		*bit_count = (1U << (period_exp - 4)) * (n_ldpc / 200);
+		*bit_error *= 3125ULL;
+	} else {
+		*bit_count = (1U << period_exp) * (n_ldpc / 200);
+		*bit_error *= 50000ULL;
+	}
+	return 0;
+}
+
+static int cxd2841er_read_ber_t(struct cxd2841er_priv *priv,
+				u32 *bit_error, u32 *bit_count)
+{
+	u8 data[2];
+	u32 period;
+
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x39, data);
+	if (!(data[0] & 0x01)) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no valid BER data\n", __func__);
+		return 0;
+	}
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x22, data, sizeof(data));
+	*bit_error = ((u32)data[0] << 8) | (u32)data[1];
+	cxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);
+	period = ((data[0] & 0x07) == 0) ? 256 : (4096 << (data[0] & 0x07));
+
+	/*
+	 * FIXME: the right thing would be to return bit_error untouched,
+	 * but, as we don't know the scale returned by the counters, let's
+	 * at least preserver BER = bit_error/bit_count.
+	 */
+	*bit_count = period / 128;
+	*bit_error *= 78125ULL;
+	return 0;
+}
+
+static u32 cxd2841er_dvbs_read_snr(struct cxd2841er_priv *priv,
+		u8 delsys, u32 *snr)
+{
+	u8 data[3];
+	u32 res = 0, value;
+	int min_index, max_index, index;
+	static const struct cxd2841er_cnr_data *cn_data;
+
+	/* Set SLV-T Bank : 0xA1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa1);
+	/*
+	 *  slave     Bank      Addr      Bit     Signal name
+	 * <SLV-T>    A1h       10h       [0]     ICPM_QUICKRDY
+	 * <SLV-T>    A1h       11h       [4:0]   ICPM_QUICKCNDT[12:8]
+	 * <SLV-T>    A1h       12h       [7:0]   ICPM_QUICKCNDT[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x10, data, 3);
+	if (data[0] & 0x01) {
+		value = ((u32)(data[1] & 0x1F) << 8) | (u32)(data[2] & 0xFF);
+		min_index = 0;
+		if (delsys == SYS_DVBS) {
+			cn_data = s_cn_data;
+			max_index = sizeof(s_cn_data) /
+				sizeof(s_cn_data[0]) - 1;
+		} else {
+			cn_data = s2_cn_data;
+			max_index = sizeof(s2_cn_data) /
+				sizeof(s2_cn_data[0]) - 1;
+		}
+		if (value >= cn_data[min_index].value) {
+			res = cn_data[min_index].cnr_x1000;
+			goto done;
+		}
+		if (value <= cn_data[max_index].value) {
+			res = cn_data[max_index].cnr_x1000;
+			goto done;
+		}
+		while ((max_index - min_index) > 1) {
+			index = (max_index + min_index) / 2;
+			if (value == cn_data[index].value) {
+				res = cn_data[index].cnr_x1000;
+				goto done;
+			} else if (value > cn_data[index].value)
+				max_index = index;
+			else
+				min_index = index;
+			if ((max_index - min_index) <= 1) {
+				if (value == cn_data[max_index].value) {
+					res = cn_data[max_index].cnr_x1000;
+					goto done;
+				} else {
+					res = cn_data[min_index].cnr_x1000;
+					goto done;
+				}
+			}
+		}
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): no data available\n", __func__);
+		return -EINVAL;
+	}
+done:
+	*snr = res;
+	return 0;
+}
+
+static uint32_t sony_log(uint32_t x)
+{
+	return (((10000>>8)*(intlog2(x)>>16) + LOG2_E_100X/2)/LOG2_E_100X);
+}
+
+static int cxd2841er_read_snr_c(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+	enum sony_dvbc_constellation_t qam = SONY_DVBC_CONSTELLATION_16QAM;
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): invalid state %d\n",
+				__func__, priv->state);
+		return -EINVAL;
+	}
+
+	/*
+	 * Freeze registers: ensure multiple separate register reads
+	 * are from the same snapshot
+	 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x01);
+
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x19, data, 1);
+	qam = (enum sony_dvbc_constellation_t) (data[0] & 0x07);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x4C, data, 2);
+
+	reg = ((u32)(data[0]&0x1f) << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+
+	switch (qam) {
+	case SONY_DVBC_CONSTELLATION_16QAM:
+	case SONY_DVBC_CONSTELLATION_64QAM:
+	case SONY_DVBC_CONSTELLATION_256QAM:
+		/* SNR(dB) = -9.50 * ln(IREG_SNR_ESTIMATE / (24320)) */
+		if (reg < 126)
+			reg = 126;
+		*snr = -95 * (int32_t)sony_log(reg) + 95941;
+		break;
+	case SONY_DVBC_CONSTELLATION_32QAM:
+	case SONY_DVBC_CONSTELLATION_128QAM:
+		/* SNR(dB) = -8.75 * ln(IREG_SNR_ESTIMATE / (20800)) */
+		if (reg < 69)
+			reg = 69;
+		*snr = -88 * (int32_t)sony_log(reg) + 86999;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cxd2841er_read_snr_t(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));
+	reg = ((u32)data[0] << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+	if (reg > 4996)
+		reg = 4996;
+	*snr = 10000 * ((intlog10(reg) - intlog10(5350 - reg)) >> 24) + 28500;
+	return 0;
+}
+
+static int cxd2841er_read_snr_t2(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid state %d\n", __func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));
+	reg = ((u32)data[0] << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+	if (reg > 10876)
+		reg = 10876;
+	*snr = 10000 * ((intlog10(reg) -
+		intlog10(12600 - reg)) >> 24) + 32000;
+	return 0;
+}
+
+static int cxd2841er_read_snr_i(struct cxd2841er_priv *priv, u32 *snr)
+{
+	u32 reg;
+	u8 data[2];
+
+	*snr = 0;
+	if (priv->state != STATE_ACTIVE_TC) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): invalid state %d\n", __func__,
+				priv->state);
+		return -EINVAL;
+	}
+
+	/* Freeze all registers */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x01);
+
+
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));
+	reg = ((u32)data[0] << 8) | (u32)data[1];
+	if (reg == 0) {
+		dev_dbg(&priv->i2c->dev,
+				"%s(): reg value out of range\n", __func__);
+		return 0;
+	}
+	if (reg > 4996)
+		reg = 4996;
+	*snr = 100 * intlog10(reg) - 9031;
+	return 0;
+}
+
+static u16 cxd2841er_read_agc_gain_c(struct cxd2841er_priv *priv,
+					u8 delsys)
+{
+	u8 data[2];
+
+	cxd2841er_write_reg(
+		priv, I2C_SLVT, 0x00, 0x40);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x49, data, 2);
+	dev_dbg(&priv->i2c->dev,
+			"%s(): AGC value=%u\n",
+			__func__, (((u16)data[0] & 0x0F) << 8) |
+			(u16)(data[1] & 0xFF));
+	return ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;
+}
+
+static u16 cxd2841er_read_agc_gain_t_t2(struct cxd2841er_priv *priv,
+					u8 delsys)
+{
+	u8 data[2];
+
+	cxd2841er_write_reg(
+		priv, I2C_SLVT, 0x00, (delsys == SYS_DVBT ? 0x10 : 0x20));
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);
+	dev_dbg(&priv->i2c->dev,
+			"%s(): AGC value=%u\n",
+			__func__, (((u16)data[0] & 0x0F) << 8) |
+			(u16)(data[1] & 0xFF));
+	return ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;
+}
+
+static u16 cxd2841er_read_agc_gain_i(struct cxd2841er_priv *priv,
+		u8 delsys)
+{
+	u8 data[2];
+
+	cxd2841er_write_reg(
+			priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);
+
+	dev_dbg(&priv->i2c->dev,
+			"%s(): AGC value=%u\n",
+			__func__, (((u16)data[0] & 0x0F) << 8) |
+			(u16)(data[1] & 0xFF));
+	return ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;
+}
+
+static u16 cxd2841er_read_agc_gain_s(struct cxd2841er_priv *priv)
+{
+	u8 data[2];
+
+	/* Set SLV-T Bank : 0xA0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	/*
+	 *  slave     Bank      Addr      Bit       Signal name
+	 * <SLV-T>    A0h       1Fh       [4:0]     IRFAGC_GAIN[12:8]
+	 * <SLV-T>    A0h       20h       [7:0]     IRFAGC_GAIN[7:0]
+	 */
+	cxd2841er_read_regs(priv, I2C_SLVT, 0x1f, data, 2);
+	return ((((u16)data[0] & 0x1F) << 8) | (u16)(data[1] & 0xFF)) << 3;
+}
+
+static void cxd2841er_read_ber(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	u32 ret, bit_error = 0, bit_count = 0;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		ret = cxd2841er_read_ber_c(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBS:
+		ret = cxd2841er_mon_read_ber_s(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBS2:
+		ret = cxd2841er_mon_read_ber_s2(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBT:
+		ret = cxd2841er_read_ber_t(priv, &bit_error, &bit_count);
+		break;
+	case SYS_DVBT2:
+		ret = cxd2841er_read_ber_t2(priv, &bit_error, &bit_count);
+		break;
+	default:
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+
+	if (!ret) {
+		p->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_error.stat[0].uvalue += bit_error;
+		p->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;
+		p->post_bit_count.stat[0].uvalue += bit_count;
+	} else {
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+}
+
+static void cxd2841er_read_signal_strength(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	s32 strength;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		strength = cxd2841er_read_agc_gain_t_t2(priv,
+							p->delivery_system);
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		/* Formula was empirically determinated @ 410 MHz */
+		p->strength.stat[0].uvalue = strength * 366 / 100 - 89520;
+		break;	/* Code moved out of the function */
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		strength = cxd2841er_read_agc_gain_c(priv,
+							p->delivery_system);
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		/*
+		 * Formula was empirically determinated via linear regression,
+		 * using frequencies: 175 MHz, 410 MHz and 800 MHz, and a
+		 * stream modulated with QAM64
+		 */
+		p->strength.stat[0].uvalue = strength * 4045 / 1000 - 85224;
+		break;
+	case SYS_ISDBT:
+		strength = cxd2841er_read_agc_gain_i(priv, p->delivery_system);
+		p->strength.stat[0].scale = FE_SCALE_DECIBEL;
+		/*
+		 * Formula was empirically determinated via linear regression,
+		 * using frequencies: 175 MHz, 410 MHz and 800 MHz.
+		 */
+		p->strength.stat[0].uvalue = strength * 3775 / 1000 - 90185;
+		break;
+	case SYS_DVBS:
+	case SYS_DVBS2:
+		strength = 65535 - cxd2841er_read_agc_gain_s(priv);
+		p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+		p->strength.stat[0].uvalue = strength;
+		break;
+	default:
+		p->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		break;
+	}
+}
+
+static void cxd2841er_read_snr(struct dvb_frontend *fe)
+{
+	u32 tmp = 0;
+	int ret = 0;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		ret = cxd2841er_read_snr_c(priv, &tmp);
+		break;
+	case SYS_DVBT:
+		ret = cxd2841er_read_snr_t(priv, &tmp);
+		break;
+	case SYS_DVBT2:
+		ret = cxd2841er_read_snr_t2(priv, &tmp);
+		break;
+	case SYS_ISDBT:
+		ret = cxd2841er_read_snr_i(priv, &tmp);
+		break;
+	case SYS_DVBS:
+	case SYS_DVBS2:
+		ret = cxd2841er_dvbs_read_snr(priv, p->delivery_system, &tmp);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): unknown delivery system %d\n",
+			__func__, p->delivery_system);
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+
+	if (!ret) {
+		p->cnr.stat[0].scale = FE_SCALE_DECIBEL;
+		p->cnr.stat[0].svalue = tmp;
+	} else {
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+}
+
+static void cxd2841er_read_ucblocks(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	u32 ucblocks;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_B:
+	case SYS_DVBC_ANNEX_C:
+		cxd2841er_read_packet_errors_c(priv, &ucblocks);
+		break;
+	case SYS_DVBT:
+		cxd2841er_read_packet_errors_t(priv, &ucblocks);
+		break;
+	case SYS_DVBT2:
+		cxd2841er_read_packet_errors_t2(priv, &ucblocks);
+		break;
+	case SYS_ISDBT:
+		cxd2841er_read_packet_errors_i(priv, &ucblocks);
+		break;
+	default:
+		p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		return;
+	}
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+
+	p->block_error.stat[0].scale = FE_SCALE_COUNTER;
+	p->block_error.stat[0].uvalue = ucblocks;
+}
+
+static int cxd2841er_dvbt2_set_profile(
+	struct cxd2841er_priv *priv, enum cxd2841er_dvbt2_profile_t profile)
+{
+	u8 tune_mode;
+	u8 seq_not2d_time;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	switch (profile) {
+	case DVBT2_PROFILE_BASE:
+		tune_mode = 0x01;
+		/* Set early unlock time */
+		seq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x0E:0x0C;
+		break;
+	case DVBT2_PROFILE_LITE:
+		tune_mode = 0x05;
+		/* Set early unlock time */
+		seq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;
+		break;
+	case DVBT2_PROFILE_ANY:
+		tune_mode = 0x00;
+		/* Set early unlock time */
+		seq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;
+		break;
+	default:
+		return -EINVAL;
+	}
+	/* Set SLV-T Bank : 0x2E */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2e);
+	/* Set profile and tune mode */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x10, tune_mode, 0x07);
+	/* Set SLV-T Bank : 0x2B */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	/* Set early unlock detection time */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9d, seq_not2d_time);
+	return 0;
+}
+
+static int cxd2841er_dvbt2_set_plp_config(struct cxd2841er_priv *priv,
+					  u8 is_auto, u8 plp_id)
+{
+	if (is_auto) {
+		dev_dbg(&priv->i2c->dev,
+			"%s() using auto PLP selection\n", __func__);
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s() using manual PLP selection, ID %d\n",
+			__func__, plp_id);
+	}
+	/* Set SLV-T Bank : 0x23 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);
+	if (!is_auto) {
+		/* Manual PLP selection mode. Set the data PLP Id. */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xaf, plp_id);
+	}
+	/* Auto PLP select (Scanning mode = 0x00). Data PLP select = 0x01. */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xad, (is_auto ? 0x00 : 0x01));
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,
+						u32 bandwidth)
+{
+	u32 iffreq;
+	u8 data[MAX_WRITE_REGSIZE];
+
+	const uint8_t nominalRate8bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x15, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate7bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x14, 0x80, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x18, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x14, 0x80, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate6bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}, /* 20.5MHz XTal */
+		{0x1C, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate5bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}, /* 20.5MHz XTal */
+		{0x21, 0x99, 0x99, 0x99, 0x99}, /* 24MHz XTal */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}  /* 41MHz XTal */
+	};
+
+	const uint8_t nominalRate17bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x58, 0xE2, 0xAF, 0xE0, 0xBC}, /* 20.5MHz XTal */
+		{0x68, 0x0F, 0xA2, 0x32, 0xD0}, /* 24MHz XTal */
+		{0x58, 0xE2, 0xAF, 0xE0, 0xBC}  /* 41MHz XTal */
+	};
+
+	const uint8_t itbCoef8bw[3][14] = {
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,
+			0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8}, /* 20.5MHz XTal */
+		{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1,
+			0x29, 0xA5, 0x2A, 0xAC, 0x29, 0xB5}, /* 24MHz XTal   */
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,
+			0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef7bw[3][14] = {
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,
+			0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5}, /* 20.5MHz XTal */
+		{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0,
+			0x29, 0xA2, 0x2B, 0xA6, 0x2B, 0xAD}, /* 24MHz XTal   */
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,
+			0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef6bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,
+			0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef5bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,
+			0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+			0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+
+	const uint8_t itbCoef17bw[3][14] = {
+		{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,
+			0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99}, /* 20.5MHz XTal */
+		{0x33, 0x8E, 0x2B, 0x97, 0x2D, 0x95, 0x37, 0x8B,
+			0x30, 0x97, 0x2D, 0x9A, 0x21, 0xA4}, /* 24MHz XTal   */
+		{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,
+			0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99}  /* 41MHz XTal   */
+	};
+
+	/* Set SLV-T Bank : 0x20 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+
+	switch (bandwidth) {
+	case 8000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate8bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef8bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.80);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x00, 0x07);
+		break;
+	case 7000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate7bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef7bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.20);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x02, 0x07);
+		break;
+	case 6000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate6bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef6bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x04, 0x07);
+		break;
+	case 5000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate5bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x00, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef5bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x06, 0x07);
+		break;
+	case 1712000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate17bw[priv->xtal], 5);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT,
+				0x7a, 0x03, 0x0f);
+
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		 */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef17bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.50);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+				priv, I2C_SLVT, 0xD7, 0x03, 0x07);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t_band(
+		struct cxd2841er_priv *priv, u32 bandwidth)
+{
+	u8 data[MAX_WRITE_REGSIZE];
+	u32 iffreq;
+	u8 nominalRate8bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x15, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x11, 0xF0, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+	u8 nominalRate7bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x14, 0x80, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x18, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x14, 0x80, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+	u8 nominalRate6bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}, /* 20.5MHz XTal */
+		{0x1C, 0x00, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x17, 0xEA, 0xAA, 0xAA, 0xAA}  /* 41MHz XTal */
+	};
+	u8 nominalRate5bw[3][5] = {
+		/* TRCG Nominal Rate [37:0] */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}, /* 20.5MHz XTal */
+		{0x21, 0x99, 0x99, 0x99, 0x99}, /* 24MHz XTal */
+		{0x1C, 0xB3, 0x33, 0x33, 0x33}  /* 41MHz XTal */
+	};
+
+	u8 itbCoef8bw[3][14] = {
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,
+			0x1F, 0xA8, 0x2C, 0xC8}, /* 20.5MHz XTal */
+		{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29, 0xA5,
+			0x2A, 0xAC, 0x29, 0xB5}, /* 24MHz XTal   */
+		{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,
+			0x1F, 0xA8, 0x2C, 0xC8}  /* 41MHz XTal   */
+	};
+	u8 itbCoef7bw[3][14] = {
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,
+			0x26, 0xA9, 0x21, 0xA5}, /* 20.5MHz XTal */
+		{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29, 0xA2,
+			0x2B, 0xA6, 0x2B, 0xAD}, /* 24MHz XTal   */
+		{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,
+			0x26, 0xA9, 0x21, 0xA5}  /* 41MHz XTal   */
+	};
+	u8 itbCoef6bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,
+			0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+	u8 itbCoef5bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,
+			0x29, 0xA2, 0x29, 0xA8}, /* 24MHz XTal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,
+			0x00, 0xE6, 0x23, 0xA4}  /* 41MHz XTal   */
+	};
+
+	/* Set SLV-T Bank : 0x13 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);
+	/* Echo performance optimization setting */
+	data[0] = 0x01;
+	data[1] = 0x14;
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x9C, data, 2);
+
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+	switch (bandwidth) {
+	case 8000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate8bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef8bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.80);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x00, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x15;
+			data[1] = 0x28;
+		} else {
+			data[0] = 0x01;
+			data[1] = 0xE0;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x01;
+		data[1] = 0x02;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	case 7000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate7bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef7bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.20);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x02, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x1F;
+			data[1] = 0xF8;
+		} else {
+			data[0] = 0x12;
+			data[1] = 0xF8;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x00;
+		data[1] = 0x03;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	case 6000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate6bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef6bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x04, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x25;
+			data[1] = 0x4C;
+		} else {
+			data[0] = 0x1F;
+			data[1] = 0xDC;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x00;
+		data[1] = 0x03;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	case 5000000:
+		/* <Timing Recovery setting> */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate5bw[priv->xtal], 5);
+		/* Group delay equaliser settings for
+		 * ASCOT2D, ASCOT2E and ASCOT3 tuners
+		*/
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef5bw[priv->xtal], 14);
+		/* <IF freq setting> */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xD7, 0x06, 0x07);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x2C;
+			data[1] = 0xC2;
+		} else {
+			data[0] = 0x26;
+			data[1] = 0x3C;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Notch filter setting */
+		data[0] = 0x00;
+		data[1] = 0x03;
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);
+		break;
+	}
+
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_i_band(
+		struct cxd2841er_priv *priv, u32 bandwidth)
+{
+	u32 iffreq;
+	u8 data[3];
+
+	/* TRCG Nominal Rate */
+	u8 nominalRate8bw[3][5] = {
+		{0x00, 0x00, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x11, 0xB8, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x00, 0x00, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	u8 nominalRate7bw[3][5] = {
+		{0x00, 0x00, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x14, 0x40, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x00, 0x00, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	u8 nominalRate6bw[3][5] = {
+		{0x14, 0x2E, 0x00, 0x00, 0x00}, /* 20.5MHz XTal */
+		{0x17, 0xA0, 0x00, 0x00, 0x00}, /* 24MHz XTal */
+		{0x14, 0x2E, 0x00, 0x00, 0x00}  /* 41MHz XTal */
+	};
+
+	u8 itbCoef8bw[3][14] = {
+		{0x00}, /* 20.5MHz XTal */
+		{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29,
+			0xA5, 0x2A, 0xAC, 0x29, 0xB5}, /* 24MHz Xtal */
+		{0x0}, /* 41MHz XTal   */
+	};
+
+	u8 itbCoef7bw[3][14] = {
+		{0x00}, /* 20.5MHz XTal */
+		{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29,
+			0xA2, 0x2B, 0xA6, 0x2B, 0xAD}, /* 24MHz Xtal */
+		{0x00}, /* 41MHz XTal   */
+	};
+
+	u8 itbCoef6bw[3][14] = {
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,
+			0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 20.5MHz XTal */
+		{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29,
+			0xA4, 0x29, 0xA2, 0x29, 0xA8}, /* 24MHz Xtal   */
+		{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,
+			0xCF, 0x00, 0xE6, 0x23, 0xA4}, /* 41MHz XTal   */
+	};
+
+	dev_dbg(&priv->i2c->dev, "%s() bandwidth=%u\n", __func__, bandwidth);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+
+	/*  20.5/41MHz Xtal support is not available
+	 *  on ISDB-T 7MHzBW and 8MHzBW
+	*/
+	if (priv->xtal != SONY_XTAL_24000 && bandwidth > 6000000) {
+		dev_err(&priv->i2c->dev,
+			"%s(): bandwidth %d supported only for 24MHz xtal\n",
+			__func__, bandwidth);
+		return -EINVAL;
+	}
+
+	switch (bandwidth) {
+	case 8000000:
+		/* TRCG Nominal Rate */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate8bw[priv->xtal], 5);
+		/*  Group delay equaliser settings for ASCOT tuners optimized */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef8bw[priv->xtal], 14);
+
+		/* IF freq setting */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.75);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x0, 0x7);
+
+		/* Demod core latency setting */
+		data[0] = 0x13;
+		data[1] = 0xFC;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Acquisition optimization setting */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x03);
+		break;
+	case 7000000:
+		/* TRCG Nominal Rate */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate7bw[priv->xtal], 5);
+		/*  Group delay equaliser settings for ASCOT tuners optimized */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef7bw[priv->xtal], 14);
+
+		/* IF freq setting */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.15);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x02, 0x7);
+
+		/* Demod core latency setting */
+		data[0] = 0x1A;
+		data[1] = 0xFA;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Acquisition optimization setting */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);
+		break;
+	case 6000000:
+		/* TRCG Nominal Rate */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0x9F, nominalRate6bw[priv->xtal], 5);
+		/*  Group delay equaliser settings for ASCOT tuners optimized */
+		cxd2841er_write_regs(priv, I2C_SLVT,
+				0xA6, itbCoef6bw[priv->xtal], 14);
+
+		/* IF freq setting */
+		iffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.55);
+		data[0] = (u8) ((iffreq >> 16) & 0xff);
+		data[1] = (u8)((iffreq >> 8) & 0xff);
+		data[2] = (u8)(iffreq & 0xff);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);
+
+		/* System bandwidth setting */
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x04, 0x7);
+
+		/* Demod core latency setting */
+		if (priv->xtal == SONY_XTAL_24000) {
+			data[0] = 0x1F;
+			data[1] = 0x79;
+		} else {
+			data[0] = 0x1A;
+			data[1] = 0xE2;
+		}
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Acquisition optimization setting */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);
+		cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x07, 0x07);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",
+				__func__, bandwidth);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,
+					       u32 bandwidth)
+{
+	u8 bw7_8mhz_b10_a6[] = {
+		0x2D, 0xC7, 0x04, 0xF4, 0x07, 0xC5, 0x2A, 0xB8,
+		0x27, 0x9E, 0x27, 0xA4, 0x29, 0xAB };
+	u8 bw6mhz_b10_a6[] = {
+		0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,
+		0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4 };
+	u8 b10_b6[3];
+	u32 iffreq;
+
+	dev_dbg(&priv->i2c->dev, "%s() bw=%d\n", __func__, bandwidth);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	switch (bandwidth) {
+	case 8000000:
+	case 7000000:
+		cxd2841er_write_regs(
+			priv, I2C_SLVT, 0xa6,
+			bw7_8mhz_b10_a6, sizeof(bw7_8mhz_b10_a6));
+		iffreq = MAKE_IFFREQ_CONFIG(4.9);
+		break;
+	case 6000000:
+		cxd2841er_write_regs(
+			priv, I2C_SLVT, 0xa6,
+			bw6mhz_b10_a6, sizeof(bw6mhz_b10_a6));
+		iffreq = MAKE_IFFREQ_CONFIG(3.7);
+		break;
+	default:
+		dev_err(&priv->i2c->dev, "%s(): unsupported bandwidth %d\n",
+			__func__, bandwidth);
+		return -EINVAL;
+	}
+	/* <IF freq setting> */
+	b10_b6[0] = (u8) ((iffreq >> 16) & 0xff);
+	b10_b6[1] = (u8)((iffreq >> 8) & 0xff);
+	b10_b6[2] = (u8)(iffreq & 0xff);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xb6, b10_b6, sizeof(b10_b6));
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	switch (bandwidth) {
+	case 8000000:
+	case 7000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xa3, 0x00, 0x1f);
+		break;
+	case 6000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0xa3, 0x14, 0x1f);
+		break;
+	}
+	/* Set SLV-T Bank : 0x40 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	switch (bandwidth) {
+	case 8000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0x26, 0x0b, 0x0f);
+		cxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0x3e);
+		break;
+	case 7000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0x26, 0x09, 0x0f);
+		cxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0xd6);
+		break;
+	case 6000000:
+		cxd2841er_set_reg_bits(
+			priv, I2C_SLVT, 0x26, 0x08, 0x0f);
+		cxd2841er_write_reg(priv, I2C_SLVT,  0x27, 0x6e);
+		break;
+	}
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t(struct cxd2841er_priv *priv,
+					  u32 bandwidth)
+{
+	u8 data[2] = { 0x09, 0x54 };
+	u8 data24m[3] = {0xDC, 0x6C, 0x00};
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBT);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+	/* Enable ADC 2 & 3 */
+	if (priv->xtal == SONY_XTAL_41000) {
+		data[0] = 0x0A;
+		data[1] = 0xD4;
+	}
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* IFAGC gain settings */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	/* BBAGC TARGET level setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x18 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);
+	/* Pre-RS BER moniter setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x36, 0x40, 0x07);
+	/* FEC Auto Recovery setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TSIF setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);
+
+	if (priv->xtal == SONY_XTAL_24000) {
+		/* Set SLV-T Bank : 0x10 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xBF, 0x60);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x24, data24m, 3);
+	}
+
+	cxd2841er_sleep_tc_to_active_t_band(priv, bandwidth);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_t2(struct cxd2841er_priv *priv,
+					   u32 bandwidth)
+{
+	u8 data[MAX_WRITE_REGSIZE];
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBT2);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x02);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x00);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+
+	if (priv->xtal == SONY_XTAL_41000) {
+		data[0] = 0x0A;
+		data[1] = 0xD4;
+	} else {
+		data[0] = 0x09;
+		data[1] = 0x54;
+	}
+
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* IFAGC gain settings */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	/* BBAGC TARGET level setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x20 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+	/* Acquisition optimization setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x8b, 0x3c);
+	/* Set SLV-T Bank : 0x2b */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x76, 0x20, 0x70);
+	/* Set SLV-T Bank : 0x23 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);
+	/* L1 Control setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE6, 0x00, 0x03);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TSIF setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);
+	/* DVB-T2 initial setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x10);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x34);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xd8);
+	/* Set SLV-T Bank : 0x2a */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x04, 0x0f);
+	/* Set SLV-T Bank : 0x2b */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x20, 0x3f);
+
+	/* 24MHz Xtal setting */
+	if (priv->xtal == SONY_XTAL_24000) {
+		/* Set SLV-T Bank : 0x11 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+		data[0] = 0xEB;
+		data[1] = 0x03;
+		data[2] = 0x3B;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x33, data, 3);
+
+		/* Set SLV-T Bank : 0x20 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);
+		data[0] = 0x5E;
+		data[1] = 0x5E;
+		data[2] = 0x47;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x95, data, 3);
+
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x99, 0x18);
+
+		data[0] = 0x3F;
+		data[1] = 0xFF;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);
+
+		/* Set SLV-T Bank : 0x24 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);
+		data[0] = 0x0B;
+		data[1] = 0x72;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x34, data, 2);
+
+		data[0] = 0x93;
+		data[1] = 0xF3;
+		data[2] = 0x00;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xD2, data, 3);
+
+		data[0] = 0x05;
+		data[1] = 0xB8;
+		data[2] = 0xD8;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0xDD, data, 3);
+
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xE0, 0x00);
+
+		/* Set SLV-T Bank : 0x25 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x25);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xED, 0x60);
+
+		/* Set SLV-T Bank : 0x27 */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0xFA, 0x34);
+
+		/* Set SLV-T Bank : 0x2B */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2B);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x4B, 0x2F);
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x9E, 0x0E);
+
+		/* Set SLV-T Bank : 0x2D */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2D);
+		data[0] = 0x89;
+		data[1] = 0x89;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x24, data, 2);
+
+		/* Set SLV-T Bank : 0x5E */
+		cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x5E);
+		data[0] = 0x24;
+		data[1] = 0x95;
+		cxd2841er_write_regs(priv, I2C_SLVT, 0x8C, data, 2);
+	}
+
+	cxd2841er_sleep_tc_to_active_t2_band(priv, bandwidth);
+
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+/* ISDB-Tb part */
+static int cxd2841er_sleep_tc_to_active_i(struct cxd2841er_priv *priv,
+		u32 bandwidth)
+{
+	u8 data[2] = { 0x09, 0x54 };
+	u8 data24m[2] = {0x60, 0x00};
+	u8 data24m2[3] = {0xB7, 0x1B, 0x00};
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBT);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x06);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Enable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x01);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x01);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+	/* xtal freq 20.5MHz or 24M */
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* FEC Auto Recovery setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x00, 0x01);
+	/* ISDB-T initial setting */
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x00, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x00, 0x01);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x69, 0x04, 0x07);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x6B, 0x03, 0x07);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9D, 0x50, 0xFF);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xD3, 0x06, 0x1F);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xED, 0x00, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE2, 0xCE, 0x80);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xF2, 0x13, 0x10);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x2E, 0x3F);
+	/* Set SLV-T Bank : 0x15 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x02, 0x03);
+	/* Set SLV-T Bank : 0x1E */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x1E);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x73, 0x68, 0xFF);
+	/* Set SLV-T Bank : 0x63 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x63);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0x81, 0x00, 0x01);
+
+	/* for xtal 24MHz */
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xBF, data24m, 2);
+	/* Set SLV-T Bank : 0x60 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);
+	cxd2841er_write_regs(priv, I2C_SLVT, 0xA8, data24m2, 3);
+
+	cxd2841er_sleep_tc_to_active_i_band(priv, bandwidth);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+static int cxd2841er_sleep_tc_to_active_c(struct cxd2841er_priv *priv,
+					  u32 bandwidth)
+{
+	u8 data[2] = { 0x09, 0x54 };
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_set_ts_clock_mode(priv, SYS_DVBC_ANNEX_A);
+	/* Set SLV-X Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);
+	/* Set demod mode */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x04);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Enable demod clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);
+	/* Disable RF level monitor */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);
+	/* Enable ADC clock */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);
+	/* Enable ADC 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);
+	/* xtal freq 20.5MHz */
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);
+	/* Enable ADC 4 */
+	cxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* IFAGC gain settings */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x09, 0x1f);
+	/* Set SLV-T Bank : 0x11 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);
+	/* BBAGC TARGET level setting */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x48);
+	/* Set SLV-T Bank : 0x10 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	/* ASCOT setting ON */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);
+	/* Set SLV-T Bank : 0x40 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);
+	/* Demod setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc3, 0x00, 0x04);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* TSIF setting */
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);
+
+	cxd2841er_sleep_tc_to_active_c_band(priv, bandwidth);
+	/* Set SLV-T Bank : 0x00 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	/* Disable HiZ Setting 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);
+	/* Disable HiZ Setting 2 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);
+	priv->state = STATE_ACTIVE_TC;
+	return 0;
+}
+
+static int cxd2841er_get_frontend(struct dvb_frontend *fe,
+				  struct dtv_frontend_properties *p)
+{
+	enum fe_status status = 0;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state == STATE_ACTIVE_S)
+		cxd2841er_read_status_s(fe, &status);
+	else if (priv->state == STATE_ACTIVE_TC)
+		cxd2841er_read_status_tc(fe, &status);
+
+	cxd2841er_read_signal_strength(fe);
+
+	if (status & FE_HAS_LOCK) {
+		cxd2841er_read_snr(fe);
+		cxd2841er_read_ucblocks(fe);
+
+		cxd2841er_read_ber(fe);
+	} else {
+		p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+		p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	}
+	return 0;
+}
+
+static int cxd2841er_set_frontend_s(struct dvb_frontend *fe)
+{
+	int ret = 0, i, timeout, carr_offset;
+	enum fe_status status;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 symbol_rate = p->symbol_rate/1000;
+
+	dev_dbg(&priv->i2c->dev, "%s(): %s frequency=%d symbol_rate=%d xtal=%d\n",
+		__func__,
+		(p->delivery_system == SYS_DVBS ? "DVB-S" : "DVB-S2"),
+		 p->frequency, symbol_rate, priv->xtal);
+	switch (priv->state) {
+	case STATE_SLEEP_S:
+		ret = cxd2841er_sleep_s_to_active_s(
+			priv, p->delivery_system, symbol_rate);
+		break;
+	case STATE_ACTIVE_S:
+		ret = cxd2841er_retune_active(priv, p);
+		break;
+	default:
+		dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		ret = -EINVAL;
+		goto done;
+	}
+	if (ret) {
+		dev_dbg(&priv->i2c->dev, "%s(): tune failed\n", __func__);
+		goto done;
+	}
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	cxd2841er_tune_done(priv);
+	timeout = ((3000000 + (symbol_rate - 1)) / symbol_rate) + 150;
+	for (i = 0; i < timeout / CXD2841ER_DVBS_POLLING_INVL; i++) {
+		usleep_range(CXD2841ER_DVBS_POLLING_INVL*1000,
+			(CXD2841ER_DVBS_POLLING_INVL + 2) * 1000);
+		cxd2841er_read_status_s(fe, &status);
+		if (status & FE_HAS_LOCK)
+			break;
+	}
+	if (status & FE_HAS_LOCK) {
+		if (cxd2841er_get_carrier_offset_s_s2(
+				priv, &carr_offset)) {
+			ret = -EINVAL;
+			goto done;
+		}
+		dev_dbg(&priv->i2c->dev, "%s(): carrier_offset=%d\n",
+			__func__, carr_offset);
+	}
+done:
+	/* Reset stats */
+	p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+	p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+
+	return ret;
+}
+
+static int cxd2841er_set_frontend_tc(struct dvb_frontend *fe)
+{
+	int ret = 0, timeout;
+	enum fe_status status;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	
+	dev_dbg(&priv->i2c->dev, "%s() delivery_system=%d bandwidth_hz=%d\n",
+		 __func__, p->delivery_system, p->bandwidth_hz);
+		 
+	
+	cxd2841er_active_t_to_sleep_tc(priv);
+	cxd2841er_sleep_tc_to_shutdown(priv);
+	cxd2841er_init_tc(fe);
+	
+	if (p->delivery_system == SYS_DVBT) {
+		priv->system = SYS_DVBT;
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_t(
+				priv, p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else if (p->delivery_system == SYS_DVBT2) {
+		priv->system = SYS_DVBT2;
+		cxd2841er_dvbt2_set_plp_config(priv,
+			(int)(p->stream_id > 255), p->stream_id);
+		cxd2841er_dvbt2_set_profile(priv, DVBT2_PROFILE_BASE);
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_t2(priv,
+				p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else if (p->delivery_system == SYS_ISDBT) {
+		priv->system = SYS_ISDBT;
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_i(
+					priv, p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+					__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else if (p->delivery_system == SYS_DVBC_ANNEX_A ||
+			p->delivery_system == SYS_DVBC_ANNEX_C) {
+		priv->system = SYS_DVBC_ANNEX_A;
+		/* correct bandwidth */
+		if (p->bandwidth_hz != 6000000 &&
+				p->bandwidth_hz != 7000000 &&
+				p->bandwidth_hz != 8000000) {
+			p->bandwidth_hz = 8000000;
+			dev_dbg(&priv->i2c->dev, "%s(): forcing bandwidth to %d\n",
+					__func__, p->bandwidth_hz);
+		}
+
+		switch (priv->state) {
+		case STATE_SLEEP_TC:
+			ret = cxd2841er_sleep_tc_to_active_c(
+				priv, p->bandwidth_hz);
+			break;
+		case STATE_ACTIVE_TC:
+			ret = cxd2841er_retune_active(priv, p);
+			break;
+		default:
+			dev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",
+				__func__, priv->state);
+			ret = -EINVAL;
+		}
+	} else {
+		dev_dbg(&priv->i2c->dev,
+			"%s(): invalid delivery system %d\n",
+			__func__, p->delivery_system);
+		ret = -EINVAL;
+	}
+	if (ret)
+		goto done;
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	cxd2841er_tune_done(priv);
+	timeout = 2500;
+	while (timeout > 0) {
+		ret = cxd2841er_read_status_tc(fe, &status);
+		if (ret)
+			goto done;
+		if (status & FE_HAS_LOCK)
+			break;
+		msleep(20);
+		timeout -= 20;
+	}
+	if (timeout < 0)
+		dev_dbg(&priv->i2c->dev,
+			"%s(): LOCK wait timeout\n", __func__);
+done:
+	return ret;
+}
+
+static int cxd2841er_tune_s(struct dvb_frontend *fe,
+			    bool re_tune,
+			    unsigned int mode_flags,
+			    unsigned int *delay,
+			    enum fe_status *status)
+{
+	int ret, carrier_offset;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s() re_tune=%d\n", __func__, re_tune);
+	if (re_tune) {
+		ret = cxd2841er_set_frontend_s(fe);
+		if (ret)
+			return ret;
+		cxd2841er_read_status_s(fe, status);
+		if (*status & FE_HAS_LOCK) {
+			if (cxd2841er_get_carrier_offset_s_s2(
+					priv, &carrier_offset))
+				return -EINVAL;
+			p->frequency += carrier_offset;
+			ret = cxd2841er_set_frontend_s(fe);
+			if (ret)
+				return ret;
+		}
+	}
+	*delay = HZ / 5;
+	return cxd2841er_read_status_s(fe, status);
+}
+
+static int cxd2841er_tune_tc(struct dvb_frontend *fe,
+			     bool re_tune,
+			     unsigned int mode_flags,
+			     unsigned int *delay,
+			     enum fe_status *status)
+{
+	int ret, carrier_offset;
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s(): re_tune %d bandwidth=%d\n", __func__,
+			re_tune, p->bandwidth_hz);
+	if (re_tune) {
+		ret = cxd2841er_set_frontend_tc(fe);
+		if (ret)
+			return ret;
+		cxd2841er_read_status_tc(fe, status);
+		if (*status & FE_HAS_LOCK) {
+			switch (priv->system) {
+			case SYS_ISDBT:
+				ret = cxd2841er_get_carrier_offset_i(
+						priv, p->bandwidth_hz,
+						&carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			case SYS_DVBT:
+				ret = cxd2841er_get_carrier_offset_t(
+					priv, p->bandwidth_hz,
+					&carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			case SYS_DVBT2:
+				ret = cxd2841er_get_carrier_offset_t2(
+					priv, p->bandwidth_hz,
+					&carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			case SYS_DVBC_ANNEX_A:
+				ret = cxd2841er_get_carrier_offset_c(
+					priv, &carrier_offset);
+				if (ret)
+					return ret;
+				break;
+			default:
+				dev_dbg(&priv->i2c->dev,
+					"%s(): invalid delivery system %d\n",
+					__func__, priv->system);
+				return -EINVAL;
+			}
+			dev_dbg(&priv->i2c->dev, "%s(): carrier offset %d\n",
+				__func__, carrier_offset);
+			p->frequency += carrier_offset;
+			ret = cxd2841er_set_frontend_tc(fe);
+			if (ret)
+				return ret;
+		}
+	}
+	*delay = HZ / 5;
+	return cxd2841er_read_status_tc(fe, status);
+}
+
+static int cxd2841er_sleep_s(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_active_s_to_sleep_s(fe->demodulator_priv);
+	cxd2841er_sleep_s_to_shutdown(fe->demodulator_priv);
+	return 0;
+}
+
+static int cxd2841er_sleep_tc(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	if (priv->state == STATE_ACTIVE_TC) {
+		switch (priv->system) {
+		case SYS_DVBT:
+			cxd2841er_active_t_to_sleep_tc(priv);
+			break;
+		case SYS_DVBT2:
+			cxd2841er_active_t2_to_sleep_tc(priv);
+			break;
+		case SYS_ISDBT:
+			cxd2841er_active_i_to_sleep_tc(priv);
+			break;
+		case SYS_DVBC_ANNEX_A:
+			cxd2841er_active_c_to_sleep_tc(priv);
+			break;
+		default:
+			dev_warn(&priv->i2c->dev,
+				"%s(): unknown delivery system %d\n",
+				__func__, priv->system);
+		}
+	}
+	if (priv->state != STATE_SLEEP_TC) {
+		dev_err(&priv->i2c->dev, "%s(): invalid state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	cxd2841er_sleep_tc_to_shutdown(priv);
+	return 0;
+}
+
+static int cxd2841er_send_burst(struct dvb_frontend *fe,
+				enum fe_sec_mini_cmd burst)
+{
+	u8 data;
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): burst mode %s\n", __func__,
+		(burst == SEC_MINI_A ? "A" : "B"));
+	if (priv->state != STATE_SLEEP_S &&
+			priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	data = (burst == SEC_MINI_A ? 0 : 1);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x34, 0x01);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x35, data);
+	return 0;
+}
+
+static int cxd2841er_set_tone(struct dvb_frontend *fe,
+			      enum fe_sec_tone_mode tone)
+{
+	u8 data;
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): tone %s\n", __func__,
+		(tone == SEC_TONE_ON ? "On" : "Off"));
+	if (priv->state != STATE_SLEEP_S &&
+			priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	data = (tone == SEC_TONE_ON ? 1 : 0);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x36, data);
+	return 0;
+}
+
+static int cxd2841er_send_diseqc_msg(struct dvb_frontend *fe,
+				     struct dvb_diseqc_master_cmd *cmd)
+{
+	int i;
+	u8 data[12];
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	if (priv->state != STATE_SLEEP_S &&
+			priv->state != STATE_ACTIVE_S) {
+		dev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",
+			__func__, priv->state);
+		return -EINVAL;
+	}
+	dev_dbg(&priv->i2c->dev,
+		"%s(): cmd->len %d\n", __func__, cmd->msg_len);
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);
+	/* DiDEqC enable */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x33, 0x01);
+	/* cmd1 length & data */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x3d, cmd->msg_len);
+	memset(data, 0, sizeof(data));
+	for (i = 0; i < cmd->msg_len && i < sizeof(data); i++)
+		data[i] = cmd->msg[i];
+	cxd2841er_write_regs(priv, I2C_SLVT, 0x3e, data, sizeof(data));
+	/* repeat count for cmd1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x37, 1);
+	/* repeat count for cmd2: always 0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x38, 0);
+	/* start transmit */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x32, 0x01);
+	/* wait for 1 sec timeout */
+	for (i = 0; i < 50; i++) {
+		cxd2841er_read_reg(priv, I2C_SLVT, 0x10, data);
+		if (!data[0]) {
+			dev_dbg(&priv->i2c->dev,
+				"%s(): DiSEqC cmd has been sent\n", __func__);
+			return 0;
+		}
+		msleep(20);
+	}
+	dev_dbg(&priv->i2c->dev,
+		"%s(): DiSEqC cmd transmit timeout\n", __func__);
+	return -ETIMEDOUT;
+}
+
+static void cxd2841er_release(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv  = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	kfree(priv);
+}
+
+static int cxd2841er_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s(): enable=%d\n", __func__, enable);
+	cxd2841er_set_reg_bits(
+		priv, I2C_SLVX, 0x8, (enable ? 0x01 : 0x00), 0x01);
+	return 0;
+}
+
+static enum dvbfe_algo cxd2841er_get_algo(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	return DVBFE_ALGO_HW;
+}
+
+static void cxd2841er_init_stats(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	p->strength.len = 1;
+	p->strength.stat[0].scale = FE_SCALE_RELATIVE;
+	p->cnr.len = 1;
+	p->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->block_error.len = 1;
+	p->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_error.len = 1;
+	p->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+	p->post_bit_count.len = 1;
+	p->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
+}
+
+
+static int cxd2841er_init_s(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+
+	/* sanity. force demod to SHUTDOWN state */
+	if (priv->state == STATE_SLEEP_S) {
+		dev_dbg(&priv->i2c->dev, "%s() forcing sleep->shutdown\n",
+				__func__);
+		cxd2841er_sleep_s_to_shutdown(priv);
+	} else if (priv->state == STATE_ACTIVE_S) {
+		dev_dbg(&priv->i2c->dev, "%s() forcing active->sleep->shutdown\n",
+				__func__);
+		cxd2841er_active_s_to_sleep_s(priv);
+		cxd2841er_sleep_s_to_shutdown(priv);
+	}
+
+	dev_dbg(&priv->i2c->dev, "%s()\n", __func__);
+	cxd2841er_shutdown_to_sleep_s(priv);
+	/* SONY_DEMOD_CONFIG_SAT_IFAGCNEG set to 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xb9, 0x01, 0x01);
+
+	cxd2841er_init_stats(fe);
+
+	return 0;
+}
+
+static int cxd2841er_init_tc(struct dvb_frontend *fe)
+{
+	struct cxd2841er_priv *priv = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dev_dbg(&priv->i2c->dev, "%s() bandwidth_hz=%d\n",
+			__func__, p->bandwidth_hz);
+	cxd2841er_shutdown_to_sleep_tc(priv);
+	/* SONY_DEMOD_CONFIG_IFAGCNEG = 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcb, 
+						priv->config->if_agc ? 0x40 : 0x00, 0x40);
+	/* SONY_DEMOD_CONFIG_IFAGC_ADC_FS = 0 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0xcd, 
+						priv->config->ifagc_adc_range);
+	/* SONY_DEMOD_CONFIG_PARALLEL_SEL = 1 */
+	cxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xCB, 
+					priv->config->ts_error_polarity ? 0x00 : 0x01, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xC5, 
+					priv->config->clock_polarity ? 0x01 : 0x00, 0x01);
+	cxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc4, 0x00, 0x80);
+
+	cxd2841er_init_stats(fe);
+
+	return 0;
+}
+
+static struct dvb_frontend_ops cxd2841er_dvbs_s2_ops;
+static struct dvb_frontend_ops cxd2841er_t_c_ops;
+
+static struct dvb_frontend *cxd2841er_attach(struct cxd2841er_config *cfg,
+					     struct i2c_adapter *i2c,
+					     u8 system)
+{
+	u8 chip_id = 0;
+	const char *type;
+	const char *name;
+	struct cxd2841er_priv *priv = NULL;
+
+	/* allocate memory for the internal state */
+	priv = kzalloc(sizeof(struct cxd2841er_priv), GFP_KERNEL);
+	if (!priv)
+		return NULL;
+	priv->i2c = i2c;
+	priv->config = cfg;
+	priv->i2c_addr_slvx = cfg->i2c_addr + 2;
+	priv->i2c_addr_slvt = cfg->i2c_addr;
+	priv->xtal = cfg->xtal;
+	priv->frontend.demodulator_priv = priv;
+	dev_info(&priv->i2c->dev,
+		"%s(): I2C adapter %p SLVX addr %x SLVT addr %x\n",
+		__func__, priv->i2c,
+		priv->i2c_addr_slvx, priv->i2c_addr_slvt);
+	chip_id = cxd2841er_chip_id(priv);
+	switch (chip_id) {
+	case CXD2837ER_CHIP_ID:
+		snprintf(cxd2841er_t_c_ops.info.name, 128,
+				"Sony CXD2837ER DVB-T/T2/C demodulator");
+		name = "CXD2837ER";
+		break;
+	case CXD2841ER_CHIP_ID:
+		snprintf(cxd2841er_t_c_ops.info.name, 128,
+				"Sony CXD2841ER DVB-T/T2/C demodulator");
+		name = "CXD2841ER";
+		break;
+	case CXD2854ER_CHIP_ID:
+		snprintf(cxd2841er_t_c_ops.info.name, 128,
+				"Sony CXD2854ER DVB-T/T2/C and ISDB-T demodulator");
+		cxd2841er_t_c_ops.delsys[3] = SYS_ISDBT;
+		name = "CXD2854ER";
+		break;
+	default:
+		dev_err(&priv->i2c->dev, "%s(): invalid chip ID 0x%02x\n",
+				__func__, chip_id);
+		priv->frontend.demodulator_priv = NULL;
+		kfree(priv);
+		return NULL;
+	}
+
+	/* create dvb_frontend */
+	if (system == SYS_DVBS) {
+		memcpy(&priv->frontend.ops,
+			&cxd2841er_dvbs_s2_ops,
+			sizeof(struct dvb_frontend_ops));
+		type = "S/S2";
+	} else {
+		memcpy(&priv->frontend.ops,
+			&cxd2841er_t_c_ops,
+			sizeof(struct dvb_frontend_ops));
+		type = "T/T2/C/ISDB-T";
+	}
+
+	dev_info(&priv->i2c->dev,
+		"%s(): attaching %s DVB-%s frontend\n",
+		__func__, name, type);
+	dev_info(&priv->i2c->dev, "%s(): chip ID 0x%02x OK.\n",
+		__func__, chip_id);
+	return &priv->frontend;
+}
+
+struct dvb_frontend *cxd2841er_attach_s(struct cxd2841er_config *cfg,
+					struct i2c_adapter *i2c)
+{
+	return cxd2841er_attach(cfg, i2c, SYS_DVBS);
+}
+EXPORT_SYMBOL(cxd2841er_attach_s);
+
+struct dvb_frontend *cxd2841er_attach_t_c(struct cxd2841er_config *cfg,
+					struct i2c_adapter *i2c)
+{
+	return cxd2841er_attach(cfg, i2c, 0);
+}
+EXPORT_SYMBOL(cxd2841er_attach_t_c);
+
+static struct dvb_frontend_ops cxd2841er_dvbs_s2_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 },
+	.info = {
+		.name		= "Sony CXD2841ER DVB-S/S2 demodulator",
+		.frequency_min	= 500000,
+		.frequency_max	= 2500000,
+		.frequency_stepsize	= 0,
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.symbol_rate_tolerance = 500,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK,
+	},
+	.init = cxd2841er_init_s,
+	.sleep = cxd2841er_sleep_s,
+	.release = cxd2841er_release,
+	.set_frontend = cxd2841er_set_frontend_s,
+	.get_frontend = cxd2841er_get_frontend,
+	.read_status = cxd2841er_read_status_s,
+	.i2c_gate_ctrl = cxd2841er_i2c_gate_ctrl,
+	.get_frontend_algo = cxd2841er_get_algo,
+	.set_tone = cxd2841er_set_tone,
+	.diseqc_send_burst = cxd2841er_send_burst,
+	.diseqc_send_master_cmd = cxd2841er_send_diseqc_msg,
+	.tune = cxd2841er_tune_s
+};
+
+static struct  dvb_frontend_ops cxd2841er_t_c_ops = {
+	.delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
+	.info = {
+		.name	= "", /* will set in attach function */
+		.caps = FE_CAN_FEC_1_2 |
+			FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 |
+			FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK |
+			FE_CAN_QAM_16 |
+			FE_CAN_QAM_32 |
+			FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 |
+			FE_CAN_QAM_256 |
+			FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_MUTE_TS |
+			FE_CAN_2G_MODULATION,
+		.frequency_min = 42000000,
+		.frequency_max = 1002000000
+	},
+	.init = cxd2841er_init_tc,
+	.sleep = cxd2841er_sleep_tc,
+	.release = cxd2841er_release,
+	.set_frontend = cxd2841er_set_frontend_tc,
+	.get_frontend = cxd2841er_get_frontend,
+	.read_status = cxd2841er_read_status_tc,
+	.tune = cxd2841er_tune_tc,
+	.i2c_gate_ctrl = cxd2841er_i2c_gate_ctrl,
+	.get_frontend_algo = cxd2841er_get_algo
+};
+
+MODULE_DESCRIPTION("Sony CXD2841ER/CXD2854ER DVB-C/C2/T/T2/S/S2 demodulator driver");
+MODULE_AUTHOR("Sergey Kozlov <serjk@netup.ru>, Abylay Ospan <aospan@netup.ru>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/cxd2841er_wetek.h b/drivers/amlogic/wetek/cxd2841er_wetek.h
new file mode 100644
index 0000000..98a4682
--- /dev/null
+++ b/drivers/amlogic/wetek/cxd2841er_wetek.h
@@ -0,0 +1,50 @@
+/*
+ * cxd2841er.h
+ *
+ * Sony CXD2441ER digital demodulator driver public definitions
+ *
+ * Copyright 2012 Sony Corporation
+ * Copyright (C) 2014 NetUP Inc.
+ * Copyright (C) 2014 Sergey Kozlov <serjk@netup.ru>
+ * Copyright (C) 2014 Abylay Ospan <aospan@netup.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+  */
+
+#ifndef CXD2841ER_H
+#define CXD2841ER_H
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+
+enum cxd2841er_xtal {
+	SONY_XTAL_20500, /* 20.5 MHz */
+	SONY_XTAL_24000, /* 24 MHz */
+	SONY_XTAL_41000 /* 41 MHz */
+};
+
+struct cxd2841er_config {
+	u8	i2c_addr;
+	u8 	if_agc;
+	u8	ifagc_adc_range;
+	u8	ts_error_polarity;
+	u8	clock_polarity;
+	u8	mxl603;
+	enum cxd2841er_xtal	xtal;
+};
+
+extern struct dvb_frontend *cxd2841er_attach_s(struct cxd2841er_config *cfg,
+					       struct i2c_adapter *i2c);
+
+extern struct dvb_frontend *cxd2841er_attach_t_c(struct cxd2841er_config *cfg,
+					       struct i2c_adapter *i2c);
+
+#endif
diff --git a/drivers/amlogic/wetek/mn88436.c b/drivers/amlogic/wetek/mn88436.c
new file mode 100644
index 0000000..755e51e
--- /dev/null
+++ b/drivers/amlogic/wetek/mn88436.c
@@ -0,0 +1,380 @@
+/*
+ * Driver for the Panasonic MN88436 ATSC demodulator
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+#include <linux/dvb/frontend.h>
+#include "dvb_frontend.h"
+#include "mn88436.h"
+
+struct mn88436_state { 
+	struct dvb_frontend frontend;
+	struct i2c_adapter   *i2c;
+	enum fe_modulation current_modulation;
+	u32 current_frequency;	
+	u8 mn88436_bank[DMD_REG_BANK];
+	bool boot;
+};
+static int mn88436_write_reg(struct mn88436_state *state, u8 id, u8 reg, u8 val)
+{
+	int ret;
+	u8 buf[] = { reg, val };
+	struct i2c_msg msg = {	.addr = state->mn88436_bank[id], 
+							.flags = 0,
+							.buf = buf, 
+							.len = 2 
+						};
+	
+		
+	ret = i2c_transfer(state->i2c, &msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d reg=%02x "
+				, ret, reg);				
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+static int mn88436_read_reg(struct mn88436_state *state, u8 id, u8 reg, u8 *val)
+{	
+	int ret;
+	u8 buf[] = { reg };
+	struct i2c_msg msg[] = {
+		{	.addr = state->mn88436_bank[id], 
+			.flags = 0,
+			.buf = buf, 
+			.len = 1 
+		},
+		{ 	.addr = state->mn88436_bank[id], 
+			.flags = I2C_M_RD,
+			.buf = val, 
+			.len = 1 
+		}, 
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d reg=%02x "
+				, ret, reg);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+static int mn88436_write_reg_mask(struct mn88436_state *state, u8 id,
+								u8 reg , u8 mask , u8 data)
+{
+	int ret;
+	u8 rd;
+	
+	ret = mn88436_read_reg(state, id, reg, &rd);
+	if (ret)
+		goto err;
+	
+	rd |= mask & data;
+	rd &= (mask ^ 0xff) | data;
+	
+	ret = mn88436_write_reg(state, id, reg, rd);
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+
+static int mn88436_read_status(struct dvb_frontend* fe, enum fe_status* status)
+{
+	struct mn88436_state* state = fe->demodulator_priv;	
+	int ret;
+	u8 locked;
+	*status = 0;
+	
+	ret = mn88436_read_reg(state, 0, DMD_MAIN_STSMON1, &locked);
+	if (ret)
+		goto err;
+
+	if (locked & 1) 
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | 
+				FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+static int mn88436_set_frontend(struct dvb_frontend* fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct mn88436_state* state = fe->demodulator_priv;
+	int cnt = 50, ret;
+	u8 locked;
+	
+	if (!state->boot) {
+		ret = -EAGAIN;
+		goto err;
+	}
+
+	if (fe->ops.tuner_ops.set_params) {
+		ret = fe->ops.tuner_ops.set_params(fe);
+		if (ret)
+			goto err;
+	}
+	
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_RSTSET1, 0x77);
+	if (ret)
+		goto err;
+			
+		
+	do {
+		ret = mn88436_read_reg(state, 0, DMD_MAIN_STSMON1, &locked);
+
+		if (!ret && (locked & 1))
+				break;
+
+		msleep(10);   
+		
+	} while (--cnt);
+	
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	dev_dbg(&state->i2c->dev, "Service locked!!!\n");
+	
+	state->current_frequency = p->frequency;
+	state->current_modulation = p->modulation;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mn88436_get_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	struct mn88436_state *state = fe->demodulator_priv;
+
+	p->modulation = state->current_modulation;
+	p->frequency = state->current_frequency;
+	
+	return 0;
+}
+
+
+static int mn88436_init(struct dvb_frontend* fe)
+{
+	struct mn88436_state* state = fe->demodulator_priv;
+	const struct firmware *fw = NULL;	
+	int ret, i;
+	u8 d;
+	
+	if (state->boot)
+		return 0;
+		
+	dev_dbg(&state->i2c->dev, "Uploading demod firmware (%s)...\n", MN88436_DEMOD_ATSC);
+	
+	ret = request_firmware(&fw, MN88436_DEMOD_ATSC, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Firmware upload failed. Timeout or file not found\n");
+		goto err1;
+	}    
+	
+	for (i = 0;;) {
+	
+		if (fw->data[i] == 0xff) 
+			break;
+			
+		ret = mn88436_write_reg(state, fw->data[i], fw->data[i + 1], fw->data[i + 2]);
+		if (ret)
+			goto err2;
+					
+		i = i + 3;		
+	}
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	dev_dbg(&state->i2c->dev, "Uploading demod pseq (%s)...\n", MN88436_DEMOD_PSEQ);
+	ret = request_firmware(&fw, MN88436_DEMOD_PSEQ, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Pseq upload failed. Timeout or file not found\n");
+		goto err1;
+	}    
+	
+	/* Load PSEQ Program */
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_PSEQSET , 0x03);
+	if (ret)
+		goto err2;
+	
+	for (i = 0; i < fw->size; i++) {
+		ret = mn88436_write_reg(state, 0, DMD_MAIN_PSEQPRG , fw->data[i]);
+		if (ret)
+			goto err2;
+	}
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	/* Check Parity bit */
+	ret = mn88436_read_reg(state, 0, DMD_MAIN_PSEQSET , &d);
+	if (ret)
+		goto err1;
+	
+	if (d & 0x20) {
+		ret = -EAGAIN;
+		goto err1;
+	}
+	
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_PSEQSET , 0x00);
+	if (ret)
+		goto err1;
+		
+		
+	/* TS parallel (Fixed clock mode) */
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_CPOSET2, 0xc1);
+	if (ret)
+		goto err1;
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_GPSET1, 0xff);
+	if (ret)
+		goto err1;
+		
+
+	/* Set TCB Through Mode */
+	ret = mn88436_write_reg_mask(state, 0, DMD_MAIN_TCBSET, 0x7f, 0x53);	
+	if (ret)
+		goto err1;		
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_TCBADR, 0x00);
+	if (ret)
+		goto err1;
+	
+	
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_VEQSET2, 0x80);
+	if (ret)
+		goto err1;
+		
+	state->boot = true;
+	
+	return 0;
+	
+err2:
+	release_firmware(fw);
+	fw = NULL;
+err1:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+static void mn88436_release(struct dvb_frontend* fe)
+{
+	struct mn88436_state* state = fe->demodulator_priv;
+	kfree(state);
+}
+
+
+static struct dvb_frontend_ops mn88436_ops = {
+	.delsys = { SYS_ATSC },
+	.info = {
+		.name = "Panasonic MN88436",		
+		.frequency_min = 51000000,
+		.frequency_max = 858000000,
+		.caps = FE_CAN_8VSB
+	},
+	.init = mn88436_init,
+	.release = mn88436_release,	
+	.set_frontend = mn88436_set_frontend,
+	.get_frontend = mn88436_get_frontend,	
+	.read_status = mn88436_read_status,
+	
+};
+
+struct dvb_frontend *mn88436_attach(struct i2c_adapter *i2c, 
+									u8 device_id)
+{
+	struct mn88436_state *state = NULL;
+	int ret;
+	
+	
+	state = kzalloc(sizeof(struct mn88436_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+
+	state->i2c = i2c;
+	
+	switch (device_id) {
+	case 0:
+	default:
+		state->mn88436_bank[0] = 0x18;
+		state->mn88436_bank[1] = 0x10;
+		break;
+	case 1:
+		state->mn88436_bank[0] = 0x19;
+		state->mn88436_bank[1] = 0x11;
+		break;
+	case 2:
+		state->mn88436_bank[0] = 0x1A;
+		state->mn88436_bank[1] = 0x12;
+		break;
+	case 3:
+		state->mn88436_bank[0] = 0x1B;
+		state->mn88436_bank[1] = 0x13;
+		break;		
+	}
+	/* Try SOFT reset */
+	ret = mn88436_write_reg(state, 0, DMD_MAIN_RSTSET1, 0x77);
+	if (ret)
+		goto err2;
+	
+	dev_info(&i2c->dev, "MN88436 ATSC successfully attached\n");						
+		
+	memcpy(&state->frontend.ops, &mn88436_ops,
+		       sizeof(struct dvb_frontend_ops));
+			   
+	state->frontend.demodulator_priv = state;
+	
+	return &state->frontend;
+	
+err2:	
+	kfree(state);
+err1:	
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);	
+	return NULL;
+}
+EXPORT_SYMBOL(mn88436_attach);
+
+MODULE_DESCRIPTION("Panasonic MN88436 ATSC demod driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/mn88436.h b/drivers/amlogic/wetek/mn88436.h
new file mode 100644
index 0000000..d1194b1
--- /dev/null
+++ b/drivers/amlogic/wetek/mn88436.h
@@ -0,0 +1,47 @@
+/*
+ * Driver for the Panasonic MN88436 ATSC demodulator
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __MN88436_H_
+#define __MN88436_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+
+#define MN88436_DEMOD_ATSC 		"dvb-fe-mn88436-atsc.fw" 
+#define MN88436_DEMOD_PSEQ 		"dvb-fe-mn88436-pseq.fw" 
+
+#define DMD_REG_BANK    		2
+
+#define DMD_MAIN_CPOSET2		0x2
+#define DMD_MAIN_GPSET1			0x5
+#define DMD_MAIN_RSTSET1		0x10
+#define DMD_MAIN_TCBSET			0x15
+#define DMD_MAIN_TCBADR			0x17
+#define DMD_MAIN_VEQSET2		0x69
+#define DMD_MAIN_STSMON1		0xC4
+#define DMD_MAIN_PSEQSET		0xF0
+#define DMD_MAIN_PSEQPRG		0xF1
+
+
+extern struct dvb_frontend *mn88436_attach(struct i2c_adapter *i2c,
+											u8 device_id);
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/wetek/mxl603.c b/drivers/amlogic/wetek/mxl603.c
new file mode 100644
index 0000000..bc7018c
--- /dev/null
+++ b/drivers/amlogic/wetek/mxl603.c
@@ -0,0 +1,1096 @@
+/*
+ * Driver for the MaxLinear MxL603 tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include "tuner-i2c.h"
+#include "mxl603.h"
+
+
+enum mxl603_mode {
+	MxL603_MODE_CABLE,
+	MxL603_MODE_ISDBT_ATSC,
+	MxL603_MODE_DVBT,
+};
+
+enum mxl603_bw_mhz {
+	MxL603_CABLE_BW_6MHz = 0x00,
+	MxL603_CABLE_BW_7MHz = 0x01,
+	MxL603_CABLE_BW_8MHz = 0x02,
+	MxL603_TERR_BW_6MHz = 0x20,
+	MxL603_TERR_BW_7MHz = 0x21,
+	MxL603_TERR_BW_8MHz = 0x22,
+};
+
+struct reg_pair_t {
+	u8 reg;
+	u8 val;
+};
+
+struct freq_table {
+	u32 center_freq;
+	u8 reg1;
+	u8 reg2;
+};
+
+static struct freq_table MxL603_Cable[] = {
+	{ 1        , 0x00, 0xD8 },
+	{ 695000000, 0x20, 0xD7 },
+	{ 0, 0, 0 },
+};
+
+static struct freq_table MxL603_Digital[] = {
+	{ 1, 0x00, 0xD8 },
+	{ 0, 0, 0 },
+};
+
+static struct reg_pair_t MxL603_DigitalDvbc[] = {
+	{ 0x0C, 0x00 },
+	{ 0x13, 0x04 },
+	{ 0x53, 0x7E },
+	{ 0x57, 0x91 },
+	{ 0x5C, 0xB1 },
+	{ 0x62, 0xF2 },
+	{ 0x6E, 0x03 },
+	{ 0x6F, 0xD1 },
+	{ 0x87, 0x77 },
+	{ 0x88, 0x55 },
+	{ 0x93, 0x33 },
+	{ 0x97, 0x03 },
+	{ 0xBA, 0x40 },
+	{ 0x98, 0xAF },
+	{ 0x9B, 0x20 },
+	{ 0x9C, 0x1E },
+	{ 0xA0, 0x18 },
+	{ 0xA5, 0x09 },
+	{ 0xC2, 0xA9 },
+	{ 0xC5, 0x7C },
+	{ 0xCD, 0x64 },
+	{ 0xCE, 0x7C },
+	{ 0xD5, 0x05 },
+	{ 0xD9, 0x00 },
+	{ 0xEA, 0x00 },
+	{ 0xDC, 0x1C },
+	{ 0, 0 }
+};
+
+static struct reg_pair_t MxL603_DigitalIsdbtAtsc[] = {
+	{ 0x0C, 0x00 },
+	{ 0x13, 0x04 },
+	{ 0x53, 0xFE },
+	{ 0x57, 0x91 },
+	{ 0x62, 0xC2 },
+	{ 0x6E, 0x01 },
+	{ 0x6F, 0x51 },
+	{ 0x87, 0x77 },
+	{ 0x88, 0x55 },
+	{ 0x93, 0x22 },
+	{ 0x97, 0x02 },
+	{ 0xBA, 0x30 },
+	{ 0x98, 0xAF },
+	{ 0x9B, 0x20 },
+	{ 0x9C, 0x1E },
+	{ 0xA0, 0x18 },
+	{ 0xA5, 0x09 },
+	{ 0xC2, 0xA9 },
+	{ 0xC5, 0x7C },
+	{ 0xCD, 0xEB },
+	{ 0xCE, 0x7F },
+	{ 0xD5, 0x03 },
+	{ 0xD9, 0x04 },
+	{ 0, 0 }
+};
+
+static struct reg_pair_t MxL603_DigitalDvbt[] = {
+	{ 0x0C, 0x00 },
+	{ 0x13, 0x04 },
+	{ 0x53, 0xFE },
+	{ 0x57, 0x91 },
+	{ 0x62, 0xC2 },
+	{ 0x6E, 0x01 },
+	{ 0x6F, 0x51 },
+	{ 0x87, 0x77 },
+	{ 0x88, 0x55 },
+	{ 0x93, 0x22 },
+	{ 0x97, 0x02 },
+	{ 0xBA, 0x30 },
+	{ 0x98, 0xAF },
+	{ 0x9B, 0x20 },
+	{ 0x9C, 0x1E },
+	{ 0xA0, 0x18 },
+	{ 0xA5, 0x09 },
+	{ 0xC2, 0xA9 },
+	{ 0xC5, 0x7C },
+	{ 0xCD, 0x64 },
+	{ 0xCE, 0x7C },
+	{ 0xD5, 0x03 },
+	{ 0xD9, 0x04 },
+	{ 0, 0 }
+};
+
+struct mxl603_state {
+	struct mxl603_config *config;
+	struct i2c_adapter   *i2c;
+	u8 addr;
+	u32 frequency;
+	u32 bandwidth;
+};
+
+static int mxl603_write_reg(struct mxl603_state *state, u8 reg, u8 val)
+{
+	
+	u8 buf[] = { reg, val };
+	struct i2c_msg msg = { .addr = state->addr, .flags = 0,
+			       .buf = buf, .len = 2 };
+	int ret;
+		
+	ret = i2c_transfer(state->i2c, &msg, 1);
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d reg=%02x "
+				, ret, reg);				
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+
+static int mxl603_write_regs(struct mxl603_state *state,
+			       struct reg_pair_t *reg_pair)
+{
+	unsigned int i = 0;
+	int ret = 0;
+
+	while ((ret == 0) && (reg_pair[i].reg || reg_pair[i].val)) {
+		ret = mxl603_write_reg(state,
+					 reg_pair[i].reg, reg_pair[i].val);
+		i++;
+	}
+	return ret;
+}
+static int mxl603_read_reg(struct mxl603_state *state, u8 reg, u8 *val)
+{
+	
+	u8 buf[2] = { 0xfb, reg };
+	struct i2c_msg msg[] = {
+		{ .addr = state->addr, .flags = 0,
+		  .buf = buf, .len = 2 },
+		{ .addr = state->addr, .flags = I2C_M_RD,
+		  .buf = val, .len = 1 },
+	};
+	int ret;
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d reg=%02x "
+				, ret, reg);
+		ret = -EREMOTEIO;
+	}
+	return ret;
+}
+static int mxl603_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+
+	*frequency = 0;
+
+	switch (state->config->if_freq_hz) {
+	case MXL603_IF_3_65MHz:
+		*frequency = 3650000;
+		break;
+	case MXL603_IF_4MHz:
+		*frequency = 4000000;
+		break;
+	case MXL603_IF_4_1MHz:
+		*frequency = 4100000;
+		break;
+	case MXL603_IF_4_15MHz:
+		*frequency = 4150000;
+		break;
+	case MXL603_IF_4_5MHz:
+		*frequency = 4500000;
+		break;
+	case MXL603_IF_4_57MHz:
+		*frequency = 4570000;
+		break;
+	case MXL603_IF_5MHz:
+		*frequency = 5000000;
+		break;
+	case MXL603_IF_5_38MHz:
+		*frequency = 5380000;
+		break;
+	case MXL603_IF_6MHz:
+		*frequency = 6000000;
+		break;
+	case MXL603_IF_6_28MHz:
+		*frequency = 6280000;
+		break;
+	case MXL603_IF_7_2MHz:
+		*frequency = 7200000;
+		break;
+	case MXL603_IF_8_25MHz:
+		*frequency = 8250000;
+		break;
+	case MXL603_IF_35_25MHz:
+		*frequency = 35250000;
+		break;
+	case MXL603_IF_36MHz:
+		*frequency = 36000000;
+		break;
+	case MXL603_IF_36_15MHz:
+		*frequency = 36150000;
+		break;
+	case MXL603_IF_36_65MHz:
+		*frequency = 36650000;
+		break;
+	case MXL603_IF_44MHz:
+		*frequency = 44000000;
+		break;
+	}
+	return 0;
+}
+
+static int mxl603_set_freq(struct mxl603_state *state,
+						   int freq,
+						   enum mxl603_mode mode,
+						   enum mxl603_bw_mhz bw,
+						   struct freq_table *ftable)
+{
+	u8 d = 0, d1 = 0, d2 = 0, d3 = 0;
+	u16 f;
+	u32 tmp, div;
+	int ret;
+	int i;
+
+	ret = mxl603_write_reg(state, 0x12, 0x00);
+	if (ret)
+		goto err;
+
+	if (freq < 700000000) {
+		ret = mxl603_write_reg(state, 0x7C, 0x1F);
+		if (ret)
+			goto err;
+
+		if (mode == MxL603_MODE_CABLE)
+			d = 0xC1;
+		else
+			d = 0x81;
+
+	} else {
+		ret = mxl603_write_reg(state, 0x7C, 0x9F);
+		if (ret)
+			goto err;
+
+		if (mode == MxL603_MODE_CABLE)
+			d = 0xD1;
+		else
+			d = 0x91;
+	}
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x31, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	for (i = 0; 0 != ftable->center_freq; i++, ftable++) {
+
+		if (ftable->center_freq == 1) {
+			d1 = ftable->reg1;
+			d2 = ftable->reg2;
+			break;
+		}
+	}
+
+	for (i = 0; 0 != ftable->center_freq; i++, ftable++) {
+
+		if ((ftable->center_freq - 500000) <= freq &&
+			(ftable->center_freq + 500000) >= freq) {
+			d1 = ftable->reg1;
+			d2 = ftable->reg2;
+			break;
+		}
+	}
+
+	ret = mxl603_write_reg(state, 0xEA, d1);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0xEB, d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x0F, bw);
+	if (ret)
+		goto err;
+
+	 /* convert freq to 10.6 fixed point float [MHz] */
+	f = freq / 1000000;
+	tmp = freq % 1000000;
+	div = 1000000;
+	for (i = 0; i < 6; i++) {
+		f <<= 1;
+		div >>= 1;
+			if (tmp > div) {
+				tmp -= div;
+				f |= 1;
+			}
+	}
+	if (tmp > 7812)
+		f++;
+
+	d1 = f & 0xFF;
+	d2 = f >> 8;
+
+	ret = mxl603_write_reg(state, 0x10, d1);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x11, d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x0B, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x96, &d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0xB6, &d1);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x60, &d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x5F, &d3);
+	if (ret)
+		goto err;
+
+	if ((d & 0x10) == 0x10) {
+
+		d1 &= 0xBF;
+		d1 |= 0x0E;
+
+		d2 &= 0xC0;
+		d2 |= 0x0E;
+
+		d3 &= 0xC0;
+		d3 |= 0x0E;
+	} else {
+
+		d1 |= 0x40;
+		d1 &= 0xC0;
+
+		d2 &= 0xC0;
+		d2 |= 0x37;
+
+		d3 &= 0xC0;
+		d3 |= 0x37;
+
+	}
+
+	ret = mxl603_write_reg(state, 0x60, d2);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x5F, d3);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0xB6, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x12, 0x01);
+	if (ret)
+		goto err;
+
+	msleep(20);
+
+	d |= 0x40;
+
+	ret = mxl603_write_reg(state, 0xB6, d);
+	if (ret)
+		goto err;
+
+	msleep(20);
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_set_mode(struct dvb_frontend *fe,
+						struct mxl603_state *state,
+						enum mxl603_mode mode)
+{
+
+	u8 cfg_0, cfg_1, pwr, dfe;
+	int ret;
+	u32 if_out_freq;
+	struct reg_pair_t *reg_table;
+
+	ret = mxl603_get_if_frequency(fe, &if_out_freq);
+	if (!if_out_freq)
+		goto err;
+
+	if_out_freq /= 1000;
+
+	switch (mode) {
+	case MxL603_MODE_CABLE:
+		reg_table = MxL603_DigitalDvbc;
+		pwr = 0;
+		dfe = 0xFF;
+
+		if (if_out_freq <  35250) {
+			cfg_0 = 0xFE;
+			cfg_1 = 0x10;
+
+		} else {
+			cfg_0 = 0xD9;
+			cfg_1 = 0x16;
+		}
+		
+		break;
+	case MxL603_MODE_ISDBT_ATSC:
+		reg_table = MxL603_DigitalIsdbtAtsc;
+		dfe = 0x1C;
+
+		if (if_out_freq <  35250) {
+			cfg_0 = 0xF9;
+			cfg_1 = 0x18;
+			pwr = 0xF1;
+		} else {
+			cfg_0 = 0xD9;
+			cfg_1 = 0x16;
+			pwr = 0xB1;
+		}
+		switch(state->config->if_out_gain_level)
+		{
+			case 0x09: dfe = 0x44; break;
+			case 0x08: dfe = 0x43; break;
+			case 0x07: dfe = 0x42; break;
+			case 0x06: dfe = 0x41; break;
+			case 0x05: dfe = 0x40; break;
+			default: break;
+		}
+
+		break;
+	case MxL603_MODE_DVBT:
+		reg_table = MxL603_DigitalDvbt;
+		dfe = 0;
+		if (if_out_freq <  35250) {
+			cfg_0 = 0xFE;
+			cfg_1 = 0x18;
+			pwr = 0xF1;
+		} else {
+			cfg_0 = 0xD9;
+			cfg_1 = 0x16;
+			pwr = 0xB1;
+		}
+		switch(state->config->if_out_gain_level)
+		{
+			case 0x09: dfe = 0x44; break;
+			case 0x08: dfe = 0x43; break;
+			case 0x07: dfe = 0x42; break;
+			case 0x06: dfe = 0x41; break;
+			case 0x05: dfe = 0x40; break;
+			default: break;
+		}
+		break;
+	default:
+			return -EINVAL;
+	}
+
+	ret = mxl603_write_regs(state, reg_table);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x5A, cfg_0);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x5B, cfg_1);
+	if (ret)
+		goto err;
+
+	if (pwr) {
+		ret = mxl603_write_reg(state, 0x5C, pwr);
+		if (ret)
+			goto err;
+	}
+
+	ret = mxl603_write_reg(state, 0xEA,
+				state->config->xtal_freq_hz ? 0x0E : 0x0D);
+	if (ret)
+		goto err;
+
+	if (dfe != 0xFF) {
+		ret = mxl603_write_reg(state, 0xDC, dfe);
+		if (ret)
+			goto err;
+	}
+
+	ret = mxl603_write_reg(state, 0x03, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x03, 0x01);
+	if (ret)
+		goto err;
+
+	msleep(50);
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_set_agc(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+
+	ret = mxl603_read_reg(state, 0x08, &d);
+	if (ret)
+		goto err;
+
+	d &= 0xF2;
+	d = (u8) (d | (state->config->agc_type << 2) | 0x01);
+	ret = mxl603_write_reg(state, 0x08, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x09, &d);
+	if (ret)
+		goto err;
+
+	d &= 0x80;
+	d |= (u8)(state->config->agc_set_point & 0xff);	
+	ret = mxl603_write_reg(state, 0x09, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x5E, &d);
+	if (ret)
+		goto err;
+
+	d &= 0xEF;
+	d |= (state->config->agc_invert_pol << 4);
+	ret = mxl603_write_reg(state, 0x5E, d);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_set_if_out(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+
+	ret = mxl603_read_reg(state, 0x04, &d);
+	if (ret)
+		goto err;
+
+	d |= state->config->if_freq_hz;
+
+	ret = mxl603_write_reg(state, 0x04, d);
+	if (ret)
+		goto err;
+
+	d = 0;
+	if (state->config->invert_if)
+		d = 0x3 << 6;
+
+	d += (state->config->gain_level & 0x0F);	
+	d |= 0x20;
+	ret = mxl603_write_reg(state, 0x05, d);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_set_xtal(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+
+	d = (u8)((state->config->xtal_freq_hz << 5)
+			| (state->config->xtal_cap & 0x1F));
+	d |= (state->config->clk_out_enable << 7);
+
+	ret = mxl603_write_reg(state, 0x01, d);
+	if (ret)
+		goto err;
+
+	d = (0x01 & (u8)state->config->clk_out_div);
+
+	if (state->config->xtal_sharing_mode) {
+		d |= 0x40;
+
+		ret = mxl603_write_reg(state, 0x02, d);
+		if (ret)
+			goto err;
+		ret = mxl603_write_reg(state, 0x6D, 0x80);
+		if (ret)
+			goto err;
+	} else {
+		d &= 0x01;
+		ret = mxl603_write_reg(state, 0x02, d);
+		if (ret)
+			goto err;
+		ret = mxl603_write_reg(state, 0x6D, 0x0A);
+		if (ret)
+			goto err;
+	}
+
+	if (state->config->single_supply_3_3V) {
+		ret = mxl603_write_reg(state, 0x0E, 0x14);
+		if (ret)
+			goto err;
+	}
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_tuner_init_default(struct mxl603_state *state)
+{
+	u8 d = 0;
+	int ret;
+	
+	ret = mxl603_write_reg(state, 0xFF, 0x00);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_regs(state, MxL603_DigitalDvbc);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	ret = mxl603_read_reg(state, 0x31, &d);
+	if (ret)
+		goto err;
+
+	d &= 0x2F;
+	d |= 0xD0;
+
+	ret = mxl603_write_reg(state, 0x31, d);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+
+	if (state->config->single_supply_3_3V) {
+		ret = mxl603_write_reg(state, 0x0E, 0x04);
+		if (ret)
+			goto err;
+	}
+
+	mdelay(1);
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_synth_lock_status(struct mxl603_state *state,
+				      int *rf_locked, int *ref_locked)
+{
+	u8 d = 0;
+	int ret;
+
+	*rf_locked = 0;
+	*ref_locked = 0;
+
+	ret = mxl603_read_reg(state, 0x2B, &d);
+	if (ret)
+		goto err;
+
+	if ((d & 0x02) == 0x02)
+		*rf_locked = 1;
+
+	if ((d & 0x01) == 0x01)
+		*ref_locked = 1;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_get_status(struct dvb_frontend *fe, u32 *status)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	int rf_locked, ref_locked, ret;
+
+	*status = 0;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = mxl603_synth_lock_status(state, &rf_locked, &ref_locked);
+	if (ret)
+		goto err;
+
+	dev_dbg(&state->i2c->dev, "%s%s", rf_locked ? "rf locked " : "",
+			ref_locked ? "ref locked" : "");
+
+	if ((rf_locked) || (ref_locked))
+		*status |= TUNER_STATUS_LOCKED;
+
+		
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int mxl603_set_params(struct dvb_frontend *fe)
+{	
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct mxl603_state *state = fe->tuner_priv;	
+	struct freq_table *ftable;
+	enum mxl603_bw_mhz bw;
+	enum mxl603_mode mode;
+	int ret;
+	u32 freq = c->frequency;
+	
+	dev_dbg(&state->i2c->dev, 
+		"%s: delivery_system=%d frequency=%d bandwidth_hz=%d\n", 
+		__func__, c->delivery_system, c->frequency, c->bandwidth_hz);		
+			
+
+	switch (c->delivery_system) {
+	case SYS_ATSC:
+		mode = MxL603_MODE_ISDBT_ATSC;
+		bw = MxL603_TERR_BW_6MHz;
+		ftable = MxL603_Digital;
+		break;
+	case SYS_DVBC_ANNEX_A:
+		mode = MxL603_MODE_CABLE;
+		ftable = MxL603_Cable;
+		bw = MxL603_CABLE_BW_8MHz;	
+		break;
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		mode = MxL603_MODE_DVBT;
+		ftable = MxL603_Digital;
+		switch (c->bandwidth_hz) {
+		case 6000000:
+			bw = MxL603_TERR_BW_6MHz;
+			break;
+		case 7000000:
+			bw = MxL603_TERR_BW_7MHz;
+			break;
+		case 8000000:
+			bw = MxL603_TERR_BW_8MHz;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		 dev_dbg(&state->i2c->dev, "%s: err state=%d\n", 
+			__func__, fe->dtv_property_cache.delivery_system);
+		return -EINVAL;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	
+	ret = mxl603_tuner_init_default(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_xtal(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_if_out(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_agc(state);
+	if (ret)
+		goto err;
+
+	ret = mxl603_set_mode(fe, state, mode);
+	if (ret)
+		goto err;
+		
+	ret = mxl603_set_freq(state, freq, mode, bw, ftable);
+	if (ret)
+		goto err;
+
+	state->frequency = freq;
+	state->bandwidth = c->bandwidth_hz;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	msleep(15);
+		
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	*frequency = state->frequency;
+	return 0;
+}
+
+static int mxl603_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	*bandwidth = state->bandwidth;
+	return 0;
+}
+
+static int mxl603_init(struct dvb_frontend *fe)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	int ret;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	/* wake from standby */
+	ret = mxl603_write_reg(state, 0x0B, 0x01);
+	if (ret)
+		goto err;
+	ret = mxl603_write_reg(state, 0x12, 0x01);
+	if (ret)
+		goto err;
+	ret = mxl603_write_reg(state, 0x00, 0x01);
+	if (ret)
+		goto err;
+
+	if (state->config->loop_thru_enable)
+		ret = mxl603_write_reg(state, 0x60, 0x0E);
+	else
+		ret = mxl603_write_reg(state, 0x60, 0x37);
+	if (ret)
+		goto err;
+
+	ret = mxl603_write_reg(state, 0x00, 0x00);
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_sleep(struct dvb_frontend *fe)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+	int ret;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	/* enter standby mode */
+	ret = mxl603_write_reg(state, 0x12, 0x00);
+	if (ret)
+		goto err;
+		
+	ret = mxl603_write_reg(state, 0x0B, 0x00);
+	if (ret)
+		goto err;
+		
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return 0;
+	
+err:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+		
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int mxl603_release(struct dvb_frontend *fe)
+{
+	struct mxl603_state *state = fe->tuner_priv;
+
+	fe->tuner_priv = NULL;
+	kfree(state);
+	
+	return 0;
+}
+static struct dvb_tuner_ops mxl603_tuner_ops = {
+	.info = {
+		.name = "MaxLinear MxL603",
+		.frequency_min = 1000000,
+		.frequency_max = 1200000000,
+		.frequency_step = 25000,
+	},
+	.init              = mxl603_init,
+	.sleep             = mxl603_sleep,
+	.set_params        = mxl603_set_params,
+	.get_status        = mxl603_get_status,
+	.get_frequency     = mxl603_get_frequency,
+	.get_bandwidth     = mxl603_get_bandwidth,
+	.release           = mxl603_release,
+	.get_if_frequency  = mxl603_get_if_frequency,
+};
+static int mxl603_get_chip_id(struct mxl603_state *state)
+{
+	int ret;
+	u8 id;
+
+	ret = mxl603_read_reg(state, 0x18, &id);
+	if (ret)
+		goto err;
+
+	if (id != 0x02) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	dev_info(&state->i2c->dev, "MxL603 detected id(%02x)\n"
+			, id);
+			
+	return ret;
+
+err:
+	dev_warn(&state->i2c->dev, "MxL603 unable to identify device(%02x)\n"
+			, id);
+	return ret;
+}
+struct dvb_frontend *mxl603_attach(struct dvb_frontend *fe,
+				     struct i2c_adapter *i2c, u8 addr,
+				     struct mxl603_config *config)
+{
+	struct mxl603_state *state = NULL;
+	int ret = 0;
+
+	state = kzalloc(sizeof(struct mxl603_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+	
+	state->config = config;
+	state->i2c = i2c;
+	state->addr = addr;
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = mxl603_get_chip_id(state);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	/* check return value of mxl603_get_chip_id */
+	if (ret)
+		goto err2;
+	
+	dev_info(&i2c->dev, "Attaching MxL603\n");
+	
+	fe->tuner_priv = state;
+
+	memcpy(&fe->ops.tuner_ops, &mxl603_tuner_ops,
+	       sizeof(struct dvb_tuner_ops));
+
+	return fe;
+	
+err2:
+	kfree(state);
+err1:
+	return NULL;
+}
+EXPORT_SYMBOL(mxl603_attach);
+
+MODULE_DESCRIPTION("MaxLinear MxL603 tuner driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/mxl603.h b/drivers/amlogic/wetek/mxl603.h
new file mode 100644
index 0000000..ee4f9fb
--- /dev/null
+++ b/drivers/amlogic/wetek/mxl603.h
@@ -0,0 +1,83 @@
+/*
+ * Driver for the MaxLinear MxL603 tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __MXL603_H__
+#define __MXL603_H__
+
+#include <linux/dvb/version.h>
+#include "dvb_frontend.h"
+
+enum mxl603_if_freq {
+	MXL603_IF_3_65MHz,
+	MXL603_IF_4MHz,
+	MXL603_IF_4_1MHz,
+	MXL603_IF_4_15MHz,
+	MXL603_IF_4_5MHz, 
+	MXL603_IF_4_57MHz,
+	MXL603_IF_5MHz,
+	MXL603_IF_5_38MHz, 
+	MXL603_IF_6MHz,
+	MXL603_IF_6_28MHz,
+	MXL603_IF_7_2MHz, 
+	MXL603_IF_8_25MHz,
+	MXL603_IF_35_25MHz,
+	MXL603_IF_36MHz, 
+	MXL603_IF_36_15MHz, 
+	MXL603_IF_36_65MHz,
+	MXL603_IF_44MHz,
+};
+
+enum mxl603_xtal_freq {
+	MXL603_XTAL_16MHz,
+	MXL603_XTAL_24MHz,
+};
+
+enum mxl603_agc {
+	MXL603_AGC_SELF,   
+	MXL603_AGC_EXTERNAL,
+};
+
+struct mxl603_config {
+	enum mxl603_xtal_freq xtal_freq_hz;
+	enum mxl603_if_freq if_freq_hz;
+	enum mxl603_agc agc_type;
+	
+	u8 xtal_cap;
+	u8 gain_level;
+	u8 if_out_gain_level;
+	u8 agc_set_point;
+	
+	u8 agc_invert_pol;
+	u8 invert_if;
+	u8 loop_thru_enable;
+	u8 clk_out_enable;
+	u8 clk_out_div;
+	u8 clk_out_ext;
+	u8 xtal_sharing_mode;
+	u8 single_supply_3_3V;
+};
+
+
+
+extern struct dvb_frontend *mxl603_attach(struct dvb_frontend *fe,
+					    struct i2c_adapter *i2c, u8 addr,
+					    struct mxl603_config *cfg);
+
+#endif /* __MXL603_H__ */
diff --git a/drivers/amlogic/wetek/nimdetect.c b/drivers/amlogic/wetek/nimdetect.c
new file mode 100644
index 0000000..073ddb6
--- /dev/null
+++ b/drivers/amlogic/wetek/nimdetect.c
@@ -0,0 +1,584 @@
+/*
+ * Wetek NIMs/DVB detection
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#ifndef CONFIG_ARM64
+#include <mach/am_regs.h>
+#else
+#include <linux/reset.h>
+#endif
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/usb.h>
+#include "nimdetect.h"
+
+#include "ascot3.h"
+#include "cxd2837.h"
+#include "cxd2841er_wetek.h"
+#include "mxl603.h"
+#include "avl6211.h"
+#include "mn88436.h"
+
+#ifdef CONFIG_ARM64
+static struct reset_control *dvb_demux_reset_ctl;
+static struct reset_control *dvb_afifo_reset_ctl;
+static struct reset_control *dvb_ahbarb0_reset_ctl;
+static struct reset_control *dvb_uparsertop_reset_ctl;
+#define TOTAL_I2C		 	1
+#define TOTAL_DEMODS 		1
+#else
+#define TOTAL_I2C		 	2
+#define TOTAL_DEMODS 		2
+#endif
+#define TOTAL_AML_INPUTS 	3
+
+
+static struct wetek_nims weteknims;
+
+static struct cxd2837_cfg cxd2837cfg = {
+		.adr = 0x6C,
+		.if_agc_polarity = 1,
+		.rfain_monitoring = 0,
+		.ts_error_polarity = 0,
+		.clock_polarity = 1,
+		.ifagc_adc_range = 0,
+		.spec_inv = 0,
+		.xtal = XTAL_20500KHz,
+		.ts_clock = SERIAL_TS_CLK_MID_FULL,
+};
+
+static struct cxd2841er_config cxd2841cfg = {
+		.i2c_addr = 0x6C,
+		.if_agc = 0,
+		.ifagc_adc_range = 0x39,
+		.ts_error_polarity = 0,
+		.clock_polarity = 1,
+		.mxl603	= 0,
+		.xtal = SONY_XTAL_20500,
+};
+struct ascot3_config ascot3cfg = {
+		.i2c_address = 0x60,
+};
+static struct mxl603_config mxl603cfg = {
+		.xtal_freq_hz = MXL603_XTAL_24MHz,
+		.if_freq_hz = MXL603_IF_5MHz,
+		.agc_type = MXL603_AGC_SELF,
+		.xtal_cap = 16,
+		.gain_level = 11,
+		.if_out_gain_level = 11,
+		.agc_set_point = 66,
+		.agc_invert_pol = 0,
+		.invert_if = 1,
+		.loop_thru_enable = 0,
+		.clk_out_enable = 1,
+		.clk_out_div = 0,
+		.clk_out_ext = 0,
+		.xtal_sharing_mode = 0,
+		.single_supply_3_3V = 1,
+};
+static struct mxl603_config mxl603cfg_atsc = {
+		.xtal_freq_hz = MXL603_XTAL_24MHz,
+		.if_freq_hz = MXL603_IF_5MHz,
+		.agc_type = MXL603_AGC_EXTERNAL,
+		.xtal_cap = 31,
+		.gain_level = 11,
+		.if_out_gain_level = 11,
+		.agc_set_point = 66,
+		.agc_invert_pol = 0,
+		.invert_if = 0,
+		.loop_thru_enable = 0,
+		.clk_out_enable = 1,
+		.clk_out_div = 0,
+		.clk_out_ext = 0,
+		.xtal_sharing_mode = 0,
+		.single_supply_3_3V = 1,
+};
+static struct avl6211_config avl6211cfg[] = {
+	{
+#ifndef CONFIG_ARM64
+		.tuner_address = 0xC2,
+#else		
+		.tuner_address = 0xC4,
+#endif
+		.tuner_i2c_clock = 200,	
+		.demod_address = 0x0C,
+		.mpeg_pol = 1,
+		.mpeg_mode = 0,
+		.mpeg_format = 0,
+		.demod_refclk = 9,
+		.mpeg_pin = 0,
+		.tuner_rfagc = 1,
+		.tuner_spectrum = 0,
+		.use_lnb_pin59 = 1,
+		.use_lnb_pin60 = 0,
+		.set_external_vol_gpio = set_external_vol_gpio,
+	},
+	{
+		.tuner_address = 0xC2,
+		.tuner_i2c_clock = 200,		
+		.demod_address = 0x0C,
+		.mpeg_pol = 1,
+		.mpeg_mode = 0,
+		.mpeg_format = 0,
+		.demod_refclk = 9,
+		.mpeg_pin = 0,
+		.tuner_rfagc = 1,
+		.tuner_spectrum = 0,
+		.use_lnb_pin59 = 1,
+		.use_lnb_pin60 = 0,
+		.set_external_vol_gpio = set_external_vol_gpio,
+	}
+};
+
+#ifndef CONFIG_ARM64
+
+#define EXPORT_SYMBOL_AS(sym, name)					\
+	extern typeof(sym) sym;						\
+	__CRC_SYMBOL(sym, "")						\
+	static const char __kstrtab_##name[]				\
+	__attribute__((section("__ksymtab_strings"), aligned(1)))	\
+	= VMLINUX_SYMBOL_STR(name);					\
+	extern const struct kernel_symbol __ksymtab_##name;		\
+	__visible const struct kernel_symbol __ksymtab_##name		\
+	__used								\
+	__attribute__((section("___ksymtab" "+" #name), unused))	\
+	= { (unsigned long)&sym, __kstrtab_##name }
+
+
+extern struct list_head usb_bus_list;
+extern struct mutex usb_bus_list_lock;
+extern struct usb_device *usb_hub_find_child(struct usb_device *hdev, int port1);
+extern struct usb_device *usb_get_dev(struct usb_device *dev);
+extern int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,
+                     __u8 requesttype, __u16 value, __u16 index, void *data,
+                     __u16 size, int timeout);
+
+EXPORT_SYMBOL_AS(usb_bus_list, wtk_bus_list);
+EXPORT_SYMBOL_AS(usb_bus_list_lock, wtk_bus_list_lock);
+EXPORT_SYMBOL_AS(usb_hub_find_child, wtk_hub_find_child);
+EXPORT_SYMBOL_AS(usb_get_dev, wtk_get_dev);
+EXPORT_SYMBOL_AS(usb_control_msg, wtk_control_msg);
+
+#endif
+
+
+int kc_class_register(struct class *cls)
+{
+	return class_register(cls);
+}
+EXPORT_SYMBOL(kc_class_register);
+void kc_class_unregister(struct class *cls)
+{
+	class_unregister(cls);
+}
+EXPORT_SYMBOL(kc_class_unregister);
+const struct cpumask *aml_get_cpu_mask(unsigned int cpu)
+{
+	const unsigned long *p = cpu_bit_bitmap[1 + cpu % BITS_PER_LONG];
+	p -= cpu / BITS_PER_LONG;
+	return to_cpumask(p);
+}
+EXPORT_SYMBOL(aml_get_cpu_mask);
+
+void get_nims_infos(struct wetek_nims *p)
+{
+	memcpy(p, &weteknims, sizeof(struct wetek_nims));
+}
+EXPORT_SYMBOL(get_nims_infos);
+int set_external_vol_gpio(int *demod_id, int on)
+{
+	if (on) {
+		if (*demod_id == 0 )
+#ifdef CONFIG_ARM64
+			gpio_direction_output(weteknims.power_ctrl, 1);
+#else		
+			amlogic_gpio_direction_output(GPIOAO_8, 1, "nimdetect");		
+#endif	
+#ifndef CONFIG_ARM64		
+        else if (*demod_id == 1)
+			amlogic_gpio_direction_output(GPIOAO_9, 1, "nimdetect");
+#endif			
+	} else if (!on) {
+		if (*demod_id == 0 )
+#ifdef CONFIG_ARM64
+			gpio_direction_output(weteknims.power_ctrl, 0);
+#else		
+			amlogic_gpio_direction_output(GPIOAO_8, 0, "nimdetect");		
+#endif
+#ifndef CONFIG_ARM64
+        else if (*demod_id == 1)		
+			amlogic_gpio_direction_output(GPIOAO_9, 0, "nimdetect");
+#endif			
+    }
+	return 0;
+}
+#ifndef CONFIG_ARM64
+static void nim_dvb_pinctrl_put(struct wetek_nims *p)
+{
+	if (p->ts[0].pinctrl) {
+		devm_pinctrl_put(p->ts[0].pinctrl);
+		p->ts[0].pinctrl = NULL;
+	}
+}
+static struct pinctrl * __must_check nim_dvb_pinctrl_get_select(
+		struct device *dev, struct wetek_nims *p, const char *name)
+{
+	/*all dvb pinctrls share the ts[0]'s pinctrl.*/
+	struct pinctrl *pctl = p->ts[0].pinctrl;
+	
+	struct pinctrl_state *s;
+	int ret;
+
+	if (!pctl) {
+		pctl = devm_pinctrl_get(dev);
+		if (IS_ERR(pctl))
+			return pctl;
+			
+		p->ts[0].pinctrl = pctl;
+	}
+
+	s = pinctrl_lookup_state(pctl, name);
+	if (IS_ERR(s)) {
+		devm_pinctrl_put(pctl);
+		return ERR_CAST(s);
+	}
+
+	ret = pinctrl_select_state(pctl, s);
+	if (ret < 0) {
+		devm_pinctrl_put(pctl);
+		return ERR_PTR(ret);
+	}
+
+	return pctl;
+}
+#endif
+
+#ifndef CONFIG_ARCH_MESON6
+#define GPIOD_8 103
+#endif
+
+void reset_demod(void)
+{
+#ifdef CONFIG_ARM64
+	gpio_direction_output(weteknims.fec_reset, 0);
+	msleep(600);
+	gpio_direction_output(weteknims.fec_reset, 1);
+	msleep(200);
+#else
+	amlogic_gpio_direction_output(GPIOD_8, 0, "nimdetect");
+	msleep(600);
+	amlogic_gpio_direction_output(GPIOD_8, 1, "nimdetect");
+	msleep(200);
+#endif
+
+}
+static int nim_dvb_probe(struct platform_device *pdev)
+{
+	int i;
+	int ret = 0;
+#ifdef CONFIG_ARM64
+    struct gpio_desc *desc;
+#endif	 
+	weteknims.pdev = pdev;
+	weteknims.dev  = &pdev->dev;
+
+#ifdef CONFIG_ARM64
+	for (i = 0; i < TOTAL_I2C; i++) {
+	
+		weteknims.i2c[i] = i2c_get_adapter(1); //tuner1 on I2C_D
+			
+		if (weteknims.i2c[i] != NULL)
+			dev_info(&pdev->dev, "Found Wetek i2c-1 adapter ...\n");
+		else {
+			dev_info(&pdev->dev, "Failed to acquire Wetek i2c-1 adapter ...\n");	
+			return 0;
+		}	
+	}
+#else
+	/* tuner0 on I2C_A
+	   tuner1 on I2C_B
+	*/
+	for (i = 0; i < TOTAL_I2C; i++) {
+		weteknims.i2c[i] = i2c_get_adapter(i + 1);
+		if (weteknims.i2c[i] != NULL)
+			dev_info(&pdev->dev, "Found Wetek i2c-%d adapter ...\n", i + 1);
+		else {
+			dev_info(&pdev->dev, "Failed to acquire Wetek i2c-%d adapter ...\n", i + 1);	
+			return 0;
+		}	
+	}
+#endif	
+	if (pdev->dev.of_node) {
+		for (i = 0; i <  TOTAL_AML_INPUTS; i++) {
+			char buf[32];
+			const char *str;
+
+			snprintf(buf, sizeof(buf), "ts%d", i);
+			ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+			if (!ret) {
+				if (!strcmp(str, "parallel")) {
+					dev_info(&pdev->dev, "%s: parallel\n", buf);
+					snprintf(buf, sizeof(buf), "p_ts%d", i);
+					weteknims.ts[i].mode    = 1;
+#ifdef CONFIG_ARM64					
+					weteknims.ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
+#else					
+					weteknims.ts[i].pinctrl = nim_dvb_pinctrl_get_select(&pdev->dev, &weteknims, buf);
+#endif					
+				}
+			}
+		}
+	}
+#ifdef CONFIG_ARM64
+
+	dvb_demux_reset_ctl = devm_reset_control_get(&pdev->dev, "demux");
+	dev_info(&pdev->dev, "dmx rst ctl = %p\n", dvb_demux_reset_ctl);
+	reset_control_deassert(dvb_demux_reset_ctl);
+
+	dvb_afifo_reset_ctl = devm_reset_control_get(&pdev->dev, "asyncfifo");
+	dev_info(&pdev->dev, "asyncfifo rst ctl = %p\n", dvb_afifo_reset_ctl);
+	reset_control_deassert(dvb_afifo_reset_ctl);
+	
+	dvb_ahbarb0_reset_ctl = devm_reset_control_get(&pdev->dev, "ahbarb0");
+	dev_info(&pdev->dev, "ahbarb0 rst ctl = %p\n", dvb_ahbarb0_reset_ctl);
+	reset_control_deassert(dvb_ahbarb0_reset_ctl);
+	
+	dvb_uparsertop_reset_ctl = devm_reset_control_get(&pdev->dev, "uparsertop");
+	dev_info(&pdev->dev, "uparsertop rst ctl = %p\n", dvb_uparsertop_reset_ctl);
+	reset_control_deassert(dvb_uparsertop_reset_ctl);
+	
+	desc = of_get_named_gpiod_flags(pdev->dev.of_node, "fec_reset_gpio-gpios", 0, NULL);
+    weteknims.fec_reset = desc_to_gpio(desc);
+	 
+	desc = of_get_named_gpiod_flags(pdev->dev.of_node, "power_ctrl_gpio-gpios", 0, NULL);
+    weteknims.power_ctrl = desc_to_gpio(desc);
+	/* FEC_RESET  GPIOY 13*/
+	gpio_request(weteknims.fec_reset, "nimdetect"); 
+	
+	/* INPUT1 POWER CTRL GPIOY 15*/
+	gpio_request(weteknims.power_ctrl, "nimdetect"); 
+	
+	
+	/* RESET DEMOD(s) */
+	reset_demod();
+#else
+	/* FEC_RESET */
+	amlogic_gpio_request(GPIOD_8, "nimdetect"); 
+	
+	/* INPUT1 POWER CTRL */
+	amlogic_gpio_request(GPIOAO_8, "nimdetect");
+	
+	/* INPUT2 POWER CTRL */
+	amlogic_gpio_request(GPIOAO_9, "nimdetect");
+
+	amlogic_gpio_direction_output(GPIOAO_8, 0, "nimdetect"); //SWITCH OFF INPUT1 POWER		
+	amlogic_gpio_direction_output(GPIOAO_9, 0, "nimdetect"); //SWITCH OFF INPUT2 POWER		
+
+	/* RESET DEMOD(s) */
+	reset_demod();
+#endif
+
+	dev_info(&pdev->dev, "Wetek NIM(s) detection in progress ...\n");
+
+	for (i = 0; i < TOTAL_DEMODS; i++) {		
+
+#ifndef CONFIG_ARM64
+		dev_info(&pdev->dev, "Checking for Sony CXD2837 DVB-C/T/T2 demod ...\n");
+
+		weteknims.fe[i] =  cxd2837_attach(weteknims.i2c[i], &cxd2837cfg);
+
+		if (weteknims.fe[i] != NULL) {
+			if (mxl603_attach(weteknims.fe[i], weteknims.i2c[i], 0x60, &mxl603cfg) == NULL) {
+				dev_info(&pdev->dev, "Failed to find MxL603 tuner!\n");
+				dev_info(&pdev->dev, "Detaching Sony CXD2837 DVB-C/T/T2 frontend!\n");
+				dvb_frontend_detach(weteknims.fe[i]);
+				goto panasonic;
+			}
+
+			weteknims.total_nims++;
+			dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+			return 0;
+		}
+#else
+		dev_info(&pdev->dev, "Checking for Sony CXD2841ER DVB-C/T/T2 demod ...\n");
+
+		weteknims.fe[i] =  cxd2841er_attach_t_c(&cxd2841cfg, weteknims.i2c[i]);
+
+		if (weteknims.fe[i] != NULL) {
+			if (mxl603_attach(weteknims.fe[i], weteknims.i2c[i], 0x60, &mxl603cfg) == NULL) {
+				dev_info(&pdev->dev, "Failed to find MxL603 tuner!\n");
+				cxd2841cfg.if_agc = 1;
+				cxd2841cfg.ifagc_adc_range = 0x50;
+				if (ascot3_attach(weteknims.fe[i], &ascot3cfg, weteknims.i2c[i]) == NULL) {
+					dev_info(&pdev->dev, "Failed to find Sony ASCOT3 tuner!\n");
+					dvb_frontend_detach(weteknims.fe[i]);
+					goto panasonic;
+				}
+			} else 
+				cxd2841cfg.mxl603 = 1;
+
+			weteknims.total_nims++;
+			dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+			return 0;
+		}
+#endif
+
+panasonic:			
+		reset_demod();
+		dev_info(&pdev->dev, "Checking for Panasonic MN88436 ATSC demod ...\n");	
+			
+		weteknims.fe[i] =  mn88436_attach(weteknims.i2c[i], 0);
+
+		if (weteknims.fe[i] != NULL) {			
+												
+			if (mxl603_attach(weteknims.fe[i], weteknims.i2c[i], 0x60, &mxl603cfg_atsc) == NULL) {
+				dev_info(&pdev->dev, "Failed to find MxL603 tuner!\n");
+				dev_info(&pdev->dev, "Detaching Panasonic MN88436 ATSC frontend!\n");
+				dvb_frontend_detach(weteknims.fe[i]);
+				goto avl6211;
+			}
+				
+			weteknims.total_nims++;
+			dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+			return 0;
+		}
+avl6211:		
+		reset_demod();
+		dev_info(&pdev->dev, "Checking for AVL6211 DVB-S/S2 demod ...\n");
+		weteknims.fe[i] = avl6211_attach( weteknims.i2c[i], &avl6211cfg[i], i);
+		if (i == 0 && weteknims.fe[i] == NULL) {
+			dev_info(&pdev->dev, "No available NIM(s) found ...\n");
+			return 0;			
+		}
+		if (weteknims.fe[i] != NULL)
+			weteknims.total_nims++;		
+	}
+	
+	if (weteknims.total_nims > 0)
+		dev_info(&pdev->dev, "Total Wetek NIM(s) found: %d\n", weteknims.total_nims);
+	
+	return 0;
+}
+static int nim_dvb_remove(struct platform_device *pdev)
+{
+	int i;
+	
+	for (i = 0; i < TOTAL_DEMODS; i++) {
+		if (weteknims.fe[i] != NULL) 
+			dvb_frontend_detach(weteknims.fe[i]);
+	}
+
+	for (i = 0; i < TOTAL_I2C; i++) {
+		if (weteknims.i2c[i] != NULL)
+			i2c_put_adapter(weteknims.i2c[i]);
+	}
+#ifdef CONFIG_ARM64
+	gpio_free(weteknims.fec_reset);
+	gpio_free(weteknims.power_ctrl);
+#else
+	amlogic_gpio_free(GPIOD_8, "nimdetect");
+	amlogic_gpio_free(GPIOAO_8, "nimdetect");
+	amlogic_gpio_free(GPIOAO_9, "nimdetect");
+#endif	
+#ifdef CONFIG_ARM64
+	devm_pinctrl_put(weteknims.ts[0].pinctrl);
+	reset_control_assert(dvb_uparsertop_reset_ctl);
+	reset_control_assert(dvb_ahbarb0_reset_ctl);
+	reset_control_assert(dvb_afifo_reset_ctl);
+	reset_control_assert(dvb_demux_reset_ctl);
+#else	
+	nim_dvb_pinctrl_put(&weteknims);
+#endif	
+	return 0;
+}
+#ifndef CONFIG_ARM64
+static int wetekcard_probe(struct platform_device *pdev)
+{
+	if (pdev->dev.of_node)
+		weteknims.card_pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+
+	return 0;
+}
+static int wetekcard_remove(struct platform_device *pdev)
+{
+	if(weteknims.card_pinctrl)
+		devm_pinctrl_put(weteknims.card_pinctrl);
+	return 0;
+}
+#endif
+static const struct of_device_id nim_dvb_dt_match[] = {
+	{
+		.compatible = "amlogic,dvb",
+	},
+	{},
+};
+static struct platform_driver nim_dvb_detection = {
+	.probe		= nim_dvb_probe,
+	.remove		= nim_dvb_remove,
+	.driver		= {
+		.name	= "wetek-dvb",
+		.owner	= THIS_MODULE,
+		.of_match_table = nim_dvb_dt_match,
+	}
+};
+#ifndef CONFIG_ARM64
+static const struct of_device_id wetekcard_dt_match[]={
+	{	.compatible = "amlogic,smartcard",
+	},
+	{},
+};
+
+static struct platform_driver wetekcard_driver = {
+	.probe		= wetekcard_probe,
+    .remove		= wetekcard_remove,
+	.driver		= {
+		.name	= "wetek-card",
+		.owner	= THIS_MODULE,
+		.of_match_table = wetekcard_dt_match,
+	}
+};
+#endif
+
+int __init nim_dvb_init(void)
+{
+	int ret;
+	
+	memset(&weteknims, 0, sizeof(struct wetek_nims));
+	
+	ret = platform_driver_register(&nim_dvb_detection);
+#ifndef CONFIG_ARM64	
+	if (!ret)
+		return platform_driver_register(&wetekcard_driver);
+#endif		
+	return ret;
+}
+void __exit nim_dvb_exit(void)
+{
+	platform_driver_unregister(&nim_dvb_detection);
+#ifndef CONFIG_ARM64
+	platform_driver_unregister(&wetekcard_driver);
+#endif	
+}
+
+module_init(nim_dvb_init);
+module_exit(nim_dvb_exit);
+
+MODULE_DESCRIPTION("Wetek NIMs DVB detection");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/wetek/nimdetect.h b/drivers/amlogic/wetek/nimdetect.h
new file mode 100644
index 0000000..ea38c82
--- /dev/null
+++ b/drivers/amlogic/wetek/nimdetect.h
@@ -0,0 +1,54 @@
+/*
+ * Wetek NIM tuner(s) detection
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __NIMDETECT_H
+#define __NIMDETECT_H
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/dvb/version.h>
+#include <linux/platform_device.h>
+#include "dvb_frontend.h"
+
+struct ts_input {
+	int                  mode;
+	struct pinctrl      *pinctrl;
+	int                  control;
+};
+
+struct wetek_nims {
+	struct dvb_frontend 	*fe[2];
+	struct i2c_adapter 		*i2c[2];	
+	struct ts_input	   		ts[3];
+	struct device       	*dev;
+	struct platform_device  *pdev;
+	struct pinctrl      	*card_pinctrl;
+	u32 total_nims;
+#ifdef CONFIG_ARM64
+	int fec_reset;
+	int power_ctrl;
+#endif
+};
+
+void get_nims_infos(struct wetek_nims *p);
+int set_external_vol_gpio(int *demod_id, int on);
+
+#endif /* __NIMDETECT_H */
diff --git a/drivers/amlogic/wifi/wifi_dt.c b/drivers/amlogic/wifi/wifi_dt.c
index f007063..2324580 100755
--- a/drivers/amlogic/wifi/wifi_dt.c
+++ b/drivers/amlogic/wifi/wifi_dt.c
@@ -162,11 +162,48 @@ static struct platform_driver wifi_plat_driver = {
         .of_match_table = wifi_match
     },
 };
+struct pinctrl      	*bt_pinctrl = NULL;
+
+static int bt_probe(struct platform_device *pdev)
+{
+#ifdef CONFIG_OF
+	if (pdev->dev.of_node) {
+		bt_pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	}
+#endif
+	return 0;
+}
+static int bt_remove(struct platform_device *pdev)
+{
+	if (bt_pinctrl)
+		devm_pinctrl_put(bt_pinctrl);
+
+	return 0;
+}
+#ifdef CONFIG_OF
+static const struct of_device_id bt_dev_dt_match[]={
+	{	.compatible = "amlogic,bt-dev",
+	},
+	{},
+};
+#else
+#define bt_dev_dt_match NULL
+#endif
+
+static struct platform_driver bt_driver = {
+	.driver		= {
+		.name	= "bt-dev",
+		.of_match_table = bt_dev_dt_match,
+	},
+	.probe		= bt_probe,
+	.remove		= bt_remove,
+};
 
 static int __init wifi_dt_init(void)
 {
 	int ret;
 	ret = platform_driver_register(&wifi_plat_driver);
+	ret = platform_driver_register(&bt_driver);
 	return ret;
 }
 // module_init(wifi_dt_init);
@@ -175,6 +212,7 @@ fs_initcall_sync(wifi_dt_init);
 static void __exit wifi_dt_exit(void)
 {
 	platform_driver_unregister(&wifi_plat_driver);
+	platform_driver_unregister(&bt_driver);
 }
 module_exit(wifi_dt_exit);
 
@@ -247,6 +285,27 @@ int wifi_setup_dt()
 		SHOW_PIN_OWN("power_on_pin2", wifi_info.power_on_pin2);
 	}
 
+	if (bt_pinctrl) {
+	
+		printk("bt_setup\n");
+		ret = amlogic_gpio_request(GPIOX_10, OWNER_NAME);
+		CHECK_RET(ret);
+		ret = amlogic_gpio_direction_output(GPIOX_10, 1, OWNER_NAME);
+		CHECK_RET(ret);
+		msleep(50);
+		
+		
+		ret = amlogic_gpio_request(GPIOE_11, OWNER_NAME);
+		CHECK_RET(ret);
+		ret = amlogic_gpio_direction_output(GPIOE_11, 0, OWNER_NAME);
+		CHECK_RET(ret);
+		msleep(20);
+				
+		ret = amlogic_gpio_direction_output(GPIOE_11, 1, OWNER_NAME);
+		CHECK_RET(ret);
+		msleep(50);
+	
+	}
 	return 0;
 }
 EXPORT_SYMBOL(wifi_setup_dt);
-- 
2.7.4

